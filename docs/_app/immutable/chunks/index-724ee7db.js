import{c as commonjsGlobal,g as getDefaultExportFromCjs}from"./_page-d9963c6f.js";import{L as Level}from"./browser-763f2d67.js";var encode_1$4=encode$r,MSB$6=128,REST$6=127,MSBALL$4=~REST$6,INT$4=Math.pow(2,31);function encode$r(t,e,r){if(Number.MAX_SAFE_INTEGER&&t>Number.MAX_SAFE_INTEGER)throw encode$r.bytes=0,new RangeError("Could not encode varint");e=e||[],r=r||0;for(var n=r;t>=INT$4;)e[r++]=t&255|MSB$6,t/=128;for(;t&MSBALL$4;)e[r++]=t&255|MSB$6,t>>>=7;return e[r]=t|0,encode$r.bytes=r-n+1,e}var decode$t=read$4,MSB$5=128,REST$5=127;function read$4(t,n){var r=0,n=n||0,o=0,i=n,s,u=t.length;do{if(i>=u||o>49)throw read$4.bytes=0,new RangeError("Could not decode varint");s=t[i++],r+=o<28?(s&REST$5)<<o:(s&REST$5)*Math.pow(2,o),o+=7}while(s>=MSB$5);return read$4.bytes=i-n,r}var N1$4=Math.pow(2,7),N2$4=Math.pow(2,14),N3$4=Math.pow(2,21),N4$4=Math.pow(2,28),N5$4=Math.pow(2,35),N6$4=Math.pow(2,42),N7$4=Math.pow(2,49),N8$4=Math.pow(2,56),N9$4=Math.pow(2,63),length$5=function(t){return t<N1$4?1:t<N2$4?2:t<N3$4?3:t<N4$4?4:t<N5$4?5:t<N6$4?6:t<N7$4?7:t<N8$4?8:t<N9$4?9:10},varint$4={encode:encode_1$4,decode:decode$t,encodingLength:length$5};const typeofs=["string","number","bigint","symbol"],objectTypeNames=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function is$1(t){if(t===null)return"null";if(t===void 0)return"undefined";if(t===!0||t===!1)return"boolean";const e=typeof t;if(typeofs.includes(e))return e;if(e==="function")return"Function";if(Array.isArray(t))return"Array";if(isBuffer$1(t))return"Buffer";const r=getObjectType(t);return r||"Object"}function isBuffer$1(t){return t&&t.constructor&&t.constructor.isBuffer&&t.constructor.isBuffer.call(null,t)}function getObjectType(t){const e=Object.prototype.toString.call(t).slice(8,-1);if(objectTypeNames.includes(e))return e}class Type{constructor(e,r,n){this.major=e,this.majorEncoded=e<<5,this.name=r,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}Type.uint=new Type(0,"uint",!0);Type.negint=new Type(1,"negint",!0);Type.bytes=new Type(2,"bytes",!0);Type.string=new Type(3,"string",!0);Type.array=new Type(4,"array",!1);Type.map=new Type(5,"map",!1);Type.tag=new Type(6,"tag",!1);Type.float=new Type(7,"float",!0);Type.false=new Type(7,"false",!0);Type.true=new Type(7,"true",!0);Type.null=new Type(7,"null",!0);Type.undefined=new Type(7,"undefined",!0);Type.break=new Type(7,"break",!0);class Token{constructor(e,r,n){this.type=e,this.value=r,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const useBuffer=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function",textDecoder$2=new TextDecoder,textEncoder$3=new TextEncoder;function isBuffer(t){return useBuffer&&globalThis.Buffer.isBuffer(t)}function asU8A(t){return t instanceof Uint8Array?isBuffer(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t:Uint8Array.from(t)}const toString$8=useBuffer?(t,e,r)=>r-e>64?globalThis.Buffer.from(t.subarray(e,r)).toString("utf8"):utf8Slice(t,e,r):(t,e,r)=>r-e>64?textDecoder$2.decode(t.subarray(e,r)):utf8Slice(t,e,r),fromString$7=useBuffer?t=>t.length>64?globalThis.Buffer.from(t):utf8ToBytes(t):t=>t.length>64?textEncoder$3.encode(t):utf8ToBytes(t),fromArray=t=>Uint8Array.from(t),slice=useBuffer?(t,e,r)=>isBuffer(t)?new Uint8Array(t.subarray(e,r)):t.slice(e,r):(t,e,r)=>t.slice(e,r),concat$2=useBuffer?(t,e)=>(t=t.map(r=>r instanceof Uint8Array?r:globalThis.Buffer.from(r)),asU8A(globalThis.Buffer.concat(t,e))):(t,e)=>{const r=new Uint8Array(e);let n=0;for(let o of t)n+o.length>r.length&&(o=o.subarray(0,r.length-n)),r.set(o,n),n+=o.length;return r},alloc=useBuffer?t=>globalThis.Buffer.allocUnsafe(t):t=>new Uint8Array(t);function compare$1(t,e){if(isBuffer(t)&&isBuffer(e))return t.compare(e);for(let r=0;r<t.length;r++)if(t[r]!==e[r])return t[r]<e[r]?-1:1;return 0}function utf8ToBytes(t,e=1/0){let r;const n=t.length;let o=null;const i=[];for(let s=0;s<n;++s){if(r=t.charCodeAt(s),r>55295&&r<57344){if(!o){if(r>56319){(e-=3)>-1&&i.push(239,191,189);continue}else if(s+1===n){(e-=3)>-1&&i.push(239,191,189);continue}o=r;continue}if(r<56320){(e-=3)>-1&&i.push(239,191,189),o=r;continue}r=(o-55296<<10|r-56320)+65536}else o&&(e-=3)>-1&&i.push(239,191,189);if(o=null,r<128){if((e-=1)<0)break;i.push(r)}else if(r<2048){if((e-=2)<0)break;i.push(r>>6|192,r&63|128)}else if(r<65536){if((e-=3)<0)break;i.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((e-=4)<0)break;i.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return i}function utf8Slice(t,e,r){const n=[];for(;e<r;){const o=t[e];let i=null,s=o>239?4:o>223?3:o>191?2:1;if(e+s<=r){let u,f,h,g;switch(s){case 1:o<128&&(i=o);break;case 2:u=t[e+1],(u&192)===128&&(g=(o&31)<<6|u&63,g>127&&(i=g));break;case 3:u=t[e+1],f=t[e+2],(u&192)===128&&(f&192)===128&&(g=(o&15)<<12|(u&63)<<6|f&63,g>2047&&(g<55296||g>57343)&&(i=g));break;case 4:u=t[e+1],f=t[e+2],h=t[e+3],(u&192)===128&&(f&192)===128&&(h&192)===128&&(g=(o&15)<<18|(u&63)<<12|(f&63)<<6|h&63,g>65535&&g<1114112&&(i=g))}}i===null?(i=65533,s=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|i&1023),n.push(i),e+=s}return decodeCodePointsArray(n)}const MAX_ARGUMENTS_LENGTH=4096;function decodeCodePointsArray(t){const e=t.length;if(e<=MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,t);let r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=MAX_ARGUMENTS_LENGTH));return r}const defaultChunkSize=256;class Bl{constructor(e=defaultChunkSize){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),this._initReuseChunk!==null&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let r=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const o=r.length-(this.maxCursor-this.cursor)-1;r.set(e,o)}else{if(r){const o=r.length-(this.maxCursor-this.cursor)-1;o<r.length&&(this.chunks[this.chunks.length-1]=r.subarray(0,o),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(r=alloc(this.chunkSize),this.chunks.push(r),this.maxCursor+=r.length,this._initReuseChunk===null&&(this._initReuseChunk=r),r.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let r;if(this.chunks.length===1){const n=this.chunks[0];e&&this.cursor>n.length/2?(r=this.cursor===n.length?n:n.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):r=slice(n,0,this.cursor)}else r=concat$2(this.chunks,this.cursor);return e&&this.reset(),r}}const decodeErrPrefix="CBOR decode error:",encodeErrPrefix="CBOR encode error:";function assertEnoughData(t,e,r){if(t.length-e<r)throw new Error(`${decodeErrPrefix} not enough data for type`)}const uintBoundaries=[24,256,65536,4294967296,BigInt("18446744073709551616")];function readUint8(t,e,r){assertEnoughData(t,e,1);const n=t[e];if(r.strict===!0&&n<uintBoundaries[0])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint16(t,e,r){assertEnoughData(t,e,2);const n=t[e]<<8|t[e+1];if(r.strict===!0&&n<uintBoundaries[1])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint32(t,e,r){assertEnoughData(t,e,4);const n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3];if(r.strict===!0&&n<uintBoundaries[2])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint64(t,e,r){assertEnoughData(t,e,8);const n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3],o=t[e+4]*16777216+(t[e+5]<<16)+(t[e+6]<<8)+t[e+7],i=(BigInt(n)<<BigInt(32))+BigInt(o);if(r.strict===!0&&i<uintBoundaries[3])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(r.allowBigInt===!0)return i;throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)}function decodeUint8(t,e,r,n){return new Token(Type.uint,readUint8(t,e+1,n),2)}function decodeUint16(t,e,r,n){return new Token(Type.uint,readUint16(t,e+1,n),3)}function decodeUint32(t,e,r,n){return new Token(Type.uint,readUint32(t,e+1,n),5)}function decodeUint64(t,e,r,n){return new Token(Type.uint,readUint64(t,e+1,n),9)}function encodeUint(t,e){return encodeUintValue(t,0,e.value)}function encodeUintValue(t,e,r){if(r<uintBoundaries[0]){const n=Number(r);t.push([e|n])}else if(r<uintBoundaries[1]){const n=Number(r);t.push([e|24,n])}else if(r<uintBoundaries[2]){const n=Number(r);t.push([e|25,n>>>8,n&255])}else if(r<uintBoundaries[3]){const n=Number(r);t.push([e|26,n>>>24&255,n>>>16&255,n>>>8&255,n&255])}else{const n=BigInt(r);if(n<uintBoundaries[4]){const o=[e|27,0,0,0,0,0,0,0];let i=Number(n&BigInt(4294967295)),s=Number(n>>BigInt(32)&BigInt(4294967295));o[8]=i&255,i=i>>8,o[7]=i&255,i=i>>8,o[6]=i&255,i=i>>8,o[5]=i&255,o[4]=s&255,s=s>>8,o[3]=s&255,s=s>>8,o[2]=s&255,s=s>>8,o[1]=s&255,t.push(o)}else throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)}}encodeUint.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};encodeUintValue.encodedSize=function(e){return e<uintBoundaries[0]?1:e<uintBoundaries[1]?2:e<uintBoundaries[2]?3:e<uintBoundaries[3]?5:9};encodeUint.compareTokens=function(e,r){return e.value<r.value?-1:e.value>r.value?1:0};function decodeNegint8(t,e,r,n){return new Token(Type.negint,-1-readUint8(t,e+1,n),2)}function decodeNegint16(t,e,r,n){return new Token(Type.negint,-1-readUint16(t,e+1,n),3)}function decodeNegint32(t,e,r,n){return new Token(Type.negint,-1-readUint32(t,e+1,n),5)}const neg1b=BigInt(-1),pos1b=BigInt(1);function decodeNegint64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o!="bigint"){const i=-1-o;if(i>=Number.MIN_SAFE_INTEGER)return new Token(Type.negint,i,9)}if(n.allowBigInt!==!0)throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);return new Token(Type.negint,neg1b-BigInt(o),9)}function encodeNegint(t,e){const r=e.value,n=typeof r=="bigint"?r*neg1b-pos1b:r*-1-1;encodeUintValue(t,e.type.majorEncoded,n)}encodeNegint.encodedSize=function(e){const r=e.value,n=typeof r=="bigint"?r*neg1b-pos1b:r*-1-1;return n<uintBoundaries[0]?1:n<uintBoundaries[1]?2:n<uintBoundaries[2]?3:n<uintBoundaries[3]?5:9};encodeNegint.compareTokens=function(e,r){return e.value<r.value?1:e.value>r.value?-1:0};function toToken$3(t,e,r,n){assertEnoughData(t,e,r+n);const o=slice(t,e+r,e+r+n);return new Token(Type.bytes,o,r+n)}function decodeBytesCompact(t,e,r,n){return toToken$3(t,e,1,r)}function decodeBytes8(t,e,r,n){return toToken$3(t,e,2,readUint8(t,e+1,n))}function decodeBytes16(t,e,r,n){return toToken$3(t,e,3,readUint16(t,e+1,n))}function decodeBytes32(t,e,r,n){return toToken$3(t,e,5,readUint32(t,e+1,n))}function decodeBytes64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);return toToken$3(t,e,9,o)}function tokenBytes(t){return t.encodedBytes===void 0&&(t.encodedBytes=t.type===Type.string?fromString$7(t.value):t.value),t.encodedBytes}function encodeBytes(t,e){const r=tokenBytes(e);encodeUintValue(t,e.type.majorEncoded,r.length),t.push(r)}encodeBytes.encodedSize=function(e){const r=tokenBytes(e);return encodeUintValue.encodedSize(r.length)+r.length};encodeBytes.compareTokens=function(e,r){return compareBytes(tokenBytes(e),tokenBytes(r))};function compareBytes(t,e){return t.length<e.length?-1:t.length>e.length?1:compare$1(t,e)}function toToken$2(t,e,r,n,o){const i=r+n;assertEnoughData(t,e,i);const s=new Token(Type.string,toString$8(t,e+r,e+i),i);return o.retainStringBytes===!0&&(s.byteValue=slice(t,e+r,e+i)),s}function decodeStringCompact(t,e,r,n){return toToken$2(t,e,1,r,n)}function decodeString8(t,e,r,n){return toToken$2(t,e,2,readUint8(t,e+1,n),n)}function decodeString16(t,e,r,n){return toToken$2(t,e,3,readUint16(t,e+1,n),n)}function decodeString32(t,e,r,n){return toToken$2(t,e,5,readUint32(t,e+1,n),n)}function decodeString64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);return toToken$2(t,e,9,o,n)}const encodeString=encodeBytes;function toToken$1(t,e,r,n){return new Token(Type.array,n,r)}function decodeArrayCompact(t,e,r,n){return toToken$1(t,e,1,r)}function decodeArray8(t,e,r,n){return toToken$1(t,e,2,readUint8(t,e+1,n))}function decodeArray16(t,e,r,n){return toToken$1(t,e,3,readUint16(t,e+1,n))}function decodeArray32(t,e,r,n){return toToken$1(t,e,5,readUint32(t,e+1,n))}function decodeArray64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);return toToken$1(t,e,9,o)}function decodeArrayIndefinite(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken$1(t,e,1,1/0)}function encodeArray(t,e){encodeUintValue(t,Type.array.majorEncoded,e.value)}encodeArray.compareTokens=encodeUint.compareTokens;encodeArray.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};function toToken(t,e,r,n){return new Token(Type.map,n,r)}function decodeMapCompact(t,e,r,n){return toToken(t,e,1,r)}function decodeMap8(t,e,r,n){return toToken(t,e,2,readUint8(t,e+1,n))}function decodeMap16(t,e,r,n){return toToken(t,e,3,readUint16(t,e+1,n))}function decodeMap32(t,e,r,n){return toToken(t,e,5,readUint32(t,e+1,n))}function decodeMap64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);return toToken(t,e,9,o)}function decodeMapIndefinite(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken(t,e,1,1/0)}function encodeMap(t,e){encodeUintValue(t,Type.map.majorEncoded,e.value)}encodeMap.compareTokens=encodeUint.compareTokens;encodeMap.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};function decodeTagCompact(t,e,r,n){return new Token(Type.tag,r,1)}function decodeTag8(t,e,r,n){return new Token(Type.tag,readUint8(t,e+1,n),2)}function decodeTag16(t,e,r,n){return new Token(Type.tag,readUint16(t,e+1,n),3)}function decodeTag32(t,e,r,n){return new Token(Type.tag,readUint32(t,e+1,n),5)}function decodeTag64(t,e,r,n){return new Token(Type.tag,readUint64(t,e+1,n),9)}function encodeTag(t,e){encodeUintValue(t,Type.tag.majorEncoded,e.value)}encodeTag.compareTokens=encodeUint.compareTokens;encodeTag.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};const MINOR_FALSE=20,MINOR_TRUE=21,MINOR_NULL=22,MINOR_UNDEFINED=23;function decodeUndefined(t,e,r,n){if(n.allowUndefined===!1)throw new Error(`${decodeErrPrefix} undefined values are not supported`);return n.coerceUndefinedToNull===!0?new Token(Type.null,null,1):new Token(Type.undefined,void 0,1)}function decodeBreak(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return new Token(Type.break,void 0,1)}function createToken(t,e,r){if(r){if(r.allowNaN===!1&&Number.isNaN(t))throw new Error(`${decodeErrPrefix} NaN values are not supported`);if(r.allowInfinity===!1&&(t===1/0||t===-1/0))throw new Error(`${decodeErrPrefix} Infinity values are not supported`)}return new Token(Type.float,t,e)}function decodeFloat16(t,e,r,n){return createToken(readFloat16(t,e+1),3,n)}function decodeFloat32(t,e,r,n){return createToken(readFloat32(t,e+1),5,n)}function decodeFloat64(t,e,r,n){return createToken(readFloat64(t,e+1),9,n)}function encodeFloat(t,e,r){const n=e.value;if(n===!1)t.push([Type.float.majorEncoded|MINOR_FALSE]);else if(n===!0)t.push([Type.float.majorEncoded|MINOR_TRUE]);else if(n===null)t.push([Type.float.majorEncoded|MINOR_NULL]);else if(n===void 0)t.push([Type.float.majorEncoded|MINOR_UNDEFINED]);else{let o,i=!1;(!r||r.float64!==!0)&&(encodeFloat16(n),o=readFloat16(ui8a,1),n===o||Number.isNaN(n)?(ui8a[0]=249,t.push(ui8a.slice(0,3)),i=!0):(encodeFloat32(n),o=readFloat32(ui8a,1),n===o&&(ui8a[0]=250,t.push(ui8a.slice(0,5)),i=!0))),i||(encodeFloat64(n),o=readFloat64(ui8a,1),ui8a[0]=251,t.push(ui8a.slice(0,9)))}}encodeFloat.encodedSize=function(e,r){const n=e.value;if(n===!1||n===!0||n===null||n===void 0)return 1;if(!r||r.float64!==!0){encodeFloat16(n);let o=readFloat16(ui8a,1);if(n===o||Number.isNaN(n))return 3;if(encodeFloat32(n),o=readFloat32(ui8a,1),n===o)return 5}return 9};const buffer=new ArrayBuffer(9),dataView=new DataView(buffer,1),ui8a=new Uint8Array(buffer,0);function encodeFloat16(t){if(t===1/0)dataView.setUint16(0,31744,!1);else if(t===-1/0)dataView.setUint16(0,64512,!1);else if(Number.isNaN(t))dataView.setUint16(0,32256,!1);else{dataView.setFloat32(0,t);const e=dataView.getUint32(0),r=(e&2139095040)>>23,n=e&8388607;if(r===255)dataView.setUint16(0,31744,!1);else if(r===0)dataView.setUint16(0,(t&2147483648)>>16|n>>13,!1);else{const o=r-127;o<-24?dataView.setUint16(0,0):o<-14?dataView.setUint16(0,(e&2147483648)>>16|1<<24+o,!1):dataView.setUint16(0,(e&2147483648)>>16|o+15<<10|n>>13,!1)}}}function readFloat16(t,e){if(t.length-e<2)throw new Error(`${decodeErrPrefix} not enough data for float16`);const r=(t[e]<<8)+t[e+1];if(r===31744)return 1/0;if(r===64512)return-1/0;if(r===32256)return NaN;const n=r>>10&31,o=r&1023;let i;return n===0?i=o*2**-24:n!==31?i=(o+1024)*2**(n-25):i=o===0?1/0:NaN,r&32768?-i:i}function encodeFloat32(t){dataView.setFloat32(0,t,!1)}function readFloat32(t,e){if(t.length-e<4)throw new Error(`${decodeErrPrefix} not enough data for float32`);const r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,4).getFloat32(0,!1)}function encodeFloat64(t){dataView.setFloat64(0,t,!1)}function readFloat64(t,e){if(t.length-e<8)throw new Error(`${decodeErrPrefix} not enough data for float64`);const r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,8).getFloat64(0,!1)}encodeFloat.compareTokens=encodeUint.compareTokens;function invalidMinor(t,e,r){throw new Error(`${decodeErrPrefix} encountered invalid minor (${r}) for major ${t[e]>>>5}`)}function errorer(t){return()=>{throw new Error(`${decodeErrPrefix} ${t}`)}}const jump=[];for(let t=0;t<=23;t++)jump[t]=invalidMinor;jump[24]=decodeUint8;jump[25]=decodeUint16;jump[26]=decodeUint32;jump[27]=decodeUint64;jump[28]=invalidMinor;jump[29]=invalidMinor;jump[30]=invalidMinor;jump[31]=invalidMinor;for(let t=32;t<=55;t++)jump[t]=invalidMinor;jump[56]=decodeNegint8;jump[57]=decodeNegint16;jump[58]=decodeNegint32;jump[59]=decodeNegint64;jump[60]=invalidMinor;jump[61]=invalidMinor;jump[62]=invalidMinor;jump[63]=invalidMinor;for(let t=64;t<=87;t++)jump[t]=decodeBytesCompact;jump[88]=decodeBytes8;jump[89]=decodeBytes16;jump[90]=decodeBytes32;jump[91]=decodeBytes64;jump[92]=invalidMinor;jump[93]=invalidMinor;jump[94]=invalidMinor;jump[95]=errorer("indefinite length bytes/strings are not supported");for(let t=96;t<=119;t++)jump[t]=decodeStringCompact;jump[120]=decodeString8;jump[121]=decodeString16;jump[122]=decodeString32;jump[123]=decodeString64;jump[124]=invalidMinor;jump[125]=invalidMinor;jump[126]=invalidMinor;jump[127]=errorer("indefinite length bytes/strings are not supported");for(let t=128;t<=151;t++)jump[t]=decodeArrayCompact;jump[152]=decodeArray8;jump[153]=decodeArray16;jump[154]=decodeArray32;jump[155]=decodeArray64;jump[156]=invalidMinor;jump[157]=invalidMinor;jump[158]=invalidMinor;jump[159]=decodeArrayIndefinite;for(let t=160;t<=183;t++)jump[t]=decodeMapCompact;jump[184]=decodeMap8;jump[185]=decodeMap16;jump[186]=decodeMap32;jump[187]=decodeMap64;jump[188]=invalidMinor;jump[189]=invalidMinor;jump[190]=invalidMinor;jump[191]=decodeMapIndefinite;for(let t=192;t<=215;t++)jump[t]=decodeTagCompact;jump[216]=decodeTag8;jump[217]=decodeTag16;jump[218]=decodeTag32;jump[219]=decodeTag64;jump[220]=invalidMinor;jump[221]=invalidMinor;jump[222]=invalidMinor;jump[223]=invalidMinor;for(let t=224;t<=243;t++)jump[t]=errorer("simple values are not supported");jump[244]=invalidMinor;jump[245]=invalidMinor;jump[246]=invalidMinor;jump[247]=decodeUndefined;jump[248]=errorer("simple values are not supported");jump[249]=decodeFloat16;jump[250]=decodeFloat32;jump[251]=decodeFloat64;jump[252]=invalidMinor;jump[253]=invalidMinor;jump[254]=invalidMinor;jump[255]=decodeBreak;const quick=[];for(let t=0;t<24;t++)quick[t]=new Token(Type.uint,t,1);for(let t=-1;t>=-24;t--)quick[31-t]=new Token(Type.negint,t,1);quick[64]=new Token(Type.bytes,new Uint8Array(0),1);quick[96]=new Token(Type.string,"",1);quick[128]=new Token(Type.array,0,1);quick[160]=new Token(Type.map,0,1);quick[244]=new Token(Type.false,!1,1);quick[245]=new Token(Type.true,!0,1);quick[246]=new Token(Type.null,null,1);function quickEncodeToken(t){switch(t.type){case Type.false:return fromArray([244]);case Type.true:return fromArray([245]);case Type.null:return fromArray([246]);case Type.bytes:return t.value.length?void 0:fromArray([64]);case Type.string:return t.value===""?fromArray([96]):void 0;case Type.array:return t.value===0?fromArray([128]):void 0;case Type.map:return t.value===0?fromArray([160]):void 0;case Type.uint:return t.value<24?fromArray([Number(t.value)]):void 0;case Type.negint:if(t.value>=-24)return fromArray([31-Number(t.value)])}}const defaultEncodeOptions$2={float64:!1,mapSorter:mapSorter$1,quickEncodeToken};function makeCborEncoders(){const t=[];return t[Type.uint.major]=encodeUint,t[Type.negint.major]=encodeNegint,t[Type.bytes.major]=encodeBytes,t[Type.string.major]=encodeString,t[Type.array.major]=encodeArray,t[Type.map.major]=encodeMap,t[Type.tag.major]=encodeTag,t[Type.float.major]=encodeFloat,t}const cborEncoders$1=makeCborEncoders(),buf=new Bl;class Ref{constructor(e,r){this.obj=e,this.parent=r}includes(e){let r=this;do if(r.obj===e)return!0;while(r=r.parent);return!1}static createCheck(e,r){if(e&&e.includes(r))throw new Error(`${encodeErrPrefix} object contains circular references`);return new Ref(r,e)}}const simpleTokens={null:new Token(Type.null,null),undefined:new Token(Type.undefined,void 0),true:new Token(Type.true,!0),false:new Token(Type.false,!1),emptyArray:new Token(Type.array,0),emptyMap:new Token(Type.map,0)},typeEncoders={number(t,e,r,n){return!Number.isInteger(t)||!Number.isSafeInteger(t)?new Token(Type.float,t):t>=0?new Token(Type.uint,t):new Token(Type.negint,t)},bigint(t,e,r,n){return t>=BigInt(0)?new Token(Type.uint,t):new Token(Type.negint,t)},Uint8Array(t,e,r,n){return new Token(Type.bytes,t)},string(t,e,r,n){return new Token(Type.string,t)},boolean(t,e,r,n){return t?simpleTokens.true:simpleTokens.false},null(t,e,r,n){return simpleTokens.null},undefined(t,e,r,n){return simpleTokens.undefined},ArrayBuffer(t,e,r,n){return new Token(Type.bytes,new Uint8Array(t))},DataView(t,e,r,n){return new Token(Type.bytes,new Uint8Array(t.buffer,t.byteOffset,t.byteLength))},Array(t,e,r,n){if(!t.length)return r.addBreakTokens===!0?[simpleTokens.emptyArray,new Token(Type.break)]:simpleTokens.emptyArray;n=Ref.createCheck(n,t);const o=[];let i=0;for(const s of t)o[i++]=objectToTokens(s,r,n);return r.addBreakTokens?[new Token(Type.array,t.length),o,new Token(Type.break)]:[new Token(Type.array,t.length),o]},Object(t,e,r,n){const o=e!=="Object",i=o?t.keys():Object.keys(t),s=o?t.size:i.length;if(!s)return r.addBreakTokens===!0?[simpleTokens.emptyMap,new Token(Type.break)]:simpleTokens.emptyMap;n=Ref.createCheck(n,t);const u=[];let f=0;for(const h of i)u[f++]=[objectToTokens(h,r,n),objectToTokens(o?t.get(h):t[h],r,n)];return sortMapEntries(u,r),r.addBreakTokens?[new Token(Type.map,s),u,new Token(Type.break)]:[new Token(Type.map,s),u]}};typeEncoders.Map=typeEncoders.Object;typeEncoders.Buffer=typeEncoders.Uint8Array;for(const t of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))typeEncoders[`${t}Array`]=typeEncoders.DataView;function objectToTokens(t,e={},r){const n=is$1(t),o=e&&e.typeEncoders&&e.typeEncoders[n]||typeEncoders[n];if(typeof o=="function"){const s=o(t,n,e,r);if(s!=null)return s}const i=typeEncoders[n];if(!i)throw new Error(`${encodeErrPrefix} unsupported type: ${n}`);return i(t,n,e,r)}function sortMapEntries(t,e){e.mapSorter&&t.sort(e.mapSorter)}function mapSorter$1(t,e){const r=Array.isArray(t[0])?t[0][0]:t[0],n=Array.isArray(e[0])?e[0][0]:e[0];if(r.type!==n.type)return r.type.compare(n.type);const o=r.type.major,i=cborEncoders$1[o].compareTokens(r,n);return i===0&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),i}function tokensToEncoded(t,e,r,n){if(Array.isArray(e))for(const o of e)tokensToEncoded(t,o,r,n);else r[e.type.major](t,e,n)}function encodeCustom(t,e,r){const n=objectToTokens(t,r);if(!Array.isArray(n)&&r.quickEncodeToken){const o=r.quickEncodeToken(n);if(o)return o;const i=e[n.type.major];if(i.encodedSize){const s=i.encodedSize(n,r),u=new Bl(s);if(i(u,n,r),u.chunks.length!==1)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return asU8A(u.chunks[0])}}return buf.reset(),tokensToEncoded(buf,n,e,r),buf.toBytes(!0)}function encode$q(t,e){return e=Object.assign({},defaultEncodeOptions$2,e),encodeCustom(t,cborEncoders$1,e)}const defaultDecodeOptions={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Tokeniser{constructor(e,r={}){this.pos=0,this.data=e,this.options=r}done(){return this.pos>=this.data.length}next(){const e=this.data[this.pos];let r=quick[e];if(r===void 0){const n=jump[e];if(!n)throw new Error(`${decodeErrPrefix} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const o=e&31;r=n(this.data,this.pos,o,this.options)}return this.pos+=r.encodedLength,r}}const DONE=Symbol.for("DONE"),BREAK=Symbol.for("BREAK");function tokenToArray(t,e,r){const n=[];for(let o=0;o<t.value;o++){const i=tokensToObject(e,r);if(i===BREAK){if(t.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)}if(i===DONE)throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${o}, expected ${t.value})`);n[o]=i}return n}function tokenToMap(t,e,r){const n=r.useMaps===!0,o=n?void 0:{},i=n?new Map:void 0;for(let s=0;s<t.value;s++){const u=tokensToObject(e,r);if(u===BREAK){if(t.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)}if(u===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${s} [no key], expected ${t.value})`);if(n!==!0&&typeof u!="string")throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof u})`);const f=tokensToObject(e,r);if(f===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${s} [no value], expected ${t.value})`);n?i.set(u,f):o[u]=f}return n?i:o}function tokensToObject(t,e){if(t.done())return DONE;const r=t.next();if(r.type===Type.break)return BREAK;if(r.type.terminal)return r.value;if(r.type===Type.array)return tokenToArray(r,t,e);if(r.type===Type.map)return tokenToMap(r,t,e);if(r.type===Type.tag){if(e.tags&&typeof e.tags[r.value]=="function"){const n=tokensToObject(t,e);return e.tags[r.value](n)}throw new Error(`${decodeErrPrefix} tag not supported (${r.value})`)}throw new Error("unsupported")}function decode$s(t,e){if(!(t instanceof Uint8Array))throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);e=Object.assign({},defaultDecodeOptions,e);const r=e.tokenizer||new Tokeniser(t,e),n=tokensToObject(r,e);if(n===DONE)throw new Error(`${decodeErrPrefix} did not find any content to decode`);if(n===BREAK)throw new Error(`${decodeErrPrefix} got unexpected break`);if(!r.done())throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);return n}const cborEncoders=makeCborEncoders(),defaultEncodeOptions$1={float64:!1,quickEncodeToken};function tokensToLength(t,e=cborEncoders,r=defaultEncodeOptions$1){if(Array.isArray(t)){let n=0;for(const o of t)n+=tokensToLength(o,e,r);return n}else{const n=e[t.type.major];if(n.encodedSize===void 0||typeof n.encodedSize!="function")throw new Error(`Encoder for ${t.type.name} does not have an encodedSize()`);return n.encodedSize(t,r)}}var encode_1$3=encode$p,MSB$4=128,REST$4=127,MSBALL$3=~REST$4,INT$3=Math.pow(2,31);function encode$p(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT$3;)e[r++]=t&255|MSB$4,t/=128;for(;t&MSBALL$3;)e[r++]=t&255|MSB$4,t>>>=7;return e[r]=t|0,encode$p.bytes=r-n+1,e}var decode$r=read$3,MSB$1$3=128,REST$1$3=127;function read$3(t,n){var r=0,n=n||0,o=0,i=n,s,u=t.length;do{if(i>=u)throw read$3.bytes=0,new RangeError("Could not decode varint");s=t[i++],r+=o<28?(s&REST$1$3)<<o:(s&REST$1$3)*Math.pow(2,o),o+=7}while(s>=MSB$1$3);return read$3.bytes=i-n,r}var N1$3=Math.pow(2,7),N2$3=Math.pow(2,14),N3$3=Math.pow(2,21),N4$3=Math.pow(2,28),N5$3=Math.pow(2,35),N6$3=Math.pow(2,42),N7$3=Math.pow(2,49),N8$3=Math.pow(2,56),N9$3=Math.pow(2,63),length$4=function(t){return t<N1$3?1:t<N2$3?2:t<N3$3?3:t<N4$3?4:t<N5$3?5:t<N6$3?6:t<N7$3?7:t<N8$3?8:t<N9$3?9:10},varint$3={encode:encode_1$3,decode:decode$r,encodingLength:length$4},_brrp_varint$3=varint$3;const decode$q=(t,e=0)=>[_brrp_varint$3.decode(t,e),_brrp_varint$3.decode.bytes],encodeTo$3=(t,e,r=0)=>(_brrp_varint$3.encode(t,e,r),e),encodingLength$3=t=>_brrp_varint$3.encodingLength(t),empty=new Uint8Array(0),toHex=t=>t.reduce((e,r)=>e+r.toString(16).padStart(2,"0"),""),fromHex=t=>{const e=t.match(/../g);return e?new Uint8Array(e.map(r=>parseInt(r,16))):empty},equals$6=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},coerce$4=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},isBinary$1=t=>t instanceof ArrayBuffer||ArrayBuffer.isView(t),fromString$6=t=>new TextEncoder().encode(t),toString$7=t=>new TextDecoder().decode(t),byteslib=Object.freeze(Object.defineProperty({__proto__:null,equals:equals$6,coerce:coerce$4,isBinary:isBinary$1,fromHex,toHex,fromString:fromString$6,toString:toString$7,empty},Symbol.toStringTag,{value:"Module"})),create$6=(t,e)=>{const r=e.byteLength,n=encodingLength$3(t),o=n+encodingLength$3(r),i=new Uint8Array(o+r);return encodeTo$3(t,i,0),encodeTo$3(r,i,n),i.set(e,o),new Digest$3(t,r,e,i)},decode$p=t=>{const e=coerce$4(t),[r,n]=decode$q(e),[o,i]=decode$q(e.subarray(n)),s=e.subarray(n+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new Digest$3(r,o,s,e)},equals$5=(t,e)=>t===e?!0:t.code===e.code&&t.size===e.size&&equals$6(t.bytes,e.bytes);class Digest$3{constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}}function base$4(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var i=t.charAt(o),s=i.charCodeAt(0);if(r[s]!==255)throw new TypeError(i+" is ambiguous");r[s]=o}var u=t.length,f=t.charAt(0),h=Math.log(u)/Math.log(256),g=Math.log(256)/Math.log(u);function $(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var v=0,k=0,P=0,L=w.length;P!==L&&w[P]===0;)P++,v++;for(var N=(L-P)*g+1>>>0,q=new Uint8Array(N);P!==L;){for(var X=w[P],Z=0,j=N-1;(X!==0||Z<k)&&j!==-1;j--,Z++)X+=256*q[j]>>>0,q[j]=X%u>>>0,X=X/u>>>0;if(X!==0)throw new Error("Non-zero carry");k=Z,P++}for(var B=N-k;B!==N&&q[B]===0;)B++;for(var K=f.repeat(v);B<N;++B)K+=t.charAt(q[B]);return K}function E(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var v=0;if(w[v]!==" "){for(var k=0,P=0;w[v]===f;)k++,v++;for(var L=(w.length-v)*h+1>>>0,N=new Uint8Array(L);w[v];){var q=r[w.charCodeAt(v)];if(q===255)return;for(var X=0,Z=L-1;(q!==0||X<P)&&Z!==-1;Z--,X++)q+=u*N[Z]>>>0,N[Z]=q%256>>>0,q=q/256>>>0;if(q!==0)throw new Error("Non-zero carry");P=X,v++}if(w[v]!==" "){for(var j=L-P;j!==L&&N[j]===0;)j++;for(var B=new Uint8Array(k+(L-j)),K=k;j!==L;)B[K++]=N[j++];return B}}}function A(w){var v=E(w);if(v)return v;throw new Error(`Non-${e} character`)}return{encode:$,decodeUnsafe:E,decode:A}}var src$4=base$4,_brrp__multiformats_scope_baseX$4=src$4;class Encoder$4{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Decoder$4{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$4(this,e)}}class ComposedDecoder$4{constructor(e){this.decoders=e}or(e){return or$4(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or$4=(t,e)=>new ComposedDecoder$4({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});class Codec$4{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$4(e,r,n),this.decoder=new Decoder$4(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const from$7=({name:t,prefix:e,encode:r,decode:n})=>new Codec$4(t,e,r,n),baseX$4=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$4(r,e);return from$7({prefix:t,name:e,encode:n,decode:i=>coerce$4(o(i))})},decode$o=(t,e,r,n)=>{const o={};for(let g=0;g<e.length;++g)o[e[g]]=g;let i=t.length;for(;t[i-1]==="=";)--i;const s=new Uint8Array(i*r/8|0);let u=0,f=0,h=0;for(let g=0;g<i;++g){const $=o[t[g]];if($===void 0)throw new SyntaxError(`Non-${n} character`);f=f<<r|$,u+=r,u>=8&&(u-=8,s[h++]=255&f>>u)}if(u>=r||255&f<<8-u)throw new SyntaxError("Unexpected end of data");return s},encode$o=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let i="",s=0,u=0;for(let f=0;f<t.length;++f)for(u=u<<8|t[f],s+=8;s>r;)s-=r,i+=e[o&u>>s];if(s&&(i+=e[o&u<<r-s]),n)for(;i.length*r&7;)i+="=";return i},rfc4648$4=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$7({prefix:e,name:t,encode(o){return encode$o(o,n,r)},decode(o){return decode$o(o,n,r,t)}}),base58btc$4=baseX$4({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr$2=baseX$4({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58$2=Object.freeze(Object.defineProperty({__proto__:null,base58btc:base58btc$4,base58flickr:base58flickr$2},Symbol.toStringTag,{value:"Module"})),base32$6=rfc4648$4({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper$2=rfc4648$4({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad$2=rfc4648$4({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper$2=rfc4648$4({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex$2=rfc4648$4({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper$2=rfc4648$4({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad$2=rfc4648$4({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper$2=rfc4648$4({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z$2=rfc4648$4({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$7=Object.freeze(Object.defineProperty({__proto__:null,base32:base32$6,base32upper:base32upper$2,base32pad:base32pad$2,base32padupper:base32padupper$2,base32hex:base32hex$2,base32hexupper:base32hexupper$2,base32hexpad:base32hexpad$2,base32hexpadupper:base32hexpadupper$2,base32z:base32z$2},Symbol.toStringTag,{value:"Module"}));class CID$2{constructor(e,r,n,o){this.code=r,this.version=e,this.multihash=n,this.bytes=o,this.byteOffset=o.byteOffset,this.byteLength=o.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:hidden,byteLength:hidden,code:readonly$1,version:readonly$1,multihash:readonly$1,bytes:readonly$1,_baseCache:hidden,asCID:hidden})}toV0(){switch(this.version){case 0:return this;default:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE$2)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE$2)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID$2.createV0(r)}}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create$6(e,r);return CID$2.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(e){return e&&this.code===e.code&&this.version===e.version&&equals$5(this.multihash,e.multihash)}toString(e){const{bytes:r,version:n,_baseCache:o}=this;switch(n){case 0:return toStringV0$2(r,o,e||base58btc$4.encoder);default:return toStringV1$2(r,o,e||base32$6.encoder)}}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(e){return deprecate(/^0\.0/,IS_CID_DEPRECATION),!!(e&&(e[cidSymbol$2]||e.asCID===e))}get toBaseEncodedString(){throw new Error("Deprecated, use .toString()")}get codec(){throw new Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw new Error('"multibaseName" property is deprecated')}get prefix(){throw new Error('"prefix" property is deprecated')}static asCID(e){if(e instanceof CID$2)return e;if(e!=null&&e.asCID===e){const{version:r,code:n,multihash:o,bytes:i}=e;return new CID$2(r,n,o,i||encodeCID$2(r,n,o.bytes))}else if(e!=null&&e[cidSymbol$2]===!0){const{version:r,multihash:n,code:o}=e,i=decode$p(n);return CID$2.create(r,o,i)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");switch(e){case 0:{if(r!==DAG_PB_CODE$2)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$2}) block encoding`);return new CID$2(e,r,n,n.bytes)}case 1:{const o=encodeCID$2(e,r,n.bytes);return new CID$2(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return CID$2.create(0,DAG_PB_CODE$2,e)}static createV1(e,r){return CID$2.create(1,e,r)}static decode(e){const[r,n]=CID$2.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=CID$2.inspectBytes(e),n=r.size-r.multihashSize,o=coerce$4(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");const i=o.subarray(r.multihashSize-r.digestSize),s=new Digest$3(r.multihashCode,r.digestSize,i,o);return[r.version===0?CID$2.createV0(s):CID$2.createV1(r.codec,s),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[$,E]=decode$q(e.subarray(r));return r+=E,$};let o=n(),i=DAG_PB_CODE$2;if(o===18?(o=0,r=0):o===1&&(i=n()),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const s=r,u=n(),f=n(),h=r+f,g=h-s;return{version:o,codec:i,multihashCode:u,digestSize:f,multihashSize:g,size:h}}static parse(e,r){const[n,o]=parseCIDtoBytes$2(e,r),i=CID$2.decode(o);return i._baseCache.set(n,e),i}}const parseCIDtoBytes$2=(t,e)=>{switch(t[0]){case"Q":{const r=e||base58btc$4;return[base58btc$4.prefix,r.decode(`${base58btc$4.prefix}${t}`)]}case base58btc$4.prefix:{const r=e||base58btc$4;return[base58btc$4.prefix,r.decode(t)]}case base32$6.prefix:{const r=e||base32$6;return[base32$6.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},toStringV0$2=(t,e,r)=>{const{prefix:n}=r;if(n!==base58btc$4.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=e.get(n);if(o==null){const i=r.encode(t).slice(1);return e.set(n,i),i}else return o},toStringV1$2=(t,e,r)=>{const{prefix:n}=r,o=e.get(n);if(o==null){const i=r.encode(t);return e.set(n,i),i}else return o},DAG_PB_CODE$2=112,SHA_256_CODE$2=18,encodeCID$2=(t,e,r)=>{const n=encodingLength$3(t),o=n+encodingLength$3(e),i=new Uint8Array(o+r.byteLength);return encodeTo$3(t,i,0),encodeTo$3(e,i,n),i.set(r,o),i},cidSymbol$2=Symbol.for("@ipld/js-cid/CID"),readonly$1={writable:!1,configurable:!1,enumerable:!0},hidden={writable:!1,enumerable:!1,configurable:!1},version$1="0.0.0-dev",deprecate=(t,e)=>{if(t.test(version$1))console.warn(e);else throw new Error(e)},IS_CID_DEPRECATION=`CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,CID_CBOR_TAG=42;function cidEncoder$1(t){if(t.asCID!==t)return null;const e=CID$2.asCID(t);if(!e)return null;const r=new Uint8Array(e.bytes.byteLength+1);return r.set(e.bytes,1),[new Token(Type.tag,CID_CBOR_TAG),new Token(Type.bytes,r)]}function undefinedEncoder$1(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder$1(t){if(Number.isNaN(t))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(t===1/0||t===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const encodeOptions$1={float64:!0,typeEncoders:{Object:cidEncoder$1,undefined:undefinedEncoder$1,number:numberEncoder$1}};function cidDecoder(t){if(t[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID$2.decode(t.subarray(1))}const decodeOptions$1={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions$1.tags[CID_CBOR_TAG]=cidDecoder;const name$7="dag-cbor",code$9=113,encode$n=t=>encode$q(t,encodeOptions$1),decode$n=t=>decode$s(t,decodeOptions$1),dagCBOR=Object.freeze(Object.defineProperty({__proto__:null,name:name$7,code:code$9,encode:encode$n,decode:decode$n},Symbol.toStringTag,{value:"Module"}));class CarBufferWriter{constructor(e,r){this.bytes=e,this.byteOffset=r,this.roots=[],this.headerSize=r}addRoot(e,r){return addRoot(this,e,r),this}write(e){return addBlock(this,e),this}close(e){return close(this,e)}}const addRoot=(t,e,r={})=>{const{resize:n=!1}=r,{bytes:o,headerSize:i,byteOffset:s,roots:u}=t;t.roots.push(e);const f=headerLength(t);if(f>i)if(f-i+s<o.byteLength)if(n)resizeHeader(t,f);else throw u.pop(),new RangeError(`Header of size ${i} has no capacity for new root ${e}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);else throw u.pop(),new RangeError(`Buffer has no capacity for a new root ${e}`)},blockLength=({cid:t,bytes:e})=>{const r=t.bytes.byteLength+e.byteLength;return varint$4.encodingLength(r)+r},addBlock=(t,{cid:e,bytes:r})=>{const n=e.bytes.byteLength+r.byteLength,o=varint$4.encode(n);if(t.byteOffset+o.length+n>t.bytes.byteLength)throw new RangeError("Buffer has no capacity for this block");writeBytes$1(t,o),writeBytes$1(t,e.bytes),writeBytes$1(t,r)},close=(t,e={})=>{const{resize:r=!1}=e,{roots:n,bytes:o,byteOffset:i,headerSize:s}=t,u=encode$n({version:1,roots:n}),f=varint$4.encode(u.length),h=f.length+u.byteLength;if(s-h===0)return writeHeader(t,f,u),o.subarray(0,i);if(r)return resizeHeader(t,h),writeHeader(t,f,u),o.subarray(0,t.byteOffset);throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`)},resizeHeader=(t,e)=>{const{bytes:r,headerSize:n}=t;r.set(r.subarray(n,t.byteOffset),e),t.byteOffset+=e-n,t.headerSize=e},writeBytes$1=(t,e)=>{t.bytes.set(e,t.byteOffset),t.byteOffset+=e.length},writeHeader=({bytes:t},e,r)=>{t.set(e),t.set(r,e.length)},headerPreludeTokens=[new Token(Type.map,2),new Token(Type.string,"version"),new Token(Type.uint,1),new Token(Type.string,"roots")],CID_TAG=new Token(Type.tag,42),calculateHeaderLength=t=>{const e=[...headerPreludeTokens];e.push(new Token(Type.array,t.length));for(const n of t)e.push(CID_TAG),e.push(new Token(Type.bytes,{length:n+1}));const r=tokensToLength(e);return varint$4.encodingLength(r)+r},headerLength=({roots:t})=>calculateHeaderLength(t.map(e=>e.bytes.byteLength)),createWriter=(t,e={})=>{const{roots:r=[],byteOffset:n=0,byteLength:o=t.byteLength,headerSize:i=headerLength({roots:r})}=e,s=new Uint8Array(t,n,o),u=new CarBufferWriter(s,i);for(const f of r)u.addRoot(f);return u},Kinds={Null:t=>t===null,Int:t=>Number.isInteger(t),Float:t=>typeof t=="number"&&Number.isFinite(t),String:t=>typeof t=="string",Bool:t=>typeof t=="boolean",Bytes:t=>t instanceof Uint8Array,Link:t=>!Kinds.Null(t)&&typeof t=="object"&&t.asCID===t,List:t=>Array.isArray(t),Map:t=>!Kinds.Null(t)&&typeof t=="object"&&t.asCID!==t&&!Kinds.List(t)&&!Kinds.Bytes(t)},Types={Int:Kinds.Int,"CarHeader > version":t=>Types.Int(t),"CarHeader > roots (anon) > valueType (anon)":Kinds.Link,"CarHeader > roots (anon)":t=>Kinds.List(t)&&Array.prototype.every.call(t,Types["CarHeader > roots (anon) > valueType (anon)"]),"CarHeader > roots":t=>Types["CarHeader > roots (anon)"](t),CarHeader:t=>{const e=t&&Object.keys(t);return Kinds.Map(t)&&["version"].every(r=>e.includes(r))&&Object.entries(t).every(([r,n])=>Types["CarHeader > "+r]&&Types["CarHeader > "+r](n))}},CarHeader=Types.CarHeader,CIDV0_BYTES={SHA2_256:18,LENGTH:32,DAG_PB:112},V2_HEADER_LENGTH=16+8+8+8;async function readVarint(t){const e=await t.upTo(8);if(!e.length)throw new Error("Unexpected end of data");const r=varint$4.decode(e);return t.seek(varint$4.decode.bytes),r}async function readV2Header(t){const e=await t.exactly(V2_HEADER_LENGTH),r=new DataView(e.buffer,e.byteOffset,e.byteLength);let n=0;const o={version:2,characteristics:[r.getBigUint64(n,!0),r.getBigUint64(n+=8,!0)],dataOffset:Number(r.getBigUint64(n+=8,!0)),dataSize:Number(r.getBigUint64(n+=8,!0)),indexOffset:Number(r.getBigUint64(n+=8,!0))};return t.seek(V2_HEADER_LENGTH),o}async function readHeader$1(t,e){const r=await readVarint(t);if(r===0)throw new Error("Invalid CAR header (zero length)");const n=await t.exactly(r);t.seek(r);const o=decode$n(n);if(!CarHeader(o))throw new Error("Invalid CAR header format");if(o.version!==1&&o.version!==2||e!==void 0&&o.version!==e)throw new Error(`Invalid CAR version: ${o.version}${e!==void 0?` (expected ${e})`:""}`);const i=Array.isArray(o.roots);if(o.version===1&&!i||o.version===2&&i)throw new Error("Invalid CAR header format");if(o.version===1)return o;const s=await readV2Header(t);t.seek(s.dataOffset-t.pos);const u=await readHeader$1(t,1);return Object.assign(u,s)}async function readMultihash(t){const e=await t.upTo(8);varint$4.decode(e);const r=varint$4.decode.bytes,n=varint$4.decode(e.subarray(varint$4.decode.bytes)),o=varint$4.decode.bytes,i=r+o+n,s=await t.exactly(i);return t.seek(i),s}async function readCid(t){const e=await t.exactly(2);if(e[0]===CIDV0_BYTES.SHA2_256&&e[1]===CIDV0_BYTES.LENGTH){const s=await t.exactly(34);t.seek(34);const u=decode$p(s);return CID$2.create(0,CIDV0_BYTES.DAG_PB,u)}const r=await readVarint(t);if(r!==1)throw new Error(`Unexpected CID version (${r})`);const n=await readVarint(t),o=await readMultihash(t),i=decode$p(o);return CID$2.create(r,n,i)}async function readBlockHead(t){const e=t.pos;let r=await readVarint(t);if(r===0)throw new Error("Invalid CAR section (zero length)");r+=t.pos-e;const n=await readCid(t),o=r-Number(t.pos-e);return{cid:n,length:r,blockLength:o}}async function readBlock(t){const{cid:e,blockLength:r}=await readBlockHead(t),n=await t.exactly(r);return t.seek(r),{bytes:n,cid:e}}async function readBlockIndex(t){const e=t.pos,{cid:r,length:n,blockLength:o}=await readBlockHead(t),i={cid:r,length:n,blockLength:o,offset:e,blockOffset:t.pos};return t.seek(i.blockLength),i}function createDecoder(t){const e=(async()=>{const r=await readHeader$1(t);if(r.version===2){const n=t.pos-r.dataOffset;t=limitReader(t,r.dataSize-n)}return r})();return{header:()=>e,async*blocks(){for(await e;(await t.upTo(8)).length>0;)yield await readBlock(t)},async*blocksIndex(){for(await e;(await t.upTo(8)).length>0;)yield await readBlockIndex(t)}}}function bytesReader(t){let e=0;return{async upTo(r){return t.subarray(e,e+Math.min(r,t.length-e))},async exactly(r){if(r>t.length-e)throw new Error("Unexpected end of data");return t.subarray(e,e+r)},seek(r){e+=r},get pos(){return e}}}function chunkReader(t){let e=0,r=0,n=0,o=new Uint8Array(0);const i=async s=>{r=o.length-n;const u=[o.subarray(n)];for(;r<s;){const h=await t();if(h==null)break;r<0?h.length>r&&u.push(h.subarray(-r)):u.push(h),r+=h.length}o=new Uint8Array(u.reduce((h,g)=>h+g.length,0));let f=0;for(const h of u)o.set(h,f),f+=h.length;n=0};return{async upTo(s){return o.length-n<s&&await i(s),o.subarray(n,n+Math.min(o.length-n,s))},async exactly(s){if(o.length-n<s&&await i(s),o.length-n<s)throw new Error("Unexpected end of data");return o.subarray(n,n+s)},seek(s){e+=s,n+=s},get pos(){return e}}}function asyncIterableReader(t){const e=t[Symbol.asyncIterator]();async function r(){const n=await e.next();return n.done?null:n.value}return chunkReader(r)}function limitReader(t,e){let r=0;return{async upTo(n){let o=await t.upTo(n);return o.length+r>e&&(o=o.subarray(0,e-r)),o},async exactly(n){const o=await t.exactly(n);if(o.length+r>e)throw new Error("Unexpected end of data");return o},seek(n){r+=n,t.seek(n)},get pos(){return t.pos}}}class CarReader{constructor(e,r){this._header=e,this._blocks=r,this._keys=r.map(n=>n.cid.toString())}get version(){return this._header.version}async getRoots(){return this._header.roots}async has(e){return this._keys.indexOf(e.toString())>-1}async get(e){const r=this._keys.indexOf(e.toString());return r>-1?this._blocks[r]:void 0}async*blocks(){for(const e of this._blocks)yield e}async*cids(){for(const e of this._blocks)yield e.cid}static async fromBytes(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return decodeReaderComplete(bytesReader(e))}static async fromIterable(e){if(!e||typeof e[Symbol.asyncIterator]!="function")throw new TypeError("fromIterable() requires an async iterable");return decodeReaderComplete(asyncIterableReader(e))}}async function decodeReaderComplete(t){const e=createDecoder(t),r=await e.header(),n=[];for await(const o of e.blocks())n.push(o);return new CarReader(r,n)}const from$6=({name:t,code:e,encode:r})=>new Hasher$2(t,e,r);class Hasher$2{constructor(e,r,n){this.name=e,this.code=r,this.encode=n}digest(e){if(e instanceof Uint8Array){const r=this.encode(e);return r instanceof Uint8Array?create$6(this.code,r):r.then(n=>create$6(this.code,n))}else throw Error("Unknown type, must be binary type")}}const name$6="raw",code$8=85,encode$m=t=>coerce$4(t),decode$m=t=>coerce$4(t),raw=Object.freeze(Object.defineProperty({__proto__:null,name:name$6,code:code$8,encode:encode$m,decode:decode$m},Symbol.toStringTag,{value:"Module"})),sha$2=t=>async e=>new Uint8Array(await crypto.subtle.digest(t,e)),sha256$2=from$6({name:"sha2-256",code:18,encode:sha$2("SHA-256")}),sha512$2=from$6({name:"sha2-512",code:19,encode:sha$2("SHA-512")}),sha2$2=Object.freeze(Object.defineProperty({__proto__:null,sha256:sha256$2,sha512:sha512$2},Symbol.toStringTag,{value:"Module"})),readonly=({enumerable:t=!0,configurable:e=!1}={})=>({enumerable:t,configurable:e,writable:!1}),links=function*(t,e){if(t!=null&&!(t instanceof Uint8Array))for(const[r,n]of Object.entries(t)){const o=[...e,r];if(n!=null&&typeof n=="object")if(Array.isArray(n))for(const[i,s]of n.entries()){const u=[...o,i],f=CID$2.asCID(s);f?yield[u.join("/"),f]:typeof s=="object"&&(yield*links(s,u))}else{const i=CID$2.asCID(n);i?yield[o.join("/"),i]:yield*links(n,o)}}},tree=function*(t,e){if(t!=null)for(const[r,n]of Object.entries(t)){const o=[...e,r];if(yield o.join("/"),n!=null&&!(n instanceof Uint8Array)&&typeof n=="object"&&!CID$2.asCID(n))if(Array.isArray(n))for(const[i,s]of n.entries()){const u=[...o,i];yield u.join("/"),typeof s=="object"&&!CID$2.asCID(s)&&(yield*tree(s,u))}else yield*tree(n,o)}},get$1=(t,e)=>{let r=t;for(const[n,o]of e.entries()){if(r=r[o],r==null)throw new Error(`Object has no property at ${e.slice(0,n+1).map(s=>`[${JSON.stringify(s)}]`).join("")}`);const i=CID$2.asCID(r);if(i)return{value:i,remaining:e.slice(n+1).join("/")}}return{value:r}};class Block{constructor({cid:e,bytes:r,value:n}){if(!e||!r||typeof n>"u")throw new Error("Missing required argument");this.cid=e,this.bytes=r,this.value=n,this.asBlock=this,Object.defineProperties(this,{cid:readonly(),bytes:readonly(),value:readonly(),asBlock:readonly()})}links(){return links(this.value,[])}tree(){return tree(this.value,[])}get(e="/"){return get$1(this.value,e.split("/").filter(Boolean))}}const encode$l=async({value:t,codec:e,hasher:r})=>{if(typeof t>"u")throw new Error('Missing required argument "value"');if(!e||!r)throw new Error("Missing required argument: codec or hasher");const n=e.encode(t),o=await r.digest(n),i=CID$2.create(1,e.code,o);return new Block({value:t,bytes:n,cid:i})},createUnsafe=({bytes:t,cid:e,value:r,codec:n})=>{const o=r!==void 0?r:n&&n.decode(t);if(o===void 0)throw new Error('Missing required argument, must either provide "value" or "codec"');return new Block({cid:e,bytes:t,value:o})},create$5=async({bytes:t,cid:e,hasher:r,codec:n})=>{if(!t)throw new Error('Missing required argument "bytes"');if(!r)throw new Error('Missing required argument "hasher"');const o=n.decode(t),i=await r.digest(t);if(!equals$6(e.multihash.bytes,i.bytes))throw new Error("CID hash does not match bytes");return createUnsafe({bytes:t,cid:e,value:o,codec:n})};function mitt(t){return{all:t=t||new Map,on:function(e,r){var n=t.get(e);n?n.push(r):t.set(e,[r])},off:function(e,r){var n=t.get(e);n&&(r?n.splice(n.indexOf(r)>>>0,1):t.set(e,[]))},emit:function(e,r){var n=t.get(e);n&&n.slice().map(function(o){o(r)}),(n=t.get("*"))&&n.slice().map(function(o){o(e,r)})}}}const{isBinary}=byteslib,encode$k=t=>isBinary(t)?encode$l({value:t,hasher:sha256$2,codec:raw}):encode$l({value:t,hasher:sha256$2,codec:dagCBOR}),decode$l=({bytes:t,cid:e})=>{let r,n;const{code:o}=e,i=e.multihash.code||decode$p(e.multihash).code;if(i===18)r=sha256$2;else throw new Error("Unsupported hash function: "+i);if(o===113)n=dagCBOR;else if(o===85)n=raw;else throw new Error("Unsupported codec: "+o);return create$5({bytes:t,cid:e,codec:n,hasher:r})};class Transaction{constructor(){Object.assign(this,mitt()),this.blocks=[]}static create(){return new this}static async load(e){const r=await CarReader.fromBytes(e),[n]=await r.getRoots();return{root:n,get:i=>r.get(i).then(s=>decode$l(s)).then(({value:s})=>s)}}async add(e){const r=await encode$k(e);return this.last=r,this.blocks.push(r),this.emit("size",this.size),r.cid}async get(e){const{cid:r,bytes:n,value:o}=await decode$l(e);return{cid:r,bytes:n,value:o}}undo(){return this.blocks.pop()}async commit(){const e=this.last.cid;let r=0,n=headerLength({roots:[e]});r+=n;for(const s of this.blocks)r+=blockLength(s);const o=new Uint8Array(r),i=await createWriter(o,{headerSize:n});i.addRoot(e);for(const s of this.blocks)i.write(s);return await i.close(),i.bytes}get size(){if(!(this!=null&&this.last))return 0;const e=this.last.cid;let r=0,n=headerLength({roots:[e]});r+=n;for(const o of this.blocks)r+=blockLength(o);return r}}var objectSafeGet=get;function get(t,e,r){if(!t)return r;var n,o;if(Array.isArray(e)&&(n=e.slice(0)),typeof e=="string"&&(n=e.split(".")),typeof e=="symbol"&&(n=[e]),!Array.isArray(n))throw new Error("props arg must be an array, a string or a symbol");for(;n.length;)if(o=n.shift(),!t||(t=t[o],t===void 0))return r;return t}var browser={exports:{}},ms$1,hasRequiredMs;function requireMs(){if(hasRequiredMs)return ms$1;hasRequiredMs=1;var t=1e3,e=t*60,r=e*60,n=r*24,o=n*7,i=n*365.25;ms$1=function(g,$){$=$||{};var E=typeof g;if(E==="string"&&g.length>0)return s(g);if(E==="number"&&isFinite(g))return $.long?f(g):u(g);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(g))};function s(g){if(g=String(g),!(g.length>100)){var $=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(g);if(!!$){var E=parseFloat($[1]),A=($[2]||"ms").toLowerCase();switch(A){case"years":case"year":case"yrs":case"yr":case"y":return E*i;case"weeks":case"week":case"w":return E*o;case"days":case"day":case"d":return E*n;case"hours":case"hour":case"hrs":case"hr":case"h":return E*r;case"minutes":case"minute":case"mins":case"min":case"m":return E*e;case"seconds":case"second":case"secs":case"sec":case"s":return E*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return E;default:return}}}}function u(g){var $=Math.abs(g);return $>=n?Math.round(g/n)+"d":$>=r?Math.round(g/r)+"h":$>=e?Math.round(g/e)+"m":$>=t?Math.round(g/t)+"s":g+"ms"}function f(g){var $=Math.abs(g);return $>=n?h(g,$,n,"day"):$>=r?h(g,$,r,"hour"):$>=e?h(g,$,e,"minute"):$>=t?h(g,$,t,"second"):g+" ms"}function h(g,$,E,A){var w=$>=E*1.5;return Math.round(g/E)+" "+A+(w?"s":"")}return ms$1}function setup(t){r.debug=r,r.default=r,r.coerce=f,r.disable=i,r.enable=o,r.enabled=s,r.humanize=requireMs(),r.destroy=h,Object.keys(t).forEach(g=>{r[g]=t[g]}),r.names=[],r.skips=[],r.formatters={};function e(g){let $=0;for(let E=0;E<g.length;E++)$=($<<5)-$+g.charCodeAt(E),$|=0;return r.colors[Math.abs($)%r.colors.length]}r.selectColor=e;function r(g){let $,E=null,A,w;function v(...k){if(!v.enabled)return;const P=v,L=Number(new Date),N=L-($||L);P.diff=N,P.prev=$,P.curr=L,$=L,k[0]=r.coerce(k[0]),typeof k[0]!="string"&&k.unshift("%O");let q=0;k[0]=k[0].replace(/%([a-zA-Z%])/g,(Z,j)=>{if(Z==="%%")return"%";q++;const B=r.formatters[j];if(typeof B=="function"){const K=k[q];Z=B.call(P,K),k.splice(q,1),q--}return Z}),r.formatArgs.call(P,k),(P.log||r.log).apply(P,k)}return v.namespace=g,v.useColors=r.useColors(),v.color=r.selectColor(g),v.extend=n,v.destroy=r.destroy,Object.defineProperty(v,"enabled",{enumerable:!0,configurable:!1,get:()=>E!==null?E:(A!==r.namespaces&&(A=r.namespaces,w=r.enabled(g)),w),set:k=>{E=k}}),typeof r.init=="function"&&r.init(v),v}function n(g,$){const E=r(this.namespace+(typeof $>"u"?":":$)+g);return E.log=this.log,E}function o(g){r.save(g),r.namespaces=g,r.names=[],r.skips=[];let $;const E=(typeof g=="string"?g:"").split(/[\s,]+/),A=E.length;for($=0;$<A;$++)!E[$]||(g=E[$].replace(/\*/g,".*?"),g[0]==="-"?r.skips.push(new RegExp("^"+g.slice(1)+"$")):r.names.push(new RegExp("^"+g+"$")))}function i(){const g=[...r.names.map(u),...r.skips.map(u).map($=>"-"+$)].join(",");return r.enable(""),g}function s(g){if(g[g.length-1]==="*")return!0;let $,E;for($=0,E=r.skips.length;$<E;$++)if(r.skips[$].test(g))return!1;for($=0,E=r.names.length;$<E;$++)if(r.names[$].test(g))return!0;return!1}function u(g){return g.toString().substring(2,g.toString().length-2).replace(/\.\*\?$/,"*")}function f(g){return g instanceof Error?g.stack||g.message:g}function h(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return r.enable(r.load()),r}var common=setup;(function(t,e){e.formatArgs=n,e.save=o,e.load=i,e.useColors=r,e.storage=s(),e.destroy=(()=>{let f=!1;return()=>{f||(f=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function r(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function n(f){if(f[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+f[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),!this.useColors)return;const h="color: "+this.color;f.splice(1,0,h,"color: inherit");let g=0,$=0;f[0].replace(/%[a-zA-Z%]/g,E=>{E!=="%%"&&(g++,E==="%c"&&($=g))}),f.splice($,0,h)}e.log=console.debug||console.log||(()=>{});function o(f){try{f?e.storage.setItem("debug",f):e.storage.removeItem("debug")}catch{}}function i(){let f;try{f=e.storage.getItem("debug")}catch{}return!f&&typeof process<"u"&&"env"in process&&(f=process.env.DEBUG),f}function s(){try{return localStorage}catch{}}t.exports=common(e);const{formatters:u}=t.exports;u.j=function(f){try{return JSON.stringify(f)}catch(h){return"[UnexpectedJSONParseError]: "+h.message}}})(browser,browser.exports);const debug=browser.exports;function assign(t,e){for(const r in e)Object.defineProperty(t,r,{value:e[r],enumerable:!0,configurable:!0});return t}function createError(t,e,r){if(!t||typeof t=="string")throw new TypeError("Please pass an Error to err-code");r||(r={}),typeof e=="object"&&(r=e,e=""),e&&(r.code=e);try{return assign(t,r)}catch{r.message=t.message,r.stack=t.stack;const o=function(){};return o.prototype=Object.create(Object.getPrototypeOf(t)),assign(new o,r)}}var errCode=createError;let nanoid$1=(t=21)=>crypto.getRandomValues(new Uint8Array(t)).reduce((e,r)=>(r&=63,r<36?e+=r.toString(36):r<62?e+=(r-26).toString(36).toUpperCase():r>62?e+="-":e+="_",e),"");function base$3(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var i=t.charAt(o),s=i.charCodeAt(0);if(r[s]!==255)throw new TypeError(i+" is ambiguous");r[s]=o}var u=t.length,f=t.charAt(0),h=Math.log(u)/Math.log(256),g=Math.log(256)/Math.log(u);function $(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var v=0,k=0,P=0,L=w.length;P!==L&&w[P]===0;)P++,v++;for(var N=(L-P)*g+1>>>0,q=new Uint8Array(N);P!==L;){for(var X=w[P],Z=0,j=N-1;(X!==0||Z<k)&&j!==-1;j--,Z++)X+=256*q[j]>>>0,q[j]=X%u>>>0,X=X/u>>>0;if(X!==0)throw new Error("Non-zero carry");k=Z,P++}for(var B=N-k;B!==N&&q[B]===0;)B++;for(var K=f.repeat(v);B<N;++B)K+=t.charAt(q[B]);return K}function E(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var v=0;if(w[v]!==" "){for(var k=0,P=0;w[v]===f;)k++,v++;for(var L=(w.length-v)*h+1>>>0,N=new Uint8Array(L);w[v];){var q=r[w.charCodeAt(v)];if(q===255)return;for(var X=0,Z=L-1;(q!==0||X<P)&&Z!==-1;Z--,X++)q+=u*N[Z]>>>0,N[Z]=q%256>>>0,q=q/256>>>0;if(q!==0)throw new Error("Non-zero carry");P=X,v++}if(w[v]!==" "){for(var j=L-P;j!==L&&N[j]===0;)j++;for(var B=new Uint8Array(k+(L-j)),K=k;j!==L;)B[K++]=N[j++];return B}}}function A(w){var v=E(w);if(v)return v;throw new Error(`Non-${e} character`)}return{encode:$,decodeUnsafe:E,decode:A}}var src$3=base$3,_brrp__multiformats_scope_baseX$3=src$3;const coerce$3=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},fromString$5=t=>new TextEncoder().encode(t),toString$6=t=>new TextDecoder().decode(t);class Encoder$3{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Decoder$3{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$3(this,e)}}class ComposedDecoder$3{constructor(e){this.decoders=e}or(e){return or$3(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or$3=(t,e)=>new ComposedDecoder$3({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});class Codec$3{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$3(e,r,n),this.decoder=new Decoder$3(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const from$5=({name:t,prefix:e,encode:r,decode:n})=>new Codec$3(t,e,r,n),baseX$3=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$3(r,e);return from$5({prefix:t,name:e,encode:n,decode:i=>coerce$3(o(i))})},decode$k=(t,e,r,n)=>{const o={};for(let g=0;g<e.length;++g)o[e[g]]=g;let i=t.length;for(;t[i-1]==="=";)--i;const s=new Uint8Array(i*r/8|0);let u=0,f=0,h=0;for(let g=0;g<i;++g){const $=o[t[g]];if($===void 0)throw new SyntaxError(`Non-${n} character`);f=f<<r|$,u+=r,u>=8&&(u-=8,s[h++]=255&f>>u)}if(u>=r||255&f<<8-u)throw new SyntaxError("Unexpected end of data");return s},encode$j=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let i="",s=0,u=0;for(let f=0;f<t.length;++f)for(u=u<<8|t[f],s+=8;s>r;)s-=r,i+=e[o&u>>s];if(s&&(i+=e[o&u<<r-s]),n)for(;i.length*r&7;)i+="=";return i},rfc4648$3=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$5({prefix:e,name:t,encode(o){return encode$j(o,n,r)},decode(o){return decode$k(o,n,r,t)}}),identity$8=from$5({prefix:"\0",name:"identity",encode:t=>toString$6(t),decode:t=>fromString$5(t)}),identityBase$2=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$8},Symbol.toStringTag,{value:"Module"})),base2$4=rfc4648$3({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$5=Object.freeze(Object.defineProperty({__proto__:null,base2:base2$4},Symbol.toStringTag,{value:"Module"})),base8$4=rfc4648$3({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$5=Object.freeze(Object.defineProperty({__proto__:null,base8:base8$4},Symbol.toStringTag,{value:"Module"})),base10$4=baseX$3({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$5=Object.freeze(Object.defineProperty({__proto__:null,base10:base10$4},Symbol.toStringTag,{value:"Module"})),base16$4=rfc4648$3({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper$2=rfc4648$3({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$5=Object.freeze(Object.defineProperty({__proto__:null,base16:base16$4,base16upper:base16upper$2},Symbol.toStringTag,{value:"Module"})),base32$4=rfc4648$3({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper$1=rfc4648$3({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad$1=rfc4648$3({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper$1=rfc4648$3({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex$1=rfc4648$3({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper$1=rfc4648$3({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad$1=rfc4648$3({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper$1=rfc4648$3({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z$1=rfc4648$3({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$5=Object.freeze(Object.defineProperty({__proto__:null,base32:base32$4,base32upper:base32upper$1,base32pad:base32pad$1,base32padupper:base32padupper$1,base32hex:base32hex$1,base32hexupper:base32hexupper$1,base32hexpad:base32hexpad$1,base32hexpadupper:base32hexpadupper$1,base32z:base32z$1},Symbol.toStringTag,{value:"Module"})),base36$4=baseX$3({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper$2=baseX$3({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$5=Object.freeze(Object.defineProperty({__proto__:null,base36:base36$4,base36upper:base36upper$2},Symbol.toStringTag,{value:"Module"})),base58btc$3=baseX$3({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr$1=baseX$3({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58$1=Object.freeze(Object.defineProperty({__proto__:null,base58btc:base58btc$3,base58flickr:base58flickr$1},Symbol.toStringTag,{value:"Module"})),base64$7=rfc4648$3({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad$2=rfc4648$3({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url$2=rfc4648$3({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad$2=rfc4648$3({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$8=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$7,base64pad:base64pad$2,base64url:base64url$2,base64urlpad:base64urlpad$2},Symbol.toStringTag,{value:"Module"})),alphabet$2=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),alphabetBytesToChars$2=alphabet$2.reduce((t,e,r)=>(t[r]=e,t),[]),alphabetCharsToBytes$2=alphabet$2.reduce((t,e,r)=>(t[e.codePointAt(0)]=r,t),[]);function encode$i(t){return t.reduce((e,r)=>(e+=alphabetBytesToChars$2[r],e),"")}function decode$j(t){const e=[];for(const r of t){const n=alphabetCharsToBytes$2[r.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${r}`);e.push(n)}return new Uint8Array(e)}const base256emoji$4=from$5({prefix:"\u{1F680}",name:"base256emoji",encode:encode$i,decode:decode$j}),base256emoji$5=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:base256emoji$4},Symbol.toStringTag,{value:"Module"}));var encode_1$2=encode$h,MSB$3=128,REST$3=127,MSBALL$2=~REST$3,INT$2=Math.pow(2,31);function encode$h(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT$2;)e[r++]=t&255|MSB$3,t/=128;for(;t&MSBALL$2;)e[r++]=t&255|MSB$3,t>>>=7;return e[r]=t|0,encode$h.bytes=r-n+1,e}var decode$i=read$2,MSB$1$2=128,REST$1$2=127;function read$2(t,n){var r=0,n=n||0,o=0,i=n,s,u=t.length;do{if(i>=u)throw read$2.bytes=0,new RangeError("Could not decode varint");s=t[i++],r+=o<28?(s&REST$1$2)<<o:(s&REST$1$2)*Math.pow(2,o),o+=7}while(s>=MSB$1$2);return read$2.bytes=i-n,r}var N1$2=Math.pow(2,7),N2$2=Math.pow(2,14),N3$2=Math.pow(2,21),N4$2=Math.pow(2,28),N5$2=Math.pow(2,35),N6$2=Math.pow(2,42),N7$2=Math.pow(2,49),N8$2=Math.pow(2,56),N9$2=Math.pow(2,63),length$3=function(t){return t<N1$2?1:t<N2$2?2:t<N3$2?3:t<N4$2?4:t<N5$2?5:t<N6$2?6:t<N7$2?7:t<N8$2?8:t<N9$2?9:10},varint$2={encode:encode_1$2,decode:decode$i,encodingLength:length$3},_brrp_varint$2=varint$2;const encodeTo$2=(t,e,r=0)=>(_brrp_varint$2.encode(t,e,r),e),encodingLength$2=t=>_brrp_varint$2.encodingLength(t),create$4=(t,e)=>{const r=e.byteLength,n=encodingLength$2(t),o=n+encodingLength$2(r),i=new Uint8Array(o+r);return encodeTo$2(t,i,0),encodeTo$2(r,i,n),i.set(e,o),new Digest$2(t,r,e,i)};class Digest$2{constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}}const from$4=({name:t,code:e,encode:r})=>new Hasher$1(t,e,r);class Hasher$1{constructor(e,r,n){this.name=e,this.code=r,this.encode=n}digest(e){if(e instanceof Uint8Array){const r=this.encode(e);return r instanceof Uint8Array?create$4(this.code,r):r.then(n=>create$4(this.code,n))}else throw Error("Unknown type, must be binary type")}}const sha$1=t=>async e=>new Uint8Array(await crypto.subtle.digest(t,e)),sha256$1=from$4({name:"sha2-256",code:18,encode:sha$1("SHA-256")}),sha512$1=from$4({name:"sha2-512",code:19,encode:sha$1("SHA-512")}),sha2$1=Object.freeze(Object.defineProperty({__proto__:null,sha256:sha256$1,sha512:sha512$1},Symbol.toStringTag,{value:"Module"})),code$7=0,name$5="identity",encode$g=coerce$3,digest$2=t=>create$4(code$7,encode$g(t)),identity$6={code:code$7,name:name$5,encode:encode$g,digest:digest$2},identity$7=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$6},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const bases$2={...identityBase$2,...base2$5,...base8$5,...base10$5,...base16$5,...base32$5,...base36$5,...base58$1,...base64$8,...base256emoji$5};({...sha2$1,...identity$7});function asUint8Array$2(t){return globalThis.Buffer!=null?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t}function allocUnsafe$2(t=0){var e;return((e=globalThis.Buffer)==null?void 0:e.allocUnsafe)!=null?asUint8Array$2(globalThis.Buffer.allocUnsafe(t)):new Uint8Array(t)}function createCodec$2(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}const string$2=createCodec$2("utf8","u",t=>"u"+new TextDecoder("utf8").decode(t),t=>new TextEncoder().encode(t.substring(1))),ascii$2=createCodec$2("ascii","a",t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},t=>{t=t.substring(1);const e=allocUnsafe$2(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}),BASES$2={utf8:string$2,"utf-8":string$2,hex:bases$2.base16,latin1:ascii$2,ascii:ascii$2,binary:ascii$2,...bases$2};function toString$5(t,e="utf8"){const r=BASES$2[e];if(r==null)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(t.buffer,t.byteOffset,t.byteLength).toString("utf8"):r.encoder.encode(t).substring(1)}function fromString$4(t,e="utf8"){const r=BASES$2[e];if(r==null)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array$2(globalThis.Buffer.from(t,"utf-8")):r.decoder.decode(`${r.prefix}${t}`)}const pathSepS="/",pathSepB=new TextEncoder().encode(pathSepS),pathSep=pathSepB[0];class Key{constructor(e,r){if(typeof e=="string")this._buf=fromString$4(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(r==null&&(r=!0),r&&this.clean(),this._buf.byteLength===0||this._buf[0]!==pathSep)throw new Error("Invalid key")}toString(e="utf8"){return toString$5(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new Key(e.join(pathSepS))}static random(){return new Key(nanoid$1().replace(/-/g,""))}static asKey(e){return e instanceof Uint8Array||typeof e=="string"?new Key(e):typeof e.uint8Array=="function"?new Key(e.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=pathSepB),this._buf[0]!==pathSep){const e=new Uint8Array(this._buf.byteLength+1);e.fill(pathSep,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===pathSep;)this._buf=this._buf.subarray(0,-1)}less(e){const r=this.list(),n=e.list();for(let o=0;o<r.length;o++){if(n.length<o+1)return!1;const i=r[o],s=n[o];if(i<s)return!0;if(i>s)return!1}return r.length<n.length}reverse(){return Key.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(pathSepS).slice(1)}type(){return namespaceType(this.baseNamespace())}name(){return namespaceValue(this.baseNamespace())}instance(e){return new Key(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(pathSepS)||(e+=pathSepS),e+=this.type(),new Key(e)}parent(){const e=this.list();return e.length===1?new Key(pathSepS):new Key(e.slice(0,-1).join(pathSepS))}child(e){return this.toString()===pathSepS?e:e.toString()===pathSepS?this:new Key(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return Key.withNamespaces([...this.namespaces(),...flatten(e.map(r=>r.namespaces()))])}}function namespaceType(t){const e=t.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function namespaceValue(t){const e=t.split(":");return e[e.length-1]}function flatten(t){return[].concat(...t)}const length$2=async t=>{let e=0;for await(const r of t)e++;return e};var itLength=length$2;const log$7=debug("ipfs:repo:migrator:migration-8");function unwrap$1(t){return t.child?unwrap$1(t.child):t}function keyToMultihash$1(t){try{const e=base32$6.decode(`b${t.toString().toLowerCase().slice(1)}`),r=CID$2.decode(e).multihash.bytes,n=base32$6.encode(r).slice(1).toUpperCase();return new Key(`/${n}`,!1)}catch{return t}}function keyToCid$1(t){try{const e=base32$6.decode(`b${t.toString().toLowerCase().slice(1)}`),r=decode$p(e),n=base32$6.encode(CID$2.createV1(code$8,r).bytes).slice(1);return new Key(`/${n.toUpperCase()}`,!1)}catch{return t}}async function process$3(t,e,r){const n=t.blocks;await n.open();const o=unwrap$1(n),i=await itLength(o.queryKeys({filters:[s=>r(s).toString()!==s.toString()]}));try{let s=0;for await(const u of o.query({})){const f=r(u.key);f.toString()!==u.key.toString()&&(s+=1,log$7(`Migrating Block from ${u.key} to ${f}`,await o.has(u.key)),await o.delete(u.key),await o.put(f,u.value),e(s/i*100,`Migrated Block from ${u.key} to ${f}`))}}finally{await n.close()}}const migration$4={version:8,description:"Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",migrate:(t,e=()=>{})=>process$3(t,e,keyToMultihash$1),revert:(t,e=()=>{})=>process$3(t,e,keyToCid$1)},textDecoder$1=new TextDecoder;function decodeVarint(t,e){let r=0;for(let n=0;;n+=7){if(n>=64)throw new Error("protobuf: varint overflow");if(e>=t.length)throw new Error("protobuf: unexpected end of data");const o=t[e++];if(r+=n<28?(o&127)<<n:(o&127)*2**n,o<128)break}return[r,e]}function decodeBytes(t,e){let r;[r,e]=decodeVarint(t,e);const n=e+r;if(r<0||n<0)throw new Error("protobuf: invalid length");if(n>t.length)throw new Error("protobuf: unexpected end of data");return[t.subarray(e,n),n]}function decodeKey(t,e){let r;return[r,e]=decodeVarint(t,e),[r&7,r>>3,e]}function decodeLink(t){const e={},r=t.length;let n=0;for(;n<r;){let o,i;if([o,i,n]=decodeKey(t,n),i===1){if(e.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(o!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Hash`);if(e.Name!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[e.Hash,n]=decodeBytes(t,n)}else if(i===2){if(e.Name!==void 0)throw new Error("protobuf: (PBLink) duplicate Name section");if(o!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Name`);if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let s;[s,n]=decodeBytes(t,n),e.Name=textDecoder$1.decode(s)}else if(i===3){if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(o!==0)throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Tsize`);[e.Tsize,n]=decodeVarint(t,n)}else throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${i}`)}if(n>r)throw new Error("protobuf: (PBLink) unexpected end of data");return e}function decodeNode(t){const e=t.length;let r=0,n,o=!1,i;for(;r<e;){let u,f;if([u,f,r]=decodeKey(t,r),u!==2)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${u}`);if(f===1){if(i)throw new Error("protobuf: (PBNode) duplicate Data section");[i,r]=decodeBytes(t,r),n&&(o=!0)}else if(f===2){if(o)throw new Error("protobuf: (PBNode) duplicate Links section");n||(n=[]);let h;[h,r]=decodeBytes(t,r),n.push(decodeLink(h))}else throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${f}`)}if(r>e)throw new Error("protobuf: (PBNode) unexpected end of data");const s={};return i&&(s.Data=i),s.Links=n||[],s}const textEncoder$2=new TextEncoder,maxInt32=2**32,maxUInt32=2**31;function encodeLink(t,e){let r=e.length;if(typeof t.Tsize=="number"){if(t.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(t.Tsize))throw new Error("Tsize too large for encoding");r=encodeVarint(e,r,t.Tsize)-1,e[r]=24}if(typeof t.Name=="string"){const n=textEncoder$2.encode(t.Name);r-=n.length,e.set(n,r),r=encodeVarint(e,r,n.length)-1,e[r]=18}return t.Hash&&(r-=t.Hash.length,e.set(t.Hash,r),r=encodeVarint(e,r,t.Hash.length)-1,e[r]=10),e.length-r}function encodeNode(t){const e=sizeNode(t),r=new Uint8Array(e);let n=e;if(t.Data&&(n-=t.Data.length,r.set(t.Data,n),n=encodeVarint(r,n,t.Data.length)-1,r[n]=10),t.Links)for(let o=t.Links.length-1;o>=0;o--){const i=encodeLink(t.Links[o],r.subarray(0,n));n-=i,n=encodeVarint(r,n,i)-1,r[n]=18}return r}function sizeLink(t){let e=0;if(t.Hash){const r=t.Hash.length;e+=1+r+sov(r)}if(typeof t.Name=="string"){const r=textEncoder$2.encode(t.Name).length;e+=1+r+sov(r)}return typeof t.Tsize=="number"&&(e+=1+sov(t.Tsize)),e}function sizeNode(t){let e=0;if(t.Data){const r=t.Data.length;e+=1+r+sov(r)}if(t.Links)for(const r of t.Links){const n=sizeLink(r);e+=1+n+sov(n)}return e}function encodeVarint(t,e,r){e-=sov(r);const n=e;for(;r>=maxUInt32;)t[e++]=r&127|128,r/=128;for(;r>=128;)t[e++]=r&127|128,r>>>=7;return t[e]=r,n}function sov(t){return t%2===0&&t++,Math.floor((len64(t)+6)/7)}function len64(t){let e=0;return t>=maxInt32&&(t=Math.floor(t/maxInt32),e=32),t>=1<<16&&(t>>>=16,e+=16),t>=1<<8&&(t>>>=8,e+=8),e+len8tab[t]}const len8tab=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],pbNodeProperties=["Data","Links"],pbLinkProperties=["Hash","Name","Tsize"],textEncoder$1=new TextEncoder;function linkComparator(t,e){if(t===e)return 0;const r=t.Name?textEncoder$1.encode(t.Name):[],n=e.Name?textEncoder$1.encode(e.Name):[];let o=r.length,i=n.length;for(let s=0,u=Math.min(o,i);s<u;++s)if(r[s]!==n[s]){o=r[s],i=n[s];break}return o<i?-1:i<o?1:0}function hasOnlyProperties(t,e){return!Object.keys(t).some(r=>!e.includes(r))}function validate(t){if(!t||typeof t!="object"||Array.isArray(t))throw new TypeError("Invalid DAG-PB form");if(!hasOnlyProperties(t,pbNodeProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(t.Data!==void 0&&!(t.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");if(!Array.isArray(t.Links))throw new TypeError("Invalid DAG-PB form (Links must be an array)");for(let e=0;e<t.Links.length;e++){const r=t.Links[e];if(!r||typeof r!="object"||Array.isArray(r))throw new TypeError("Invalid DAG-PB form (bad link object)");if(!hasOnlyProperties(r,pbLinkProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");if(!r.Hash)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(r.Hash.asCID!==r.Hash)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(r.Name!==void 0&&typeof r.Name!="string")throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(r.Tsize!==void 0&&(typeof r.Tsize!="number"||r.Tsize%1!==0))throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(e>0&&linkComparator(r,t.Links[e-1])===-1)throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}const code$6=112;function encode$f(t){validate(t);const e={};return t.Links&&(e.Links=t.Links.map(r=>{const n={};return r.Hash&&(n.Hash=r.Hash.bytes),r.Name!==void 0&&(n.Name=r.Name),r.Tsize!==void 0&&(n.Tsize=r.Tsize),n})),t.Data&&(e.Data=t.Data),encodeNode(e)}function decode$h(t){const e=decodeNode(t),r={};return e.Data&&(r.Data=e.Data),e.Links&&(r.Links=e.Links.map(n=>{const o={};try{o.Hash=CID$2.decode(n.Hash)}catch{}if(!o.Hash)throw new Error("Invalid Hash field found in link, expected CID");return n.Name!==void 0&&(o.Name=n.Name),n.Tsize!==void 0&&(o.Tsize=n.Tsize),o})),r}var minimal$1={exports:{}},indexMinimal={},minimal={},aspromise=asPromise;function asPromise(t,e){for(var r=new Array(arguments.length-1),n=0,o=2,i=!0;o<arguments.length;)r[n++]=arguments[o++];return new Promise(function(u,f){r[n]=function(g){if(i)if(i=!1,g)f(g);else{for(var $=new Array(arguments.length-1),E=0;E<$.length;)$[E++]=arguments[E];u.apply(null,$)}};try{t.apply(e||null,r)}catch(h){i&&(i=!1,f(h))}})}var base64$6={};(function(t){var e=t;e.length=function(u){var f=u.length;if(!f)return 0;for(var h=0;--f%4>1&&u.charAt(f)==="=";)++h;return Math.ceil(u.length*3)/4-h};for(var r=new Array(64),n=new Array(123),o=0;o<64;)n[r[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;e.encode=function(u,f,h){for(var g=null,$=[],E=0,A=0,w;f<h;){var v=u[f++];switch(A){case 0:$[E++]=r[v>>2],w=(v&3)<<4,A=1;break;case 1:$[E++]=r[w|v>>4],w=(v&15)<<2,A=2;break;case 2:$[E++]=r[w|v>>6],$[E++]=r[v&63],A=0;break}E>8191&&((g||(g=[])).push(String.fromCharCode.apply(String,$)),E=0)}return A&&($[E++]=r[w],$[E++]=61,A===1&&($[E++]=61)),g?(E&&g.push(String.fromCharCode.apply(String,$.slice(0,E))),g.join("")):String.fromCharCode.apply(String,$.slice(0,E))};var i="invalid encoding";e.decode=function(u,f,h){for(var g=h,$=0,E,A=0;A<u.length;){var w=u.charCodeAt(A++);if(w===61&&$>1)break;if((w=n[w])===void 0)throw Error(i);switch($){case 0:E=w,$=1;break;case 1:f[h++]=E<<2|(w&48)>>4,E=w,$=2;break;case 2:f[h++]=(E&15)<<4|(w&60)>>2,E=w,$=3;break;case 3:f[h++]=(E&3)<<6|w,$=0;break}}if($===1)throw Error(i);return h-g},e.test=function(u){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(u)}})(base64$6);var eventemitter=EventEmitter$1;function EventEmitter$1(){this._listeners={}}EventEmitter$1.prototype.on=function(e,r,n){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:r,ctx:n||this}),this};EventEmitter$1.prototype.off=function(e,r){if(e===void 0)this._listeners={};else if(r===void 0)this._listeners[e]=[];else for(var n=this._listeners[e],o=0;o<n.length;)n[o].fn===r?n.splice(o,1):++o;return this};EventEmitter$1.prototype.emit=function(e){var r=this._listeners[e];if(r){for(var n=[],o=1;o<arguments.length;)n.push(arguments[o++]);for(o=0;o<r.length;)r[o].fn.apply(r[o++].ctx,n)}return this};var float=factory(factory);function factory(t){return typeof Float32Array<"u"?function(){var e=new Float32Array([-0]),r=new Uint8Array(e.buffer),n=r[3]===128;function o(f,h,g){e[0]=f,h[g]=r[0],h[g+1]=r[1],h[g+2]=r[2],h[g+3]=r[3]}function i(f,h,g){e[0]=f,h[g]=r[3],h[g+1]=r[2],h[g+2]=r[1],h[g+3]=r[0]}t.writeFloatLE=n?o:i,t.writeFloatBE=n?i:o;function s(f,h){return r[0]=f[h],r[1]=f[h+1],r[2]=f[h+2],r[3]=f[h+3],e[0]}function u(f,h){return r[3]=f[h],r[2]=f[h+1],r[1]=f[h+2],r[0]=f[h+3],e[0]}t.readFloatLE=n?s:u,t.readFloatBE=n?u:s}():function(){function e(n,o,i,s){var u=o<0?1:0;if(u&&(o=-o),o===0)n(1/o>0?0:2147483648,i,s);else if(isNaN(o))n(2143289344,i,s);else if(o>34028234663852886e22)n((u<<31|2139095040)>>>0,i,s);else if(o<11754943508222875e-54)n((u<<31|Math.round(o/1401298464324817e-60))>>>0,i,s);else{var f=Math.floor(Math.log(o)/Math.LN2),h=Math.round(o*Math.pow(2,-f)*8388608)&8388607;n((u<<31|f+127<<23|h)>>>0,i,s)}}t.writeFloatLE=e.bind(null,writeUintLE),t.writeFloatBE=e.bind(null,writeUintBE);function r(n,o,i){var s=n(o,i),u=(s>>31)*2+1,f=s>>>23&255,h=s&8388607;return f===255?h?NaN:u*(1/0):f===0?u*1401298464324817e-60*h:u*Math.pow(2,f-150)*(h+8388608)}t.readFloatLE=r.bind(null,readUintLE),t.readFloatBE=r.bind(null,readUintBE)}(),typeof Float64Array<"u"?function(){var e=new Float64Array([-0]),r=new Uint8Array(e.buffer),n=r[7]===128;function o(f,h,g){e[0]=f,h[g]=r[0],h[g+1]=r[1],h[g+2]=r[2],h[g+3]=r[3],h[g+4]=r[4],h[g+5]=r[5],h[g+6]=r[6],h[g+7]=r[7]}function i(f,h,g){e[0]=f,h[g]=r[7],h[g+1]=r[6],h[g+2]=r[5],h[g+3]=r[4],h[g+4]=r[3],h[g+5]=r[2],h[g+6]=r[1],h[g+7]=r[0]}t.writeDoubleLE=n?o:i,t.writeDoubleBE=n?i:o;function s(f,h){return r[0]=f[h],r[1]=f[h+1],r[2]=f[h+2],r[3]=f[h+3],r[4]=f[h+4],r[5]=f[h+5],r[6]=f[h+6],r[7]=f[h+7],e[0]}function u(f,h){return r[7]=f[h],r[6]=f[h+1],r[5]=f[h+2],r[4]=f[h+3],r[3]=f[h+4],r[2]=f[h+5],r[1]=f[h+6],r[0]=f[h+7],e[0]}t.readDoubleLE=n?s:u,t.readDoubleBE=n?u:s}():function(){function e(n,o,i,s,u,f){var h=s<0?1:0;if(h&&(s=-s),s===0)n(0,u,f+o),n(1/s>0?0:2147483648,u,f+i);else if(isNaN(s))n(0,u,f+o),n(2146959360,u,f+i);else if(s>17976931348623157e292)n(0,u,f+o),n((h<<31|2146435072)>>>0,u,f+i);else{var g;if(s<22250738585072014e-324)g=s/5e-324,n(g>>>0,u,f+o),n((h<<31|g/4294967296)>>>0,u,f+i);else{var $=Math.floor(Math.log(s)/Math.LN2);$===1024&&($=1023),g=s*Math.pow(2,-$),n(g*4503599627370496>>>0,u,f+o),n((h<<31|$+1023<<20|g*1048576&1048575)>>>0,u,f+i)}}}t.writeDoubleLE=e.bind(null,writeUintLE,0,4),t.writeDoubleBE=e.bind(null,writeUintBE,4,0);function r(n,o,i,s,u){var f=n(s,u+o),h=n(s,u+i),g=(h>>31)*2+1,$=h>>>20&2047,E=4294967296*(h&1048575)+f;return $===2047?E?NaN:g*(1/0):$===0?g*5e-324*E:g*Math.pow(2,$-1075)*(E+4503599627370496)}t.readDoubleLE=r.bind(null,readUintLE,0,4),t.readDoubleBE=r.bind(null,readUintBE,4,0)}(),t}function writeUintLE(t,e,r){e[r]=t&255,e[r+1]=t>>>8&255,e[r+2]=t>>>16&255,e[r+3]=t>>>24}function writeUintBE(t,e,r){e[r]=t>>>24,e[r+1]=t>>>16&255,e[r+2]=t>>>8&255,e[r+3]=t&255}function readUintLE(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}function readUintBE(t,e){return(t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3])>>>0}var inquire_1=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}var utf8$2={};(function(t){var e=t;e.length=function(n){for(var o=0,i=0,s=0;s<n.length;++s)i=n.charCodeAt(s),i<128?o+=1:i<2048?o+=2:(i&64512)===55296&&(n.charCodeAt(s+1)&64512)===56320?(++s,o+=4):o+=3;return o},e.read=function(n,o,i){var s=i-o;if(s<1)return"";for(var u=null,f=[],h=0,g;o<i;)g=n[o++],g<128?f[h++]=g:g>191&&g<224?f[h++]=(g&31)<<6|n[o++]&63:g>239&&g<365?(g=((g&7)<<18|(n[o++]&63)<<12|(n[o++]&63)<<6|n[o++]&63)-65536,f[h++]=55296+(g>>10),f[h++]=56320+(g&1023)):f[h++]=(g&15)<<12|(n[o++]&63)<<6|n[o++]&63,h>8191&&((u||(u=[])).push(String.fromCharCode.apply(String,f)),h=0);return u?(h&&u.push(String.fromCharCode.apply(String,f.slice(0,h))),u.join("")):String.fromCharCode.apply(String,f.slice(0,h))},e.write=function(n,o,i){for(var s=i,u,f,h=0;h<n.length;++h)u=n.charCodeAt(h),u<128?o[i++]=u:u<2048?(o[i++]=u>>6|192,o[i++]=u&63|128):(u&64512)===55296&&((f=n.charCodeAt(h+1))&64512)===56320?(u=65536+((u&1023)<<10)+(f&1023),++h,o[i++]=u>>18|240,o[i++]=u>>12&63|128,o[i++]=u>>6&63|128,o[i++]=u&63|128):(o[i++]=u>>12|224,o[i++]=u>>6&63|128,o[i++]=u&63|128);return i-s}})(utf8$2);var pool_1=pool;function pool(t,e,r){var n=r||8192,o=n>>>1,i=null,s=n;return function(f){if(f<1||f>o)return t(f);s+f>n&&(i=t(n),s=0);var h=e.call(i,s,s+=f);return s&7&&(s=(s|7)+1),h}}var longbits,hasRequiredLongbits;function requireLongbits(){if(hasRequiredLongbits)return longbits;hasRequiredLongbits=1,longbits=e;var t=requireMinimal();function e(i,s){this.lo=i>>>0,this.hi=s>>>0}var r=e.zero=new e(0,0);r.toNumber=function(){return 0},r.zzEncode=r.zzDecode=function(){return this},r.length=function(){return 1};var n=e.zeroHash="\0\0\0\0\0\0\0\0";e.fromNumber=function(s){if(s===0)return r;var u=s<0;u&&(s=-s);var f=s>>>0,h=(s-f)/4294967296>>>0;return u&&(h=~h>>>0,f=~f>>>0,++f>4294967295&&(f=0,++h>4294967295&&(h=0))),new e(f,h)},e.from=function(s){if(typeof s=="number")return e.fromNumber(s);if(t.isString(s))if(t.Long)s=t.Long.fromString(s);else return e.fromNumber(parseInt(s,10));return s.low||s.high?new e(s.low>>>0,s.high>>>0):r},e.prototype.toNumber=function(s){if(!s&&this.hi>>>31){var u=~this.lo+1>>>0,f=~this.hi>>>0;return u||(f=f+1>>>0),-(u+f*4294967296)}return this.lo+this.hi*4294967296},e.prototype.toLong=function(s){return t.Long?new t.Long(this.lo|0,this.hi|0,Boolean(s)):{low:this.lo|0,high:this.hi|0,unsigned:Boolean(s)}};var o=String.prototype.charCodeAt;return e.fromHash=function(s){return s===n?r:new e((o.call(s,0)|o.call(s,1)<<8|o.call(s,2)<<16|o.call(s,3)<<24)>>>0,(o.call(s,4)|o.call(s,5)<<8|o.call(s,6)<<16|o.call(s,7)<<24)>>>0)},e.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},e.prototype.zzEncode=function(){var s=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^s)>>>0,this.lo=(this.lo<<1^s)>>>0,this},e.prototype.zzDecode=function(){var s=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^s)>>>0,this.hi=(this.hi>>>1^s)>>>0,this},e.prototype.length=function(){var s=this.lo,u=(this.lo>>>28|this.hi<<4)>>>0,f=this.hi>>>24;return f===0?u===0?s<16384?s<128?1:2:s<2097152?3:4:u<16384?u<128?5:6:u<2097152?7:8:f<128?9:10},longbits}var hasRequiredMinimal;function requireMinimal(){return hasRequiredMinimal||(hasRequiredMinimal=1,function(t){var e=t;e.asPromise=aspromise,e.base64=base64$6,e.EventEmitter=eventemitter,e.float=float,e.inquire=inquire_1,e.utf8=utf8$2,e.pool=pool_1,e.LongBits=requireLongbits(),e.isNode=Boolean(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),e.global=e.isNode&&commonjsGlobal||typeof window<"u"&&window||typeof self<"u"&&self||commonjsGlobal,e.emptyArray=Object.freeze?Object.freeze([]):[],e.emptyObject=Object.freeze?Object.freeze({}):{},e.isInteger=Number.isInteger||function(i){return typeof i=="number"&&isFinite(i)&&Math.floor(i)===i},e.isString=function(i){return typeof i=="string"||i instanceof String},e.isObject=function(i){return i&&typeof i=="object"},e.isset=e.isSet=function(i,s){var u=i[s];return u!=null&&i.hasOwnProperty(s)?typeof u!="object"||(Array.isArray(u)?u.length:Object.keys(u).length)>0:!1},e.Buffer=function(){try{var o=e.inquire("buffer").Buffer;return o.prototype.utf8Write?o:null}catch{return null}}(),e._Buffer_from=null,e._Buffer_allocUnsafe=null,e.newBuffer=function(i){return typeof i=="number"?e.Buffer?e._Buffer_allocUnsafe(i):new e.Array(i):e.Buffer?e._Buffer_from(i):typeof Uint8Array>"u"?i:new Uint8Array(i)},e.Array=typeof Uint8Array<"u"?Uint8Array:Array,e.Long=e.global.dcodeIO&&e.global.dcodeIO.Long||e.global.Long||e.inquire("long"),e.key2Re=/^true|false|0|1$/,e.key32Re=/^-?(?:0|[1-9][0-9]*)$/,e.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,e.longToHash=function(i){return i?e.LongBits.from(i).toHash():e.LongBits.zeroHash},e.longFromHash=function(i,s){var u=e.LongBits.fromHash(i);return e.Long?e.Long.fromBits(u.lo,u.hi,s):u.toNumber(Boolean(s))};function r(o,i,s){for(var u=Object.keys(i),f=0;f<u.length;++f)(o[u[f]]===void 0||!s)&&(o[u[f]]=i[u[f]]);return o}e.merge=r,e.lcFirst=function(i){return i.charAt(0).toLowerCase()+i.substring(1)};function n(o){function i(s,u){if(!(this instanceof i))return new i(s,u);Object.defineProperty(this,"message",{get:function(){return s}}),Error.captureStackTrace?Error.captureStackTrace(this,i):Object.defineProperty(this,"stack",{value:new Error().stack||""}),u&&r(this,u)}return i.prototype=Object.create(Error.prototype,{constructor:{value:i,writable:!0,enumerable:!1,configurable:!0},name:{get(){return o},set:void 0,enumerable:!1,configurable:!0},toString:{value(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),i}e.newError=n,e.ProtocolError=n("ProtocolError"),e.oneOfGetter=function(i){for(var s={},u=0;u<i.length;++u)s[i[u]]=1;return function(){for(var f=Object.keys(this),h=f.length-1;h>-1;--h)if(s[f[h]]===1&&this[f[h]]!==void 0&&this[f[h]]!==null)return f[h]}},e.oneOfSetter=function(i){return function(s){for(var u=0;u<i.length;++u)i[u]!==s&&delete this[i[u]]}},e.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},e._configure=function(){var o=e.Buffer;if(!o){e._Buffer_from=e._Buffer_allocUnsafe=null;return}e._Buffer_from=o.from!==Uint8Array.from&&o.from||function(s,u){return new o(s,u)},e._Buffer_allocUnsafe=o.allocUnsafe||function(s){return new o(s)}}}(minimal)),minimal}var writer=Writer$1,util$4=requireMinimal(),BufferWriter$1,LongBits$1=util$4.LongBits,base64$5=util$4.base64,utf8$1=util$4.utf8;function Op(t,e,r){this.fn=t,this.len=e,this.next=void 0,this.val=r}function noop(){}function State(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function Writer$1(){this.len=0,this.head=new Op(noop,0,0),this.tail=this.head,this.states=null}var create$3=function t(){return util$4.Buffer?function(){return(Writer$1.create=function(){return new BufferWriter$1})()}:function(){return new Writer$1}};Writer$1.create=create$3();Writer$1.alloc=function t(e){return new util$4.Array(e)};util$4.Array!==Array&&(Writer$1.alloc=util$4.pool(Writer$1.alloc,util$4.Array.prototype.subarray));Writer$1.prototype._push=function t(e,r,n){return this.tail=this.tail.next=new Op(e,r,n),this.len+=r,this};function writeByte(t,e,r){e[r]=t&255}function writeVarint32(t,e,r){for(;t>127;)e[r++]=t&127|128,t>>>=7;e[r]=t}function VarintOp(t,e){this.len=t,this.next=void 0,this.val=e}VarintOp.prototype=Object.create(Op.prototype);VarintOp.prototype.fn=writeVarint32;Writer$1.prototype.uint32=function t(e){return this.len+=(this.tail=this.tail.next=new VarintOp((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this};Writer$1.prototype.int32=function t(e){return e<0?this._push(writeVarint64,10,LongBits$1.fromNumber(e)):this.uint32(e)};Writer$1.prototype.sint32=function t(e){return this.uint32((e<<1^e>>31)>>>0)};function writeVarint64(t,e,r){for(;t.hi;)e[r++]=t.lo&127|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[r++]=t.lo&127|128,t.lo=t.lo>>>7;e[r++]=t.lo}Writer$1.prototype.uint64=function t(e){var r=LongBits$1.from(e);return this._push(writeVarint64,r.length(),r)};Writer$1.prototype.int64=Writer$1.prototype.uint64;Writer$1.prototype.sint64=function t(e){var r=LongBits$1.from(e).zzEncode();return this._push(writeVarint64,r.length(),r)};Writer$1.prototype.bool=function t(e){return this._push(writeByte,1,e?1:0)};function writeFixed32(t,e,r){e[r]=t&255,e[r+1]=t>>>8&255,e[r+2]=t>>>16&255,e[r+3]=t>>>24}Writer$1.prototype.fixed32=function t(e){return this._push(writeFixed32,4,e>>>0)};Writer$1.prototype.sfixed32=Writer$1.prototype.fixed32;Writer$1.prototype.fixed64=function t(e){var r=LongBits$1.from(e);return this._push(writeFixed32,4,r.lo)._push(writeFixed32,4,r.hi)};Writer$1.prototype.sfixed64=Writer$1.prototype.fixed64;Writer$1.prototype.float=function t(e){return this._push(util$4.float.writeFloatLE,4,e)};Writer$1.prototype.double=function t(e){return this._push(util$4.float.writeDoubleLE,8,e)};var writeBytes=util$4.Array.prototype.set?function t(e,r,n){r.set(e,n)}:function t(e,r,n){for(var o=0;o<e.length;++o)r[n+o]=e[o]};Writer$1.prototype.bytes=function t(e){var r=e.length>>>0;if(!r)return this._push(writeByte,1,0);if(util$4.isString(e)){var n=Writer$1.alloc(r=base64$5.length(e));base64$5.decode(e,n,0),e=n}return this.uint32(r)._push(writeBytes,r,e)};Writer$1.prototype.string=function t(e){var r=utf8$1.length(e);return r?this.uint32(r)._push(utf8$1.write,r,e):this._push(writeByte,1,0)};Writer$1.prototype.fork=function t(){return this.states=new State(this),this.head=this.tail=new Op(noop,0,0),this.len=0,this};Writer$1.prototype.reset=function t(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop,0,0),this.len=0),this};Writer$1.prototype.ldelim=function t(){var e=this.head,r=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=e.next,this.tail=r,this.len+=n),this};Writer$1.prototype.finish=function t(){for(var e=this.head.next,r=this.constructor.alloc(this.len),n=0;e;)e.fn(e.val,r,n),n+=e.len,e=e.next;return r};Writer$1._configure=function(t){BufferWriter$1=t,Writer$1.create=create$3(),BufferWriter$1._configure()};var writer_buffer=BufferWriter,Writer=writer;(BufferWriter.prototype=Object.create(Writer.prototype)).constructor=BufferWriter;var util$3=requireMinimal();function BufferWriter(){Writer.call(this)}BufferWriter._configure=function(){BufferWriter.alloc=util$3._Buffer_allocUnsafe,BufferWriter.writeBytesBuffer=util$3.Buffer&&util$3.Buffer.prototype instanceof Uint8Array&&util$3.Buffer.prototype.set.name==="set"?function(e,r,n){r.set(e,n)}:function(e,r,n){if(e.copy)e.copy(r,n,0,e.length);else for(var o=0;o<e.length;)r[n++]=e[o++]}};BufferWriter.prototype.bytes=function t(e){util$3.isString(e)&&(e=util$3._Buffer_from(e,"base64"));var r=e.length>>>0;return this.uint32(r),r&&this._push(BufferWriter.writeBytesBuffer,r,e),this};function writeStringBuffer(t,e,r){t.length<40?util$3.utf8.write(t,e,r):e.utf8Write?e.utf8Write(t,r):e.write(t,r)}BufferWriter.prototype.string=function t(e){var r=util$3.Buffer.byteLength(e);return this.uint32(r),r&&this._push(writeStringBuffer,r,e),this};BufferWriter._configure();var reader=Reader$1,util$2=requireMinimal(),BufferReader$1,LongBits=util$2.LongBits,utf8=util$2.utf8;function indexOutOfRange(t,e){return RangeError("index out of range: "+t.pos+" + "+(e||1)+" > "+t.len)}function Reader$1(t){this.buf=t,this.pos=0,this.len=t.length}var create_array=typeof Uint8Array<"u"?function t(e){if(e instanceof Uint8Array||Array.isArray(e))return new Reader$1(e);throw Error("illegal buffer")}:function t(e){if(Array.isArray(e))return new Reader$1(e);throw Error("illegal buffer")},create$2=function t(){return util$2.Buffer?function(r){return(Reader$1.create=function(o){return util$2.Buffer.isBuffer(o)?new BufferReader$1(o):create_array(o)})(r)}:create_array};Reader$1.create=create$2();Reader$1.prototype._slice=util$2.Array.prototype.subarray||util$2.Array.prototype.slice;Reader$1.prototype.uint32=function t(){var e=4294967295;return function(){if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return e}}();Reader$1.prototype.int32=function t(){return this.uint32()|0};Reader$1.prototype.sint32=function t(){var e=this.uint32();return e>>>1^-(e&1)|0};function readLongVarint(){var t=new LongBits(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw indexOutOfRange(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw indexOutOfRange(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}Reader$1.prototype.bool=function t(){return this.uint32()!==0};function readFixed32_end(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}Reader$1.prototype.fixed32=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)};Reader$1.prototype.sfixed32=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)|0};function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}Reader$1.prototype.float=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var e=util$2.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e};Reader$1.prototype.double=function t(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var e=util$2.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e};Reader$1.prototype.bytes=function t(){var e=this.uint32(),r=this.pos,n=this.pos+e;if(n>this.len)throw indexOutOfRange(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(r,n):r===n?new this.buf.constructor(0):this._slice.call(this.buf,r,n)};Reader$1.prototype.string=function t(){var e=this.bytes();return utf8.read(e,0,e.length)};Reader$1.prototype.skip=function t(e){if(typeof e=="number"){if(this.pos+e>this.len)throw indexOutOfRange(this,e);this.pos+=e}else do if(this.pos>=this.len)throw indexOutOfRange(this);while(this.buf[this.pos++]&128);return this};Reader$1.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos)}return this};Reader$1._configure=function(t){BufferReader$1=t,Reader$1.create=create$2(),BufferReader$1._configure();var e=util$2.Long?"toLong":"toNumber";util$2.merge(Reader$1.prototype,{int64:function(){return readLongVarint.call(this)[e](!1)},uint64:function(){return readLongVarint.call(this)[e](!0)},sint64:function(){return readLongVarint.call(this).zzDecode()[e](!1)},fixed64:function(){return readFixed64.call(this)[e](!0)},sfixed64:function(){return readFixed64.call(this)[e](!1)}})};var reader_buffer=BufferReader,Reader=reader;(BufferReader.prototype=Object.create(Reader.prototype)).constructor=BufferReader;var util$1=requireMinimal();function BufferReader(t){Reader.call(this,t)}BufferReader._configure=function(){util$1.Buffer&&(BufferReader.prototype._slice=util$1.Buffer.prototype.slice)};BufferReader.prototype.string=function t(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))};BufferReader._configure();var rpc={},service=Service,util=requireMinimal();(Service.prototype=Object.create(util.EventEmitter.prototype)).constructor=Service;function Service(t,e,r){if(typeof t!="function")throw TypeError("rpcImpl must be a function");util.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=Boolean(e),this.responseDelimited=Boolean(r)}Service.prototype.rpcCall=function t(e,r,n,o,i){if(!o)throw TypeError("request must be specified");var s=this;if(!i)return util.asPromise(t,s,e,r,n,o);if(!s.rpcImpl){setTimeout(function(){i(Error("already ended"))},0);return}try{return s.rpcImpl(e,r[s.requestDelimited?"encodeDelimited":"encode"](o).finish(),function(f,h){if(f)return s.emit("error",f,e),i(f);if(h===null){s.end(!0);return}if(!(h instanceof n))try{h=n[s.responseDelimited?"decodeDelimited":"decode"](h)}catch(g){return s.emit("error",g,e),i(g)}return s.emit("data",h,e),i(null,h)})}catch(u){s.emit("error",u,e),setTimeout(function(){i(u)},0);return}};Service.prototype.end=function t(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this};(function(t){var e=t;e.Service=service})(rpc);var roots={};(function(t){var e=t;e.build="minimal",e.Writer=writer,e.BufferWriter=writer_buffer,e.Reader=reader,e.BufferReader=reader_buffer,e.util=requireMinimal(),e.rpc=rpc,e.roots=roots,e.configure=r;function r(){e.util._configure(),e.Writer._configure(e.BufferWriter),e.Reader._configure(e.BufferReader)}r()})(indexMinimal);(function(t){t.exports=indexMinimal})(minimal$1);const $protobuf=getDefaultExportFromCjs(minimal$1.exports),$Reader$5=$protobuf.Reader,$Writer$5=$protobuf.Writer;$protobuf.util;const $root$5=$protobuf.roots.default||($protobuf.roots.default={}),ipfs=$root$5.ipfs=(()=>{const t={};return t.pin=function(){const e={};return e.Set=function(){function r(n){if(n)for(var o=Object.keys(n),i=0;i<o.length;++i)n[o[i]]!=null&&(this[o[i]]=n[o[i]])}return r.prototype.version=0,r.prototype.fanout=0,r.prototype.seed=0,r.encode=function(o,i){return i||(i=$Writer$5.create()),o.version!=null&&Object.hasOwnProperty.call(o,"version")&&i.uint32(8).uint32(o.version),o.fanout!=null&&Object.hasOwnProperty.call(o,"fanout")&&i.uint32(16).uint32(o.fanout),o.seed!=null&&Object.hasOwnProperty.call(o,"seed")&&i.uint32(29).fixed32(o.seed),i},r.decode=function(o,i){o instanceof $Reader$5||(o=$Reader$5.create(o));for(var s=i===void 0?o.len:o.pos+i,u=new $root$5.ipfs.pin.Set;o.pos<s;){var f=o.uint32();switch(f>>>3){case 1:u.version=o.uint32();break;case 2:u.fanout=o.uint32();break;case 3:u.seed=o.fixed32();break;default:o.skipType(f&7);break}}return u},r.fromObject=function(o){if(o instanceof $root$5.ipfs.pin.Set)return o;var i=new $root$5.ipfs.pin.Set;return o.version!=null&&(i.version=o.version>>>0),o.fanout!=null&&(i.fanout=o.fanout>>>0),o.seed!=null&&(i.seed=o.seed>>>0),i},r.toObject=function(o,i){i||(i={});var s={};return i.defaults&&(s.version=0,s.fanout=0,s.seed=0),o.version!=null&&o.hasOwnProperty("version")&&(s.version=o.version),o.fanout!=null&&o.hasOwnProperty("fanout")&&(s.fanout=o.fanout),o.seed!=null&&o.hasOwnProperty("seed")&&(s.seed=o.seed),s},r.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},r}(),e}(),t})();var fnv1a$1={exports:{}};(function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),r.BASE=2166136261;function r(n,o=r.BASE){const i=n.length;for(let s=0;s<i;s++)o^=n.charCodeAt(s),o+=(o<<1)+(o<<4)+(o<<7)+(o<<8)+(o<<24);return o>>>0}e.default=r,t.exports=r})(fnv1a$1,fnv1a$1.exports);const fnv1a=getDefaultExportFromCjs(fnv1a$1.exports),PIN_DS_KEY=new Key("/local/pins"),DEFAULT_FANOUT=256,MAX_ITEMS=8192,EMPTY_KEY=CID$2.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n"),PinTypes$1={direct:"direct",recursive:"recursive"};function cidToKey$2(t){return new Key(`/${base32$6.encode(t.multihash.bytes).toUpperCase().substring(1)}`)}function asUint8Array$1(t){return globalThis.Buffer!=null?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t}function allocUnsafe$1(t=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?asUint8Array$1(globalThis.Buffer.allocUnsafe(t)):new Uint8Array(t)}function concat$1(t,e){e||(e=t.reduce((o,i)=>o+i.length,0));const r=allocUnsafe$1(e);let n=0;for(const o of t)r.set(o,n),n+=o.length;return asUint8Array$1(r)}function compare(t,e){for(let r=0;r<t.byteLength;r++){if(t[r]<e[r])return-1;if(t[r]>e[r])return 1}return t.byteLength>e.byteLength?1:t.byteLength<e.byteLength?-1:0}const identity$5=from$7({prefix:"\0",name:"identity",encode:t=>toString$7(t),decode:t=>fromString$6(t)}),identityBase$1=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$5},Symbol.toStringTag,{value:"Module"})),base2$2=rfc4648$4({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$3=Object.freeze(Object.defineProperty({__proto__:null,base2:base2$2},Symbol.toStringTag,{value:"Module"})),base8$2=rfc4648$4({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$3=Object.freeze(Object.defineProperty({__proto__:null,base8:base8$2},Symbol.toStringTag,{value:"Module"})),base10$2=baseX$4({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$3=Object.freeze(Object.defineProperty({__proto__:null,base10:base10$2},Symbol.toStringTag,{value:"Module"})),base16$2=rfc4648$4({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper$1=rfc4648$4({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$3=Object.freeze(Object.defineProperty({__proto__:null,base16:base16$2,base16upper:base16upper$1},Symbol.toStringTag,{value:"Module"})),base36$2=baseX$4({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper$1=baseX$4({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$3=Object.freeze(Object.defineProperty({__proto__:null,base36:base36$2,base36upper:base36upper$1},Symbol.toStringTag,{value:"Module"})),base64$3=rfc4648$4({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad$1=rfc4648$4({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url$1=rfc4648$4({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad$1=rfc4648$4({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$4=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$3,base64pad:base64pad$1,base64url:base64url$1,base64urlpad:base64urlpad$1},Symbol.toStringTag,{value:"Module"})),alphabet$1=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),alphabetBytesToChars$1=alphabet$1.reduce((t,e,r)=>(t[r]=e,t),[]),alphabetCharsToBytes$1=alphabet$1.reduce((t,e,r)=>(t[e.codePointAt(0)]=r,t),[]);function encode$e(t){return t.reduce((e,r)=>(e+=alphabetBytesToChars$1[r],e),"")}function decode$g(t){const e=[];for(const r of t){const n=alphabetCharsToBytes$1[r.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${r}`);e.push(n)}return new Uint8Array(e)}const base256emoji$2=from$7({prefix:"\u{1F680}",name:"base256emoji",encode:encode$e,decode:decode$g}),base256emoji$3=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:base256emoji$2},Symbol.toStringTag,{value:"Module"})),code$5=0,name$4="identity",encode$d=coerce$4,digest$1=t=>create$6(code$5,encode$d(t)),identity$3={code:code$5,name:name$4,encode:encode$d,digest:digest$1},identity$4=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$3},Symbol.toStringTag,{value:"Module"})),textEncoder=new TextEncoder,textDecoder=new TextDecoder,name$3="json",code$4=512,encode$c=t=>textEncoder.encode(JSON.stringify(t)),decode$f=t=>JSON.parse(textDecoder.decode(t)),json=Object.freeze(Object.defineProperty({__proto__:null,name:name$3,code:code$4,encode:encode$c,decode:decode$f},Symbol.toStringTag,{value:"Module"})),bases$1={...identityBase$1,...base2$3,...base8$3,...base10$3,...base16$3,...base32$7,...base36$3,...base58$2,...base64$4,...base256emoji$3},hashes={...sha2$2,...identity$4},codecs={raw,json};function createCodec$1(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}const string$1=createCodec$1("utf8","u",t=>"u"+new TextDecoder("utf8").decode(t),t=>new TextEncoder().encode(t.substring(1))),ascii$1=createCodec$1("ascii","a",t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},t=>{t=t.substring(1);const e=allocUnsafe$1(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}),BASES$1={utf8:string$1,"utf-8":string$1,hex:bases$1.base16,latin1:ascii$1,ascii:ascii$1,binary:ascii$1,...bases$1};function toString$4(t,e="utf8"){const r=BASES$1[e];if(!r)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(t.buffer,t.byteOffset,t.byteLength).toString("utf8"):r.encoder.encode(t).substring(1)}function fromString$3(t,e="utf8"){const r=BASES$1[e];if(!r)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array$1(globalThis.Buffer.from(t,"utf-8")):r.decoder.decode(`${r.prefix}${t}`)}const PinSet=ipfs.pin.Set;function readHeader(t){const e=t.Data;if(!e)throw new Error("No data present");const r=varint$4.decode(e),n=varint$4.decode.bytes;if(n<=0)throw new Error("Invalid Set header length");if(n+r>e.length)throw new Error("Impossibly large set header length");const o=e.slice(n,r+n),i=PinSet.toObject(PinSet.decode(o),{defaults:!1,arrays:!0,longs:Number,objects:!1});if(i.version!==1)throw new Error(`Unsupported Set version: ${i.version}`);if(i.fanout>t.Links.length)throw new Error("Impossibly large fanout");return{header:i,data:e.slice(r+n)}}function hash(t,e){const r=new Uint8Array(4);new DataView(r.buffer).setUint32(0,t,!0);const o=fromString$3(e.toString()),i=concat$1([r,o],r.byteLength+o.byteLength);return fnv1a(toString$4(i))}async function*walkItems(t,e){const r=readHeader(e);let n=0;for(const o of e.Links){if(n<r.header.fanout){const i=o.Hash;if(!EMPTY_KEY.equals(i)){const s=await t.get(i),u=decode$h(s);yield*walkItems(t,u)}}else yield o.Hash;n++}}async function*loadSet(t,e,r){const n=e.Links.find(s=>s.Name===r);if(!n)throw new Error("No link found with name "+r);const o=await t.get(n.Hash),i=decode$h(o);yield*walkItems(t,i)}function storeItems(t,e){return r(e,0);async function r(n,o){const i=PinSet.encode({version:1,fanout:DEFAULT_FANOUT,seed:o}).finish(),s=varint$4.encode(i.length),u=concat$1([s,i]),f=[];for(let g=0;g<DEFAULT_FANOUT;g++)f.push({Name:"",Tsize:1,Hash:EMPTY_KEY});if(n.length<=MAX_ITEMS){const g=n.map(A=>({link:{Name:"",Tsize:1,Hash:A.key},data:A.data||new Uint8Array})).sort((A,w)=>compare(A.link.Hash.bytes,w.link.Hash.bytes)),$=f.concat(g.map(A=>A.link));return{Data:concat$1([u,...g.map(A=>A.data)]),Links:$}}else{const g=n.reduce((E,A)=>{const w=hash(o,A.key)%DEFAULT_FANOUT;return E[w]=w in E?E[w].concat([A]):[A],E},[]);let $=0;for(const E of g){const A=await r(E,o+1);await h(A,$),$++}return{Data:u,Links:f}}async function h(g,$){const E=encode$f(g),A=await sha256$2.digest(E),w=CID$2.createV0(A);await t.put(w,E);const v=g.Links.reduce((k,P)=>k+(P.Tsize||0),0)+E.length;f[$]={Name:"",Tsize:v,Hash:w}}}}async function storeSet(t,e,r){const n=await storeItems(t,r.map(f=>({key:f}))),o=encode$f(n),i=await sha256$2.digest(o),s=CID$2.createV0(i);await t.put(s,o);const u=n.Links.reduce((f,h)=>f+h.Tsize,0)+o.length;return{Name:e,Tsize:u,Hash:s}}async function pinsToDatastore(t,e,r,n){if(!await e.has(PIN_DS_KEY))return;const o=await e.get(PIN_DS_KEY),i=CID$2.decode(o),s=await t.get(i),u=decode$h(s);let f=0;const h=await itLength(loadSet(t,u,PinTypes$1.recursive))+await itLength(loadSet(t,u,PinTypes$1.direct));for await(const g of loadSet(t,u,PinTypes$1.recursive)){f++;const $={depth:1/0};g.version!==0&&($.version=g.version),g.code!==code$6&&($.codec=g.code),await r.put(cidToKey$2(g),encode$q($)),n(f/h*100,`Migrated recursive pin ${g}`)}for await(const g of loadSet(t,u,PinTypes$1.direct)){f++;const $={depth:0};g.version!==0&&($.version=g.version),g.code!==code$6&&($.codec=g.code),await r.put(cidToKey$2(g),encode$q($)),n(f/h*100,`Migrated direct pin ${g}`)}await t.delete(i),await e.delete(PIN_DS_KEY)}async function pinsToDAG(t,e,r,n){const o=[],i=[];let s=0;const u=await itLength(r.queryKeys({}));for await(const{key:E,value:A}of r.query({})){s++;const w=decode$s(A),v=CID$2.create(w.version||0,w.codec||code$6,decode$p(base32$6.decode("b"+E.toString().toLowerCase().split("/").pop())));w.depth===0?(n(s/u*100,`Reverted direct pin ${v}`),i.push(v)):(n(s/u*100,`Reverted recursive pin ${v}`),o.push(v))}n(100,"Updating pin root");const f={Links:[await storeSet(t,PinTypes$1.direct,i),await storeSet(t,PinTypes$1.recursive,o)]},h=encode$f(f),g=await sha256$2.digest(h),$=CID$2.createV0(g);await t.put($,h),await e.put(PIN_DS_KEY,$.bytes)}async function process$2(t,e,r){const n=t.blocks,o=t.datastore,i=t.pins;await n.open(),await o.open(),await i.open();try{await r(n,o,i,e)}finally{await i.close(),await o.close(),await n.close()}}const migration$3={version:9,description:"Migrates pins to datastore",migrate:(t,e=()=>{})=>process$2(t,e,pinsToDatastore),revert:(t,e=()=>{})=>process$2(t,e,pinsToDAG)};function dbOpenFailedError(t){return t=t||new Error("Cannot open database"),errCode(t,"ERR_DB_OPEN_FAILED")}function dbDeleteFailedError(t){return t=t||new Error("Delete failed"),errCode(t,"ERR_DB_DELETE_FAILED")}function dbWriteFailedError(t){return t=t||new Error("Write failed"),errCode(t,"ERR_DB_WRITE_FAILED")}function notFoundError$1(t){return t=t||new Error("Not Found"),errCode(t,"ERR_NOT_FOUND")}const CONFIG_KEY=new Key("/config"),VERSION_KEY=new Key("/version");function findLevelJs$1(t){let e=t;for(;e.db||e.child;)if(e=e.db||e.child,e.type==="level-js"||e.constructor.name==="Level")return e}async function hasWithFallback$1(t,e,r){const n=await e(t);if(n)return n;const o=findLevelJs$1(r);return o?new Promise((i,s)=>{const u=o.store("readonly").get(t.toString());u.transaction.onabort=()=>{s(u.transaction.error)},u.transaction.oncomplete=()=>{i(Boolean(u.result))}}):!1}async function getWithFallback$1(t,e,r,n){if(await r(t))return e(t);const o=findLevelJs$1(n);if(!o)throw notFoundError$1();return new Promise((i,s)=>{const u=o.store("readonly").get(t.toString());u.transaction.onabort=()=>{s(u.transaction.error)},u.transaction.oncomplete=()=>{if(u.result)return i(u.result);s(notFoundError$1())}})}function wrapStore(t){const e=t.get.bind(t),r=t.has.bind(t);return t.get=n=>getWithFallback$1(n,e,r,t),t.has=n=>hasWithFallback$1(n,r,t),t}function wrapBackends(t){return{...t,root:wrapStore(t.root),datastore:wrapStore(t.datastore),pins:wrapStore(t.pins),keys:wrapStore(t.keys)}}async function keysToBinary(t,e,r=()=>{}){const n=findLevelJs$1(e);if(!n){r(`${t} did not need an upgrade`);return}r(`Upgrading ${t}`),await withEach(n,(i,s)=>[{type:"del",key:i},{type:"put",key:fromString$3(i),value:s}])}async function keysToStrings(t,e,r=()=>{}){const n=findLevelJs$1(e);if(!n){r(`${t} did not need a downgrade`);return}r(`Downgrading ${t}`),await withEach(n,(i,s)=>[{type:"del",key:i},{type:"put",key:toString$4(i),value:s}])}function unwrap(t){return t.child?unwrap(t.child):t}async function process$1(t,e,r){const n=Object.entries(t).map(([s,u])=>({key:s,backend:unwrap(u)})).filter(({key:s,backend:u})=>u.constructor.name==="LevelDatastore").map(({key:s,backend:u})=>({name:s,store:u}));e(0,`Migrating ${n.length} dbs`);let o=0;const i=s=>{e(Math.round(o/n.length*100),s)};for(const{name:s,store:u}of n){await u.open();try{await r(s,u,i)}finally{o++,await u.close()}}e(100,`Migrated ${n.length} dbs`)}const migration$2={version:10,description:"Migrates datastore-level keys to binary",migrate:(t,e=()=>{})=>process$1(t,e,keysToBinary),revert:(t,e=()=>{})=>process$1(t,e,keysToStrings)};function withEach(t,e){function r(n,o){const i=t.store("readwrite"),s=i.transaction;let u=0,f;s.onabort=()=>o(f||s.error||new Error("aborted by user")),s.oncomplete=()=>o();function h(){const g=n[u++],$=g.key;let E;try{E=g.type==="del"?i.delete($):i.put(g.value,$)}catch(A){f=A,s.abort();return}u<n.length&&(E.onsuccess=h)}h()}return new Promise((n,o)=>{const i=t.iterator(),s=f=>f;i._deserializeKey=i._deserializeValue=s,u();function u(){const f=(h,g,$)=>{if(h||g===void 0){const E=A=>{if(A){o(A);return}n()};i.end(E);return}r(e(g,$),u)};i.next(f)}})}const MFS_ROOT_KEY$1=new Key("/local/filesroot");async function storeMfsRootInDatastore(t,e=()=>{}){if(e(100,"Migrating MFS root to repo datastore"),await t.root.open(),await t.datastore.open(),await t.root.has(MFS_ROOT_KEY$1)){const r=await t.root.get(MFS_ROOT_KEY$1);await t.datastore.put(MFS_ROOT_KEY$1,r),await t.root.delete(MFS_ROOT_KEY$1)}await t.datastore.close(),await t.root.close(),e(100,"Stored MFS root in repo datastore")}async function storeMfsRootInRoot(t,e=()=>{}){if(e(100,"Migrating MFS root to repo root datastore"),await t.root.open(),await t.datastore.open(),await t.datastore.has(MFS_ROOT_KEY$1)){const r=await t.datastore.get(MFS_ROOT_KEY$1);await t.root.put(MFS_ROOT_KEY$1,r),await t.datastore.delete(MFS_ROOT_KEY$1)}await t.datastore.close(),await t.root.close(),e(100,"Stored MFS root in repo root datastore")}const migration$1={version:11,description:"Store mfs root in the datastore",migrate:storeMfsRootInDatastore,revert:storeMfsRootInRoot},$Reader$4=$protobuf.Reader,$Writer$4=$protobuf.Writer,$util$4=$protobuf.util,$root$4=$protobuf.roots.default||($protobuf.roots.default={}),Protocols=$root$4.Protocols=(()=>{function t(e){if(this.protocols=[],e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.protocols=$util$4.emptyArray,t.encode=function(r,n){if(n||(n=$Writer$4.create()),r.protocols!=null&&r.protocols.length)for(var o=0;o<r.protocols.length;++o)n.uint32(10).string(r.protocols[o]);return n},t.decode=function(r,n){r instanceof $Reader$4||(r=$Reader$4.create(r));for(var o=n===void 0?r.len:r.pos+n,i=new $root$4.Protocols;r.pos<o;){var s=r.uint32();switch(s>>>3){case 1:i.protocols&&i.protocols.length||(i.protocols=[]),i.protocols.push(r.string());break;default:r.skipType(s&7);break}}return i},t.fromObject=function(r){if(r instanceof $root$4.Protocols)return r;var n=new $root$4.Protocols;if(r.protocols){if(!Array.isArray(r.protocols))throw TypeError(".Protocols.protocols: array expected");n.protocols=[];for(var o=0;o<r.protocols.length;++o)n.protocols[o]=String(r.protocols[o])}return n},t.toObject=function(r,n){n||(n={});var o={};if((n.arrays||n.defaults)&&(o.protocols=[]),r.protocols&&r.protocols.length){o.protocols=[];for(var i=0;i<r.protocols.length;++i)o.protocols[i]=r.protocols[i]}return o},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t})(),$Reader$3=$protobuf.Reader,$Writer$3=$protobuf.Writer,$util$3=$protobuf.util,$root$3=$protobuf.roots.default||($protobuf.roots.default={}),Addresses=$root$3.Addresses=(()=>{function t(e){if(this.addrs=[],e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.addrs=$util$3.emptyArray,t.prototype.certifiedRecord=null,t.encode=function(r,n){if(n||(n=$Writer$3.create()),r.addrs!=null&&r.addrs.length)for(var o=0;o<r.addrs.length;++o)$root$3.Addresses.Address.encode(r.addrs[o],n.uint32(10).fork()).ldelim();return r.certifiedRecord!=null&&Object.hasOwnProperty.call(r,"certifiedRecord")&&$root$3.Addresses.CertifiedRecord.encode(r.certifiedRecord,n.uint32(18).fork()).ldelim(),n},t.decode=function(r,n){r instanceof $Reader$3||(r=$Reader$3.create(r));for(var o=n===void 0?r.len:r.pos+n,i=new $root$3.Addresses;r.pos<o;){var s=r.uint32();switch(s>>>3){case 1:i.addrs&&i.addrs.length||(i.addrs=[]),i.addrs.push($root$3.Addresses.Address.decode(r,r.uint32()));break;case 2:i.certifiedRecord=$root$3.Addresses.CertifiedRecord.decode(r,r.uint32());break;default:r.skipType(s&7);break}}return i},t.fromObject=function(r){if(r instanceof $root$3.Addresses)return r;var n=new $root$3.Addresses;if(r.addrs){if(!Array.isArray(r.addrs))throw TypeError(".Addresses.addrs: array expected");n.addrs=[];for(var o=0;o<r.addrs.length;++o){if(typeof r.addrs[o]!="object")throw TypeError(".Addresses.addrs: object expected");n.addrs[o]=$root$3.Addresses.Address.fromObject(r.addrs[o])}}if(r.certifiedRecord!=null){if(typeof r.certifiedRecord!="object")throw TypeError(".Addresses.certifiedRecord: object expected");n.certifiedRecord=$root$3.Addresses.CertifiedRecord.fromObject(r.certifiedRecord)}return n},t.toObject=function(r,n){n||(n={});var o={};if((n.arrays||n.defaults)&&(o.addrs=[]),n.defaults&&(o.certifiedRecord=null),r.addrs&&r.addrs.length){o.addrs=[];for(var i=0;i<r.addrs.length;++i)o.addrs[i]=$root$3.Addresses.Address.toObject(r.addrs[i],n)}return r.certifiedRecord!=null&&r.hasOwnProperty("certifiedRecord")&&(o.certifiedRecord=$root$3.Addresses.CertifiedRecord.toObject(r.certifiedRecord,n)),o},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t.Address=function(){function e(n){if(n)for(var o=Object.keys(n),i=0;i<o.length;++i)n[o[i]]!=null&&(this[o[i]]=n[o[i]])}e.prototype.multiaddr=$util$3.newBuffer([]),e.prototype.isCertified=null;let r;return Object.defineProperty(e.prototype,"_isCertified",{get:$util$3.oneOfGetter(r=["isCertified"]),set:$util$3.oneOfSetter(r)}),e.encode=function(o,i){return i||(i=$Writer$3.create()),o.multiaddr!=null&&Object.hasOwnProperty.call(o,"multiaddr")&&i.uint32(10).bytes(o.multiaddr),o.isCertified!=null&&Object.hasOwnProperty.call(o,"isCertified")&&i.uint32(16).bool(o.isCertified),i},e.decode=function(o,i){o instanceof $Reader$3||(o=$Reader$3.create(o));for(var s=i===void 0?o.len:o.pos+i,u=new $root$3.Addresses.Address;o.pos<s;){var f=o.uint32();switch(f>>>3){case 1:u.multiaddr=o.bytes();break;case 2:u.isCertified=o.bool();break;default:o.skipType(f&7);break}}return u},e.fromObject=function(o){if(o instanceof $root$3.Addresses.Address)return o;var i=new $root$3.Addresses.Address;return o.multiaddr!=null&&(typeof o.multiaddr=="string"?$util$3.base64.decode(o.multiaddr,i.multiaddr=$util$3.newBuffer($util$3.base64.length(o.multiaddr)),0):o.multiaddr.length&&(i.multiaddr=o.multiaddr)),o.isCertified!=null&&(i.isCertified=Boolean(o.isCertified)),i},e.toObject=function(o,i){i||(i={});var s={};return i.defaults&&(i.bytes===String?s.multiaddr="":(s.multiaddr=[],i.bytes!==Array&&(s.multiaddr=$util$3.newBuffer(s.multiaddr)))),o.multiaddr!=null&&o.hasOwnProperty("multiaddr")&&(s.multiaddr=i.bytes===String?$util$3.base64.encode(o.multiaddr,0,o.multiaddr.length):i.bytes===Array?Array.prototype.slice.call(o.multiaddr):o.multiaddr),o.isCertified!=null&&o.hasOwnProperty("isCertified")&&(s.isCertified=o.isCertified,i.oneofs&&(s._isCertified="isCertified")),s},e.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},e}(),t.CertifiedRecord=function(){function e(r){if(r)for(var n=Object.keys(r),o=0;o<n.length;++o)r[n[o]]!=null&&(this[n[o]]=r[n[o]])}return e.prototype.seq=$util$3.Long?$util$3.Long.fromBits(0,0,!0):0,e.prototype.raw=$util$3.newBuffer([]),e.encode=function(n,o){return o||(o=$Writer$3.create()),n.seq!=null&&Object.hasOwnProperty.call(n,"seq")&&o.uint32(8).uint64(n.seq),n.raw!=null&&Object.hasOwnProperty.call(n,"raw")&&o.uint32(18).bytes(n.raw),o},e.decode=function(n,o){n instanceof $Reader$3||(n=$Reader$3.create(n));for(var i=o===void 0?n.len:n.pos+o,s=new $root$3.Addresses.CertifiedRecord;n.pos<i;){var u=n.uint32();switch(u>>>3){case 1:s.seq=n.uint64();break;case 2:s.raw=n.bytes();break;default:n.skipType(u&7);break}}return s},e.fromObject=function(n){if(n instanceof $root$3.Addresses.CertifiedRecord)return n;var o=new $root$3.Addresses.CertifiedRecord;return n.seq!=null&&($util$3.Long?(o.seq=$util$3.Long.fromValue(n.seq)).unsigned=!0:typeof n.seq=="string"?o.seq=parseInt(n.seq,10):typeof n.seq=="number"?o.seq=n.seq:typeof n.seq=="object"&&(o.seq=new $util$3.LongBits(n.seq.low>>>0,n.seq.high>>>0).toNumber(!0))),n.raw!=null&&(typeof n.raw=="string"?$util$3.base64.decode(n.raw,o.raw=$util$3.newBuffer($util$3.base64.length(n.raw)),0):n.raw.length&&(o.raw=n.raw)),o},e.toObject=function(n,o){o||(o={});var i={};if(o.defaults){if($util$3.Long){var s=new $util$3.Long(0,0,!0);i.seq=o.longs===String?s.toString():o.longs===Number?s.toNumber():s}else i.seq=o.longs===String?"0":0;o.bytes===String?i.raw="":(i.raw=[],o.bytes!==Array&&(i.raw=$util$3.newBuffer(i.raw)))}return n.seq!=null&&n.hasOwnProperty("seq")&&(typeof n.seq=="number"?i.seq=o.longs===String?String(n.seq):n.seq:i.seq=o.longs===String?$util$3.Long.prototype.toString.call(n.seq):o.longs===Number?new $util$3.LongBits(n.seq.low>>>0,n.seq.high>>>0).toNumber(!0):n.seq),n.raw!=null&&n.hasOwnProperty("raw")&&(i.raw=o.bytes===String?$util$3.base64.encode(n.raw,0,n.raw.length):o.bytes===Array?Array.prototype.slice.call(n.raw):n.raw),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},e}(),t})(),$Reader$2=$protobuf.Reader,$Writer$2=$protobuf.Writer,$util$2=$protobuf.util,$root$2=$protobuf.roots.default||($protobuf.roots.default={}),Peer=$root$2.Peer=(()=>{function t(r){if(this.addresses=[],this.protocols=[],this.metadata=[],r)for(var n=Object.keys(r),o=0;o<n.length;++o)r[n[o]]!=null&&(this[n[o]]=r[n[o]])}t.prototype.addresses=$util$2.emptyArray,t.prototype.protocols=$util$2.emptyArray,t.prototype.metadata=$util$2.emptyArray,t.prototype.pubKey=null,t.prototype.peerRecordEnvelope=null;let e;return Object.defineProperty(t.prototype,"_pubKey",{get:$util$2.oneOfGetter(e=["pubKey"]),set:$util$2.oneOfSetter(e)}),Object.defineProperty(t.prototype,"_peerRecordEnvelope",{get:$util$2.oneOfGetter(e=["peerRecordEnvelope"]),set:$util$2.oneOfSetter(e)}),t.encode=function(n,o){if(o||(o=$Writer$2.create()),n.addresses!=null&&n.addresses.length)for(var i=0;i<n.addresses.length;++i)$root$2.Address.encode(n.addresses[i],o.uint32(10).fork()).ldelim();if(n.protocols!=null&&n.protocols.length)for(var i=0;i<n.protocols.length;++i)o.uint32(18).string(n.protocols[i]);if(n.metadata!=null&&n.metadata.length)for(var i=0;i<n.metadata.length;++i)$root$2.Metadata.encode(n.metadata[i],o.uint32(26).fork()).ldelim();return n.pubKey!=null&&Object.hasOwnProperty.call(n,"pubKey")&&o.uint32(34).bytes(n.pubKey),n.peerRecordEnvelope!=null&&Object.hasOwnProperty.call(n,"peerRecordEnvelope")&&o.uint32(42).bytes(n.peerRecordEnvelope),o},t.decode=function(n,o){n instanceof $Reader$2||(n=$Reader$2.create(n));for(var i=o===void 0?n.len:n.pos+o,s=new $root$2.Peer;n.pos<i;){var u=n.uint32();switch(u>>>3){case 1:s.addresses&&s.addresses.length||(s.addresses=[]),s.addresses.push($root$2.Address.decode(n,n.uint32()));break;case 2:s.protocols&&s.protocols.length||(s.protocols=[]),s.protocols.push(n.string());break;case 3:s.metadata&&s.metadata.length||(s.metadata=[]),s.metadata.push($root$2.Metadata.decode(n,n.uint32()));break;case 4:s.pubKey=n.bytes();break;case 5:s.peerRecordEnvelope=n.bytes();break;default:n.skipType(u&7);break}}return s},t.fromObject=function(n){if(n instanceof $root$2.Peer)return n;var o=new $root$2.Peer;if(n.addresses){if(!Array.isArray(n.addresses))throw TypeError(".Peer.addresses: array expected");o.addresses=[];for(var i=0;i<n.addresses.length;++i){if(typeof n.addresses[i]!="object")throw TypeError(".Peer.addresses: object expected");o.addresses[i]=$root$2.Address.fromObject(n.addresses[i])}}if(n.protocols){if(!Array.isArray(n.protocols))throw TypeError(".Peer.protocols: array expected");o.protocols=[];for(var i=0;i<n.protocols.length;++i)o.protocols[i]=String(n.protocols[i])}if(n.metadata){if(!Array.isArray(n.metadata))throw TypeError(".Peer.metadata: array expected");o.metadata=[];for(var i=0;i<n.metadata.length;++i){if(typeof n.metadata[i]!="object")throw TypeError(".Peer.metadata: object expected");o.metadata[i]=$root$2.Metadata.fromObject(n.metadata[i])}}return n.pubKey!=null&&(typeof n.pubKey=="string"?$util$2.base64.decode(n.pubKey,o.pubKey=$util$2.newBuffer($util$2.base64.length(n.pubKey)),0):n.pubKey.length&&(o.pubKey=n.pubKey)),n.peerRecordEnvelope!=null&&(typeof n.peerRecordEnvelope=="string"?$util$2.base64.decode(n.peerRecordEnvelope,o.peerRecordEnvelope=$util$2.newBuffer($util$2.base64.length(n.peerRecordEnvelope)),0):n.peerRecordEnvelope.length&&(o.peerRecordEnvelope=n.peerRecordEnvelope)),o},t.toObject=function(n,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.addresses=[],i.protocols=[],i.metadata=[]),n.addresses&&n.addresses.length){i.addresses=[];for(var s=0;s<n.addresses.length;++s)i.addresses[s]=$root$2.Address.toObject(n.addresses[s],o)}if(n.protocols&&n.protocols.length){i.protocols=[];for(var s=0;s<n.protocols.length;++s)i.protocols[s]=n.protocols[s]}if(n.metadata&&n.metadata.length){i.metadata=[];for(var s=0;s<n.metadata.length;++s)i.metadata[s]=$root$2.Metadata.toObject(n.metadata[s],o)}return n.pubKey!=null&&n.hasOwnProperty("pubKey")&&(i.pubKey=o.bytes===String?$util$2.base64.encode(n.pubKey,0,n.pubKey.length):o.bytes===Array?Array.prototype.slice.call(n.pubKey):n.pubKey,o.oneofs&&(i._pubKey="pubKey")),n.peerRecordEnvelope!=null&&n.hasOwnProperty("peerRecordEnvelope")&&(i.peerRecordEnvelope=o.bytes===String?$util$2.base64.encode(n.peerRecordEnvelope,0,n.peerRecordEnvelope.length):o.bytes===Array?Array.prototype.slice.call(n.peerRecordEnvelope):n.peerRecordEnvelope,o.oneofs&&(i._peerRecordEnvelope="peerRecordEnvelope")),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t})();$root$2.Address=(()=>{function t(r){if(r)for(var n=Object.keys(r),o=0;o<n.length;++o)r[n[o]]!=null&&(this[n[o]]=r[n[o]])}t.prototype.multiaddr=$util$2.newBuffer([]),t.prototype.isCertified=null;let e;return Object.defineProperty(t.prototype,"_isCertified",{get:$util$2.oneOfGetter(e=["isCertified"]),set:$util$2.oneOfSetter(e)}),t.encode=function(n,o){return o||(o=$Writer$2.create()),n.multiaddr!=null&&Object.hasOwnProperty.call(n,"multiaddr")&&o.uint32(10).bytes(n.multiaddr),n.isCertified!=null&&Object.hasOwnProperty.call(n,"isCertified")&&o.uint32(16).bool(n.isCertified),o},t.decode=function(n,o){n instanceof $Reader$2||(n=$Reader$2.create(n));for(var i=o===void 0?n.len:n.pos+o,s=new $root$2.Address;n.pos<i;){var u=n.uint32();switch(u>>>3){case 1:s.multiaddr=n.bytes();break;case 2:s.isCertified=n.bool();break;default:n.skipType(u&7);break}}return s},t.fromObject=function(n){if(n instanceof $root$2.Address)return n;var o=new $root$2.Address;return n.multiaddr!=null&&(typeof n.multiaddr=="string"?$util$2.base64.decode(n.multiaddr,o.multiaddr=$util$2.newBuffer($util$2.base64.length(n.multiaddr)),0):n.multiaddr.length&&(o.multiaddr=n.multiaddr)),n.isCertified!=null&&(o.isCertified=Boolean(n.isCertified)),o},t.toObject=function(n,o){o||(o={});var i={};return o.defaults&&(o.bytes===String?i.multiaddr="":(i.multiaddr=[],o.bytes!==Array&&(i.multiaddr=$util$2.newBuffer(i.multiaddr)))),n.multiaddr!=null&&n.hasOwnProperty("multiaddr")&&(i.multiaddr=o.bytes===String?$util$2.base64.encode(n.multiaddr,0,n.multiaddr.length):o.bytes===Array?Array.prototype.slice.call(n.multiaddr):n.multiaddr),n.isCertified!=null&&n.hasOwnProperty("isCertified")&&(i.isCertified=n.isCertified,o.oneofs&&(i._isCertified="isCertified")),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t})();$root$2.Metadata=(()=>{function t(e){if(e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.key="",t.prototype.value=$util$2.newBuffer([]),t.encode=function(r,n){return n||(n=$Writer$2.create()),r.key!=null&&Object.hasOwnProperty.call(r,"key")&&n.uint32(10).string(r.key),r.value!=null&&Object.hasOwnProperty.call(r,"value")&&n.uint32(18).bytes(r.value),n},t.decode=function(r,n){r instanceof $Reader$2||(r=$Reader$2.create(r));for(var o=n===void 0?r.len:r.pos+n,i=new $root$2.Metadata;r.pos<o;){var s=r.uint32();switch(s>>>3){case 1:i.key=r.string();break;case 2:i.value=r.bytes();break;default:r.skipType(s&7);break}}return i},t.fromObject=function(r){if(r instanceof $root$2.Metadata)return r;var n=new $root$2.Metadata;return r.key!=null&&(n.key=String(r.key)),r.value!=null&&(typeof r.value=="string"?$util$2.base64.decode(r.value,n.value=$util$2.newBuffer($util$2.base64.length(r.value)),0):r.value.length&&(n.value=r.value)),n},t.toObject=function(r,n){n||(n={});var o={};return n.defaults&&(o.key="",n.bytes===String?o.value="":(o.value=[],n.bytes!==Array&&(o.value=$util$2.newBuffer(o.value)))),r.key!=null&&r.hasOwnProperty("key")&&(o.key=r.key),r.value!=null&&r.hasOwnProperty("value")&&(o.value=n.bytes===String?$util$2.base64.encode(r.value,0,r.value.length):n.bytes===Array?Array.prototype.slice.call(r.value):r.value),o},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t})();const $Reader$1=$protobuf.Reader,$Writer$1=$protobuf.Writer,$util$1=$protobuf.util,$root$1=$protobuf.roots.default||($protobuf.roots.default={}),Envelope=$root$1.Envelope=(()=>{function t(e){if(e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.publicKey=$util$1.newBuffer([]),t.prototype.payloadType=$util$1.newBuffer([]),t.prototype.payload=$util$1.newBuffer([]),t.prototype.signature=$util$1.newBuffer([]),t.encode=function(r,n){return n||(n=$Writer$1.create()),r.publicKey!=null&&Object.hasOwnProperty.call(r,"publicKey")&&n.uint32(10).bytes(r.publicKey),r.payloadType!=null&&Object.hasOwnProperty.call(r,"payloadType")&&n.uint32(18).bytes(r.payloadType),r.payload!=null&&Object.hasOwnProperty.call(r,"payload")&&n.uint32(26).bytes(r.payload),r.signature!=null&&Object.hasOwnProperty.call(r,"signature")&&n.uint32(42).bytes(r.signature),n},t.decode=function(r,n){r instanceof $Reader$1||(r=$Reader$1.create(r));for(var o=n===void 0?r.len:r.pos+n,i=new $root$1.Envelope;r.pos<o;){var s=r.uint32();switch(s>>>3){case 1:i.publicKey=r.bytes();break;case 2:i.payloadType=r.bytes();break;case 3:i.payload=r.bytes();break;case 5:i.signature=r.bytes();break;default:r.skipType(s&7);break}}return i},t.fromObject=function(r){if(r instanceof $root$1.Envelope)return r;var n=new $root$1.Envelope;return r.publicKey!=null&&(typeof r.publicKey=="string"?$util$1.base64.decode(r.publicKey,n.publicKey=$util$1.newBuffer($util$1.base64.length(r.publicKey)),0):r.publicKey.length&&(n.publicKey=r.publicKey)),r.payloadType!=null&&(typeof r.payloadType=="string"?$util$1.base64.decode(r.payloadType,n.payloadType=$util$1.newBuffer($util$1.base64.length(r.payloadType)),0):r.payloadType.length&&(n.payloadType=r.payloadType)),r.payload!=null&&(typeof r.payload=="string"?$util$1.base64.decode(r.payload,n.payload=$util$1.newBuffer($util$1.base64.length(r.payload)),0):r.payload.length&&(n.payload=r.payload)),r.signature!=null&&(typeof r.signature=="string"?$util$1.base64.decode(r.signature,n.signature=$util$1.newBuffer($util$1.base64.length(r.signature)),0):r.signature.length&&(n.signature=r.signature)),n},t.toObject=function(r,n){n||(n={});var o={};return n.defaults&&(n.bytes===String?o.publicKey="":(o.publicKey=[],n.bytes!==Array&&(o.publicKey=$util$1.newBuffer(o.publicKey))),n.bytes===String?o.payloadType="":(o.payloadType=[],n.bytes!==Array&&(o.payloadType=$util$1.newBuffer(o.payloadType))),n.bytes===String?o.payload="":(o.payload=[],n.bytes!==Array&&(o.payload=$util$1.newBuffer(o.payload))),n.bytes===String?o.signature="":(o.signature=[],n.bytes!==Array&&(o.signature=$util$1.newBuffer(o.signature)))),r.publicKey!=null&&r.hasOwnProperty("publicKey")&&(o.publicKey=n.bytes===String?$util$1.base64.encode(r.publicKey,0,r.publicKey.length):n.bytes===Array?Array.prototype.slice.call(r.publicKey):r.publicKey),r.payloadType!=null&&r.hasOwnProperty("payloadType")&&(o.payloadType=n.bytes===String?$util$1.base64.encode(r.payloadType,0,r.payloadType.length):n.bytes===Array?Array.prototype.slice.call(r.payloadType):r.payloadType),r.payload!=null&&r.hasOwnProperty("payload")&&(o.payload=n.bytes===String?$util$1.base64.encode(r.payload,0,r.payload.length):n.bytes===Array?Array.prototype.slice.call(r.payload):r.payload),r.signature!=null&&r.hasOwnProperty("signature")&&(o.signature=n.bytes===String?$util$1.base64.encode(r.signature,0,r.signature.length):n.bytes===Array?Array.prototype.slice.call(r.signature):r.signature),o},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t})(),$Reader=$protobuf.Reader,$Writer=$protobuf.Writer,$util=$protobuf.util,$root=$protobuf.roots.default||($protobuf.roots.default={}),PeerRecord=$root.PeerRecord=(()=>{function t(e){if(this.addresses=[],e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.peerId=$util.newBuffer([]),t.prototype.seq=$util.Long?$util.Long.fromBits(0,0,!0):0,t.prototype.addresses=$util.emptyArray,t.encode=function(r,n){if(n||(n=$Writer.create()),r.peerId!=null&&Object.hasOwnProperty.call(r,"peerId")&&n.uint32(10).bytes(r.peerId),r.seq!=null&&Object.hasOwnProperty.call(r,"seq")&&n.uint32(16).uint64(r.seq),r.addresses!=null&&r.addresses.length)for(var o=0;o<r.addresses.length;++o)$root.PeerRecord.AddressInfo.encode(r.addresses[o],n.uint32(26).fork()).ldelim();return n},t.decode=function(r,n){r instanceof $Reader||(r=$Reader.create(r));for(var o=n===void 0?r.len:r.pos+n,i=new $root.PeerRecord;r.pos<o;){var s=r.uint32();switch(s>>>3){case 1:i.peerId=r.bytes();break;case 2:i.seq=r.uint64();break;case 3:i.addresses&&i.addresses.length||(i.addresses=[]),i.addresses.push($root.PeerRecord.AddressInfo.decode(r,r.uint32()));break;default:r.skipType(s&7);break}}return i},t.fromObject=function(r){if(r instanceof $root.PeerRecord)return r;var n=new $root.PeerRecord;if(r.peerId!=null&&(typeof r.peerId=="string"?$util.base64.decode(r.peerId,n.peerId=$util.newBuffer($util.base64.length(r.peerId)),0):r.peerId.length&&(n.peerId=r.peerId)),r.seq!=null&&($util.Long?(n.seq=$util.Long.fromValue(r.seq)).unsigned=!0:typeof r.seq=="string"?n.seq=parseInt(r.seq,10):typeof r.seq=="number"?n.seq=r.seq:typeof r.seq=="object"&&(n.seq=new $util.LongBits(r.seq.low>>>0,r.seq.high>>>0).toNumber(!0))),r.addresses){if(!Array.isArray(r.addresses))throw TypeError(".PeerRecord.addresses: array expected");n.addresses=[];for(var o=0;o<r.addresses.length;++o){if(typeof r.addresses[o]!="object")throw TypeError(".PeerRecord.addresses: object expected");n.addresses[o]=$root.PeerRecord.AddressInfo.fromObject(r.addresses[o])}}return n},t.toObject=function(r,n){n||(n={});var o={};if((n.arrays||n.defaults)&&(o.addresses=[]),n.defaults)if(n.bytes===String?o.peerId="":(o.peerId=[],n.bytes!==Array&&(o.peerId=$util.newBuffer(o.peerId))),$util.Long){var i=new $util.Long(0,0,!0);o.seq=n.longs===String?i.toString():n.longs===Number?i.toNumber():i}else o.seq=n.longs===String?"0":0;if(r.peerId!=null&&r.hasOwnProperty("peerId")&&(o.peerId=n.bytes===String?$util.base64.encode(r.peerId,0,r.peerId.length):n.bytes===Array?Array.prototype.slice.call(r.peerId):r.peerId),r.seq!=null&&r.hasOwnProperty("seq")&&(typeof r.seq=="number"?o.seq=n.longs===String?String(r.seq):r.seq:o.seq=n.longs===String?$util.Long.prototype.toString.call(r.seq):n.longs===Number?new $util.LongBits(r.seq.low>>>0,r.seq.high>>>0).toNumber(!0):r.seq),r.addresses&&r.addresses.length){o.addresses=[];for(var s=0;s<r.addresses.length;++s)o.addresses[s]=$root.PeerRecord.AddressInfo.toObject(r.addresses[s],n)}return o},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t.AddressInfo=function(){function e(r){if(r)for(var n=Object.keys(r),o=0;o<n.length;++o)r[n[o]]!=null&&(this[n[o]]=r[n[o]])}return e.prototype.multiaddr=$util.newBuffer([]),e.encode=function(n,o){return o||(o=$Writer.create()),n.multiaddr!=null&&Object.hasOwnProperty.call(n,"multiaddr")&&o.uint32(10).bytes(n.multiaddr),o},e.decode=function(n,o){n instanceof $Reader||(n=$Reader.create(n));for(var i=o===void 0?n.len:n.pos+o,s=new $root.PeerRecord.AddressInfo;n.pos<i;){var u=n.uint32();switch(u>>>3){case 1:s.multiaddr=n.bytes();break;default:n.skipType(u&7);break}}return s},e.fromObject=function(n){if(n instanceof $root.PeerRecord.AddressInfo)return n;var o=new $root.PeerRecord.AddressInfo;return n.multiaddr!=null&&(typeof n.multiaddr=="string"?$util.base64.decode(n.multiaddr,o.multiaddr=$util.newBuffer($util.base64.length(n.multiaddr)),0):n.multiaddr.length&&(o.multiaddr=n.multiaddr)),o},e.toObject=function(n,o){o||(o={});var i={};return o.defaults&&(o.bytes===String?i.multiaddr="":(i.multiaddr=[],o.bytes!==Array&&(i.multiaddr=$util.newBuffer(i.multiaddr)))),n.multiaddr!=null&&n.hasOwnProperty("multiaddr")&&(i.multiaddr=o.bytes===String?$util.base64.encode(n.multiaddr,0,n.multiaddr.length):o.bytes===Array?Array.prototype.slice.call(n.multiaddr):n.multiaddr),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},e}(),t})(),word="[a-fA-F\\d:]",boundry=t=>t&&t.includeBoundaries?`(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))`:"",v4="(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",v6segment="[a-fA-F\\d]{1,4}",v6=`
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm,"").replace(/\n/g,"").trim(),v46Exact=new RegExp(`(?:^${v4}$)|(?:^${v6}$)`),v4exact=new RegExp(`^${v4}$`),v6exact=new RegExp(`^${v6}$`),ipRegex=t=>t&&t.exact?v46Exact:new RegExp(`(?:${boundry(t)}${v4}${boundry(t)})|(?:${boundry(t)}${v6}${boundry(t)})`,"g");ipRegex.v4=t=>t&&t.exact?v4exact:new RegExp(`${boundry(t)}${v4}${boundry(t)}`,"g");ipRegex.v6=t=>t&&t.exact?v6exact:new RegExp(`${boundry(t)}${v6}${boundry(t)}`,"g");function functionTimeout(t){const e=(...r)=>t(...r);return Object.defineProperty(e,"name",{value:`functionTimeout(${t.name||"<anonymous>"})`,configurable:!0}),e}const{toString:toString$3}=Object.prototype;function isRegexp(t){return toString$3.call(t)==="[object RegExp]"}const flagMap={global:"g",ignoreCase:"i",multiline:"m",dotAll:"s",sticky:"y",unicode:"u"};function clonedRegexp(t,e={}){if(!isRegexp(t))throw new TypeError("Expected a RegExp instance");const r=Object.keys(flagMap).map(o=>(typeof e[o]=="boolean"?e[o]:t[o])?flagMap[o]:"").join(""),n=new RegExp(e.source||t.source,r);return n.lastIndex=typeof e.lastIndex=="number"?e.lastIndex:t.lastIndex,n}function isMatch(t,e,{timeout:r}={}){try{return functionTimeout(()=>clonedRegexp(t).test(e),{timeout:r})()}catch(n){throw n}}const maxIPv4Length=15,maxIPv6Length=45,options={timeout:400};function isIP(t){return isMatch(ipRegex({exact:!0}),t.slice(0,maxIPv6Length),options)}function isIPv6(t){return isMatch(ipRegex.v6({exact:!0}),t.slice(0,maxIPv6Length),options)}function isIPv4(t){return isMatch(ipRegex.v4({exact:!0}),t.slice(0,maxIPv4Length),options)}const isV4=isIPv4,isV6=isIPv6,toBytes=function(t){let e=0;if(t=t.toString().trim(),isV4(t)){const r=new Uint8Array(e+4);return t.split(/\./g).forEach(n=>{r[e++]=parseInt(n,10)&255}),r}if(isV6(t)){const r=t.split(":",8);let n;for(n=0;n<r.length;n++){const i=isV4(r[n]);let s;i&&(s=toBytes(r[n]),r[n]=toString$5(s.slice(0,2),"base16")),s!=null&&++n<8&&r.splice(n,0,toString$5(s.slice(2,4),"base16"))}if(r[0]==="")for(;r.length<8;)r.unshift("0");else if(r[r.length-1]==="")for(;r.length<8;)r.push("0");else if(r.length<8){for(n=0;n<r.length&&r[n]!=="";n++);const i=[n,1];for(n=9-r.length;n>0;n--)i.push("0");r.splice.apply(r,i)}const o=new Uint8Array(e+16);for(n=0;n<r.length;n++){const i=parseInt(r[n],16);o[e++]=i>>8&255,o[e++]=i&255}return o}throw new Error("invalid ip address")},toString$2=function(t,e=0,r){e=~~e,r=r!=null?r:t.length-e;const n=new DataView(t.buffer);if(r===4){const o=[];for(let i=0;i<r;i++)o.push(t[e+i]);return o.join(".")}if(r===16){const o=[];for(let i=0;i<r;i+=2)o.push(n.getUint16(e+i).toString(16));return o.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},V=-1,names={},codes={},table=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,V,"ip6zone"],[53,V,"dns",!0],[54,V,"dns4",!0],[55,V,"dns6",!0],[56,V,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,V,"unix",!1,!0],[421,V,"ipfs"],[421,V,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,V,"garlic64"],[460,0,"quic"],[465,0,"webtransport"],[466,V,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,V,"memory"]];table.forEach(t=>{const e=createProtocol(...t);codes[e.code]=e,names[e.name]=e});function createProtocol(t,e,r,n,o){return{code:t,size:e,name:r,resolvable:Boolean(n),path:Boolean(o)}}function getProtocol(t){if(typeof t=="number"){if(codes[t]!=null)return codes[t];throw new Error(`no protocol with code: ${t}`)}else if(typeof t=="string"){if(names[t]!=null)return names[t];throw new Error(`no protocol with name: ${t}`)}throw new Error(`invalid protocol id type: ${typeof t}`)}var encode_1$1=encode$b,MSB$2=128,REST$2=127,MSBALL$1=~REST$2,INT$1=Math.pow(2,31);function encode$b(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT$1;)e[r++]=t&255|MSB$2,t/=128;for(;t&MSBALL$1;)e[r++]=t&255|MSB$2,t>>>=7;return e[r]=t|0,encode$b.bytes=r-n+1,e}var decode$e=read$1,MSB$1$1=128,REST$1$1=127;function read$1(t,n){var r=0,n=n||0,o=0,i=n,s,u=t.length;do{if(i>=u)throw read$1.bytes=0,new RangeError("Could not decode varint");s=t[i++],r+=o<28?(s&REST$1$1)<<o:(s&REST$1$1)*Math.pow(2,o),o+=7}while(s>=MSB$1$1);return read$1.bytes=i-n,r}var N1$1=Math.pow(2,7),N2$1=Math.pow(2,14),N3$1=Math.pow(2,21),N4$1=Math.pow(2,28),N5$1=Math.pow(2,35),N6$1=Math.pow(2,42),N7$1=Math.pow(2,49),N8$1=Math.pow(2,56),N9$1=Math.pow(2,63),length$1=function(t){return t<N1$1?1:t<N2$1?2:t<N3$1?3:t<N4$1?4:t<N5$1?5:t<N6$1?6:t<N7$1?7:t<N8$1?8:t<N9$1?9:10},varint$1={encode:encode_1$1,decode:decode$e,encodingLength:length$1},_brrp_varint$1=varint$1;const decode$d=(t,e=0)=>[_brrp_varint$1.decode(t,e),_brrp_varint$1.decode.bytes],encodeTo$1=(t,e,r=0)=>(_brrp_varint$1.encode(t,e,r),e),encodingLength$1=t=>_brrp_varint$1.encodingLength(t),equals$4=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},coerce$2=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},fromString$2=t=>new TextEncoder().encode(t),toString$1=t=>new TextDecoder().decode(t),create$1=(t,e)=>{const r=e.byteLength,n=encodingLength$1(t),o=n+encodingLength$1(r),i=new Uint8Array(o+r);return encodeTo$1(t,i,0),encodeTo$1(r,i,n),i.set(e,o),new Digest$1(t,r,e,i)},decode$c=t=>{const e=coerce$2(t),[r,n]=decode$d(e),[o,i]=decode$d(e.subarray(n)),s=e.subarray(n+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new Digest$1(r,o,s,e)},equals$3=(t,e)=>{if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&equals$4(t.bytes,r.bytes)}};class Digest$1{constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}}function base$2(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var i=t.charAt(o),s=i.charCodeAt(0);if(r[s]!==255)throw new TypeError(i+" is ambiguous");r[s]=o}var u=t.length,f=t.charAt(0),h=Math.log(u)/Math.log(256),g=Math.log(256)/Math.log(u);function $(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var v=0,k=0,P=0,L=w.length;P!==L&&w[P]===0;)P++,v++;for(var N=(L-P)*g+1>>>0,q=new Uint8Array(N);P!==L;){for(var X=w[P],Z=0,j=N-1;(X!==0||Z<k)&&j!==-1;j--,Z++)X+=256*q[j]>>>0,q[j]=X%u>>>0,X=X/u>>>0;if(X!==0)throw new Error("Non-zero carry");k=Z,P++}for(var B=N-k;B!==N&&q[B]===0;)B++;for(var K=f.repeat(v);B<N;++B)K+=t.charAt(q[B]);return K}function E(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var v=0;if(w[v]!==" "){for(var k=0,P=0;w[v]===f;)k++,v++;for(var L=(w.length-v)*h+1>>>0,N=new Uint8Array(L);w[v];){var q=r[w.charCodeAt(v)];if(q===255)return;for(var X=0,Z=L-1;(q!==0||X<P)&&Z!==-1;Z--,X++)q+=u*N[Z]>>>0,N[Z]=q%256>>>0,q=q/256>>>0;if(q!==0)throw new Error("Non-zero carry");P=X,v++}if(w[v]!==" "){for(var j=L-P;j!==L&&N[j]===0;)j++;for(var B=new Uint8Array(k+(L-j)),K=k;j!==L;)B[K++]=N[j++];return B}}}function A(w){var v=E(w);if(v)return v;throw new Error(`Non-${e} character`)}return{encode:$,decodeUnsafe:E,decode:A}}var src$2=base$2,_brrp__multiformats_scope_baseX$2=src$2;class Encoder$2{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Decoder$2{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$2(this,e)}}class ComposedDecoder$2{constructor(e){this.decoders=e}or(e){return or$2(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or$2=(t,e)=>new ComposedDecoder$2({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});class Codec$2{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$2(e,r,n),this.decoder=new Decoder$2(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const from$3=({name:t,prefix:e,encode:r,decode:n})=>new Codec$2(t,e,r,n),baseX$2=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$2(r,e);return from$3({prefix:t,name:e,encode:n,decode:i=>coerce$2(o(i))})},decode$b=(t,e,r,n)=>{const o={};for(let g=0;g<e.length;++g)o[e[g]]=g;let i=t.length;for(;t[i-1]==="=";)--i;const s=new Uint8Array(i*r/8|0);let u=0,f=0,h=0;for(let g=0;g<i;++g){const $=o[t[g]];if($===void 0)throw new SyntaxError(`Non-${n} character`);f=f<<r|$,u+=r,u>=8&&(u-=8,s[h++]=255&f>>u)}if(u>=r||255&f<<8-u)throw new SyntaxError("Unexpected end of data");return s},encode$a=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let i="",s=0,u=0;for(let f=0;f<t.length;++f)for(u=u<<8|t[f],s+=8;s>r;)s-=r,i+=e[o&u>>s];if(s&&(i+=e[o&u<<r-s]),n)for(;i.length*r&7;)i+="=";return i},rfc4648$2=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$3({prefix:e,name:t,encode(o){return encode$a(o,n,r)},decode(o){return decode$b(o,n,r,t)}}),base58btc$2=baseX$2({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr=baseX$2({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58=Object.freeze(Object.defineProperty({__proto__:null,base58btc:base58btc$2,base58flickr},Symbol.toStringTag,{value:"Module"})),base32$2=rfc4648$2({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper=rfc4648$2({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad=rfc4648$2({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper=rfc4648$2({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex=rfc4648$2({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper=rfc4648$2({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad=rfc4648$2({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper=rfc4648$2({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z=rfc4648$2({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$3=Object.freeze(Object.defineProperty({__proto__:null,base32:base32$2,base32upper,base32pad,base32padupper,base32hex,base32hexupper,base32hexpad,base32hexpadupper,base32z},Symbol.toStringTag,{value:"Module"})),format$2=(t,e)=>{const{bytes:r,version:n}=t;switch(n){case 0:return toStringV0$1(r,baseCache$1(t),e||base58btc$2.encoder);default:return toStringV1$1(r,baseCache$1(t),e||base32$2.encoder)}},cache$1=new WeakMap,baseCache$1=t=>{const e=cache$1.get(t);if(e==null){const r=new Map;return cache$1.set(t,r),r}return e};class CID$1{constructor(e,r,n,o){this.code=r,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE$1)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE$1)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID$1.createV0(r)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create$1(e,r);return CID$1.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return CID$1.equals(this,e)}static equals(e,r){const n=r;return n&&e.code===n.code&&e.version===n.version&&equals$3(e.multihash,n.multihash)}toString(e){return format$2(this,e)}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const r=e;if(r instanceof CID$1)return r;if(r["/"]!=null&&r["/"]===r.bytes||r.asCID===r){const{version:n,code:o,multihash:i,bytes:s}=r;return new CID$1(n,o,i,s||encodeCID$1(n,o,i.bytes))}else if(r[cidSymbol$1]===!0){const{version:n,multihash:o,code:i}=r,s=decode$c(o);return CID$1.create(n,i,s)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(r!==DAG_PB_CODE$1)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$1}) block encoding`);return new CID$1(e,r,n,n.bytes)}case 1:{const o=encodeCID$1(e,r,n.bytes);return new CID$1(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return CID$1.create(0,DAG_PB_CODE$1,e)}static createV1(e,r){return CID$1.create(1,e,r)}static decode(e){const[r,n]=CID$1.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=CID$1.inspectBytes(e),n=r.size-r.multihashSize,o=coerce$2(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");const i=o.subarray(r.multihashSize-r.digestSize),s=new Digest$1(r.multihashCode,r.digestSize,i,o);return[r.version===0?CID$1.createV0(s):CID$1.createV1(r.codec,s),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[$,E]=decode$d(e.subarray(r));return r+=E,$};let o=n(),i=DAG_PB_CODE$1;if(o===18?(o=0,r=0):i=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const s=r,u=n(),f=n(),h=r+f,g=h-s;return{version:o,codec:i,multihashCode:u,digestSize:f,multihashSize:g,size:h}}static parse(e,r){const[n,o]=parseCIDtoBytes$1(e,r),i=CID$1.decode(o);return baseCache$1(i).set(n,e),i}}const parseCIDtoBytes$1=(t,e)=>{switch(t[0]){case"Q":{const r=e||base58btc$2;return[base58btc$2.prefix,r.decode(`${base58btc$2.prefix}${t}`)]}case base58btc$2.prefix:{const r=e||base58btc$2;return[base58btc$2.prefix,r.decode(t)]}case base32$2.prefix:{const r=e||base32$2;return[base32$2.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},toStringV0$1=(t,e,r)=>{const{prefix:n}=r;if(n!==base58btc$2.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=e.get(n);if(o==null){const i=r.encode(t).slice(1);return e.set(n,i),i}else return o},toStringV1$1=(t,e,r)=>{const{prefix:n}=r,o=e.get(n);if(o==null){const i=r.encode(t);return e.set(n,i),i}else return o},DAG_PB_CODE$1=112,SHA_256_CODE$1=18,encodeCID$1=(t,e,r)=>{const n=encodingLength$1(t),o=n+encodingLength$1(e),i=new Uint8Array(o+r.byteLength);return encodeTo$1(t,i,0),encodeTo$1(e,i,n),i.set(r,o),i},cidSymbol$1=Symbol.for("@ipld/js-cid/CID"),identity$2=from$3({prefix:"\0",name:"identity",encode:t=>toString$1(t),decode:t=>fromString$2(t)}),identityBase=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$2},Symbol.toStringTag,{value:"Module"})),base2=rfc4648$2({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$1=Object.freeze(Object.defineProperty({__proto__:null,base2},Symbol.toStringTag,{value:"Module"})),base8=rfc4648$2({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$1=Object.freeze(Object.defineProperty({__proto__:null,base8},Symbol.toStringTag,{value:"Module"})),base10=baseX$2({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$1=Object.freeze(Object.defineProperty({__proto__:null,base10},Symbol.toStringTag,{value:"Module"})),base16=rfc4648$2({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper=rfc4648$2({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$1=Object.freeze(Object.defineProperty({__proto__:null,base16,base16upper},Symbol.toStringTag,{value:"Module"})),base36=baseX$2({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper=baseX$2({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$1=Object.freeze(Object.defineProperty({__proto__:null,base36,base36upper},Symbol.toStringTag,{value:"Module"})),base64$1=rfc4648$2({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad=rfc4648$2({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url=rfc4648$2({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad=rfc4648$2({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$2=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$1,base64pad,base64url,base64urlpad},Symbol.toStringTag,{value:"Module"})),alphabet=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),alphabetBytesToChars=alphabet.reduce((t,e,r)=>(t[r]=e,t),[]),alphabetCharsToBytes=alphabet.reduce((t,e,r)=>(t[e.codePointAt(0)]=r,t),[]);function encode$9(t){return t.reduce((e,r)=>(e+=alphabetBytesToChars[r],e),"")}function decode$a(t){const e=[];for(const r of t){const n=alphabetCharsToBytes[r.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${r}`);e.push(n)}return new Uint8Array(e)}const base256emoji=from$3({prefix:"\u{1F680}",name:"base256emoji",encode:encode$9,decode:decode$a}),base256emoji$1=Object.freeze(Object.defineProperty({__proto__:null,base256emoji},Symbol.toStringTag,{value:"Module"})),from$2=({name:t,code:e,encode:r})=>new Hasher(t,e,r);class Hasher{constructor(e,r,n){this.name=e,this.code=r,this.encode=n}digest(e){if(e instanceof Uint8Array){const r=this.encode(e);return r instanceof Uint8Array?create$1(this.code,r):r.then(n=>create$1(this.code,n))}else throw Error("Unknown type, must be binary type")}}const sha=t=>async e=>new Uint8Array(await crypto.subtle.digest(t,e)),sha256=from$2({name:"sha2-256",code:18,encode:sha("SHA-256")}),sha512=from$2({name:"sha2-512",code:19,encode:sha("SHA-512")}),sha2=Object.freeze(Object.defineProperty({__proto__:null,sha256,sha512},Symbol.toStringTag,{value:"Module"})),code$3=0,name$2="identity",encode$8=coerce$2,digest=t=>create$1(code$3,encode$8(t)),identity={code:code$3,name:name$2,encode:encode$8,digest},identity$1=Object.freeze(Object.defineProperty({__proto__:null,identity},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const bases={...identityBase,...base2$1,...base8$1,...base10$1,...base16$1,...base32$3,...base36$1,...base58,...base64$2,...base256emoji$1};({...sha2,...identity$1});function concat(t,e){e==null&&(e=t.reduce((o,i)=>o+i.length,0));const r=allocUnsafe$2(e);let n=0;for(const o of t)r.set(o,n),n+=o.length;return asUint8Array$2(r)}function convertToString(t,e){switch(getProtocol(t).code){case 4:case 41:return bytes2ip(e);case 6:case 273:case 33:case 132:return bytes2port(e).toString();case 53:case 54:case 55:case 56:case 400:case 777:return bytes2str(e);case 421:return bytes2mh(e);case 444:return bytes2onion(e);case 445:return bytes2onion(e);case 466:return bytes2mb(e);default:return toString$5(e,"base16")}}function convertToBytes(t,e){switch(getProtocol(t).code){case 4:return ip2bytes(e);case 41:return ip2bytes(e);case 6:case 273:case 33:case 132:return port2bytes(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 777:return str2bytes(e);case 421:return mh2bytes(e);case 444:return onion2bytes(e);case 445:return onion32bytes(e);case 466:return mb2bytes(e);default:return fromString$4(e,"base16")}}const decoders=Object.values(bases).map(t=>t.decoder),anybaseDecoder=function(){let t=decoders[0].or(decoders[1]);return decoders.slice(2).forEach(e=>t=t.or(e)),t}();function ip2bytes(t){if(!isIP(t))throw new Error("invalid ip address");return toBytes(t)}function bytes2ip(t){const e=toString$2(t,0,t.length);if(e==null)throw new Error("ipBuff is required");if(!isIP(e))throw new Error("invalid ip address");return e}function port2bytes(t){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,t),new Uint8Array(e)}function bytes2port(t){return new DataView(t.buffer).getUint16(t.byteOffset)}function str2bytes(t){const e=fromString$4(t),r=Uint8Array.from(varint$4.encode(e.length));return concat([r,e],r.length+e.length)}function bytes2str(t){const e=varint$4.decode(t);if(t=t.slice(varint$4.decode.bytes),t.length!==e)throw new Error("inconsistent lengths");return toString$5(t)}function mh2bytes(t){let e;t[0]==="Q"||t[0]==="1"?e=decode$c(base58btc$2.decode(`z${t}`)).bytes:e=CID$1.parse(t).multihash.bytes;const r=Uint8Array.from(varint$4.encode(e.length));return concat([r,e],r.length+e.length)}function mb2bytes(t){const e=anybaseDecoder.decode(t),r=Uint8Array.from(varint$4.encode(e.length));return concat([r,e],r.length+e.length)}function bytes2mb(t){const e=varint$4.decode(t),r=t.slice(varint$4.decode.bytes);if(r.length!==e)throw new Error("inconsistent lengths");return"u"+toString$5(r,"base64url")}function bytes2mh(t){const e=varint$4.decode(t),r=t.slice(varint$4.decode.bytes);if(r.length!==e)throw new Error("inconsistent lengths");return toString$5(r,"base58btc")}function onion2bytes(t){const e=t.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const r=base32$2.decode("b"+e[0]),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const o=port2bytes(n);return concat([r,o],r.length+o.length)}function onion32bytes(t){const e=t.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const r=base32$2.decode(`b${e[0]}`),n=parseInt(e[1],10);if(n<1||n>65536)throw new Error("Port number is not in range(1, 65536)");const o=port2bytes(n);return concat([r,o],r.length+o.length)}function bytes2onion(t){const e=t.slice(0,t.length-2),r=t.slice(t.length-2),n=toString$5(e,"base32"),o=bytes2port(r);return`${n}:${o}`}function stringToStringTuples(t){const e=[],r=t.split("/").slice(1);if(r.length===1&&r[0]==="")return[];for(let n=0;n<r.length;n++){const o=r[n],i=getProtocol(o);if(i.size===0){e.push([o]);continue}if(n++,n>=r.length)throw ParseError("invalid address: "+t);if(i.path===!0){e.push([o,cleanPath(r.slice(n).join("/"))]);break}e.push([o,r[n]])}return e}function stringTuplesToString(t){const e=[];return t.map(r=>{const n=protoFromTuple(r);return e.push(n.name),r.length>1&&r[1]!=null&&e.push(r[1]),null}),cleanPath(e.join("/"))}function stringTuplesToTuples(t){return t.map(e=>{Array.isArray(e)||(e=[e]);const r=protoFromTuple(e);return e.length>1?[r.code,convertToBytes(r.code,e[1])]:[r.code]})}function tuplesToStringTuples(t){return t.map(e=>{const r=protoFromTuple(e);return e[1]!=null?[r.code,convertToString(r.code,e[1])]:[r.code]})}function tuplesToBytes(t){return fromBytes(concat(t.map(e=>{const r=protoFromTuple(e);let n=Uint8Array.from(varint$4.encode(r.code));return e.length>1&&e[1]!=null&&(n=concat([n,e[1]])),n})))}function sizeForAddr(t,e){return t.size>0?t.size/8:t.size===0?0:varint$4.decode(e)+varint$4.decode.bytes}function bytesToTuples(t){const e=[];let r=0;for(;r<t.length;){const n=varint$4.decode(t,r),o=varint$4.decode.bytes,i=getProtocol(n),s=sizeForAddr(i,t.slice(r+o));if(s===0){e.push([n]),r+=o;continue}const u=t.slice(r+o,r+o+s);if(r+=s+o,r>t.length)throw ParseError("Invalid address Uint8Array: "+toString$5(t,"base16"));e.push([n,u])}return e}function bytesToString(t){const e=bytesToTuples(t),r=tuplesToStringTuples(e);return stringTuplesToString(r)}function stringToBytes(t){t=cleanPath(t);const e=stringToStringTuples(t),r=stringTuplesToTuples(e);return tuplesToBytes(r)}function fromString$1(t){return stringToBytes(t)}function fromBytes(t){const e=validateBytes(t);if(e!=null)throw e;return Uint8Array.from(t)}function validateBytes(t){try{bytesToTuples(t)}catch(e){return e}}function cleanPath(t){return"/"+t.trim().split("/").filter(e=>e).join("/")}function ParseError(t){return new Error("Error parsing address: "+t)}function protoFromTuple(t){return getProtocol(t[0])}function equals$2(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}var __classPrivateFieldGet$2=globalThis&&globalThis.__classPrivateFieldGet||function(t,e,r,n){if(r==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?t!==e||!n:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return r==="m"?n:r==="a"?n.call(t):n?n.value:e.get(t)},__classPrivateFieldSet$1=globalThis&&globalThis.__classPrivateFieldSet||function(t,e,r,n,o){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!o)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?t!==e||!o:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?o.call(t,r):o?o.value=r:e.set(t,r),r},_DefaultMultiaddr_string,_DefaultMultiaddr_tuples,_DefaultMultiaddr_stringTuples,_a$1;const inspect=Symbol.for("nodejs.util.inspect.custom"),DNS_CODES=[getProtocol("dns").code,getProtocol("dns4").code,getProtocol("dns6").code,getProtocol("dnsaddr").code],P2P_CODES=[getProtocol("p2p").code,getProtocol("ipfs").code],resolvers=new Map,symbol=Symbol.for("@multiformats/js-multiaddr/multiaddr");function isMultiaddr(t){return Boolean(t==null?void 0:t[symbol])}class DefaultMultiaddr{constructor(e){if(_DefaultMultiaddr_string.set(this,void 0),_DefaultMultiaddr_tuples.set(this,void 0),_DefaultMultiaddr_stringTuples.set(this,void 0),this[_a$1]=!0,e==null&&(e=""),e instanceof Uint8Array)this.bytes=fromBytes(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);this.bytes=fromString$1(e)}else if(isMultiaddr(e))this.bytes=fromBytes(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr")}toString(){return __classPrivateFieldGet$2(this,_DefaultMultiaddr_string,"f")==null&&__classPrivateFieldSet$1(this,_DefaultMultiaddr_string,bytesToString(this.bytes),"f"),__classPrivateFieldGet$2(this,_DefaultMultiaddr_string,"f")}toJSON(){return this.toString()}toOptions(){const e=this.protoCodes(),r=this.toString().split("/").slice(1);let n,o;if(r.length>2)DNS_CODES.includes(e[0])&&P2P_CODES.includes(e[1])?(n=getProtocol("tcp").name,o=443):(n=getProtocol(r[2]).name,o=parseInt(r[3]));else if(DNS_CODES.includes(e[0]))n=getProtocol("tcp").name,o=443;else throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e[0]===41||e[0]===55?6:4,host:r[1],transport:n,port:o}}protos(){return this.protoCodes().map(e=>Object.assign({},getProtocol(e)))}protoCodes(){const e=[],r=this.bytes;let n=0;for(;n<r.length;){const o=varint$4.decode(r,n),i=varint$4.decode.bytes,s=getProtocol(o),u=sizeForAddr(s,r.slice(n+i));n+=u+i,e.push(o)}return e}protoNames(){return this.protos().map(e=>e.name)}tuples(){return __classPrivateFieldGet$2(this,_DefaultMultiaddr_tuples,"f")==null&&__classPrivateFieldSet$1(this,_DefaultMultiaddr_tuples,bytesToTuples(this.bytes),"f"),__classPrivateFieldGet$2(this,_DefaultMultiaddr_tuples,"f")}stringTuples(){return __classPrivateFieldGet$2(this,_DefaultMultiaddr_stringTuples,"f")==null&&__classPrivateFieldSet$1(this,_DefaultMultiaddr_stringTuples,tuplesToStringTuples(this.tuples()),"f"),__classPrivateFieldGet$2(this,_DefaultMultiaddr_stringTuples,"f")}encapsulate(e){return e=new DefaultMultiaddr(e),new DefaultMultiaddr(this.toString()+e.toString())}decapsulate(e){const r=e.toString(),n=this.toString(),o=n.lastIndexOf(r);if(o<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new DefaultMultiaddr(n.slice(0,o))}decapsulateCode(e){const r=this.tuples();for(let n=r.length-1;n>=0;n--)if(r[n][0]===e)return new DefaultMultiaddr(tuplesToBytes(r.slice(0,n)));return this}getPeerId(){try{const r=this.stringTuples().filter(n=>n[0]===names.ipfs.code).pop();if((r==null?void 0:r[1])!=null){const n=r[1];return n[0]==="Q"||n[0]==="1"?toString$5(base58btc$2.decode(`z${n}`),"base58btc"):toString$5(CID$1.parse(n).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){let e=null;try{e=this.stringTuples().filter(r=>getProtocol(r[0]).path===!0)[0][1],e==null&&(e=null)}catch{e=null}return e}equals(e){return equals$2(this.bytes,e.bytes)}async resolve(e){const r=this.protos().find(i=>i.resolvable);if(r==null)return[this];const n=resolvers.get(r.name);if(n==null)throw errCode(new Error(`no available resolver for ${r.name}`),"ERR_NO_AVAILABLE_RESOLVER");return(await n(this,e)).map(i=>new DefaultMultiaddr(i))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){const r=(e!=null?e:this).protos();return!(r.length!==2||r[0].code!==4&&r[0].code!==41||r[1].code!==6&&r[1].code!==273)}[(_DefaultMultiaddr_string=new WeakMap,_DefaultMultiaddr_tuples=new WeakMap,_DefaultMultiaddr_stringTuples=new WeakMap,_a$1=symbol,inspect)](){return this.inspect()}inspect(){return"<Multiaddr "+toString$5(this.bytes,"base16")+" - "+bytesToString(this.bytes)+">"}}function multiaddr(t){return new DefaultMultiaddr(t)}$protobuf.util.Long=void 0;$protobuf.configure();async function storePeerUnderSingleDatastoreKey(t,e=()=>{}){e(0,"Storing each peerstore key under a single datastore key"),await t.datastore.open();const r={},n=[];for await(const{key:o,value:i}of t.datastore.query({prefix:"/peers"})){n.push(o);const s=o.toString(),[u,f,h,g,$]=s.split("/");if(f==="peers"&&!!["protos","addrs","metadata","keys"].includes(h)&&!!g)if(r[g]=r[g]||{addresses:[],protocols:[],metadata:[]},h==="protos"){const E=Protocols.decode(i);r[g].protocols=E.protocols.sort()}else if(h==="addrs"){const E=Addresses.decode(i);r[g].addresses=E.addrs.sort((A,w)=>multiaddr(A.multiaddr).toString().localeCompare(multiaddr(w.multiaddr).toString())),E.certifiedRecord&&E.certifiedRecord.raw&&(r[g].peerRecordEnvelope=E.certifiedRecord.raw)}else h==="metadata"?r[g].metadata.push({key:$,value:i}):h==="keys"&&(r[g].pubKey=i)}e(33,"Read peer data from store");for(const o of n)await t.datastore.delete(o);e(66,"Removed existing peer data from store");for(const o of Object.keys(r)){const i=r[o];i.metadata=i.metadata.sort((u,f)=>u.key.localeCompare(f.key));const s=Peer.encode(i).finish();await t.datastore.put(new Key(`/peers/${o}`),s)}await t.datastore.close(),e(100,"Stored each peerstore key under a single datastore key")}async function storePeerUnderMultipleDatastoreKeys(t,e=()=>{}){e(0,"Storing each peerstore key under a multiple datastore keys"),await t.datastore.open();const r={},n=[];for await(const{key:o,value:i}of t.datastore.query({prefix:"/peers"})){n.push(o);const s=o.toString(),[u,f,h]=s.split("/");r[h]=Peer.decode(i)}e(33,"Read peer data from store");for(const o of n)await t.datastore.delete(o);e(66,"Removed existing peer data from store");for(const[o,i]of Object.entries(r)){if(i.protocols&&i.protocols.length>0&&await t.datastore.put(new Key(`/peers/protos/${o}`),Protocols.encode({protocols:i.protocols}).finish()),i.addresses&&i.addresses.length>0){const s=i.peerRecordEnvelope;let u;if(s){const f=Envelope.decode(s),h=PeerRecord.decode(f.payload);u={raw:s,seq:h.seq}}await t.datastore.put(new Key(`/peers/addrs/${o}`),Addresses.encode({addrs:i.addresses,certifiedRecord:u}).finish())}if(i.metadata&&i.metadata.length>0)for(const{key:s,value:u}of i.metadata)await t.datastore.put(new Key(`/peers/metadata/${o}/${s}`),u);i.pubKey&&await t.datastore.put(new Key(`/peers/keys/${o}`),i.pubKey)}await t.datastore.close(),e(100,"Stored each peerstore key under multiple datastore keys")}const migration={version:12,description:"Store each peerstore peer under a single datastore key",migrate:storePeerUnderSingleDatastoreKey,revert:storePeerUnderMultipleDatastoreKeys},emptyMigration={description:"Empty migration.",migrate:()=>{},revert:()=>{},empty:!0},defaultMigrations=[Object.assign({version:1},emptyMigration),Object.assign({version:2},emptyMigration),Object.assign({version:3},emptyMigration),Object.assign({version:4},emptyMigration),Object.assign({version:5},emptyMigration),Object.assign({version:6},emptyMigration),Object.assign({version:7},emptyMigration),migration$4,migration$3,migration$2,migration$1,migration];class NonReversibleMigrationError extends Error{constructor(e){super(e),this.name="NonReversibleMigrationError",this.code=NonReversibleMigrationError.code,this.message=e}}NonReversibleMigrationError.code="ERR_NON_REVERSIBLE_MIGRATION";class NotInitializedRepoError extends Error{constructor(e){super(e),this.name="NotInitializedRepoError",this.code=NotInitializedRepoError.code,this.message=e}}NotInitializedRepoError.code="ERR_NOT_INITIALIZED_REPO";class RequiredParameterError extends Error{constructor(e){super(e),this.name="RequiredParameterError",this.code=RequiredParameterError.code,this.message=e}}RequiredParameterError.code="ERR_REQUIRED_PARAMETER";class InvalidValueError extends Error{constructor(e){super(e),this.name="InvalidValueError",this.code=InvalidValueError.code,this.message=e}}InvalidValueError.code="ERR_INVALID_VALUE";class MissingRepoOptionsError extends Error{constructor(e){super(e),this.name="MissingRepoOptionsError",this.code=MissingRepoOptionsError.code,this.message=e}}MissingRepoOptionsError.code="ERR_MISSING_REPO_OPTIONS";const Errors=Object.freeze(Object.defineProperty({__proto__:null,NonReversibleMigrationError,NotInitializedRepoError,RequiredParameterError,InvalidValueError,MissingRepoOptionsError},Symbol.toStringTag,{value:"Module"})),log$6=debug("ipfs:repo:migrator:repo:init");async function isRepoInitialized(t){if(!t)throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");const e=t.root;try{await e.open();const r=await e.has(VERSION_KEY),n=await e.has(CONFIG_KEY);return!r||!n?(log$6(`Version entry present: ${r}`),log$6(`Config entry present: ${n}`),!1):!0}catch(r){return log$6("While checking if repo is initialized error was thrown: "+r.message),!1}finally{if(e!==void 0)try{await e.close()}catch{}}}async function getVersion(t){if(!await isRepoInitialized(t))throw new NotInitializedRepoError("Repo is not initialized!");const e=t.root;await e.open();try{return parseInt(toString$4(await e.get(VERSION_KEY)))}finally{await e.close()}}async function setVersion(t,e){if(!e)throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");const r=e.root;await r.open(),await r.put(VERSION_KEY,fromString$3(String(t))),await r.close()}const log$5=debug("ipfs:repo:migrator");function getLatestMigrationVersion(t){return t=t||defaultMigrations,!Array.isArray(t)||t.length===0?0:t[t.length-1].version}async function migrate(t,e,r,n,o={}){var $,E,A;const i=($=o.ignoreLock)!=null?$:!1,s=o.onProgress,u=(E=o.isDryRun)!=null?E:!1,f=(A=o.migrations)!=null?A:defaultMigrations;if(!t)throw new errors.RequiredParameterError("Path argument is required!");if(!r)throw new errors.RequiredParameterError("repoOptions argument is required!");if(!n)throw new errors.RequiredParameterError("toVersion argument is required!");if(!Number.isInteger(n)||n<=0)throw new errors.InvalidValueError("Version has to be positive integer!");e=wrapBackends(e);const h=await getVersion(e);if(h===n){log$5("Nothing to migrate.");return}if(h>n)throw new errors.InvalidValueError(`Current repo's version (${h}) is higher then toVersion (${n}), you probably wanted to revert it?`);verifyAvailableMigrations(f,h,n);let g;!u&&!i&&(g=await r.repoLock.lock(t));try{for(const w of f){if(n!==void 0&&w.version>n)break;if(!(w.version<=h)){log$5(`Migrating version ${w.version}`);try{if(!u){let v=()=>{};s&&(v=(k,P)=>s(w.version,k.toFixed(2),P)),await w.migrate(e,v)}}catch(v){const k=w.version-1;throw log$5(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${k}`),await setVersion(k,e),new Error(`During migration to version ${w.version} exception was raised: ${v.stack||v.message||v}`)}log$5(`Migrating to version ${w.version} finished`)}}u||await setVersion(n||getLatestMigrationVersion(f),e),log$5("Repo successfully migrated",n!==void 0?`to version ${n}!`:"to latest version!")}finally{!u&&!i&&g&&await g.close()}}async function revert(t,e,r,n,o={}){var $,E,A;const i=($=o.ignoreLock)!=null?$:!1,s=o.onProgress,u=(E=o.isDryRun)!=null?E:!1,f=(A=o.migrations)!=null?A:defaultMigrations;if(!t)throw new errors.RequiredParameterError("Path argument is required!");if(!r)throw new errors.RequiredParameterError("repoOptions argument is required!");if(!n)throw new errors.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");if(!Number.isInteger(n)||n<=0)throw new errors.InvalidValueError("Version has to be positive integer!");e=wrapBackends(e);const h=await getVersion(e);if(h===n){log$5("Nothing to revert.");return}if(h<n)throw new errors.InvalidValueError(`Current repo's version (${h}) is lower then toVersion (${n}), you probably wanted to migrate it?`);verifyAvailableMigrations(f,n,h,!0);let g;!u&&!i&&(g=await r.repoLock.lock(t)),log$5(`Reverting from version ${h} to ${n}`);try{const w=f.slice().reverse();for(const v of w){if(v.version<=n)break;if(!(v.version>h)){log$5(`Reverting migration version ${v.version}`);try{if(!u){let k=()=>{};s&&(k=(P,L)=>s(v.version,P.toFixed(2),L)),await v.revert(e,k)}}catch(k){const P=v.version;throw log$5(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${P}`),await setVersion(P,e),k.message=`During reversion to version ${v.version} exception was raised: ${k.message}`,k}log$5(`Reverting to version ${v.version} finished`)}}u||await setVersion(n,e),log$5(`All migrations successfully reverted to version ${n}!`)}finally{!u&&!i&&g&&await g.close()}}function verifyAvailableMigrations(t,e,r,n=!1){let o=0;for(const i of t){if(i.version>r)break;if(i.version>e){if(n&&!i.revert)throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${e} because migration version ${i.version} is not reversible. Cancelling reversion.`);o++}}if(o!==r-e)throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${e} to ${r}`)}const errors=Errors;var bytes$1={exports:{}};/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */bytes$1.exports=bytes;bytes$1.exports.format=format$1;bytes$1.exports.parse=parse;var formatThousandsRegExp=/\B(?=(\d{3})+(?!\d))/g,formatDecimalsRegExp=/(?:\.0*|(\.[^0]+)0+)$/,map$1={b:1,kb:1<<10,mb:1<<20,gb:1<<30,tb:Math.pow(1024,4),pb:Math.pow(1024,5)},parseRegExp=/^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;function bytes(t,e){return typeof t=="string"?parse(t):typeof t=="number"?format$1(t,e):null}function format$1(t,e){if(!Number.isFinite(t))return null;var r=Math.abs(t),n=e&&e.thousandsSeparator||"",o=e&&e.unitSeparator||"",i=e&&e.decimalPlaces!==void 0?e.decimalPlaces:2,s=Boolean(e&&e.fixedDecimals),u=e&&e.unit||"";(!u||!map$1[u.toLowerCase()])&&(r>=map$1.pb?u="PB":r>=map$1.tb?u="TB":r>=map$1.gb?u="GB":r>=map$1.mb?u="MB":r>=map$1.kb?u="KB":u="B");var f=t/map$1[u.toLowerCase()],h=f.toFixed(i);return s||(h=h.replace(formatDecimalsRegExp,"$1")),n&&(h=h.split(".").map(function(g,$){return $===0?g.replace(formatThousandsRegExp,n):g}).join(".")),h+o+u}function parse(t){if(typeof t=="number"&&!isNaN(t))return t;if(typeof t!="string")return null;var e=parseRegExp.exec(t),r,n="b";return e?(r=parseFloat(e[1]),n=e[4].toLowerCase()):(r=parseInt(t,10),n="b"),isNaN(r)?null:Math.floor(map$1[n]*r)}var isPlainObj=t=>{if(Object.prototype.toString.call(t)!=="[object Object]")return!1;const e=Object.getPrototypeOf(t);return e===null||e===Object.prototype};const isOptionObject=isPlainObj,{hasOwnProperty}=Object.prototype,{propertyIsEnumerable}=Object,defineProperty=(t,e,r)=>Object.defineProperty(t,e,{value:r,writable:!0,enumerable:!0,configurable:!0}),globalThis$1=commonjsGlobal,defaultMergeOptions={concatArrays:!1,ignoreUndefined:!1},getEnumerableOwnPropertyKeys=t=>{const e=[];for(const r in t)hasOwnProperty.call(t,r)&&e.push(r);if(Object.getOwnPropertySymbols){const r=Object.getOwnPropertySymbols(t);for(const n of r)propertyIsEnumerable.call(t,n)&&e.push(n)}return e};function clone(t){return Array.isArray(t)?cloneArray(t):isOptionObject(t)?cloneOptionObject(t):t}function cloneArray(t){const e=t.slice(0,0);return getEnumerableOwnPropertyKeys(t).forEach(r=>{defineProperty(e,r,clone(t[r]))}),e}function cloneOptionObject(t){const e=Object.getPrototypeOf(t)===null?Object.create(null):{};return getEnumerableOwnPropertyKeys(t).forEach(r=>{defineProperty(e,r,clone(t[r]))}),e}const mergeKeys=(t,e,r,n)=>(r.forEach(o=>{typeof e[o]>"u"&&n.ignoreUndefined||(o in t&&t[o]!==Object.getPrototypeOf(t)?defineProperty(t,o,merge$1(t[o],e[o],n)):defineProperty(t,o,clone(e[o])))}),t),concatArrays=(t,e,r)=>{let n=t.slice(0,0),o=0;return[t,e].forEach(i=>{const s=[];for(let u=0;u<i.length;u++)!hasOwnProperty.call(i,u)||(s.push(String(u)),i===t?defineProperty(n,o++,i[u]):defineProperty(n,o++,clone(i[u])));n=mergeKeys(n,i,getEnumerableOwnPropertyKeys(i).filter(u=>!s.includes(u)),r)}),n};function merge$1(t,e,r){return r.concatArrays&&Array.isArray(t)&&Array.isArray(e)?concatArrays(t,e,r):!isOptionObject(e)||!isOptionObject(t)?clone(e):mergeKeys(t,e,getEnumerableOwnPropertyKeys(e),r)}var mergeOptions=function(...t){const e=merge$1(clone(defaultMergeOptions),this!==globalThis$1&&this||{},defaultMergeOptions);let r={_:{}};for(const n of t)if(n!==void 0){if(!isOptionObject(n))throw new TypeError("`"+n+"` is not an Option Object");r=merge$1(r,{_:n},e)}return r._};const repoVersion=12;function asUint8Array(t){return globalThis.Buffer!=null?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t}function allocUnsafe(t=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?asUint8Array(globalThis.Buffer.allocUnsafe(t)):new Uint8Array(t)}function createCodec(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}const string=createCodec("utf8","u",t=>"u"+new TextDecoder("utf8").decode(t),t=>new TextEncoder().encode(t.substring(1))),ascii=createCodec("ascii","a",t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},t=>{t=t.substring(1);const e=allocUnsafe(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}),BASES={utf8:string,"utf-8":string,hex:bases$1.base16,latin1:ascii,ascii,binary:ascii,...bases$1};function toString(t,e="utf8"){const r=BASES[e];if(!r)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(t.buffer,t.byteOffset,t.byteLength).toString("utf8"):r.encoder.encode(t).substring(1)}function fromString(t,e="utf8"){const r=BASES[e];if(!r)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array(globalThis.Buffer.from(t,"utf-8")):r.decoder.decode(`${r.prefix}${t}`)}class LockExistsError extends Error{constructor(e){super(e),this.name="LockExistsError",this.code=LockExistsError.code}}LockExistsError.code="ERR_LOCK_EXISTS";class NotFoundError extends Error{constructor(e){super(e),this.name="NotFoundError",this.code=NotFoundError.code}}NotFoundError.code="ERR_NOT_FOUND";class InvalidRepoVersionError extends Error{constructor(e){super(e),this.name="InvalidRepoVersionError",this.code=InvalidRepoVersionError.code}}InvalidRepoVersionError.code="ERR_INVALID_REPO_VERSION";const ERR_REPO_NOT_INITIALIZED="ERR_REPO_NOT_INITIALIZED",ERR_REPO_ALREADY_OPEN="ERR_REPO_ALREADY_OPEN",ERR_REPO_ALREADY_CLOSED="ERR_REPO_ALREADY_CLOSED";async function hasWithFallback(t,e,r){const n=await e(t);if(n)return n;const o=findLevelJs(r);return o?new Promise((i,s)=>{const u=o.store("readonly").get(t.toString());u.transaction.onabort=()=>{s(u.transaction.error)},u.transaction.oncomplete=()=>{i(Boolean(u.result))}}):!1}async function getWithFallback(t,e,r,n){if(await r(t))return e(t);const o=findLevelJs(n);if(!o)throw new NotFoundError;return new Promise((i,s)=>{const u=o.store("readonly").get(t.toString());u.transaction.onabort=()=>{s(u.transaction.error)},u.transaction.oncomplete=()=>{if(u.result)return i(u.result);s(new NotFoundError)}})}function findLevelJs(t){let e=t;for(;e.db||e.child;)if(e=e.db||e.child,e.type==="level-js"||e.constructor.name==="Level")return e}const log$4=debug("ipfs:repo:version"),versionKey=new Key("version");function version(t){return{async exists(){return hasWithFallback(versionKey,t.has.bind(t),t)},async get(){const e=await getWithFallback(versionKey,t.get.bind(t),t.has.bind(t),t);return parseInt(toString(e),10)},set(e){return t.put(versionKey,fromString(String(e)))},async check(e){const r=await this.get();return log$4("comparing version: %s and %s",r,e),r===e||(r===6&&e===7||e===6&&r===7)}}}var eventemitter3={exports:{}};(function(t){var e=Object.prototype.hasOwnProperty,r="~";function n(){}Object.create&&(n.prototype=Object.create(null),new n().__proto__||(r=!1));function o(f,h,g){this.fn=f,this.context=h,this.once=g||!1}function i(f,h,g,$,E){if(typeof g!="function")throw new TypeError("The listener must be a function");var A=new o(g,$||f,E),w=r?r+h:h;return f._events[w]?f._events[w].fn?f._events[w]=[f._events[w],A]:f._events[w].push(A):(f._events[w]=A,f._eventsCount++),f}function s(f,h){--f._eventsCount===0?f._events=new n:delete f._events[h]}function u(){this._events=new n,this._eventsCount=0}u.prototype.eventNames=function(){var h=[],g,$;if(this._eventsCount===0)return h;for($ in g=this._events)e.call(g,$)&&h.push(r?$.slice(1):$);return Object.getOwnPropertySymbols?h.concat(Object.getOwnPropertySymbols(g)):h},u.prototype.listeners=function(h){var g=r?r+h:h,$=this._events[g];if(!$)return[];if($.fn)return[$.fn];for(var E=0,A=$.length,w=new Array(A);E<A;E++)w[E]=$[E].fn;return w},u.prototype.listenerCount=function(h){var g=r?r+h:h,$=this._events[g];return $?$.fn?1:$.length:0},u.prototype.emit=function(h,g,$,E,A,w){var v=r?r+h:h;if(!this._events[v])return!1;var k=this._events[v],P=arguments.length,L,N;if(k.fn){switch(k.once&&this.removeListener(h,k.fn,void 0,!0),P){case 1:return k.fn.call(k.context),!0;case 2:return k.fn.call(k.context,g),!0;case 3:return k.fn.call(k.context,g,$),!0;case 4:return k.fn.call(k.context,g,$,E),!0;case 5:return k.fn.call(k.context,g,$,E,A),!0;case 6:return k.fn.call(k.context,g,$,E,A,w),!0}for(N=1,L=new Array(P-1);N<P;N++)L[N-1]=arguments[N];k.fn.apply(k.context,L)}else{var q=k.length,X;for(N=0;N<q;N++)switch(k[N].once&&this.removeListener(h,k[N].fn,void 0,!0),P){case 1:k[N].fn.call(k[N].context);break;case 2:k[N].fn.call(k[N].context,g);break;case 3:k[N].fn.call(k[N].context,g,$);break;case 4:k[N].fn.call(k[N].context,g,$,E);break;default:if(!L)for(X=1,L=new Array(P-1);X<P;X++)L[X-1]=arguments[X];k[N].fn.apply(k[N].context,L)}}return!0},u.prototype.on=function(h,g,$){return i(this,h,g,$,!1)},u.prototype.once=function(h,g,$){return i(this,h,g,$,!0)},u.prototype.removeListener=function(h,g,$,E){var A=r?r+h:h;if(!this._events[A])return this;if(!g)return s(this,A),this;var w=this._events[A];if(w.fn)w.fn===g&&(!E||w.once)&&(!$||w.context===$)&&s(this,A);else{for(var v=0,k=[],P=w.length;v<P;v++)(w[v].fn!==g||E&&!w[v].once||$&&w[v].context!==$)&&k.push(w[v]);k.length?this._events[A]=k.length===1?k[0]:k:s(this,A)}return this},u.prototype.removeAllListeners=function(h){var g;return h?(g=r?r+h:h,this._events[g]&&s(this,g)):(this._events=new n,this._eventsCount=0),this},u.prototype.off=u.prototype.removeListener,u.prototype.addListener=u.prototype.on,u.prefixed=r,u.EventEmitter=u,t.exports=u})(eventemitter3);const EventEmitter=eventemitter3.exports;class TimeoutError$1 extends Error{constructor(e){super(e),this.name="TimeoutError"}}class AbortError$2 extends Error{constructor(e){super(),this.name="AbortError",this.message=e}}const getDOMException$1=t=>globalThis.DOMException===void 0?new AbortError$2(t):new DOMException(t),getAbortedReason$1=t=>{const e=t.reason===void 0?getDOMException$1("This operation was aborted."):t.reason;return e instanceof Error?e:getDOMException$1(e)};function pTimeout$1(t,e,r,n){let o;const i=new Promise((s,u)=>{if(typeof e!="number"||Math.sign(e)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);if(e===Number.POSITIVE_INFINITY){s(t);return}if(n={customTimers:{setTimeout,clearTimeout},...n},n.signal){const{signal:f}=n;f.aborted&&u(getAbortedReason$1(f)),f.addEventListener("abort",()=>{u(getAbortedReason$1(f))})}o=n.customTimers.setTimeout.call(void 0,()=>{if(typeof r=="function"){try{s(r())}catch(g){u(g)}return}const f=typeof r=="string"?r:`Promise timed out after ${e} milliseconds`,h=r instanceof Error?r:new TimeoutError$1(f);typeof t.cancel=="function"&&t.cancel(),u(h)},e),(async()=>{try{s(await t)}catch(f){u(f)}finally{n.customTimers.clearTimeout.call(void 0,o)}})()});return i.clear=()=>{clearTimeout(o),o=void 0},i}function lowerBound(t,e,r){let n=0,o=t.length;for(;o>0;){const i=Math.trunc(o/2);let s=n+i;r(t[s],e)<=0?(n=++s,o-=i+1):o=i}return n}var __classPrivateFieldGet$1=globalThis&&globalThis.__classPrivateFieldGet||function(t,e,r,n){if(r==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?t!==e||!n:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return r==="m"?n:r==="a"?n.call(t):n?n.value:e.get(t)},_PriorityQueue_queue;class PriorityQueue{constructor(){_PriorityQueue_queue.set(this,[])}enqueue(e,r){r={priority:0,...r};const n={priority:r.priority,run:e};if(this.size&&__classPrivateFieldGet$1(this,_PriorityQueue_queue,"f")[this.size-1].priority>=r.priority){__classPrivateFieldGet$1(this,_PriorityQueue_queue,"f").push(n);return}const o=lowerBound(__classPrivateFieldGet$1(this,_PriorityQueue_queue,"f"),n,(i,s)=>s.priority-i.priority);__classPrivateFieldGet$1(this,_PriorityQueue_queue,"f").splice(o,0,n)}dequeue(){const e=__classPrivateFieldGet$1(this,_PriorityQueue_queue,"f").shift();return e==null?void 0:e.run}filter(e){return __classPrivateFieldGet$1(this,_PriorityQueue_queue,"f").filter(r=>r.priority===e.priority).map(r=>r.run)}get size(){return __classPrivateFieldGet$1(this,_PriorityQueue_queue,"f").length}}_PriorityQueue_queue=new WeakMap;var __classPrivateFieldSet=globalThis&&globalThis.__classPrivateFieldSet||function(t,e,r,n,o){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!o)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?t!==e||!o:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?o.call(t,r):o?o.value=r:e.set(t,r),r},__classPrivateFieldGet=globalThis&&globalThis.__classPrivateFieldGet||function(t,e,r,n){if(r==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?t!==e||!n:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return r==="m"?n:r==="a"?n.call(t):n?n.value:e.get(t)},_PQueue_instances,_PQueue_carryoverConcurrencyCount,_PQueue_isIntervalIgnored,_PQueue_intervalCount,_PQueue_intervalCap,_PQueue_interval,_PQueue_intervalEnd,_PQueue_intervalId,_PQueue_timeoutId,_PQueue_queue,_PQueue_queueClass,_PQueue_pendingCount,_PQueue_concurrency,_PQueue_isPaused,_PQueue_throwOnTimeout,_PQueue_doesIntervalAllowAnother_get,_PQueue_doesConcurrentAllowAnother_get,_PQueue_next,_PQueue_emitEvents,_PQueue_onResumeInterval,_PQueue_isIntervalPaused_get,_PQueue_tryToStartAnother,_PQueue_initializeIntervalIfNeeded,_PQueue_onInterval,_PQueue_processQueue,_PQueue_onEvent;const timeoutError=new TimeoutError$1;class AbortError$1 extends Error{}class PQueue extends EventEmitter{constructor(e){var r,n,o,i;if(super(),_PQueue_instances.add(this),_PQueue_carryoverConcurrencyCount.set(this,void 0),_PQueue_isIntervalIgnored.set(this,void 0),_PQueue_intervalCount.set(this,0),_PQueue_intervalCap.set(this,void 0),_PQueue_interval.set(this,void 0),_PQueue_intervalEnd.set(this,0),_PQueue_intervalId.set(this,void 0),_PQueue_timeoutId.set(this,void 0),_PQueue_queue.set(this,void 0),_PQueue_queueClass.set(this,void 0),_PQueue_pendingCount.set(this,0),_PQueue_concurrency.set(this,void 0),_PQueue_isPaused.set(this,void 0),_PQueue_throwOnTimeout.set(this,void 0),Object.defineProperty(this,"timeout",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:PriorityQueue,...e},!(typeof e.intervalCap=="number"&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n=(r=e.intervalCap)===null||r===void 0?void 0:r.toString())!==null&&n!==void 0?n:""}\` (${typeof e.intervalCap})`);if(e.interval===void 0||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(i=(o=e.interval)===null||o===void 0?void 0:o.toString())!==null&&i!==void 0?i:""}\` (${typeof e.interval})`);__classPrivateFieldSet(this,_PQueue_carryoverConcurrencyCount,e.carryoverConcurrencyCount,"f"),__classPrivateFieldSet(this,_PQueue_isIntervalIgnored,e.intervalCap===Number.POSITIVE_INFINITY||e.interval===0,"f"),__classPrivateFieldSet(this,_PQueue_intervalCap,e.intervalCap,"f"),__classPrivateFieldSet(this,_PQueue_interval,e.interval,"f"),__classPrivateFieldSet(this,_PQueue_queue,new e.queueClass,"f"),__classPrivateFieldSet(this,_PQueue_queueClass,e.queueClass,"f"),this.concurrency=e.concurrency,this.timeout=e.timeout,__classPrivateFieldSet(this,_PQueue_throwOnTimeout,e.throwOnTimeout===!0,"f"),__classPrivateFieldSet(this,_PQueue_isPaused,e.autoStart===!1,"f")}get concurrency(){return __classPrivateFieldGet(this,_PQueue_concurrency,"f")}set concurrency(e){if(!(typeof e=="number"&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);__classPrivateFieldSet(this,_PQueue_concurrency,e,"f"),__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_processQueue).call(this)}async add(e,r={}){return new Promise((n,o)=>{const i=async()=>{var s,u,f;__classPrivateFieldSet(this,_PQueue_pendingCount,(u=__classPrivateFieldGet(this,_PQueue_pendingCount,"f"),u++,u),"f"),__classPrivateFieldSet(this,_PQueue_intervalCount,(f=__classPrivateFieldGet(this,_PQueue_intervalCount,"f"),f++,f),"f");try{if(!((s=r.signal)===null||s===void 0)&&s.aborted){o(new AbortError$1("The task was aborted."));return}const g=await(this.timeout===void 0&&r.timeout===void 0?e({signal:r.signal}):pTimeout$1(Promise.resolve(e({signal:r.signal})),r.timeout===void 0?this.timeout:r.timeout,()=>{(r.throwOnTimeout===void 0?__classPrivateFieldGet(this,_PQueue_throwOnTimeout,"f"):r.throwOnTimeout)&&o(timeoutError)}));n(g),this.emit("completed",g)}catch(h){o(h),this.emit("error",h)}__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_next).call(this)};__classPrivateFieldGet(this,_PQueue_queue,"f").enqueue(i,r),__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_tryToStartAnother).call(this),this.emit("add")})}async addAll(e,r){return Promise.all(e.map(async n=>this.add(n,r)))}start(){return __classPrivateFieldGet(this,_PQueue_isPaused,"f")?(__classPrivateFieldSet(this,_PQueue_isPaused,!1,"f"),__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_processQueue).call(this),this):this}pause(){__classPrivateFieldSet(this,_PQueue_isPaused,!0,"f")}clear(){__classPrivateFieldSet(this,_PQueue_queue,new(__classPrivateFieldGet(this,_PQueue_queueClass,"f")),"f")}async onEmpty(){__classPrivateFieldGet(this,_PQueue_queue,"f").size!==0&&await __classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_onEvent).call(this,"empty")}async onSizeLessThan(e){__classPrivateFieldGet(this,_PQueue_queue,"f").size<e||await __classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_onEvent).call(this,"next",()=>__classPrivateFieldGet(this,_PQueue_queue,"f").size<e)}async onIdle(){__classPrivateFieldGet(this,_PQueue_pendingCount,"f")===0&&__classPrivateFieldGet(this,_PQueue_queue,"f").size===0||await __classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_onEvent).call(this,"idle")}get size(){return __classPrivateFieldGet(this,_PQueue_queue,"f").size}sizeBy(e){return __classPrivateFieldGet(this,_PQueue_queue,"f").filter(e).length}get pending(){return __classPrivateFieldGet(this,_PQueue_pendingCount,"f")}get isPaused(){return __classPrivateFieldGet(this,_PQueue_isPaused,"f")}}_PQueue_carryoverConcurrencyCount=new WeakMap,_PQueue_isIntervalIgnored=new WeakMap,_PQueue_intervalCount=new WeakMap,_PQueue_intervalCap=new WeakMap,_PQueue_interval=new WeakMap,_PQueue_intervalEnd=new WeakMap,_PQueue_intervalId=new WeakMap,_PQueue_timeoutId=new WeakMap,_PQueue_queue=new WeakMap,_PQueue_queueClass=new WeakMap,_PQueue_pendingCount=new WeakMap,_PQueue_concurrency=new WeakMap,_PQueue_isPaused=new WeakMap,_PQueue_throwOnTimeout=new WeakMap,_PQueue_instances=new WeakSet,_PQueue_doesIntervalAllowAnother_get=function t(){return __classPrivateFieldGet(this,_PQueue_isIntervalIgnored,"f")||__classPrivateFieldGet(this,_PQueue_intervalCount,"f")<__classPrivateFieldGet(this,_PQueue_intervalCap,"f")},_PQueue_doesConcurrentAllowAnother_get=function t(){return __classPrivateFieldGet(this,_PQueue_pendingCount,"f")<__classPrivateFieldGet(this,_PQueue_concurrency,"f")},_PQueue_next=function t(){var e;__classPrivateFieldSet(this,_PQueue_pendingCount,(e=__classPrivateFieldGet(this,_PQueue_pendingCount,"f"),e--,e),"f"),__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_tryToStartAnother).call(this),this.emit("next")},_PQueue_emitEvents=function t(){this.emit("empty"),__classPrivateFieldGet(this,_PQueue_pendingCount,"f")===0&&this.emit("idle")},_PQueue_onResumeInterval=function t(){__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_onInterval).call(this),__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_initializeIntervalIfNeeded).call(this),__classPrivateFieldSet(this,_PQueue_timeoutId,void 0,"f")},_PQueue_isIntervalPaused_get=function t(){const e=Date.now();if(__classPrivateFieldGet(this,_PQueue_intervalId,"f")===void 0){const r=__classPrivateFieldGet(this,_PQueue_intervalEnd,"f")-e;if(r<0)__classPrivateFieldSet(this,_PQueue_intervalCount,__classPrivateFieldGet(this,_PQueue_carryoverConcurrencyCount,"f")?__classPrivateFieldGet(this,_PQueue_pendingCount,"f"):0,"f");else return __classPrivateFieldGet(this,_PQueue_timeoutId,"f")===void 0&&__classPrivateFieldSet(this,_PQueue_timeoutId,setTimeout(()=>{__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_onResumeInterval).call(this)},r),"f"),!0}return!1},_PQueue_tryToStartAnother=function t(){if(__classPrivateFieldGet(this,_PQueue_queue,"f").size===0)return __classPrivateFieldGet(this,_PQueue_intervalId,"f")&&clearInterval(__classPrivateFieldGet(this,_PQueue_intervalId,"f")),__classPrivateFieldSet(this,_PQueue_intervalId,void 0,"f"),__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_emitEvents).call(this),!1;if(!__classPrivateFieldGet(this,_PQueue_isPaused,"f")){const e=!__classPrivateFieldGet(this,_PQueue_instances,"a",_PQueue_isIntervalPaused_get);if(__classPrivateFieldGet(this,_PQueue_instances,"a",_PQueue_doesIntervalAllowAnother_get)&&__classPrivateFieldGet(this,_PQueue_instances,"a",_PQueue_doesConcurrentAllowAnother_get)){const r=__classPrivateFieldGet(this,_PQueue_queue,"f").dequeue();return r?(this.emit("active"),r(),e&&__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_initializeIntervalIfNeeded).call(this),!0):!1}}return!1},_PQueue_initializeIntervalIfNeeded=function t(){__classPrivateFieldGet(this,_PQueue_isIntervalIgnored,"f")||__classPrivateFieldGet(this,_PQueue_intervalId,"f")!==void 0||(__classPrivateFieldSet(this,_PQueue_intervalId,setInterval(()=>{__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_onInterval).call(this)},__classPrivateFieldGet(this,_PQueue_interval,"f")),"f"),__classPrivateFieldSet(this,_PQueue_intervalEnd,Date.now()+__classPrivateFieldGet(this,_PQueue_interval,"f"),"f"))},_PQueue_onInterval=function t(){__classPrivateFieldGet(this,_PQueue_intervalCount,"f")===0&&__classPrivateFieldGet(this,_PQueue_pendingCount,"f")===0&&__classPrivateFieldGet(this,_PQueue_intervalId,"f")&&(clearInterval(__classPrivateFieldGet(this,_PQueue_intervalId,"f")),__classPrivateFieldSet(this,_PQueue_intervalId,void 0,"f")),__classPrivateFieldSet(this,_PQueue_intervalCount,__classPrivateFieldGet(this,_PQueue_carryoverConcurrencyCount,"f")?__classPrivateFieldGet(this,_PQueue_pendingCount,"f"):0,"f"),__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_processQueue).call(this)},_PQueue_processQueue=function t(){for(;__classPrivateFieldGet(this,_PQueue_instances,"m",_PQueue_tryToStartAnother).call(this););},_PQueue_onEvent=async function t(e,r){return new Promise(n=>{const o=()=>{r&&!r()||(this.off(e,o),n())};this.on(e,o)})};var objectSafeSet=set;function set(t,e,r){var n,o;if(Array.isArray(e)&&(n=e.slice(0)),typeof e=="string"&&(n=e.split(".")),typeof e=="symbol"&&(n=[e]),!Array.isArray(n))throw new Error("props arg must be an array, a string or a symbol");if(o=n.pop(),!o)return!1;prototypeCheck(o);for(var i;i=n.shift();)if(prototypeCheck(i),typeof t[i]>"u"&&(t[i]={}),t=t[i],!t||typeof t!="object")return!1;return t[o]=r,!0}function prototypeCheck(t){if(t=="__proto__"||t=="constructor"||t=="prototype")throw new Error("setting of prototype values not supported")}const Queue=PQueue.default?PQueue.default:PQueue,configKey=new Key("config");function config(t){const e=new Queue({concurrency:1}),r={async getAll(i={}){const s=await getWithFallback(configKey,t.get.bind(t),t.has.bind(t),t);return JSON.parse(toString(s))},async get(i,s={}){if(i==null)throw new NotFoundError(`Key ${i} does not exist in config`);const u=await this.getAll(s),f=objectSafeGet(u,i);if(f===void 0)throw new NotFoundError(`Key ${i} does not exist in config`);return f},set(i,s,u={}){if(typeof i!="string"&&!(i instanceof String))throw errCode(new Error("Invalid key type: "+typeof i),"ERR_INVALID_KEY");if(s===void 0||s instanceof Uint8Array)throw errCode(new Error("Invalid value type: "+typeof s),"ERR_INVALID_VALUE");return e.add(()=>n({key:i,value:s},u.signal))},replace(i,s={}){if(!i||i instanceof Uint8Array)throw errCode(new Error("Invalid value type: "+typeof i),"ERR_INVALID_VALUE");return e.add(()=>n({key:void 0,value:i},s.signal))},async exists(){return hasWithFallback(configKey,t.has.bind(t),t)}};return r;async function n(i,s){if(s&&s.aborted)return;const u=i.key,f=i.value;if(u){const h=await r.getAll();return typeof h=="object"&&h!==null&&objectSafeSet(h,u,f),o(h)}return o(f)}function o(i){const s=fromString(JSON.stringify(i,null,2));return t.put(configKey,s)}}function isPlainObject(t){if(typeof t!="object"||t===null)return!1;const e=Object.getPrototypeOf(t);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in t)&&!(Symbol.iterator in t)}function sortKeys(t,e={}){if(!isPlainObject(t)&&!Array.isArray(t))throw new TypeError("Expected a plain object or array");const{deep:r,compare:n}=e,o=[],i=[],s=f=>{const h=o.indexOf(f);if(h!==-1)return i[h];const g=[];return o.push(f),i.push(g),g.push(...f.map($=>Array.isArray($)?s($):isPlainObject($)?u($):$)),g},u=f=>{const h=o.indexOf(f);if(h!==-1)return i[h];const g={},$=Object.keys(f).sort(n);o.push(f),i.push(g);for(const E of $){const A=f[E];let w;r&&Array.isArray(A)?w=s(A):w=r&&isPlainObject(A)?u(A):A,Object.defineProperty(g,E,{...Object.getOwnPropertyDescriptor(f,E),value:w})}return g};return Array.isArray(t)?r?s(t):t.slice():u(t)}const specKey=new Key("datastore_spec");function spec(t){return{exists(){return t.has(specKey)},async get(){const e=await t.get(specKey);return JSON.parse(toString(e))},async set(e){return t.put(specKey,fromString(JSON.stringify(sortKeys(e,{deep:!0}))))}}}const apiFile=new Key("api");function apiAddr(t){return{async get(){const e=await t.get(apiFile);return e&&e.toString()},set(e){return t.put(apiFile,fromString(e.toString()))},delete(){return t.delete(apiFile)}}}const filter=async function*(t,e){for await(const r of t)await e(r)&&(yield r)};var itFilter=filter;class FixedFIFO$1{constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}class FIFO$1{constructor(e={}){var r;this.hwm=(r=e.splitLimit)!=null?r:16,this.head=new FixedFIFO$1(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return(e==null?void 0:e.byteLength)!=null?e.byteLength:1}push(e){if((e==null?void 0:e.value)!=null&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const r=this.head;this.head=r.next=new FixedFIFO$1(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next!=null){const r=this.tail.next;this.tail.next=null,this.tail=r,e=this.tail.shift()}return(e==null?void 0:e.value)!=null&&(this.size-=this.calculateSize(e.value)),e}isEmpty(){return this.head.isEmpty()}}function pushable$1(t={}){return _pushable(r=>{const n=r.shift();if(n==null)return{done:!0};if(n.error!=null)throw n.error;return{done:n.done===!0,value:n.value}},t)}function _pushable(t,e){e=e!=null?e:{};let r=e.onEnd,n=new FIFO$1,o,i,s;const u=async()=>n.isEmpty()?s?{done:!0}:await new Promise((v,k)=>{i=P=>{i=null,n.push(P);try{v(t(n))}catch(L){k(L)}return o}}):t(n),f=v=>i!=null?i(v):(n.push(v),o),h=v=>(n=new FIFO$1,i!=null?i({error:v}):(n.push({error:v}),o)),g=v=>{if(s)return o;if((e==null?void 0:e.objectMode)!==!0&&(v==null?void 0:v.byteLength)==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return f({done:!1,value:v})},$=v=>s?o:(s=!0,v!=null?h(v):f({done:!0})),E=()=>(n=new FIFO$1,$(),{done:!0}),A=v=>($(v),{done:!0});if(o={[Symbol.asyncIterator](){return this},next:u,return:E,throw:A,push:g,end:$,get readableLength(){return n.size}},r==null)return o;const w=o;return o={[Symbol.asyncIterator](){return this},next(){return w.next()},throw(v){return w.throw(v),r!=null&&(r(v),r=void 0),{done:!0}},return(){return w.return(),r!=null&&(r(),r=void 0),{done:!0}},push:g,end(v){return w.end(v),r!=null&&(r(v),r=void 0),o},get readableLength(){return w.readableLength}},o}const drain=async t=>{for await(const e of t);};var itDrain=drain;function createIdStore(t){return{open(){return t.open()},close(){return t.close()},query(e,r){return t.query(e,r)},queryKeys(e,r){return t.queryKeys(e,r)},async get(e,r){const n=extractContents(e);return n.isIdentity?Promise.resolve(n.digest):t.get(e,r)},async*getMany(e,r){for await(const n of e)yield this.get(n,r)},async put(e,r,n){const{isIdentity:o}=extractContents(e);o||await t.put(e,r,n)},async*putMany(e,r){const n=pushable$1({objectMode:!0});(globalThis.process&&globalThis.process.nextTick?globalThis.process.nextTick:globalThis.setImmediate||globalThis.setTimeout)(async()=>{try{await itDrain(t.putMany(async function*(){for await(const{key:i,value:s}of e)extractContents(i).isIdentity||(yield{key:i,value:s}),n.push({key:i,value:s})}())),n.end()}catch(i){n.end(i)}}),yield*n},has(e,r){const{isIdentity:n}=extractContents(e);return n?Promise.resolve(!0):t.has(e,r)},delete(e,r){const{isIdentity:n}=extractContents(e);return n?Promise.resolve():t.delete(e,r)},deleteMany(e,r){return t.deleteMany(itFilter(e,n=>!extractContents(n).isIdentity),r)},batch(){const e=t.batch();return{put(r,n){const{isIdentity:o}=extractContents(r);o||e.put(r,n)},delete(r){const{isIdentity:n}=extractContents(r);n||e.delete(r)},commit:r=>e.commit(r)}}}}function extractContents(t){const e=CID$2.asCID(t);if(e==null)throw errCode(new Error("Not a valid cid"),"ERR_INVALID_CID");return e.multihash.code!==identity$3.code?{isIdentity:!1}:{isIdentity:!0,digest:e.multihash.digest}}const log$3=debug("ipfs:repo:lock:memory"),lockFile="repo.lock",LOCKS={};async function lock(t){const e=t+"/"+lockFile;if(log$3("locking %s",e),LOCKS[e]===!0)throw new LockExistsError(`Lock already being held for file: ${e}`);return LOCKS[e]=!0,{async close(){LOCKS[e]&&delete LOCKS[e]}}}async function locked(t){const e=t+"/"+lockFile;return log$3(`checking lock: ${e}`),Boolean(LOCKS[e])}const MemoryLock={lock,locked},defaultOptions$2={autoMigrate:!0,onMigrationProgress:()=>{},repoOwner:!0,repoLock:MemoryLock},defaultDatastore={Spec:{type:"mount",mounts:[{mountpoint:"/blocks",type:"measure",prefix:"flatfs.datastore",child:{type:"flatfs",path:"blocks",sync:!0,shardFunc:"/repo/flatfs/shard/v1/next-to-last/2"}},{mountpoint:"/",type:"measure",prefix:"leveldb.datastore",child:{type:"levelds",path:"datastore",compression:"none"}}]}},first=async t=>{for await(const e of t)return e};var itFirst=first;function cidToKey$1(t){const e=CID$2.asCID(t);if(e==null)throw errCode(new Error("Not a valid cid"),"ERR_INVALID_CID");const r=base32$6.encode(e.multihash.bytes);return new Key("/"+r.slice(1).toUpperCase(),!1)}function keyToMultihash(t){return decode$p(base32$6.decode(`b${t.toString().toLowerCase().substring(1)}`))}const log$2=debug("ipfs:repo:utils:walk-dag");async function*walkDag(t,e,r,n){try{const o=await e.get(t,n),i=await r(t.code),s=createUnsafe({bytes:o,cid:t,codec:i});for(const[,u]of s.links())yield u,yield*walkDag(u,e,r,n)}catch(o){throw log$2("Could not walk DAG for CID",t.toString(),o),o}}const PinTypes={direct:"direct",recursive:"recursive",indirect:"indirect",all:"all"};class QuickLRU extends Map{constructor(e={}){if(super(),!(e.maxSize&&e.maxSize>0))throw new TypeError("`maxSize` must be a number greater than 0");if(typeof e.maxAge=="number"&&e.maxAge===0)throw new TypeError("`maxAge` must be a number greater than 0");this.maxSize=e.maxSize,this.maxAge=e.maxAge||Number.POSITIVE_INFINITY,this.onEviction=e.onEviction,this.cache=new Map,this.oldCache=new Map,this._size=0}_emitEvictions(e){if(typeof this.onEviction=="function")for(const[r,n]of e)this.onEviction(r,n.value)}_deleteIfExpired(e,r){return typeof r.expiry=="number"&&r.expiry<=Date.now()?(typeof this.onEviction=="function"&&this.onEviction(e,r.value),this.delete(e)):!1}_getOrDeleteIfExpired(e,r){if(this._deleteIfExpired(e,r)===!1)return r.value}_getItemValue(e,r){return r.expiry?this._getOrDeleteIfExpired(e,r):r.value}_peek(e,r){const n=r.get(e);return this._getItemValue(e,n)}_set(e,r){this.cache.set(e,r),this._size++,this._size>=this.maxSize&&(this._size=0,this._emitEvictions(this.oldCache),this.oldCache=this.cache,this.cache=new Map)}_moveToRecent(e,r){this.oldCache.delete(e),this._set(e,r)}*_entriesAscending(){for(const e of this.oldCache){const[r,n]=e;this.cache.has(r)||this._deleteIfExpired(r,n)===!1&&(yield e)}for(const e of this.cache){const[r,n]=e;this._deleteIfExpired(r,n)===!1&&(yield e)}}get(e){if(this.cache.has(e)){const r=this.cache.get(e);return this._getItemValue(e,r)}if(this.oldCache.has(e)){const r=this.oldCache.get(e);if(this._deleteIfExpired(e,r)===!1)return this._moveToRecent(e,r),r.value}}set(e,r,{maxAge:n=this.maxAge}={}){const o=typeof n=="number"&&n!==Number.POSITIVE_INFINITY?Date.now()+n:void 0;this.cache.has(e)?this.cache.set(e,{value:r,expiry:o}):this._set(e,{value:r,expiry:o})}has(e){return this.cache.has(e)?!this._deleteIfExpired(e,this.cache.get(e)):this.oldCache.has(e)?!this._deleteIfExpired(e,this.oldCache.get(e)):!1}peek(e){if(this.cache.has(e))return this._peek(e,this.cache);if(this.oldCache.has(e))return this._peek(e,this.oldCache)}delete(e){const r=this.cache.delete(e);return r&&this._size--,this.oldCache.delete(e)||r}clear(){this.cache.clear(),this.oldCache.clear(),this._size=0}resize(e){if(!(e&&e>0))throw new TypeError("`maxSize` must be a number greater than 0");const r=[...this._entriesAscending()],n=r.length-e;n<0?(this.cache=new Map(r),this.oldCache=new Map,this._size=r.length):(n>0&&this._emitEvictions(r.slice(0,n)),this.oldCache=new Map(r.slice(n)),this.cache=new Map,this._size=0),this.maxSize=e}*keys(){for(const[e]of this)yield e}*values(){for(const[,e]of this)yield e}*[Symbol.iterator](){for(const e of this.cache){const[r,n]=e;this._deleteIfExpired(r,n)===!1&&(yield[r,n.value])}for(const e of this.oldCache){const[r,n]=e;this.cache.has(r)||this._deleteIfExpired(r,n)===!1&&(yield[r,n.value])}}*entriesDescending(){let e=[...this.cache];for(let r=e.length-1;r>=0;--r){const n=e[r],[o,i]=n;this._deleteIfExpired(o,i)===!1&&(yield[o,i.value])}e=[...this.oldCache];for(let r=e.length-1;r>=0;--r){const n=e[r],[o,i]=n;this.cache.has(o)||this._deleteIfExpired(o,i)===!1&&(yield[o,i.value])}}*entriesAscending(){for(const[e,r]of this._entriesAscending())yield[e,r.value]}get size(){if(!this._size)return this.oldCache.size;let e=0;for(const r of this.oldCache.keys())this.cache.has(r)||e++;return Math.min(this._size+e,this.maxSize)}entries(){return this.entriesAscending()}forEach(e,r=this){for(const[n,o]of this.entriesAscending())e.call(r,o,n,this)}get[Symbol.toStringTag](){return JSON.stringify([...this.entriesAscending()])}}const CID_CACHE_MAX_SIZE=2048;function invalidPinTypeErr(t){const e=`Invalid type '${t}', must be one of {direct, indirect, recursive, all}`;return errCode(new Error(e),"ERR_INVALID_PIN_TYPE")}class PinManager{constructor({pinstore:e,blockstore:r,loadCodec:n}){this.pinstore=e,this.blockstore=r,this.loadCodec=n,this.log=debug("ipfs:repo:pin"),this.directPins=new Set,this.recursivePins=new Set}async pinDirectly(e,r={}){await this.blockstore.get(e,r);const n={depth:0};return e.version!==0&&(n.version=e.version),e.code!==code$6&&(n.codec=e.code),r.metadata&&(n.metadata=r.metadata),this.pinstore.put(cidToKey$1(e),encode$q(n))}unpin(e,r){return this.pinstore.delete(cidToKey$1(e),r)}async pinRecursively(e,r={}){await this.fetchCompleteDag(e,r);const n={depth:1/0};e.version!==0&&(n.version=e.version),e.code!==code$6&&(n.codec=e.code),r.metadata&&(n.metadata=r.metadata),await this.pinstore.put(cidToKey$1(e),encode$q(n))}async*directKeys(e){for await(const r of this.pinstore.query({filters:[n=>decode$s(n.value).depth===0]})){const n=decode$s(r.value),o=n.version||0,i=n.codec!=null?n.codec:code$6,s=keyToMultihash(r.key);yield{cid:CID$2.create(o,i,s),metadata:n.metadata}}}async*recursiveKeys(e){for await(const r of this.pinstore.query({filters:[n=>decode$s(n.value).depth===1/0]})){const n=decode$s(r.value),o=n.version||0,i=n.codec!=null?n.codec:code$6,s=keyToMultihash(r.key);yield{cid:CID$2.create(o,i,s),metadata:n.metadata}}}async*indirectKeys(e){for await(const{cid:r}of this.recursiveKeys())for await(const n of walkDag(r,this.blockstore,this.loadCodec,e)){const o=[PinTypes.recursive];(await this.isPinnedWithType(n,o)).pinned||(yield n)}}async isPinnedWithType(e,r,n){Array.isArray(r)||(r=[r]);const o=r.includes(PinTypes.all),i=r.includes(PinTypes.direct),s=r.includes(PinTypes.recursive),u=r.includes(PinTypes.indirect);if(s||i||o){const g=await itFirst(this.pinstore.query({prefix:cidToKey$1(e).toString(),filters:[$=>{if(o)return!0;const E=decode$s($.value);return r.includes(E.depth===0?PinTypes.direct:PinTypes.recursive)}],limit:1}));if(g){const $=decode$s(g.value);return{cid:e,pinned:!0,reason:$.depth===0?PinTypes.direct:PinTypes.recursive,metadata:$.metadata}}}const f=this;async function*h(g,$){for await(const{cid:E}of $)for await(const A of walkDag(E,f.blockstore,f.loadCodec))if(A.equals(g)){yield E;return}}if(o||u){const g=await itFirst(h(e,this.recursiveKeys()));if(g)return{cid:e,pinned:!0,reason:PinTypes.indirect,parent:g}}return{cid:e,pinned:!1}}async fetchCompleteDag(e,r={}){var i;const n=new QuickLRU({maxSize:(i=r.cidCacheMaxSize)!=null?i:CID_CACHE_MAX_SIZE}),o=async(s,u)=>{if(n.has(s.toString()))return;n.set(s.toString(),!0);const f=await this.blockstore.get(s,u),h=await this.loadCodec(s.code),g=createUnsafe({bytes:f,cid:s,codec:h});await Promise.all([...g.links()].map(([,$])=>o($,u)))};await o(e,r)}static checkPinType(e){if(typeof e!="string"||!Object.keys(PinTypes).includes(e))throw invalidPinTypeErr(e);return!0}}const map=async function*(t,e){for await(const r of t)yield e(r)};var itMap=map;function createPinnedBlockstore(t,e){return{open(){return e.open()},close(){return e.close()},query(r,n){return e.query(r,n)},queryKeys(r,n){return e.queryKeys(r,n)},async get(r,n){return e.get(r,n)},async*getMany(r,n){yield*e.getMany(r,n)},async put(r,n,o){await e.put(r,n,o)},async*putMany(r,n){yield*e.putMany(r,n)},has(r,n){return e.has(r,n)},async delete(r,n){return await ensureNotPinned(r,t),e.delete(r,n)},deleteMany(r,n){return e.deleteMany(itMap(r,async o=>(await ensureNotPinned(o,t),o)),n)},batch(){return e.batch()}}}async function ensureNotPinned(t,e){const{pinned:r,reason:n}=await e.isPinnedWithType(t,PinTypes.all);if(r)throw errCode(new Error(`pinned: ${n}`),"ERR_BLOCK_PINNED")}class TimeoutError extends Error{constructor(e){super(e),this.name="TimeoutError"}}class AbortError extends Error{constructor(e){super(),this.name="AbortError",this.message=e}}const getDOMException=t=>globalThis.DOMException===void 0?new AbortError(t):new DOMException(t),getAbortedReason=t=>{const e=t.reason===void 0?getDOMException("This operation was aborted."):t.reason;return e instanceof Error?e:getDOMException(e)};function pTimeout(t,e){const{milliseconds:r,fallback:n,message:o,customTimers:i={setTimeout,clearTimeout}}=e;let s;const u=new Promise((f,h)=>{if(typeof r!="number"||Math.sign(r)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${r}\``);if(r===Number.POSITIVE_INFINITY){f(t);return}if(e.signal){const{signal:g}=e;g.aborted&&h(getAbortedReason(g)),g.addEventListener("abort",()=>{h(getAbortedReason(g))})}s=i.setTimeout.call(void 0,()=>{if(n){try{f(n())}catch(E){h(E)}return}const g=typeof o=="string"?o:`Promise timed out after ${r} milliseconds`,$=o instanceof Error?o:new TimeoutError(g);typeof t.cancel=="function"&&t.cancel(),h($)},r),(async()=>{try{f(await t)}catch(g){h(g)}finally{i.clearTimeout.call(void 0,s)}})()});return u.clear=()=>{i.clearTimeout.call(void 0,s),s=void 0},u}let nanoid=(t=21)=>crypto.getRandomValues(new Uint8Array(t)).reduce((e,r)=>(r&=63,r<36?e+=r.toString(36):r<62?e+=(r-26).toString(36).toUpperCase():r>62?e+="-":e+="_",e),"");const WORKER_REQUEST_READ_LOCK="lock:worker:request-read",WORKER_RELEASE_READ_LOCK="lock:worker:release-read",MASTER_GRANT_READ_LOCK="lock:master:grant-read",WORKER_REQUEST_WRITE_LOCK="lock:worker:request-write",WORKER_RELEASE_WRITE_LOCK="lock:worker:release-write",MASTER_GRANT_WRITE_LOCK="lock:master:grant-write",events={},observable=t=>{t.addEventListener("message",e=>{observable.dispatchEvent("message",t,e)}),t.port!=null&&t.port.addEventListener("message",e=>{observable.dispatchEvent("message",t,e)})};observable.addEventListener=(t,e)=>{events[t]==null&&(events[t]=[]),events[t].push(e)};observable.removeEventListener=(t,e)=>{events[t]!=null&&(events[t]=events[t].filter(r=>r===e))};observable.dispatchEvent=function(t,e,r){events[t]!=null&&events[t].forEach(n=>n(e,r))};const handleWorkerLockRequest=(t,e,r,n,o)=>(i,s)=>{if(s.data.type!==r)return;const u={type:s.data.type,name:s.data.name,identifier:s.data.identifier};t.dispatchEvent(new MessageEvent(e,{data:{name:u.name,handler:async()=>(i.postMessage({type:o,name:u.name,identifier:u.identifier}),await new Promise(f=>{const h=g=>{if(g==null||g.data==null)return;const $={type:g.data.type,name:g.data.name,identifier:g.data.identifier};$.type===n&&$.identifier===u.identifier&&(i.removeEventListener("message",h),f())};i.addEventListener("message",h)}))}}))},makeWorkerLockRequest=(t,e,r,n)=>async()=>{const o=nanoid();return globalThis.postMessage({type:e,identifier:o,name:t}),await new Promise(i=>{const s=u=>{if(u==null||u.data==null)return;const f={type:u.data.type,identifier:u.data.identifier};f.type===r&&f.identifier===o&&(globalThis.removeEventListener("message",s),i(()=>{globalThis.postMessage({type:n,identifier:o,name:t})}))};globalThis.addEventListener("message",s)})},defaultOptions$1={singleProcess:!1},impl=t=>{if(t=Object.assign({},defaultOptions$1,t),Boolean(globalThis.document)||t.singleProcess){const r=new EventTarget;return observable.addEventListener("message",handleWorkerLockRequest(r,"requestReadLock",WORKER_REQUEST_READ_LOCK,WORKER_RELEASE_READ_LOCK,MASTER_GRANT_READ_LOCK)),observable.addEventListener("message",handleWorkerLockRequest(r,"requestWriteLock",WORKER_REQUEST_WRITE_LOCK,WORKER_RELEASE_WRITE_LOCK,MASTER_GRANT_WRITE_LOCK)),r}return{isWorker:!0,readLock:r=>makeWorkerLockRequest(r,WORKER_REQUEST_READ_LOCK,MASTER_GRANT_READ_LOCK,WORKER_RELEASE_READ_LOCK),writeLock:r=>makeWorkerLockRequest(r,WORKER_REQUEST_WRITE_LOCK,MASTER_GRANT_WRITE_LOCK,WORKER_RELEASE_WRITE_LOCK)}},mutexes={};let implementation;async function createReleaseable(t,e){let r;const n=new Promise(o=>{r=o});return t.add(async()=>await pTimeout((async()=>await new Promise(o=>{r(()=>{o()})}))(),{milliseconds:e.timeout})),await n}const createMutex=(t,e)=>{if(implementation.isWorker===!0)return{readLock:implementation.readLock(t,e),writeLock:implementation.writeLock(t,e)};const r=new PQueue({concurrency:1});let n;return{async readLock(){if(n!=null)return await createReleaseable(n,e);n=new PQueue({concurrency:e.concurrency,autoStart:!1});const o=n,i=createReleaseable(n,e);return r.add(async()=>(o.start(),await o.onIdle().then(()=>{n===o&&(n=null)}))),await i},async writeLock(){return n=null,await createReleaseable(r,e)}}},defaultOptions={name:"lock",concurrency:1/0,timeout:846e5,singleProcess:!1};function createMortice(t){const e=Object.assign({},defaultOptions,t);return implementation==null&&(implementation=impl(e),implementation.isWorker!==!0&&(implementation.addEventListener("requestReadLock",r=>{mutexes[r.data.name]!=null&&mutexes[r.data.name].readLock().then(async n=>await r.data.handler().finally(()=>n()))}),implementation.addEventListener("requestWriteLock",async r=>{mutexes[r.data.name]!=null&&mutexes[r.data.name].writeLock().then(async n=>await r.data.handler().finally(()=>n()))}))),mutexes[e.name]==null&&(mutexes[e.name]=createMutex(e.name,e)),mutexes[e.name]}async function*batch$1(t,e=1){let r=[];e<1&&(e=1);for await(const n of t)for(r.push(n);r.length>=e;)yield r.slice(0,e),r=r.slice(e);for(;r.length;)yield r.slice(0,e),r=r.slice(e)}var itBatch=batch$1;const batch=itBatch;async function*parallelBatch(t,e=1){for await(const r of batch(t,e)){const n=r.map(o=>o().then(i=>({ok:!0,value:i}),i=>({ok:!1,err:i})));for(let o=0;o<n.length;o++){const i=await n[o];if(i.ok)yield i.value;else throw i.err}}}var itParallelBatch=parallelBatch,fixedSize=class{constructor(e){if(!(e>0)||(e-1&e)!==0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}peek(){return this.buffer[this.btm]}isEmpty(){return this.buffer[this.btm]===void 0}};const FixedFIFO=fixedSize;var fastFifo=class{constructor(e){this.hwm=e||16,this.head=new FixedFIFO(this.hwm),this.tail=this.head}push(e){if(!this.head.push(e)){const r=this.head;this.head=r.next=new FixedFIFO(2*this.head.buffer.length),this.head.push(e)}}shift(){const e=this.tail.shift();if(e===void 0&&this.tail.next){const r=this.tail.next;return this.tail.next=null,this.tail=r,this.tail.shift()}return e}peek(){return this.tail.peek()}isEmpty(){return this.head.isEmpty()}};const FIFO=fastFifo;var itPushable=t=>{t=t||{};let e;typeof t=="function"?(e=t,t={}):e=t.onEnd;let r=new FIFO,n,o,i;const s=()=>{if(!r.isEmpty()){if(t.writev){let v;const k=[];for(;!r.isEmpty();){if(v=r.shift(),v.error)throw v.error;k.push(v.value)}return{done:v.done,value:k}}const w=r.shift();if(w.error)throw w.error;return w}return i?{done:!0}:new Promise((w,v)=>{o=k=>(o=null,k.error?v(k.error):t.writev&&!k.done?w({done:k.done,value:[k.value]}):w(k),n)})},u=w=>o?o(w):(r.push(w),n),f=w=>(r=new FIFO,o?o({error:w}):(r.push({error:w}),n)),h=w=>i?n:u({done:!1,value:w}),g=w=>i?n:(i=!0,w?f(w):u({done:!0})),$=()=>(r=new FIFO,g(),{done:!0}),E=w=>(g(w),{done:!0});if(n={[Symbol.asyncIterator](){return this},next:s,return:$,throw:E,push:h,end:g},!e)return n;const A=n;return n={[Symbol.asyncIterator](){return this},next(){return A.next()},throw(w){return A.throw(w),e&&(e(w),e=null),{done:!0}},return(){return A.return(),e&&(e(),e=null),{done:!0}},push:h,end(w){return A.end(w),e&&(e(w),e=null),n}},n};const pushable=itPushable,merge=async function*(...t){const e=pushable();setTimeout(async()=>{try{await Promise.all(t.map(async r=>{for await(const n of r)e.push(n)})),e.end()}catch(r){e.end(r)}},0),yield*e};var itMerge=merge;const rawPipe=(...t)=>{let e;for(;t.length>0;)e=t.shift()(e);return e},isIterable=t=>t!=null&&(typeof t[Symbol.asyncIterator]=="function"||typeof t[Symbol.iterator]=="function"||typeof t.next=="function"),isDuplex=t=>t!=null&&typeof t.sink=="function"&&isIterable(t.source),duplexPipelineFn=t=>e=>{const r=t.sink(e);if(r.then!=null){const n=pushable$1({objectMode:!0});return r.then(()=>{n.end()},i=>{n.end(i)}),itMerge(n,async function*(){yield*t.source,n.end()}())}return t.source};function pipe(t,...e){if(isDuplex(t)){const n=t;t=()=>n.source}else if(isIterable(t)){const n=t;t=()=>n}const r=[t,...e];if(r.length>1&&isDuplex(r[r.length-1])&&(r[r.length-1]=r[r.length-1].sink),r.length>2)for(let n=1;n<r.length-1;n++)isDuplex(r[n])&&(r[n]=duplexPipelineFn(r[n]));return rawPipe(...r)}const log$1=debug("ipfs:repo:gc"),ERR_NOT_FOUND=notFoundError$1().code,BLOCK_RM_CONCURRENCY=256,MFS_ROOT_KEY=new Key("/local/filesroot");function gc$1({gcLock:t,pins:e,blockstore:r,root:n,loadCodec:o}){async function*i(){const s=Date.now();log$1("Creating set of marked blocks");const u=await t.writeLock();try{const f=await createMarkedSet({pins:e,blockstore:r,root:n,loadCodec:o}),h=r.queryKeys({});yield*deleteUnmarkedBlocks({blockstore:r},f,h),log$1(`Complete (${Date.now()-s}ms)`)}finally{u()}}return i}async function createMarkedSet({pins:t,blockstore:e,loadCodec:r,root:n}){const o=async function*(){let u;try{u=await n.get(MFS_ROOT_KEY)}catch(h){if(h.code===ERR_NOT_FOUND){log$1("No blocks in MFS");return}throw h}const f=CID$2.decode(u);yield f,yield*walkDag(f,e,r)}(),i=itMerge(itMap(t.recursiveKeys(),({cid:u})=>u),t.indirectKeys(),itMap(t.directKeys(),({cid:u})=>u),o),s=new Set;for await(const u of itMerge(i,o))s.add(base32$6.encode(u.multihash.bytes));return s}async function*deleteUnmarkedBlocks({blockstore:t},e,r){let n=0,o=0;yield*pipe(itParallelBatch(itMap(r,async s=>async function(){n++;try{const f=base32$6.encode(s.multihash.bytes);if(e.has(f))return null;try{await t.delete(s),o++}catch(h){return{err:new Error(`Could not delete block with CID ${s}: ${h.message}`)}}return{cid:s}}catch(f){const h=`Could delete block with CID ${s}`;return log$1(h,f),{err:new Error(h+`: ${f.message}`)}}}),BLOCK_RM_CONCURRENCY),s=>itFilter(s,Boolean)),log$1(`Marked set has ${e.size} unique blocks. Blockstore has ${n} blocks. Deleted ${o} blocks.`)}const log=debug("ipfs:repo"),noLimit=Number.MAX_SAFE_INTEGER,AUTO_MIGRATE_CONFIG_KEY="repoAutoMigrate";class Repo{constructor(e,r,n,o){if(typeof e!="string")throw new Error("missing repo path");if(typeof r!="function")throw new Error("missing codec loader");this.options=mergeOptions(defaultOptions$2,o),this.closed=!0,this.path=e,this.root=n.root,this.datastore=n.datastore,this.keys=n.keys;const i=n.blocks,s=n.pins;this.pins=new PinManager({pinstore:s,blockstore:i,loadCodec:r});const u=createPinnedBlockstore(this.pins,i);this.blocks=createIdStore(u),this.version=version(this.root),this.config=config(this.root),this.spec=spec(this.root),this.apiAddr=apiAddr(this.root),this.gcLock=createMortice({name:e,singleProcess:this.options.repoOwner!==!1}),this.gc=gc$1({gcLock:this.gcLock,pins:this.pins,blockstore:this.blocks,root:this.root,loadCodec:r})}async init(e){log("initializing at: %s",this.path),await this._openRoot(),await this.config.replace(buildConfig(e)),await this.spec.set(buildDatastoreSpec(e)),await this.version.set(repoVersion)}async isInitialized(){if(!this.closed)return!0;try{return await this._openRoot(),await this._checkInitialized(),await this.root.close(),!0}catch{return!1}}async open(){if(!this.closed)throw errCode(new Error("repo is already open"),ERR_REPO_ALREADY_OPEN);log("opening at: %s",this.path);try{if(await this._openRoot(),await this._checkInitialized(),this._lockfile=await this._openLock(),log("acquired repo.lock"),!await this.version.check(repoVersion))if(await this._isAutoMigrationEnabled())await this._migrate(repoVersion,{root:this.root,datastore:this.datastore,pins:this.pins.pinstore,blocks:this.pins.blockstore,keys:this.keys});else throw new InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");log("creating datastore"),await this.datastore.open(),log("creating blocks"),await this.blocks.open(),log("creating keystore"),await this.keys.open(),log("creating pins"),await this.pins.pinstore.open(),this.closed=!1,log("all opened")}catch(e){if(this._lockfile)try{await this._closeLock(),this._lockfile=null}catch(r){log("error removing lock",r)}throw e}}async _openRoot(){try{await this.root.open()}catch(e){if(e.message!=="Already open")throw e}}async _openLock(){const e=await this.options.repoLock.lock(this.path);if(typeof e.close!="function")throw errCode(new Error("Locks must have a close method"),"ERR_NO_CLOSE_FUNCTION");return e}_closeLock(){return this._lockfile&&this._lockfile.close()}async _checkInitialized(){log("init check");let e;try{[e]=await Promise.all([this.config.exists(),this.spec.exists(),this.version.exists()])}catch(r){throw r.code==="ERR_NOT_FOUND"?errCode(new Error("repo is not initialized yet"),ERR_REPO_NOT_INITIALIZED,{path:this.path}):r}if(!e)throw errCode(new Error("repo is not initialized yet"),ERR_REPO_NOT_INITIALIZED,{path:this.path})}async close(){if(this.closed)throw errCode(new Error("repo is already closed"),ERR_REPO_ALREADY_CLOSED);log("closing at: %s",this.path);try{await this.apiAddr.delete()}catch(e){if(e.code!==ERR_REPO_NOT_INITIALIZED&&!e.message.startsWith("ENOENT"))throw e}await Promise.all([this.root,this.blocks,this.keys,this.datastore,this.pins.pinstore].map(e=>e&&e.close())),log("unlocking"),this.closed=!0,await this._closeLock()}exists(){return this.version.exists()}async stat(){if(this.datastore&&this.keys){const[e,r,n,o,i]=await Promise.all([this._storageMaxStat(),this._blockStat(),this.version.get(),getSize(this.datastore),getSize(this.keys)]),s=r.size+o+i;return{repoPath:this.path,storageMax:e,version:n,numObjects:r.count,repoSize:s}}throw errCode(new Error("repo is not initialized yet"),ERR_REPO_NOT_INITIALIZED,{path:this.path})}async _isAutoMigrationEnabled(){if(this.options.autoMigrate!==void 0)return this.options.autoMigrate;let e;try{e=await this.config.get(AUTO_MIGRATE_CONFIG_KEY)}catch(r){if(r.code===NotFoundError.code)e=!0;else throw r}return e}async _migrate(e,r){return await this.version.get()>e?(log(`reverting to version ${e}`),revert(this.path,r,this.options,e,{ignoreLock:!0,onProgress:this.options.onMigrationProgress})):(log(`migrating to version ${e}`),migrate(this.path,r,this.options,e,{ignoreLock:!0,onProgress:this.options.onMigrationProgress}))}async _storageMaxStat(){try{const e=await this.config.get("Datastore.StorageMax");return BigInt(bytes$1.exports(e))}catch{return BigInt(noLimit)}}async _blockStat(){let e=BigInt(0),r=BigInt(0);if(this.blocks)for await(const{key:n,value:o}of this.blocks.query({}))e+=BigInt(1),r+=BigInt(o.byteLength),r+=BigInt(n.bytes.byteLength);return{count:e,size:r}}}async function getSize(t){let e=BigInt(0);for await(const r of t.query({}))e+=BigInt(r.value.byteLength),e+=BigInt(r.key.uint8Array().byteLength);return e}function createRepo$1(t,e,r,n){return new Repo(t,e,r,n)}function buildConfig(t){return t.Datastore=Object.assign({},defaultDatastore,objectSafeGet(t,"datastore")),t}function buildDatastoreSpec(t){const e={...defaultDatastore.Spec,...objectSafeGet(t,"Datastore.Spec")};return{type:e.type,mounts:e.mounts.map(r=>({mountpoint:r.mountpoint,type:r.child.type,path:r.child.path,shardFunc:r.child.shardFunc}))}}const SHARDING_FN="SHARDING",README_FN="_README",all$1=async t=>{const e=[];for await(const r of t)e.push(r);return e};var itAll=all$1;const sortAll$1=(t,e)=>async function*(){yield*(await itAll(t)).sort(e)}(),take=async function*(t,e){let r=0;if(!(e<1)){for await(const n of t)if(yield n,r++,r===e)return}};var itTake=take;class BaseDatastore{open(){return Promise.reject(new Error(".open is not implemented"))}close(){return Promise.reject(new Error(".close is not implemented"))}put(e,r,n){return Promise.reject(new Error(".put is not implemented"))}get(e,r){return Promise.reject(new Error(".get is not implemented"))}has(e,r){return Promise.reject(new Error(".has is not implemented"))}delete(e,r){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,r={}){for await(const{key:n,value:o}of e)await this.put(n,o,r),yield{key:n,value:o}}async*getMany(e,r={}){for await(const n of e)yield this.get(n,r)}async*deleteMany(e,r={}){for await(const n of e)await this.delete(n,r),yield n}batch(){let e=[],r=[];return{put(n,o){e.push({key:n,value:o})},delete(n){r.push(n)},commit:async n=>{await itDrain(this.putMany(e,n)),e=[],await itDrain(this.deleteMany(r,n)),r=[]}}}async*_all(e,r){throw new Error("._all is not implemented")}async*_allKeys(e,r){throw new Error("._allKeys is not implemented")}query(e,r){let n=this._all(e,r);if(e.prefix!=null&&(n=itFilter(n,o=>o.key.toString().startsWith(e.prefix))),Array.isArray(e.filters)&&(n=e.filters.reduce((o,i)=>itFilter(o,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((o,i)=>sortAll$1(o,i),n)),e.offset!=null){let o=0;n=itFilter(n,()=>o++>=e.offset)}return e.limit!=null&&(n=itTake(n,e.limit)),n}queryKeys(e,r){let n=this._allKeys(e,r);if(e.prefix!=null&&(n=itFilter(n,o=>o.toString().startsWith(e.prefix))),Array.isArray(e.filters)&&(n=e.filters.reduce((o,i)=>itFilter(o,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((o,i)=>sortAll$1(o,i),n)),e.offset!=null){let o=0;n=itFilter(n,()=>o++>=e.offset)}return e.limit!=null&&(n=itTake(n,e.limit)),n}}class MemoryDatastore extends BaseDatastore{constructor(){super(),this.data={}}open(){return Promise.resolve()}close(){return Promise.resolve()}async put(e,r){this.data[e.toString()]=r}async get(e){if(!await this.has(e))throw notFoundError$1();return this.data[e.toString()]}async has(e){return this.data[e.toString()]!==void 0}async delete(e){delete this.data[e.toString()]}async*_all(){yield*Object.entries(this.data).map(([e,r])=>({key:new Key(e),value:r}))}async*_allKeys(){yield*Object.entries(this.data).map(([e])=>new Key(e))}}new Key(SHARDING_FN);new Key(README_FN);function base$1(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var i=t.charAt(o),s=i.charCodeAt(0);if(r[s]!==255)throw new TypeError(i+" is ambiguous");r[s]=o}var u=t.length,f=t.charAt(0),h=Math.log(u)/Math.log(256),g=Math.log(256)/Math.log(u);function $(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var v=0,k=0,P=0,L=w.length;P!==L&&w[P]===0;)P++,v++;for(var N=(L-P)*g+1>>>0,q=new Uint8Array(N);P!==L;){for(var X=w[P],Z=0,j=N-1;(X!==0||Z<k)&&j!==-1;j--,Z++)X+=256*q[j]>>>0,q[j]=X%u>>>0,X=X/u>>>0;if(X!==0)throw new Error("Non-zero carry");k=Z,P++}for(var B=N-k;B!==N&&q[B]===0;)B++;for(var K=f.repeat(v);B<N;++B)K+=t.charAt(q[B]);return K}function E(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var v=0;if(w[v]!==" "){for(var k=0,P=0;w[v]===f;)k++,v++;for(var L=(w.length-v)*h+1>>>0,N=new Uint8Array(L);w[v];){var q=r[w.charCodeAt(v)];if(q===255)return;for(var X=0,Z=L-1;(q!==0||X<P)&&Z!==-1;Z--,X++)q+=u*N[Z]>>>0,N[Z]=q%256>>>0,q=q/256>>>0;if(q!==0)throw new Error("Non-zero carry");P=X,v++}if(w[v]!==" "){for(var j=L-P;j!==L&&N[j]===0;)j++;for(var B=new Uint8Array(k+(L-j)),K=k;j!==L;)B[K++]=N[j++];return B}}}function A(w){var v=E(w);if(v)return v;throw new Error(`Non-${e} character`)}return{encode:$,decodeUnsafe:E,decode:A}}var src$1=base$1,_brrp__multiformats_scope_baseX$1=src$1;const coerce$1=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")};class Encoder$1{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Decoder$1{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or$1(this,e)}}class ComposedDecoder$1{constructor(e){this.decoders=e}or(e){return or$1(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or$1=(t,e)=>new ComposedDecoder$1({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});class Codec$1{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder$1(e,r,n),this.decoder=new Decoder$1(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const from$1=({name:t,prefix:e,encode:r,decode:n})=>new Codec$1(t,e,r,n),baseX$1=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX$1(r,e);return from$1({prefix:t,name:e,encode:n,decode:i=>coerce$1(o(i))})},decode$9=(t,e,r,n)=>{const o={};for(let g=0;g<e.length;++g)o[e[g]]=g;let i=t.length;for(;t[i-1]==="=";)--i;const s=new Uint8Array(i*r/8|0);let u=0,f=0,h=0;for(let g=0;g<i;++g){const $=o[t[g]];if($===void 0)throw new SyntaxError(`Non-${n} character`);f=f<<r|$,u+=r,u>=8&&(u-=8,s[h++]=255&f>>u)}if(u>=r||255&f<<8-u)throw new SyntaxError("Unexpected end of data");return s},encode$7=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let i="",s=0,u=0;for(let f=0;f<t.length;++f)for(u=u<<8|t[f],s+=8;s>r;)s-=r,i+=e[o&u>>s];if(s&&(i+=e[o&u<<r-s]),n)for(;i.length*r&7;)i+="=";return i},rfc4648$1=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$1({prefix:e,name:t,encode(o){return encode$7(o,n,r)},decode(o){return decode$9(o,n,r,t)}}),base58btc$1=baseX$1({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});baseX$1({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});const base32$1=rfc4648$1({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});rfc4648$1({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});rfc4648$1({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});rfc4648$1({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});rfc4648$1({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});rfc4648$1({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});rfc4648$1({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});rfc4648$1({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});rfc4648$1({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const base64=rfc4648$1({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6});rfc4648$1({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6});rfc4648$1({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6});rfc4648$1({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});debug.formatters.b=t=>t==null?"undefined":base58btc$1.baseEncode(t);debug.formatters.t=t=>t==null?"undefined":base32$1.baseEncode(t);debug.formatters.m=t=>t==null?"undefined":base64.baseEncode(t);debug.formatters.p=t=>t==null?"undefined":t.toString();debug.formatters.c=t=>t==null?"undefined":t.toString();debug.formatters.k=t=>t==null?"undefined":t.toString();function logger(t){return Object.assign(debug(t),{error:debug(`${t}:error`),trace:debug(`${t}:trace`)})}logger("datastore:core:tiered");const all=itAll,sort=async function*(t,e){yield*(await all(t)).sort(e)};var itSort=sort;class LevelDatastore extends BaseDatastore{constructor(e,r={}){super(),this.db=typeof e=="string"?new Level(e,{...r,keyEncoding:"utf8",valueEncoding:"view"}):e,this.opts={createIfMissing:!0,compression:!1,...r}}async open(){try{await this.db.open(this.opts)}catch(e){throw dbOpenFailedError(e)}}async put(e,r){try{await this.db.put(e.toString(),r)}catch(n){throw dbWriteFailedError(n)}}async get(e){let r;try{r=await this.db.get(e.toString())}catch(n){throw n.notFound?notFoundError$1(n):dbWriteFailedError(n)}return r}async has(e){try{await this.db.get(e.toString())}catch(r){if(r.notFound)return!1;throw r}return!0}async delete(e){try{await this.db.del(e.toString())}catch(r){throw dbDeleteFailedError(r)}}close(){return this.db&&this.db.close()}batch(){const e=[];return{put:(r,n)=>{e.push({type:"put",key:r.toString(),value:n})},delete:r=>{e.push({type:"del",key:r.toString()})},commit:()=>this.db.batch(e)}}query(e){let r=this._query({values:!0,prefix:e.prefix});Array.isArray(e.filters)&&(r=e.filters.reduce((i,s)=>itFilter(i,s),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((i,s)=>itSort(i,s),r));const{offset:n,limit:o}=e;if(n){let i=0;r=itFilter(r,()=>i++>=n)}return o&&(r=itTake(r,o)),r}queryKeys(e){let r=itMap(this._query({values:!1,prefix:e.prefix}),({key:i})=>i);Array.isArray(e.filters)&&(r=e.filters.reduce((i,s)=>itFilter(i,s),r)),Array.isArray(e.orders)&&(r=e.orders.reduce((i,s)=>itSort(i,s),r));const{offset:n,limit:o}=e;if(n){let i=0;r=itFilter(r,()=>i++>=n)}return o&&(r=itTake(r,o)),r}_query(e){const r={keys:!0,keyEncoding:"buffer",values:e.values};if(e.prefix!=null){const o=e.prefix.toString();r.gte=o,r.lt=o+"\xFF"}const n=this.db.iterator(r);if(n[Symbol.asyncIterator])return levelIteratorToIterator(n);if(n.next!=null&&n.end!=null)return oldLevelIteratorToIterator(n);throw new Error("Level returned incompatible iterator")}}async function*levelIteratorToIterator(t){for await(const[e,r]of t)yield{key:new Key(e,!1),value:r};await t.close()}function oldLevelIteratorToIterator(t){return{[Symbol.asyncIterator](){return{next:()=>new Promise((e,r)=>{t.next((n,o,i)=>{if(n)return r(n);if(o==null)return t.end(s=>{if(s)return r(s);e({done:!0,value:void 0})});e({done:!1,value:{key:new Key(o,!1),value:i}})})}),return:()=>new Promise((e,r)=>{t.end(n=>{if(n)return r(n);e({done:!0,value:void 0})})})}}}}const sortAll=(t,e)=>async function*(){yield*(await itAll(t)).sort(e)}();class BaseBlockstore{open(){return Promise.reject(new Error(".open is not implemented"))}close(){return Promise.reject(new Error(".close is not implemented"))}put(e,r,n){return Promise.reject(new Error(".put is not implemented"))}get(e,r){return Promise.reject(new Error(".get is not implemented"))}has(e,r){return Promise.reject(new Error(".has is not implemented"))}delete(e,r){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,r={}){for await(const{key:n,value:o}of e)await this.put(n,o,r),yield{key:n,value:o}}async*getMany(e,r={}){for await(const n of e)yield this.get(n,r)}async*deleteMany(e,r={}){for await(const n of e)await this.delete(n,r),yield n}batch(){let e=[],r=[];return{put(n,o){e.push({key:n,value:o})},delete(n){r.push(n)},commit:async n=>{await itDrain(this.putMany(e,n)),e=[],await itDrain(this.deleteMany(r,n)),r=[]}}}async*_all(e,r){throw new Error("._all is not implemented")}async*_allKeys(e,r){throw new Error("._allKeys is not implemented")}query(e,r){let n=this._all(e,r);if(e.prefix!=null&&(n=itFilter(n,o=>o.key.toString().startsWith(e.prefix||""))),Array.isArray(e.filters)&&(n=e.filters.reduce((o,i)=>itFilter(o,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((o,i)=>sortAll(o,i),n)),e.offset!=null){let o=0;n=itFilter(n,()=>o++>=(e.offset||0))}return e.limit!=null&&(n=itTake(n,e.limit)),n}queryKeys(e,r){let n=this._allKeys(e,r);if(e.prefix!=null&&(n=itFilter(n,o=>o.toString().startsWith(e.prefix||""))),Array.isArray(e.filters)&&(n=e.filters.reduce((o,i)=>itFilter(o,i),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((o,i)=>sortAll(o,i),n)),e.offset!=null){let o=0;n=itFilter(n,()=>o++>=e.offset)}return e.limit!=null&&(n=itTake(n,e.limit)),n}}function cidToKey(t){const e=CID$2.asCID(t);if(!e)throw errCode(new Error("Not a valid cid"),"ERR_INVALID_CID");return new Key("/"+base32$6.encode(e.multihash.bytes).slice(1).toUpperCase(),!1)}function keyToCid(t){return CID$2.createV1(code$8,decode$p(base32$6.decode("b"+t.toString().slice(1).toLowerCase())))}function convertPrefix(t){const e=t.substring(0,1);if(e==="/")return convertPrefix(t.substring(1));let r;e.toLowerCase()==="b"?r=i=>base32$6.decode(i.toLowerCase()).subarray(2):e.toLowerCase()==="c"?r=i=>base32pad$2.decode(i.toLowerCase()).subarray(2):e==="z"?r=i=>base58btc$4.decode(i).subarray(2):e==="Q"?r=i=>base58btc$4.decode("z"+i):r=i=>base32$6.decode("b"+i.toLowerCase()).subarray(2);let n;for(let i=1;i<t.length;i++)try{n=r(t.substring(0,i))}catch(s){if(s.message!=="Unexpected end of data")throw s}let o="/C";return n&&(o=`/${base32$6.encode(n).slice(1,-1).toUpperCase()||"C"}`),o}function convertQuery(t){return{...t,prefix:t.prefix?convertPrefix(t.prefix):void 0,filters:t.filters?t.filters.map(e=>r=>e({key:keyToCid(r.key),value:r.value})):void 0,orders:t.orders?t.orders.map(e=>(r,n)=>e({key:keyToCid(r.key),value:r.value},{key:keyToCid(n.key),value:n.value})):void 0}}function convertKeyQuery(t){return{...t,prefix:t.prefix?convertPrefix(t.prefix):void 0,filters:t.filters?t.filters.map(e=>r=>e(keyToCid(r))):void 0,orders:t.orders?t.orders.map(e=>(r,n)=>e(keyToCid(r),keyToCid(n))):void 0}}class BlockstoreDatastoreAdapter extends BaseBlockstore{constructor(e){super(),this.child=e}open(){return this.child.open()}close(){return this.child.close()}async*query(e,r){for await(const{key:n,value:o}of this.child.query(convertQuery(e),r))yield{key:keyToCid(n),value:o}}async*queryKeys(e,r){for await(const n of this.child.queryKeys(convertKeyQuery(e),r))yield keyToCid(n)}async get(e,r){return this.child.get(cidToKey(e),r)}async*getMany(e,r){for await(const n of e)yield this.get(n,r)}async put(e,r,n){await this.child.put(cidToKey(e),r,n)}async*putMany(e,r){const n=pushable$1({objectMode:!0});(globalThis.process&&globalThis.process.nextTick?globalThis.process.nextTick:globalThis.setImmediate||globalThis.setTimeout)(async()=>{try{const i=this.child;await itDrain(this.child.putMany(async function*(){for await(const s of e){const u=cidToKey(s.key);await i.has(u,r)||(yield{key:u,value:s.value}),n.push(s)}}())),n.end()}catch(i){n.end(i)}}),yield*n}has(e,r){return this.child.has(cidToKey(e),r)}delete(e,r){return this.child.delete(cidToKey(e),r)}deleteMany(e,r){const n=pushable$1({objectMode:!0});return itDrain(this.child.deleteMany(async function*(){for await(const o of e)yield cidToKey(o),n.push(o);n.end()}(),r)).catch(o=>{n.end(o)}),n}}function createRepo(t,e,r){const n=r.path||"ipfs";return createRepo$1(n,o=>e.getCodec(o),{root:new LevelDatastore(n,{prefix:"",version:2}),blocks:new BlockstoreDatastoreAdapter(new LevelDatastore(`${n}/blocks`,{prefix:"",version:2})),datastore:new LevelDatastore(`${n}/datastore`,{prefix:"",version:2}),keys:new LevelDatastore(`${n}/keys`,{prefix:"",version:2}),pins:new LevelDatastore(`${n}/pins`,{prefix:"",version:2})},{autoMigrate:r.autoMigrate,onMigrationProgress:r.onMigrationProgress||t,repoLock:MemoryLock})}var Tc=Object.create,nr=Object.defineProperty,Ic=Object.getOwnPropertyDescriptor,Sc=Object.getOwnPropertyNames,Uc=Object.getPrototypeOf,Fc=Object.prototype.hasOwnProperty,F=(t,e)=>()=>(t&&(e=t(t=0)),e),S=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),M=(t,e)=>{for(var r in e)nr(t,r,{get:e[r],enumerable:!0})},No=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of Sc(e))!Fc.call(t,o)&&o!==r&&nr(t,o,{get:()=>e[o],enumerable:!(n=Ic(e,o))||n.enumerable});return t},J=(t,e,r)=>(r=t!=null?Tc(Uc(t)):{},No(e||!t||!t.__esModule?nr(r,"default",{value:t,enumerable:!0}):r,t)),R=t=>No(nr({},"__esModule",{value:!0}),t),Po=S(t=>{a(),t.byteLength=f,t.toByteArray=g,t.fromByteArray=A;var e=[],r=[],n=typeof Uint8Array<"u"?Uint8Array:Array,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(i=0,s=o.length;i<s;++i)e[i]=o[i],r[o.charCodeAt(i)]=i;var i,s;r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63;function u(w){var v=w.length;if(v%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var k=w.indexOf("=");k===-1&&(k=v);var P=k===v?0:4-k%4;return[k,P]}function f(w){var v=u(w),k=v[0],P=v[1];return(k+P)*3/4-P}function h(w,v,k){return(v+k)*3/4-k}function g(w){var v,k=u(w),P=k[0],L=k[1],N=new n(h(w,P,L)),q=0,X=L>0?P-4:P,Z;for(Z=0;Z<X;Z+=4)v=r[w.charCodeAt(Z)]<<18|r[w.charCodeAt(Z+1)]<<12|r[w.charCodeAt(Z+2)]<<6|r[w.charCodeAt(Z+3)],N[q++]=v>>16&255,N[q++]=v>>8&255,N[q++]=v&255;return L===2&&(v=r[w.charCodeAt(Z)]<<2|r[w.charCodeAt(Z+1)]>>4,N[q++]=v&255),L===1&&(v=r[w.charCodeAt(Z)]<<10|r[w.charCodeAt(Z+1)]<<4|r[w.charCodeAt(Z+2)]>>2,N[q++]=v>>8&255,N[q++]=v&255),N}function $(w){return e[w>>18&63]+e[w>>12&63]+e[w>>6&63]+e[w&63]}function E(w,v,k){for(var P,L=[],N=v;N<k;N+=3)P=(w[N]<<16&16711680)+(w[N+1]<<8&65280)+(w[N+2]&255),L.push($(P));return L.join("")}function A(w){for(var v,k=w.length,P=k%3,L=[],N=16383,q=0,X=k-P;q<X;q+=N)L.push(E(w,q,q+N>X?X:q+N));return P===1?(v=w[k-1],L.push(e[v>>2]+e[v<<4&63]+"==")):P===2&&(v=(w[k-2]<<8)+w[k-1],L.push(e[v>>10]+e[v>>4&63]+e[v<<2&63]+"=")),L.join("")}}),Ro=S(t=>{a(),t.read=function(e,r,n,o,i){var s,u,f=i*8-o-1,h=(1<<f)-1,g=h>>1,$=-7,E=n?i-1:0,A=n?-1:1,w=e[r+E];for(E+=A,s=w&(1<<-$)-1,w>>=-$,$+=f;$>0;s=s*256+e[r+E],E+=A,$-=8);for(u=s&(1<<-$)-1,s>>=-$,$+=o;$>0;u=u*256+e[r+E],E+=A,$-=8);if(s===0)s=1-g;else{if(s===h)return u?NaN:(w?-1:1)*(1/0);u=u+Math.pow(2,o),s=s-g}return(w?-1:1)*u*Math.pow(2,s-o)},t.write=function(e,r,n,o,i,s){var u,f,h,g=s*8-i-1,$=(1<<g)-1,E=$>>1,A=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,w=o?0:s-1,v=o?1:-1,k=r<0||r===0&&1/r<0?1:0;for(r=Math.abs(r),isNaN(r)||r===1/0?(f=isNaN(r)?1:0,u=$):(u=Math.floor(Math.log(r)/Math.LN2),r*(h=Math.pow(2,-u))<1&&(u--,h*=2),u+E>=1?r+=A/h:r+=A*Math.pow(2,1-E),r*h>=2&&(u++,h/=2),u+E>=$?(f=0,u=$):u+E>=1?(f=(r*h-1)*Math.pow(2,i),u=u+E):(f=r*Math.pow(2,E-1)*Math.pow(2,i),u=0));i>=8;e[n+w]=f&255,w+=v,f/=256,i-=8);for(u=u<<i|f,g+=i;g>0;e[n+w]=u&255,w+=v,u/=256,g-=8);e[n+w-v]|=k*128}}),ti=S(t=>{a();var e=Po(),r=Ro(),n=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;t.Buffer=u,t.SlowBuffer=L,t.INSPECT_MAX_BYTES=50;var o=2147483647;t.kMaxLength=o,u.TYPED_ARRAY_SUPPORT=i(),!u.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function i(){try{let c=new Uint8Array(1),y={foo:function(){return 42}};return Object.setPrototypeOf(y,Uint8Array.prototype),Object.setPrototypeOf(c,y),c.foo()===42}catch{return!1}}Object.defineProperty(u.prototype,"parent",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.buffer}}),Object.defineProperty(u.prototype,"offset",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.byteOffset}});function s(c){if(c>o)throw new RangeError('The value "'+c+'" is invalid for option "size"');let y=new Uint8Array(c);return Object.setPrototypeOf(y,u.prototype),y}function u(c,y,m){if(typeof c=="number"){if(typeof y=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return $(c)}return f(c,y,m)}u.poolSize=8192;function f(c,y,m){if(typeof c=="string")return E(c,y);if(ArrayBuffer.isView(c))return w(c);if(c==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof c);if(We(c,ArrayBuffer)||c&&We(c.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(We(c,SharedArrayBuffer)||c&&We(c.buffer,SharedArrayBuffer)))return v(c,y,m);if(typeof c=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');let O=c.valueOf&&c.valueOf();if(O!=null&&O!==c)return u.from(O,y,m);let I=k(c);if(I)return I;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof c[Symbol.toPrimitive]=="function")return u.from(c[Symbol.toPrimitive]("string"),y,m);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof c)}u.from=function(c,y,m){return f(c,y,m)},Object.setPrototypeOf(u.prototype,Uint8Array.prototype),Object.setPrototypeOf(u,Uint8Array);function h(c){if(typeof c!="number")throw new TypeError('"size" argument must be of type number');if(c<0)throw new RangeError('The value "'+c+'" is invalid for option "size"')}function g(c,y,m){return h(c),c<=0?s(c):y!==void 0?typeof m=="string"?s(c).fill(y,m):s(c).fill(y):s(c)}u.alloc=function(c,y,m){return g(c,y,m)};function $(c){return h(c),s(c<0?0:P(c)|0)}u.allocUnsafe=function(c){return $(c)},u.allocUnsafeSlow=function(c){return $(c)};function E(c,y){if((typeof y!="string"||y==="")&&(y="utf8"),!u.isEncoding(y))throw new TypeError("Unknown encoding: "+y);let m=N(c,y)|0,O=s(m),I=O.write(c,y);return I!==m&&(O=O.slice(0,I)),O}function A(c){let y=c.length<0?0:P(c.length)|0,m=s(y);for(let O=0;O<y;O+=1)m[O]=c[O]&255;return m}function w(c){if(We(c,Uint8Array)){let y=new Uint8Array(c);return v(y.buffer,y.byteOffset,y.byteLength)}return A(c)}function v(c,y,m){if(y<0||c.byteLength<y)throw new RangeError('"offset" is outside of buffer bounds');if(c.byteLength<y+(m||0))throw new RangeError('"length" is outside of buffer bounds');let O;return y===void 0&&m===void 0?O=new Uint8Array(c):m===void 0?O=new Uint8Array(c,y):O=new Uint8Array(c,y,m),Object.setPrototypeOf(O,u.prototype),O}function k(c){if(u.isBuffer(c)){let y=P(c.length)|0,m=s(y);return m.length===0||c.copy(m,0,0,y),m}if(c.length!==void 0)return typeof c.length!="number"||at(c.length)?s(0):A(c);if(c.type==="Buffer"&&Array.isArray(c.data))return A(c.data)}function P(c){if(c>=o)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o.toString(16)+" bytes");return c|0}function L(c){return+c!=c&&(c=0),u.alloc(+c)}u.isBuffer=function(c){return c!=null&&c._isBuffer===!0&&c!==u.prototype},u.compare=function(c,y){if(We(c,Uint8Array)&&(c=u.from(c,c.offset,c.byteLength)),We(y,Uint8Array)&&(y=u.from(y,y.offset,y.byteLength)),!u.isBuffer(c)||!u.isBuffer(y))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(c===y)return 0;let m=c.length,O=y.length;for(let I=0,W=Math.min(m,O);I<W;++I)if(c[I]!==y[I]){m=c[I],O=y[I];break}return m<O?-1:O<m?1:0},u.isEncoding=function(c){switch(String(c).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(c,y){if(!Array.isArray(c))throw new TypeError('"list" argument must be an Array of Buffers');if(c.length===0)return u.alloc(0);let m;if(y===void 0)for(y=0,m=0;m<c.length;++m)y+=c[m].length;let O=u.allocUnsafe(y),I=0;for(m=0;m<c.length;++m){let W=c[m];if(We(W,Uint8Array))I+W.length>O.length?(u.isBuffer(W)||(W=u.from(W)),W.copy(O,I)):Uint8Array.prototype.set.call(O,W,I);else if(u.isBuffer(W))W.copy(O,I);else throw new TypeError('"list" argument must be an Array of Buffers');I+=W.length}return O};function N(c,y){if(u.isBuffer(c))return c.length;if(ArrayBuffer.isView(c)||We(c,ArrayBuffer))return c.byteLength;if(typeof c!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof c);let m=c.length,O=arguments.length>2&&arguments[2]===!0;if(!O&&m===0)return 0;let I=!1;for(;;)switch(y){case"ascii":case"latin1":case"binary":return m;case"utf8":case"utf-8":return st(c).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return m*2;case"hex":return m>>>1;case"base64":return St(c).length;default:if(I)return O?-1:st(c).length;y=(""+y).toLowerCase(),I=!0}}u.byteLength=N;function q(c,y,m){let O=!1;if((y===void 0||y<0)&&(y=0),y>this.length||((m===void 0||m>this.length)&&(m=this.length),m<=0)||(m>>>=0,y>>>=0,m<=y))return"";for(c||(c="utf8");;)switch(c){case"hex":return Ve(this,y,m);case"utf8":case"utf-8":return _e(this,y,m);case"ascii":return Ee(this,y,m);case"latin1":case"binary":return ie(this,y,m);case"base64":return ae(this,y,m);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Je(this,y,m);default:if(O)throw new TypeError("Unknown encoding: "+c);c=(c+"").toLowerCase(),O=!0}}u.prototype._isBuffer=!0;function X(c,y,m){let O=c[y];c[y]=c[m],c[m]=O}u.prototype.swap16=function(){let c=this.length;if(c%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let y=0;y<c;y+=2)X(this,y,y+1);return this},u.prototype.swap32=function(){let c=this.length;if(c%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let y=0;y<c;y+=4)X(this,y,y+3),X(this,y+1,y+2);return this},u.prototype.swap64=function(){let c=this.length;if(c%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let y=0;y<c;y+=8)X(this,y,y+7),X(this,y+1,y+6),X(this,y+2,y+5),X(this,y+3,y+4);return this},u.prototype.toString=function(){let c=this.length;return c===0?"":arguments.length===0?_e(this,0,c):q.apply(this,arguments)},u.prototype.toLocaleString=u.prototype.toString,u.prototype.equals=function(c){if(!u.isBuffer(c))throw new TypeError("Argument must be a Buffer");return this===c?!0:u.compare(this,c)===0},u.prototype.inspect=function(){let c="",y=t.INSPECT_MAX_BYTES;return c=this.toString("hex",0,y).replace(/(.{2})/g,"$1 ").trim(),this.length>y&&(c+=" ... "),"<Buffer "+c+">"},n&&(u.prototype[n]=u.prototype.inspect),u.prototype.compare=function(c,y,m,O,I){if(We(c,Uint8Array)&&(c=u.from(c,c.offset,c.byteLength)),!u.isBuffer(c))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof c);if(y===void 0&&(y=0),m===void 0&&(m=c?c.length:0),O===void 0&&(O=0),I===void 0&&(I=this.length),y<0||m>c.length||O<0||I>this.length)throw new RangeError("out of range index");if(O>=I&&y>=m)return 0;if(O>=I)return-1;if(y>=m)return 1;if(y>>>=0,m>>>=0,O>>>=0,I>>>=0,this===c)return 0;let W=I-O,oe=m-y,he=Math.min(W,oe),je=this.slice(O,I),be=c.slice(y,m);for(let ge=0;ge<he;++ge)if(je[ge]!==be[ge]){W=je[ge],oe=be[ge];break}return W<oe?-1:oe<W?1:0};function Z(c,y,m,O,I){if(c.length===0)return-1;if(typeof m=="string"?(O=m,m=0):m>2147483647?m=2147483647:m<-2147483648&&(m=-2147483648),m=+m,at(m)&&(m=I?0:c.length-1),m<0&&(m=c.length+m),m>=c.length){if(I)return-1;m=c.length-1}else if(m<0)if(I)m=0;else return-1;if(typeof y=="string"&&(y=u.from(y,O)),u.isBuffer(y))return y.length===0?-1:j(c,y,m,O,I);if(typeof y=="number")return y=y&255,typeof Uint8Array.prototype.indexOf=="function"?I?Uint8Array.prototype.indexOf.call(c,y,m):Uint8Array.prototype.lastIndexOf.call(c,y,m):j(c,[y],m,O,I);throw new TypeError("val must be string, number or Buffer")}function j(c,y,m,O,I){let W=1,oe=c.length,he=y.length;if(O!==void 0&&(O=String(O).toLowerCase(),O==="ucs2"||O==="ucs-2"||O==="utf16le"||O==="utf-16le")){if(c.length<2||y.length<2)return-1;W=2,oe/=2,he/=2,m/=2}function je(ge,Ae){return W===1?ge[Ae]:ge.readUInt16BE(Ae*W)}let be;if(I){let ge=-1;for(be=m;be<oe;be++)if(je(c,be)===je(y,ge===-1?0:be-ge)){if(ge===-1&&(ge=be),be-ge+1===he)return ge*W}else ge!==-1&&(be-=be-ge),ge=-1}else for(m+he>oe&&(m=oe-he),be=m;be>=0;be--){let ge=!0;for(let Ae=0;Ae<he;Ae++)if(je(c,be+Ae)!==je(y,Ae)){ge=!1;break}if(ge)return be}return-1}u.prototype.includes=function(c,y,m){return this.indexOf(c,y,m)!==-1},u.prototype.indexOf=function(c,y,m){return Z(this,c,y,m,!0)},u.prototype.lastIndexOf=function(c,y,m){return Z(this,c,y,m,!1)};function B(c,y,m,O){m=Number(m)||0;let I=c.length-m;O?(O=Number(O),O>I&&(O=I)):O=I;let W=y.length;O>W/2&&(O=W/2);let oe;for(oe=0;oe<O;++oe){let he=parseInt(y.substr(oe*2,2),16);if(at(he))return oe;c[m+oe]=he}return oe}function K(c,y,m,O){return ot(st(y,c.length-m),c,m,O)}function ue(c,y,m,O){return ot(Bt(y),c,m,O)}function se(c,y,m,O){return ot(St(y),c,m,O)}function de(c,y,m,O){return ot(Ft(y,c.length-m),c,m,O)}u.prototype.write=function(c,y,m,O){if(y===void 0)O="utf8",m=this.length,y=0;else if(m===void 0&&typeof y=="string")O=y,m=this.length,y=0;else if(isFinite(y))y=y>>>0,isFinite(m)?(m=m>>>0,O===void 0&&(O="utf8")):(O=m,m=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");let I=this.length-y;if((m===void 0||m>I)&&(m=I),c.length>0&&(m<0||y<0)||y>this.length)throw new RangeError("Attempt to write outside buffer bounds");O||(O="utf8");let W=!1;for(;;)switch(O){case"hex":return B(this,c,y,m);case"utf8":case"utf-8":return K(this,c,y,m);case"ascii":case"latin1":case"binary":return ue(this,c,y,m);case"base64":return se(this,c,y,m);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return de(this,c,y,m);default:if(W)throw new TypeError("Unknown encoding: "+O);O=(""+O).toLowerCase(),W=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function ae(c,y,m){return y===0&&m===c.length?e.fromByteArray(c):e.fromByteArray(c.slice(y,m))}function _e(c,y,m){m=Math.min(c.length,m);let O=[],I=y;for(;I<m;){let W=c[I],oe=null,he=W>239?4:W>223?3:W>191?2:1;if(I+he<=m){let je,be,ge,Ae;switch(he){case 1:W<128&&(oe=W);break;case 2:je=c[I+1],(je&192)===128&&(Ae=(W&31)<<6|je&63,Ae>127&&(oe=Ae));break;case 3:je=c[I+1],be=c[I+2],(je&192)===128&&(be&192)===128&&(Ae=(W&15)<<12|(je&63)<<6|be&63,Ae>2047&&(Ae<55296||Ae>57343)&&(oe=Ae));break;case 4:je=c[I+1],be=c[I+2],ge=c[I+3],(je&192)===128&&(be&192)===128&&(ge&192)===128&&(Ae=(W&15)<<18|(je&63)<<12|(be&63)<<6|ge&63,Ae>65535&&Ae<1114112&&(oe=Ae))}}oe===null?(oe=65533,he=1):oe>65535&&(oe-=65536,O.push(oe>>>10&1023|55296),oe=56320|oe&1023),O.push(oe),I+=he}return De(O)}var xe=4096;function De(c){let y=c.length;if(y<=xe)return String.fromCharCode.apply(String,c);let m="",O=0;for(;O<y;)m+=String.fromCharCode.apply(String,c.slice(O,O+=xe));return m}function Ee(c,y,m){let O="";m=Math.min(c.length,m);for(let I=y;I<m;++I)O+=String.fromCharCode(c[I]&127);return O}function ie(c,y,m){let O="";m=Math.min(c.length,m);for(let I=y;I<m;++I)O+=String.fromCharCode(c[I]);return O}function Ve(c,y,m){let O=c.length;(!y||y<0)&&(y=0),(!m||m<0||m>O)&&(m=O);let I="";for(let W=y;W<m;++W)I+=It[c[W]];return I}function Je(c,y,m){let O=c.slice(y,m),I="";for(let W=0;W<O.length-1;W+=2)I+=String.fromCharCode(O[W]+O[W+1]*256);return I}u.prototype.slice=function(c,y){let m=this.length;c=~~c,y=y===void 0?m:~~y,c<0?(c+=m,c<0&&(c=0)):c>m&&(c=m),y<0?(y+=m,y<0&&(y=0)):y>m&&(y=m),y<c&&(y=c);let O=this.subarray(c,y);return Object.setPrototypeOf(O,u.prototype),O};function we(c,y,m){if(c%1!==0||c<0)throw new RangeError("offset is not uint");if(c+y>m)throw new RangeError("Trying to access beyond buffer length")}u.prototype.readUintLE=u.prototype.readUIntLE=function(c,y,m){c=c>>>0,y=y>>>0,m||we(c,y,this.length);let O=this[c],I=1,W=0;for(;++W<y&&(I*=256);)O+=this[c+W]*I;return O},u.prototype.readUintBE=u.prototype.readUIntBE=function(c,y,m){c=c>>>0,y=y>>>0,m||we(c,y,this.length);let O=this[c+--y],I=1;for(;y>0&&(I*=256);)O+=this[c+--y]*I;return O},u.prototype.readUint8=u.prototype.readUInt8=function(c,y){return c=c>>>0,y||we(c,1,this.length),this[c]},u.prototype.readUint16LE=u.prototype.readUInt16LE=function(c,y){return c=c>>>0,y||we(c,2,this.length),this[c]|this[c+1]<<8},u.prototype.readUint16BE=u.prototype.readUInt16BE=function(c,y){return c=c>>>0,y||we(c,2,this.length),this[c]<<8|this[c+1]},u.prototype.readUint32LE=u.prototype.readUInt32LE=function(c,y){return c=c>>>0,y||we(c,4,this.length),(this[c]|this[c+1]<<8|this[c+2]<<16)+this[c+3]*16777216},u.prototype.readUint32BE=u.prototype.readUInt32BE=function(c,y){return c=c>>>0,y||we(c,4,this.length),this[c]*16777216+(this[c+1]<<16|this[c+2]<<8|this[c+3])},u.prototype.readBigUInt64LE=Ye(function(c){c=c>>>0,et(c,"offset");let y=this[c],m=this[c+7];(y===void 0||m===void 0)&&rt(c,this.length-8);let O=y+this[++c]*2**8+this[++c]*2**16+this[++c]*2**24,I=this[++c]+this[++c]*2**8+this[++c]*2**16+m*2**24;return BigInt(O)+(BigInt(I)<<BigInt(32))}),u.prototype.readBigUInt64BE=Ye(function(c){c=c>>>0,et(c,"offset");let y=this[c],m=this[c+7];(y===void 0||m===void 0)&&rt(c,this.length-8);let O=y*2**24+this[++c]*2**16+this[++c]*2**8+this[++c],I=this[++c]*2**24+this[++c]*2**16+this[++c]*2**8+m;return(BigInt(O)<<BigInt(32))+BigInt(I)}),u.prototype.readIntLE=function(c,y,m){c=c>>>0,y=y>>>0,m||we(c,y,this.length);let O=this[c],I=1,W=0;for(;++W<y&&(I*=256);)O+=this[c+W]*I;return I*=128,O>=I&&(O-=Math.pow(2,8*y)),O},u.prototype.readIntBE=function(c,y,m){c=c>>>0,y=y>>>0,m||we(c,y,this.length);let O=y,I=1,W=this[c+--O];for(;O>0&&(I*=256);)W+=this[c+--O]*I;return I*=128,W>=I&&(W-=Math.pow(2,8*y)),W},u.prototype.readInt8=function(c,y){return c=c>>>0,y||we(c,1,this.length),this[c]&128?(255-this[c]+1)*-1:this[c]},u.prototype.readInt16LE=function(c,y){c=c>>>0,y||we(c,2,this.length);let m=this[c]|this[c+1]<<8;return m&32768?m|4294901760:m},u.prototype.readInt16BE=function(c,y){c=c>>>0,y||we(c,2,this.length);let m=this[c+1]|this[c]<<8;return m&32768?m|4294901760:m},u.prototype.readInt32LE=function(c,y){return c=c>>>0,y||we(c,4,this.length),this[c]|this[c+1]<<8|this[c+2]<<16|this[c+3]<<24},u.prototype.readInt32BE=function(c,y){return c=c>>>0,y||we(c,4,this.length),this[c]<<24|this[c+1]<<16|this[c+2]<<8|this[c+3]},u.prototype.readBigInt64LE=Ye(function(c){c=c>>>0,et(c,"offset");let y=this[c],m=this[c+7];(y===void 0||m===void 0)&&rt(c,this.length-8);let O=this[c+4]+this[c+5]*2**8+this[c+6]*2**16+(m<<24);return(BigInt(O)<<BigInt(32))+BigInt(y+this[++c]*2**8+this[++c]*2**16+this[++c]*2**24)}),u.prototype.readBigInt64BE=Ye(function(c){c=c>>>0,et(c,"offset");let y=this[c],m=this[c+7];(y===void 0||m===void 0)&&rt(c,this.length-8);let O=(y<<24)+this[++c]*2**16+this[++c]*2**8+this[++c];return(BigInt(O)<<BigInt(32))+BigInt(this[++c]*2**24+this[++c]*2**16+this[++c]*2**8+m)}),u.prototype.readFloatLE=function(c,y){return c=c>>>0,y||we(c,4,this.length),r.read(this,c,!0,23,4)},u.prototype.readFloatBE=function(c,y){return c=c>>>0,y||we(c,4,this.length),r.read(this,c,!1,23,4)},u.prototype.readDoubleLE=function(c,y){return c=c>>>0,y||we(c,8,this.length),r.read(this,c,!0,52,8)},u.prototype.readDoubleBE=function(c,y){return c=c>>>0,y||we(c,8,this.length),r.read(this,c,!1,52,8)};function Te(c,y,m,O,I,W){if(!u.isBuffer(c))throw new TypeError('"buffer" argument must be a Buffer instance');if(y>I||y<W)throw new RangeError('"value" argument is out of bounds');if(m+O>c.length)throw new RangeError("Index out of range")}u.prototype.writeUintLE=u.prototype.writeUIntLE=function(c,y,m,O){if(c=+c,y=y>>>0,m=m>>>0,!O){let oe=Math.pow(2,8*m)-1;Te(this,c,y,m,oe,0)}let I=1,W=0;for(this[y]=c&255;++W<m&&(I*=256);)this[y+W]=c/I&255;return y+m},u.prototype.writeUintBE=u.prototype.writeUIntBE=function(c,y,m,O){if(c=+c,y=y>>>0,m=m>>>0,!O){let oe=Math.pow(2,8*m)-1;Te(this,c,y,m,oe,0)}let I=m-1,W=1;for(this[y+I]=c&255;--I>=0&&(W*=256);)this[y+I]=c/W&255;return y+m},u.prototype.writeUint8=u.prototype.writeUInt8=function(c,y,m){return c=+c,y=y>>>0,m||Te(this,c,y,1,255,0),this[y]=c&255,y+1},u.prototype.writeUint16LE=u.prototype.writeUInt16LE=function(c,y,m){return c=+c,y=y>>>0,m||Te(this,c,y,2,65535,0),this[y]=c&255,this[y+1]=c>>>8,y+2},u.prototype.writeUint16BE=u.prototype.writeUInt16BE=function(c,y,m){return c=+c,y=y>>>0,m||Te(this,c,y,2,65535,0),this[y]=c>>>8,this[y+1]=c&255,y+2},u.prototype.writeUint32LE=u.prototype.writeUInt32LE=function(c,y,m){return c=+c,y=y>>>0,m||Te(this,c,y,4,4294967295,0),this[y+3]=c>>>24,this[y+2]=c>>>16,this[y+1]=c>>>8,this[y]=c&255,y+4},u.prototype.writeUint32BE=u.prototype.writeUInt32BE=function(c,y,m){return c=+c,y=y>>>0,m||Te(this,c,y,4,4294967295,0),this[y]=c>>>24,this[y+1]=c>>>16,this[y+2]=c>>>8,this[y+3]=c&255,y+4};function Ge(c,y,m,O,I){Ct(y,O,I,c,m,7);let W=Number(y&BigInt(4294967295));c[m++]=W,W=W>>8,c[m++]=W,W=W>>8,c[m++]=W,W=W>>8,c[m++]=W;let oe=Number(y>>BigInt(32)&BigInt(4294967295));return c[m++]=oe,oe=oe>>8,c[m++]=oe,oe=oe>>8,c[m++]=oe,oe=oe>>8,c[m++]=oe,m}function Ie(c,y,m,O,I){Ct(y,O,I,c,m,7);let W=Number(y&BigInt(4294967295));c[m+7]=W,W=W>>8,c[m+6]=W,W=W>>8,c[m+5]=W,W=W>>8,c[m+4]=W;let oe=Number(y>>BigInt(32)&BigInt(4294967295));return c[m+3]=oe,oe=oe>>8,c[m+2]=oe,oe=oe>>8,c[m+1]=oe,oe=oe>>8,c[m]=oe,m+8}u.prototype.writeBigUInt64LE=Ye(function(c,y=0){return Ge(this,c,y,BigInt(0),BigInt("0xffffffffffffffff"))}),u.prototype.writeBigUInt64BE=Ye(function(c,y=0){return Ie(this,c,y,BigInt(0),BigInt("0xffffffffffffffff"))}),u.prototype.writeIntLE=function(c,y,m,O){if(c=+c,y=y>>>0,!O){let he=Math.pow(2,8*m-1);Te(this,c,y,m,he-1,-he)}let I=0,W=1,oe=0;for(this[y]=c&255;++I<m&&(W*=256);)c<0&&oe===0&&this[y+I-1]!==0&&(oe=1),this[y+I]=(c/W>>0)-oe&255;return y+m},u.prototype.writeIntBE=function(c,y,m,O){if(c=+c,y=y>>>0,!O){let he=Math.pow(2,8*m-1);Te(this,c,y,m,he-1,-he)}let I=m-1,W=1,oe=0;for(this[y+I]=c&255;--I>=0&&(W*=256);)c<0&&oe===0&&this[y+I+1]!==0&&(oe=1),this[y+I]=(c/W>>0)-oe&255;return y+m},u.prototype.writeInt8=function(c,y,m){return c=+c,y=y>>>0,m||Te(this,c,y,1,127,-128),c<0&&(c=255+c+1),this[y]=c&255,y+1},u.prototype.writeInt16LE=function(c,y,m){return c=+c,y=y>>>0,m||Te(this,c,y,2,32767,-32768),this[y]=c&255,this[y+1]=c>>>8,y+2},u.prototype.writeInt16BE=function(c,y,m){return c=+c,y=y>>>0,m||Te(this,c,y,2,32767,-32768),this[y]=c>>>8,this[y+1]=c&255,y+2},u.prototype.writeInt32LE=function(c,y,m){return c=+c,y=y>>>0,m||Te(this,c,y,4,2147483647,-2147483648),this[y]=c&255,this[y+1]=c>>>8,this[y+2]=c>>>16,this[y+3]=c>>>24,y+4},u.prototype.writeInt32BE=function(c,y,m){return c=+c,y=y>>>0,m||Te(this,c,y,4,2147483647,-2147483648),c<0&&(c=4294967295+c+1),this[y]=c>>>24,this[y+1]=c>>>16,this[y+2]=c>>>8,this[y+3]=c&255,y+4},u.prototype.writeBigInt64LE=Ye(function(c,y=0){return Ge(this,c,y,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),u.prototype.writeBigInt64BE=Ye(function(c,y=0){return Ie(this,c,y,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function nt(c,y,m,O,I,W){if(m+O>c.length)throw new RangeError("Index out of range");if(m<0)throw new RangeError("Index out of range")}function $t(c,y,m,O,I){return y=+y,m=m>>>0,I||nt(c,y,m,4),r.write(c,y,m,O,23,4),m+4}u.prototype.writeFloatLE=function(c,y,m){return $t(this,c,y,!0,m)},u.prototype.writeFloatBE=function(c,y,m){return $t(this,c,y,!1,m)};function vt(c,y,m,O,I){return y=+y,m=m>>>0,I||nt(c,y,m,8),r.write(c,y,m,O,52,8),m+8}u.prototype.writeDoubleLE=function(c,y,m){return vt(this,c,y,!0,m)},u.prototype.writeDoubleBE=function(c,y,m){return vt(this,c,y,!1,m)},u.prototype.copy=function(c,y,m,O){if(!u.isBuffer(c))throw new TypeError("argument should be a Buffer");if(m||(m=0),!O&&O!==0&&(O=this.length),y>=c.length&&(y=c.length),y||(y=0),O>0&&O<m&&(O=m),O===m||c.length===0||this.length===0)return 0;if(y<0)throw new RangeError("targetStart out of bounds");if(m<0||m>=this.length)throw new RangeError("Index out of range");if(O<0)throw new RangeError("sourceEnd out of bounds");O>this.length&&(O=this.length),c.length-y<O-m&&(O=c.length-y+m);let I=O-m;return this===c&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(y,m,O):Uint8Array.prototype.set.call(c,this.subarray(m,O),y),I},u.prototype.fill=function(c,y,m,O){if(typeof c=="string"){if(typeof y=="string"?(O=y,y=0,m=this.length):typeof m=="string"&&(O=m,m=this.length),O!==void 0&&typeof O!="string")throw new TypeError("encoding must be a string");if(typeof O=="string"&&!u.isEncoding(O))throw new TypeError("Unknown encoding: "+O);if(c.length===1){let W=c.charCodeAt(0);(O==="utf8"&&W<128||O==="latin1")&&(c=W)}}else typeof c=="number"?c=c&255:typeof c=="boolean"&&(c=Number(c));if(y<0||this.length<y||this.length<m)throw new RangeError("Out of range index");if(m<=y)return this;y=y>>>0,m=m===void 0?this.length:m>>>0,c||(c=0);let I;if(typeof c=="number")for(I=y;I<m;++I)this[I]=c;else{let W=u.isBuffer(c)?c:u.from(c,O),oe=W.length;if(oe===0)throw new TypeError('The value "'+c+'" is invalid for argument "value"');for(I=0;I<m-y;++I)this[I+y]=W[I%oe]}return this};var Ze={};function it(c,y,m){Ze[c]=class extends m{constructor(){super(),Object.defineProperty(this,"message",{value:y.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${c}]`,this.stack,delete this.name}get code(){return c}set code(O){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:O,writable:!0})}toString(){return`${this.name} [${c}]: ${this.message}`}}}it("ERR_BUFFER_OUT_OF_BOUNDS",function(c){return c?`${c} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),it("ERR_INVALID_ARG_TYPE",function(c,y){return`The "${c}" argument must be of type number. Received type ${typeof y}`},TypeError),it("ERR_OUT_OF_RANGE",function(c,y,m){let O=`The value of "${c}" is out of range.`,I=m;return Number.isInteger(m)&&Math.abs(m)>2**32?I=_t(String(m)):typeof m=="bigint"&&(I=String(m),(m>BigInt(2)**BigInt(32)||m<-(BigInt(2)**BigInt(32)))&&(I=_t(I)),I+="n"),O+=` It must be ${y}. Received ${I}`,O},RangeError);function _t(c){let y="",m=c.length,O=c[0]==="-"?1:0;for(;m>=O+4;m-=3)y=`_${c.slice(m-3,m)}${y}`;return`${c.slice(0,m)}${y}`}function At(c,y,m){et(y,"offset"),(c[y]===void 0||c[y+m]===void 0)&&rt(y,c.length-(m+1))}function Ct(c,y,m,O,I,W){if(c>m||c<y){let oe=typeof y=="bigint"?"n":"",he;throw W>3?y===0||y===BigInt(0)?he=`>= 0${oe} and < 2${oe} ** ${(W+1)*8}${oe}`:he=`>= -(2${oe} ** ${(W+1)*8-1}${oe}) and < 2 ** ${(W+1)*8-1}${oe}`:he=`>= ${y}${oe} and <= ${m}${oe}`,new Ze.ERR_OUT_OF_RANGE("value",he,c)}At(O,I,W)}function et(c,y){if(typeof c!="number")throw new Ze.ERR_INVALID_ARG_TYPE(y,"number",c)}function rt(c,y,m){throw Math.floor(c)!==c?(et(c,m),new Ze.ERR_OUT_OF_RANGE(m||"offset","an integer",c)):y<0?new Ze.ERR_BUFFER_OUT_OF_BOUNDS:new Ze.ERR_OUT_OF_RANGE(m||"offset",`>= ${m?1:0} and <= ${y}`,c)}var xt=/[^+/0-9A-Za-z-_]/g;function kt(c){if(c=c.split("=")[0],c=c.trim().replace(xt,""),c.length<2)return"";for(;c.length%4!==0;)c=c+"=";return c}function st(c,y){y=y||1/0;let m,O=c.length,I=null,W=[];for(let oe=0;oe<O;++oe){if(m=c.charCodeAt(oe),m>55295&&m<57344){if(!I){if(m>56319){(y-=3)>-1&&W.push(239,191,189);continue}else if(oe+1===O){(y-=3)>-1&&W.push(239,191,189);continue}I=m;continue}if(m<56320){(y-=3)>-1&&W.push(239,191,189),I=m;continue}m=(I-55296<<10|m-56320)+65536}else I&&(y-=3)>-1&&W.push(239,191,189);if(I=null,m<128){if((y-=1)<0)break;W.push(m)}else if(m<2048){if((y-=2)<0)break;W.push(m>>6|192,m&63|128)}else if(m<65536){if((y-=3)<0)break;W.push(m>>12|224,m>>6&63|128,m&63|128)}else if(m<1114112){if((y-=4)<0)break;W.push(m>>18|240,m>>12&63|128,m>>6&63|128,m&63|128)}else throw new Error("Invalid code point")}return W}function Bt(c){let y=[];for(let m=0;m<c.length;++m)y.push(c.charCodeAt(m)&255);return y}function Ft(c,y){let m,O,I,W=[];for(let oe=0;oe<c.length&&!((y-=2)<0);++oe)m=c.charCodeAt(oe),O=m>>8,I=m%256,W.push(I),W.push(O);return W}function St(c){return e.toByteArray(kt(c))}function ot(c,y,m,O){let I;for(I=0;I<O&&!(I+m>=y.length||I>=c.length);++I)y[I+m]=c[I];return I}function We(c,y){return c instanceof y||c!=null&&c.constructor!=null&&c.constructor.name!=null&&c.constructor.name===y.name}function at(c){return c!==c}var It=function(){let c="0123456789abcdef",y=new Array(256);for(let m=0;m<16;++m){let O=m*16;for(let I=0;I<16;++I)y[O+I]=c[m]+c[I]}return y}();function Ye(c){return typeof BigInt>"u"?Nt:c}function Nt(){throw new Error("BigInt not supported")}}),si=S((t,e)=>{a();var r=e.exports={},n,o;function i(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}(function(){try{typeof setTimeout=="function"?n=setTimeout:n=i}catch{n=i}try{typeof clearTimeout=="function"?o=clearTimeout:o=s}catch{o=s}})();function u(P){if(n===setTimeout)return setTimeout(P,0);if((n===i||!n)&&setTimeout)return n=setTimeout,setTimeout(P,0);try{return n(P,0)}catch{try{return n.call(null,P,0)}catch{return n.call(this,P,0)}}}function f(P){if(o===clearTimeout)return clearTimeout(P);if((o===s||!o)&&clearTimeout)return o=clearTimeout,clearTimeout(P);try{return o(P)}catch{try{return o.call(null,P)}catch{return o.call(this,P)}}}var h=[],g=!1,$,E=-1;function A(){!g||!$||(g=!1,$.length?h=$.concat(h):E=-1,h.length&&w())}function w(){if(!g){var P=u(A);g=!0;for(var L=h.length;L;){for($=h,h=[];++E<L;)$&&$[E].run();E=-1,L=h.length}$=null,g=!1,f(P)}}r.nextTick=function(P){var L=new Array(arguments.length-1);if(arguments.length>1)for(var N=1;N<arguments.length;N++)L[N-1]=arguments[N];h.push(new v(P,L)),h.length===1&&!g&&u(w)};function v(P,L){this.fun=P,this.array=L}v.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={};function k(){}r.on=k,r.addListener=k,r.once=k,r.off=k,r.removeListener=k,r.removeAllListeners=k,r.emit=k,r.prependListener=k,r.prependOnceListener=k,r.listeners=function(P){return[]},r.binding=function(P){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(P){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}}),p,d,a=F(()=>{ti().Buffer,p=si(),d=globalThis,globalThis&&globalThis.process&&globalThis.process.env&&(globalThis.process.env.LIBP2P_FORCE_PNET=!1)});function ci(t,e,r){e=e||[],r=r||0;for(var n=r;t>=mf;)e[r++]=t&255|ai,t/=128;for(;t&pf;)e[r++]=t&255|ai,t>>>=7;return e[r]=t|0,ci.bytes=r-n+1,e}function un(t,n){var r=0,n=n||0,o=0,i=n,s,u=t.length;do{if(i>=u)throw un.bytes=0,new RangeError("Could not decode varint");s=t[i++],r+=o<28?(s&ui)<<o:(s&ui)*Math.pow(2,o),o+=7}while(s>=wf);return un.bytes=i-n,r}var df,ai,hf,pf,mf,yf,wf,ui,gf,Df,bf,Ef,xf,Cf,Bf,Af,Tf,If,Sf,Uf,Lt,fi=F(()=>{a(),df=ci,ai=128,hf=127,pf=~hf,mf=Math.pow(2,31),yf=un,wf=128,ui=127,gf=Math.pow(2,7),Df=Math.pow(2,14),bf=Math.pow(2,21),Ef=Math.pow(2,28),xf=Math.pow(2,35),Cf=Math.pow(2,42),Bf=Math.pow(2,49),Af=Math.pow(2,56),Tf=Math.pow(2,63),If=function(t){return t<gf?1:t<Df?2:t<bf?3:t<Ef?4:t<xf?5:t<Cf?6:t<Bf?7:t<Af?8:t<Tf?9:10},Sf={encode:df,decode:yf,encodingLength:If},Uf=Sf,Lt=Uf}),Pt,ut,ct,cr=F(()=>{a(),fi(),Pt=t=>[Lt.decode(t),Lt.decode.bytes],ut=(t,e,r=0)=>(Lt.encode(t,e,r),e),ct=t=>Lt.encodingLength(t)}),li,Se,di,hi,Ne=F(()=>{a(),li=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},Se=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},di=t=>new TextEncoder().encode(t),hi=t=>new TextDecoder().decode(t)}),Ue={};M(Ue,{Digest:()=>Xe,create:()=>$e,decode:()=>ft,equals:()=>fn});var $e,ft,fn,Xe,Le=F(()=>{a(),Ne(),cr(),$e=(t,e)=>{let r=e.byteLength,n=ct(t),o=n+ct(r),i=new Uint8Array(o+r);return ut(t,i,0),ut(r,i,n),i.set(e,o),new Xe(t,r,e,i)},ft=t=>{let e=Se(t),[r,n]=Pt(e),[o,i]=Pt(e.subarray(n)),s=e.subarray(n+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new Xe(r,o,s,e)},fn=(t,e)=>t===e?!0:t.code===e.code&&t.size===e.size&&li(t.bytes,e.bytes),Xe=class{constructor(t,e,r,n){this.code=t,this.size=e,this.digest=r,this.bytes=n}}});function Ff(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var i=t.charAt(o),s=i.charCodeAt(0);if(r[s]!==255)throw new TypeError(i+" is ambiguous");r[s]=o}var u=t.length,f=t.charAt(0),h=Math.log(u)/Math.log(256),g=Math.log(256)/Math.log(u);function $(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var v=0,k=0,P=0,L=w.length;P!==L&&w[P]===0;)P++,v++;for(var N=(L-P)*g+1>>>0,q=new Uint8Array(N);P!==L;){for(var X=w[P],Z=0,j=N-1;(X!==0||Z<k)&&j!==-1;j--,Z++)X+=256*q[j]>>>0,q[j]=X%u>>>0,X=X/u>>>0;if(X!==0)throw new Error("Non-zero carry");k=Z,P++}for(var B=N-k;B!==N&&q[B]===0;)B++;for(var K=f.repeat(v);B<N;++B)K+=t.charAt(q[B]);return K}function E(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var v=0;if(w[v]!==" "){for(var k=0,P=0;w[v]===f;)k++,v++;for(var L=(w.length-v)*h+1>>>0,N=new Uint8Array(L);w[v];){var q=r[w.charCodeAt(v)];if(q===255)return;for(var X=0,Z=L-1;(q!==0||X<P)&&Z!==-1;Z--,X++)q+=u*N[Z]>>>0,N[Z]=q%256>>>0,q=q/256>>>0;if(q!==0)throw new Error("Non-zero carry");P=X,v++}if(w[v]!==" "){for(var j=L-P;j!==L&&N[j]===0;)j++;for(var B=new Uint8Array(k+(L-j)),K=k;j!==L;)B[K++]=N[j++];return B}}}function A(w){var v=E(w);if(v)return v;throw new Error(`Non-${e} character`)}return{encode:$,decodeUnsafe:E,decode:A}}var vf,kf,pi,mi=F(()=>{a(),vf=Ff,kf=vf,pi=kf}),ln,dn,hn,yi,pn,lt,Pe,_f,Nf,_,pe=F(()=>{a(),mi(),Ne(),ln=class{constructor(t,e,r){this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},dn=class{constructor(t,e,r){if(this.name=t,this.prefix=e,e.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=e.codePointAt(0),this.baseDecode=r}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return yi(this,t)}},hn=class{constructor(t){this.decoders=t}or(t){return yi(this,t)}decode(t){let e=t[0],r=this.decoders[e];if(r)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}},yi=(t,e)=>new hn({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}}),pn=class{constructor(t,e,r,n){this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=n,this.encoder=new ln(t,e,r),this.decoder=new dn(t,e,n)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}},lt=({name:t,prefix:e,encode:r,decode:n})=>new pn(t,e,r,n),Pe=({prefix:t,name:e,alphabet:r})=>{let{encode:n,decode:o}=pi(r,e);return lt({prefix:t,name:e,encode:n,decode:i=>Se(o(i))})},_f=(t,e,r,n)=>{let o={};for(let g=0;g<e.length;++g)o[e[g]]=g;let i=t.length;for(;t[i-1]==="=";)--i;let s=new Uint8Array(i*r/8|0),u=0,f=0,h=0;for(let g=0;g<i;++g){let $=o[t[g]];if($===void 0)throw new SyntaxError(`Non-${n} character`);f=f<<r|$,u+=r,u>=8&&(u-=8,s[h++]=255&f>>u)}if(u>=r||255&f<<8-u)throw new SyntaxError("Unexpected end of data");return s},Nf=(t,e,r)=>{let n=e[e.length-1]==="=",o=(1<<r)-1,i="",s=0,u=0;for(let f=0;f<t.length;++f)for(u=u<<8|t[f],s+=8;s>r;)s-=r,i+=e[o&u>>s];if(s&&(i+=e[o&u<<r-s]),n)for(;i.length*r&7;)i+="=";return i},_=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>lt({prefix:e,name:t,encode(o){return Nf(o,n,r)},decode(o){return _f(o,n,r,t)}})}),dt={};M(dt,{base58btc:()=>Y,base58flickr:()=>$f});var Y,$f,Re=F(()=>{a(),pe(),Y=Pe({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),$f=Pe({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"})}),Rt={};M(Rt,{base32:()=>Me,base32hex:()=>Mf,base32hexpad:()=>zf,base32hexpadupper:()=>qf,base32hexupper:()=>Of,base32pad:()=>Pf,base32padupper:()=>Rf,base32upper:()=>Lf,base32z:()=>Hf});var Me,Lf,Pf,Rf,Mf,Of,zf,qf,Hf,ht=F(()=>{a(),pe(),Me=_({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Lf=_({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Pf=_({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Rf=_({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Mf=_({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Of=_({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),zf=_({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),qf=_({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Hf=_({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5})}),dr={};M(dr,{CID:()=>x});var x,jf,Vf,Gf,Mt,Wf,wi,gi,fr,lr,Jf,Xf,Yf,Q=F(()=>{a(),cr(),Le(),Re(),ht(),Ne(),x=class{constructor(t,e,r,n){this.code=e,this.version=t,this.multihash=r,this.bytes=n,this.byteOffset=n.byteOffset,this.byteLength=n.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:lr,byteLength:lr,code:fr,version:fr,multihash:fr,bytes:fr,_baseCache:lr,asCID:lr})}toV0(){switch(this.version){case 0:return this;default:{let{code:t,multihash:e}=this;if(t!==Mt)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Wf)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return x.createV0(e)}}}toV1(){switch(this.version){case 0:{let{code:t,digest:e}=this.multihash,r=$e(t,e);return x.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(t){return t&&this.code===t.code&&this.version===t.version&&fn(this.multihash,t.multihash)}toString(t){let{bytes:e,version:r,_baseCache:n}=this;switch(r){case 0:return Vf(e,n,t||Y.encoder);default:return Gf(e,n,t||Me.encoder)}}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(t){return Xf(/^0\.0/,Yf),!!(t&&(t[gi]||t.asCID===t))}get toBaseEncodedString(){throw new Error("Deprecated, use .toString()")}get codec(){throw new Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw new Error('"multibaseName" property is deprecated')}get prefix(){throw new Error('"prefix" property is deprecated')}static asCID(t){if(t instanceof x)return t;if(t!=null&&t.asCID===t){let{version:e,code:r,multihash:n,bytes:o}=t;return new x(e,r,n,o||wi(e,r,n.bytes))}else if(t!=null&&t[gi]===!0){let{version:e,multihash:r,code:n}=t,o=ft(r);return x.create(e,n,o)}else return null}static create(t,e,r){if(typeof e!="number")throw new Error("String codecs are no longer supported");switch(t){case 0:{if(e!==Mt)throw new Error(`Version 0 CID must use dag-pb (code: ${Mt}) block encoding`);return new x(t,e,r,r.bytes)}case 1:{let n=wi(t,e,r.bytes);return new x(t,e,r,n)}default:throw new Error("Invalid version")}}static createV0(t){return x.create(0,Mt,t)}static createV1(t,e){return x.create(1,t,e)}static decode(t){let[e,r]=x.decodeFirst(t);if(r.length)throw new Error("Incorrect length");return e}static decodeFirst(t){let e=x.inspectBytes(t),r=e.size-e.multihashSize,n=Se(t.subarray(r,r+e.multihashSize));if(n.byteLength!==e.multihashSize)throw new Error("Incorrect length");let o=n.subarray(e.multihashSize-e.digestSize),i=new Xe(e.multihashCode,e.digestSize,o,n);return[e.version===0?x.createV0(i):x.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0,r=()=>{let[g,$]=Pt(t.subarray(e));return e+=$,g},n=r(),o=Mt;if(n===18?(n=0,e=0):n===1&&(o=r()),n!==0&&n!==1)throw new RangeError(`Invalid CID version ${n}`);let i=e,s=r(),u=r(),f=e+u,h=f-i;return{version:n,codec:o,multihashCode:s,digestSize:u,multihashSize:h,size:f}}static parse(t,e){let[r,n]=jf(t,e),o=x.decode(n);return o._baseCache.set(r,t),o}},jf=(t,e)=>{switch(t[0]){case"Q":{let r=e||Y;return[Y.prefix,r.decode(`${Y.prefix}${t}`)]}case Y.prefix:{let r=e||Y;return[Y.prefix,r.decode(t)]}case Me.prefix:{let r=e||Me;return[Me.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},Vf=(t,e,r)=>{let{prefix:n}=r;if(n!==Y.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);let o=e.get(n);if(o==null){let i=r.encode(t).slice(1);return e.set(n,i),i}else return o},Gf=(t,e,r)=>{let{prefix:n}=r,o=e.get(n);if(o==null){let i=r.encode(t);return e.set(n,i),i}else return o},Mt=112,Wf=18,wi=(t,e,r)=>{let n=ct(t),o=n+ct(e),i=new Uint8Array(o+r.byteLength);return ut(t,i,0),ut(e,i,n),i.set(r,o),i},gi=Symbol.for("@ipld/js-cid/CID"),fr={writable:!1,configurable:!1,enumerable:!0},lr={writable:!1,enumerable:!1,configurable:!1},Jf="0.0.0-dev",Xf=(t,e)=>{if(t.test(Jf))console.warn(e);else throw new Error(e)},Yf=`CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`}),yn,mn,wn=F(()=>{a(),Le(),yn=({name:t,code:e,encode:r})=>new mn(t,e,r),mn=class{constructor(t,e,r){this.name=t,this.code=e,this.encode=r}digest(t){if(t instanceof Uint8Array){let e=this.encode(t);return e instanceof Uint8Array?$e(this.code,e):e.then(r=>$e(this.code,r))}else throw Error("Unknown type, must be binary type")}}}),gn=F(()=>{a(),Q(),cr(),Ne(),wn(),Le()}),Ci=S((t,e)=>{a(),e.exports=s;var r=128,n=127,o=~n,i=Math.pow(2,31);function s(u,f,h){if(Number.MAX_SAFE_INTEGER&&u>Number.MAX_SAFE_INTEGER)throw s.bytes=0,new RangeError("Could not encode varint");f=f||[],h=h||0;for(var g=h;u>=i;)f[h++]=u&255|r,u/=128;for(;u&o;)f[h++]=u&255|r,u>>>=7;return f[h]=u|0,s.bytes=h-g+1,f}}),Ti=S((t,e)=>{a(),e.exports=o;var r=128,n=127;function o(i,f){var u=0,f=f||0,h=0,g=f,$,E=i.length;do{if(g>=E||h>49)throw o.bytes=0,new RangeError("Could not decode varint");$=i[g++],u+=h<28?($&n)<<h:($&n)*Math.pow(2,h),h+=7}while($>=r);return o.bytes=g-f,u}}),Si=S((t,e)=>{a();var r=Math.pow(2,7),n=Math.pow(2,14),o=Math.pow(2,21),i=Math.pow(2,28),s=Math.pow(2,35),u=Math.pow(2,42),f=Math.pow(2,49),h=Math.pow(2,56),g=Math.pow(2,63);e.exports=function($){return $<r?1:$<n?2:$<o?3:$<i?4:$<s?5:$<u?6:$<f?7:$<h?8:$<g?9:10}}),pt=S((t,e)=>{a(),e.exports={encode:Ci(),decode:Ti(),encodingLength:Si()}}),Ws=S((t,e)=>{a(),e.exports=function(){return Date.now()}}),Xs=S((t,e)=>{a();var r=Ws(),n=class{constructor(i,s,u){let f=this;this._started=r(),this._rescheduled=0,this._scheduled=s,this._args=u,this._triggered=!1,this._timerWrapper=()=>{f._rescheduled>0?(f._scheduled=f._rescheduled-(r()-f._started),f._schedule(f._scheduled)):(f._triggered=!0,i.apply(null,f._args))},this._timer=setTimeout(this._timerWrapper,s)}reschedule(i){i||(i=this._scheduled);let s=r();s+i-(this._started+this._scheduled)<0?(clearTimeout(this._timer),this._schedule(i)):this._triggered?this._schedule(i):(this._started=s,this._rescheduled=i)}_schedule(i){this._triggered=!1,this._started=r(),this._rescheduled=0,this._scheduled=i,this._timer=setTimeout(this._timerWrapper,i)}clear(){clearTimeout(this._timer)}};function o(){if(typeof arguments[0]!="function")throw new Error("callback needed");if(typeof arguments[1]!="number")throw new Error("timeout needed");let i;if(arguments.length>0){i=new Array(arguments.length-2);for(var s=0;s<i.length;s++)i[s]=arguments[s+2]}return new n(arguments[0],arguments[1],i)}e.exports=o}),Zs=S((t,e)=>{a();var{AbortController:r}=globalThis,n=Xs(),o=class extends r{constructor(i){super(),this._ms=i,this._timer=n(()=>this.abort(),i),Object.setPrototypeOf(this,o.prototype)}abort(){return this._timer.clear(),super.abort()}clear(){this._timer.clear()}reset(){this._timer.clear(),this._timer=n(()=>this.abort(),this._ms)}};e.exports={TimeoutController:o}}),ea=S((t,e)=>{a();function r(n){let o=new globalThis.AbortController;function i(){o.abort();for(let s of n)!s||!s.removeEventListener||s.removeEventListener("abort",i)}for(let s of n)if(!(!s||!s.addEventListener)){if(s.aborted){i();break}s.addEventListener("abort",i)}return o.signal}e.exports=r,e.exports.anySignal=r}),sa=S((t,e)=>{a();var r=1e3,n=r*60,o=n*60,i=o*24,s=i*7,u=i*365.25;e.exports=function(E,A){A=A||{};var w=typeof E;if(w==="string"&&E.length>0)return f(E);if(w==="number"&&isFinite(E))return A.long?g(E):h(E);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(E))};function f(E){if(E=String(E),!(E.length>100)){var A=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(E);if(A){var w=parseFloat(A[1]),v=(A[2]||"ms").toLowerCase();switch(v){case"years":case"year":case"yrs":case"yr":case"y":return w*u;case"weeks":case"week":case"w":return w*s;case"days":case"day":case"d":return w*i;case"hours":case"hour":case"hrs":case"hr":case"h":return w*o;case"minutes":case"minute":case"mins":case"min":case"m":return w*n;case"seconds":case"second":case"secs":case"sec":case"s":return w*r;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return w;default:return}}}}function h(E){var A=Math.abs(E);return A>=i?Math.round(E/i)+"d":A>=o?Math.round(E/o)+"h":A>=n?Math.round(E/n)+"m":A>=r?Math.round(E/r)+"s":E+"ms"}function g(E){var A=Math.abs(E);return A>=i?$(E,A,i,"day"):A>=o?$(E,A,o,"hour"):A>=n?$(E,A,n,"minute"):A>=r?$(E,A,r,"second"):E+" ms"}function $(E,A,w,v){var k=A>=w*1.5;return Math.round(E/w)+" "+v+(k?"s":"")}}),ua=S((t,e)=>{a();function r(n){i.debug=i,i.default=i,i.coerce=$,i.disable=f,i.enable=u,i.enabled=h,i.humanize=sa(),i.destroy=E,Object.keys(n).forEach(A=>{i[A]=n[A]}),i.names=[],i.skips=[],i.formatters={};function o(A){let w=0;for(let v=0;v<A.length;v++)w=(w<<5)-w+A.charCodeAt(v),w|=0;return i.colors[Math.abs(w)%i.colors.length]}i.selectColor=o;function i(A){let w,v=null,k,P;function L(...N){if(!L.enabled)return;let q=L,X=Number(new Date),Z=X-(w||X);q.diff=Z,q.prev=w,q.curr=X,w=X,N[0]=i.coerce(N[0]),typeof N[0]!="string"&&N.unshift("%O");let j=0;N[0]=N[0].replace(/%([a-zA-Z%])/g,(B,K)=>{if(B==="%%")return"%";j++;let ue=i.formatters[K];if(typeof ue=="function"){let se=N[j];B=ue.call(q,se),N.splice(j,1),j--}return B}),i.formatArgs.call(q,N),(q.log||i.log).apply(q,N)}return L.namespace=A,L.useColors=i.useColors(),L.color=i.selectColor(A),L.extend=s,L.destroy=i.destroy,Object.defineProperty(L,"enabled",{enumerable:!0,configurable:!1,get:()=>v!==null?v:(k!==i.namespaces&&(k=i.namespaces,P=i.enabled(A)),P),set:N=>{v=N}}),typeof i.init=="function"&&i.init(L),L}function s(A,w){let v=i(this.namespace+(typeof w>"u"?":":w)+A);return v.log=this.log,v}function u(A){i.save(A),i.namespaces=A,i.names=[],i.skips=[];let w,v=(typeof A=="string"?A:"").split(/[\s,]+/),k=v.length;for(w=0;w<k;w++)!v[w]||(A=v[w].replace(/\*/g,".*?"),A[0]==="-"?i.skips.push(new RegExp("^"+A.slice(1)+"$")):i.names.push(new RegExp("^"+A+"$")))}function f(){let A=[...i.names.map(g),...i.skips.map(g).map(w=>"-"+w)].join(",");return i.enable(""),A}function h(A){if(A[A.length-1]==="*")return!0;let w,v;for(w=0,v=i.skips.length;w<v;w++)if(i.skips[w].test(A))return!1;for(w=0,v=i.names.length;w<v;w++)if(i.names[w].test(A))return!0;return!1}function g(A){return A.toString().substring(2,A.toString().length-2).replace(/\.\*\?$/,"*")}function $(A){return A instanceof Error?A.stack||A.message:A}function E(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return i.enable(i.load()),i}e.exports=r}),ca=S((t,e)=>{a(),t.formatArgs=n,t.save=o,t.load=i,t.useColors=r,t.storage=s(),t.destroy=(()=>{let f=!1;return()=>{f||(f=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function r(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function n(f){if(f[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+f[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;let h="color: "+this.color;f.splice(1,0,h,"color: inherit");let g=0,$=0;f[0].replace(/%[a-zA-Z%]/g,E=>{E!=="%%"&&(g++,E==="%c"&&($=g))}),f.splice($,0,h)}t.log=console.debug||console.log||(()=>{});function o(f){try{f?t.storage.setItem("debug",f):t.storage.removeItem("debug")}catch{}}function i(){let f;try{f=t.storage.getItem("debug")}catch{}return!f&&typeof p<"u"&&"env"in p&&(f=p.env.DEBUG),f}function s(){try{return localStorage}catch{}}e.exports=ua()(t);var{formatters:u}=e.exports;u.j=function(f){try{return JSON.stringify(f)}catch(h){return"[UnexpectedJSONParseError]: "+h.message}}}),On={};M(On,{base64:()=>Mn,base64pad:()=>md,base64url:()=>yd,base64urlpad:()=>wd});var Mn,md,yd,wd,zn=F(()=>{a(),pe(),Mn=_({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),md=_({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),yd=_({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),wd=_({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6})}),fa,qn=F(()=>{a(),Ne(),fa=85}),da,Hn=F(()=>{a(),new TextEncoder,new TextDecoder,da=512}),wa=S((t,e)=>{a();var r=async n=>{for await(let o of n)return o};e.exports=r}),Da=S((t,e)=>{a();var r=async n=>{let o;for await(let i of n)o=i;return o};e.exports=r}),xa=S((t,e)=>{a();var r="[a-fA-F\\d:]",n=$=>$&&$.includeBoundaries?`(?:(?<=\\s|^)(?=${r})|(?<=${r})(?=\\s|$))`:"",o="(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",i="[a-fA-F\\d]{1,4}",s=`
(?:
(?:${i}:){7}(?:${i}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${i}:){6}(?:${o}|:${i}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${i}:){5}(?::${o}|(?::${i}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${i}:){4}(?:(?::${i}){0,1}:${o}|(?::${i}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${i}:){3}(?:(?::${i}){0,2}:${o}|(?::${i}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${i}:){2}(?:(?::${i}){0,3}:${o}|(?::${i}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${i}:){1}(?:(?::${i}){0,4}:${o}|(?::${i}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${i}){0,5}:${o}|(?::${i}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm,"").replace(/\n/g,"").trim(),u=new RegExp(`(?:^${o}$)|(?:^${s}$)`),f=new RegExp(`^${o}$`),h=new RegExp(`^${s}$`),g=$=>$&&$.exact?u:new RegExp(`(?:${n($)}${o}${n($)})|(?:${n($)}${s}${n($)})`,"g");g.v4=$=>$&&$.exact?f:new RegExp(`${n($)}${o}${n($)}`,"g"),g.v6=$=>$&&$.exact?h:new RegExp(`${n($)}${s}${n($)}`,"g"),e.exports=g}),Ba=S((t,e)=>{a();var r=xa(),n=o=>r({exact:!0}).test(o);n.v4=o=>r.v4({exact:!0}).test(o),n.v6=o=>r.v6({exact:!0}).test(o),n.version=o=>n(o)?n.v4(o)?4:6:void 0,e.exports=n}),Wn={};M(Wn,{identity:()=>Ad});var Ad,Aa=F(()=>{a(),pe(),Ne(),Ad=lt({prefix:"\0",name:"identity",encode:t=>hi(t),decode:t=>di(t)})}),Jn={};M(Jn,{base2:()=>Td});var Td,Ta=F(()=>{a(),pe(),Td=_({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1})}),Xn={};M(Xn,{base8:()=>Id});var Id,Ia=F(()=>{a(),pe(),Id=_({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3})}),Yn={};M(Yn,{base10:()=>Sd});var Sd,Sa=F(()=>{a(),pe(),Sd=Pe({prefix:"9",name:"base10",alphabet:"0123456789"})}),Qn={};M(Qn,{base16:()=>Ud,base16upper:()=>Fd});var Ud,Fd,Ua=F(()=>{a(),pe(),Ud=_({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Fd=_({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4})}),Zn={};M(Zn,{base36:()=>vd,base36upper:()=>kd});var vd,kd,Fa=F(()=>{a(),pe(),vd=Pe({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),kd=Pe({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"})}),Kn={};M(Kn,{base256emoji:()=>Pd});function $d(t){return t.reduce((e,r)=>(e+=_d[r],e),"")}function Ld(t){let e=[];for(let r of t){let n=Nd[r.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${r}`);e.push(n)}return new Uint8Array(e)}var va,_d,Nd,Pd,ka=F(()=>{a(),pe(),va=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),_d=va.reduce((t,e,r)=>(t[r]=e,t),[]),Nd=va.reduce((t,e,r)=>(t[e.codePointAt(0)]=r,t),[]),Pd=lt({prefix:"\u{1F680}",name:"base256emoji",encode:$d,decode:Ld})}),eo={};M(eo,{sha256:()=>Rd,sha512:()=>Md});var _a,Rd,Md,Na=F(()=>{a(),wn(),_a=t=>async e=>new Uint8Array(await crypto.subtle.digest(t,e)),Rd=yn({name:"sha2-256",code:18,encode:_a("SHA-256")}),Md=yn({name:"sha2-512",code:19,encode:_a("SHA-512")})}),to={};M(to,{identity:()=>qd});var $a,Od,La,zd,qd,Pa=F(()=>{a(),Ne(),Le(),$a=0,Od="identity",La=Se,zd=t=>$e($a,La(t)),qd={code:$a,name:Od,encode:La,digest:zd}}),ro,Ra=F(()=>{a(),Aa(),Ta(),Ia(),Sa(),Ua(),ht(),Fa(),Re(),zn(),ka(),Na(),Pa(),qn(),Hn(),gn(),ro={...Wn,...Jn,...Xn,...Yn,...Qn,...Rt,...Zn,...dt,...On,...Kn},{...eo,...to}});function Nr(t=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(t):new Uint8Array(t)}var no=F(()=>{a()});function Oa(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}var Ma,oo,Hd,$r,io=F(()=>{a(),Ra(),no(),Ma=Oa("utf8","u",t=>"u"+new TextDecoder("utf8").decode(t),t=>new TextEncoder().encode(t.substring(1))),oo=Oa("ascii","a",t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},t=>{t=t.substring(1);let e=Nr(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}),Hd={utf8:Ma,"utf-8":Ma,hex:ro.base16,latin1:oo,ascii:oo,binary:oo,...ro},$r=Hd}),Tt={};M(Tt,{toString:()=>so});function so(t,e="utf8"){let r=$r[e];if(!r)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(t.buffer,t.byteOffset,t.byteLength).toString("utf8"):r.encoder.encode(t).substring(1)}var Ke=F(()=>{a(),io()}),Va=S((t,e)=>{a();var r=Ba(),{toString:n}=(Ke(),R(Tt)),o=r,i=r.v4,s=r.v6,u=function(h,g,$){$=~~$;let E;if(i(h))E=g||new Uint8Array($+4),h.split(/\./g).map(function(A){E[$++]=parseInt(A,10)&255});else if(s(h)){let A=h.split(":",8),w;for(w=0;w<A.length;w++){let v=i(A[w]),k;v&&(k=u(A[w]),A[w]=n(k.slice(0,2),"base16")),k&&++w<8&&A.splice(w,0,n(k.slice(2,4),"base16"))}if(A[0]==="")for(;A.length<8;)A.unshift("0");else if(A[A.length-1]==="")for(;A.length<8;)A.push("0");else if(A.length<8){for(w=0;w<A.length&&A[w]!=="";w++);let v=[w,"1"];for(w=9-A.length;w>0;w--)v.push("0");A.splice.apply(A,v)}for(E=g||new Uint8Array($+16),w=0;w<A.length;w++){let v=parseInt(A[w],16);E[$++]=v>>8&255,E[$++]=v&255}}if(!E)throw Error("Invalid ip address: "+h);return E},f=function(h,g,$){g=~~g,$=$||h.length-g;let E=[],A,w=new DataView(h.buffer);if($===4){for(let v=0;v<$;v++)E.push(h[g+v]);A=E.join(".")}else if($===16){for(let v=0;v<$;v+=2)E.push(w.getUint16(g+v).toString(16));A=E.join(":"),A=A.replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3"),A=A.replace(/:{3,4}/,"::")}return A};e.exports={isIP:o,isV4:i,isV6:s,toBytes:u,toString:f}}),Lr=S((t,e)=>{a();function r(i){if(typeof i=="number"){if(r.codes[i])return r.codes[i];throw new Error("no protocol with code: "+i)}else if(typeof i=="string"){if(r.names[i])return r.names[i];throw new Error("no protocol with name: "+i)}throw new Error("invalid protocol id type: "+i)}var n=-1;r.lengthPrefixedVarSize=n,r.V=n,r.table=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,n,"ip6zone"],[53,n,"dns","resolvable"],[54,n,"dns4","resolvable"],[55,n,"dns6","resolvable"],[56,n,"dnsaddr","resolvable"],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,n,"unix",!1,"path"],[421,n,"ipfs"],[421,n,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,n,"garlic64"],[460,0,"quic"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,n,"memory"]],r.names={},r.codes={},r.table.map(i=>{let s=o.apply(null,i);return r.codes[s.code]=s,r.names[s.name]=s,null}),r.object=o;function o(i,s,u,f,h){return{code:i,size:s,name:u,resolvable:Boolean(f),path:Boolean(h)}}e.exports=r}),Ja={};M(Ja,{fromString:()=>co});function co(t,e="utf8"){let r=$r[e];if(!r)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(t,"utf8"):r.decoder.decode(`${r.prefix}${t}`)}var fo=F(()=>{a(),io()}),lo={};M(lo,{concat:()=>Gd});function Gd(t,e){e||(e=t.reduce((o,i)=>o+i.length,0));let r=Nr(e),n=0;for(let o of t)r.set(o,n),n+=o.length;return r}var ho=F(()=>{a(),no()}),ru=S((t,e)=>{a();var r=Va(),n=Lr(),{CID:o}=(Q(),R(dr)),{base32:i}=(ht(),R(Rt)),{base58btc:s}=(Re(),R(dt)),u=(Le(),R(Ue)),f=pt(),{toString:h}=(Ke(),R(Tt)),{fromString:g}=(fo(),R(Ja)),{concat:$}=(ho(),R(lo));e.exports=E;function E(B,K){return K instanceof Uint8Array?E.toString(B,K):E.toBytes(B,K)}E.toString=function(B,K){switch(n(B).code){case 4:case 41:return w(K);case 6:case 273:case 33:case 132:return k(K).toString();case 53:case 54:case 55:case 56:case 400:case 777:return L(K);case 421:return q(K);case 444:return j(K);case 445:return j(K);default:return h(K,"base16")}},E.toBytes=function(B,K){switch(n(B).code){case 4:return A(K);case 41:return A(K);case 6:case 273:case 33:case 132:return v(parseInt(K,10));case 53:case 54:case 55:case 56:case 400:case 777:return P(K);case 421:return N(K);case 444:return X(K);case 445:return Z(K);default:return g(K,"base16")}};function A(B){if(!r.isIP(B))throw new Error("invalid ip address");return r.toBytes(B)}function w(B){let K=r.toString(B);if(!K||!r.isIP(K))throw new Error("invalid ip address");return K}function v(B){let K=new ArrayBuffer(2);return new DataView(K).setUint16(0,B),new Uint8Array(K)}function k(B){return new DataView(B.buffer).getUint16(B.byteOffset)}function P(B){let K=g(B),ue=Uint8Array.from(f.encode(K.length));return $([ue,K],ue.length+K.length)}function L(B){let K=f.decode(B);if(B=B.slice(f.decode.bytes),B.length!==K)throw new Error("inconsistent lengths");return h(B)}function N(B){let K;B[0]==="Q"||B[0]==="1"?K=u.decode(s.decode(`z${B}`)).bytes:K=o.parse(B).multihash.bytes;let ue=Uint8Array.from(f.encode(K.length));return $([ue,K],ue.length+K.length)}function q(B){let K=f.decode(B),ue=B.slice(f.decode.bytes);if(ue.length!==K)throw new Error("inconsistent lengths");return h(ue,"base58btc")}function X(B){let K=B.split(":");if(K.length!==2)throw new Error("failed to parse onion addr: "+K+" does not contain a port number");if(K[0].length!==16)throw new Error("failed to parse onion addr: "+K[0]+" not a Tor onion address.");let ue=i.decode("b"+K[0]),se=parseInt(K[1],10);if(se<1||se>65536)throw new Error("Port number is not in range(1, 65536)");let de=v(se);return $([ue,de],ue.length+de.length)}function Z(B){let K=B.split(":");if(K.length!==2)throw new Error("failed to parse onion addr: "+K+" does not contain a port number");if(K[0].length!==56)throw new Error("failed to parse onion addr: "+K[0]+" not a Tor onion3 address.");let ue=i.decode("b"+K[0]),se=parseInt(K[1],10);if(se<1||se>65536)throw new Error("Port number is not in range(1, 65536)");let de=v(se);return $([ue,de],ue.length+de.length)}function j(B){let K=B.slice(0,B.length-2),ue=B.slice(B.length-2),se=h(K,"base32"),de=k(ue);return se+":"+de}}),pu=S((t,e)=>{a();var r=ru(),n=Lr(),o=pt(),{concat:i}=(ho(),R(lo)),{toString:s}=(Ke(),R(Tt));e.exports={stringToStringTuples:u,stringTuplesToString:f,tuplesToStringTuples:g,stringTuplesToTuples:h,bytesToTuples:A,tuplesToBytes:$,bytesToString:w,stringToBytes:v,fromString:k,fromBytes:P,validateBytes:L,isValidBytes:N,cleanPath:q,ParseError:X,protoFromTuple:Z,sizeForAddr:E};function u(j){let B=[],K=j.split("/").slice(1);if(K.length===1&&K[0]==="")return[];for(let ue=0;ue<K.length;ue++){let se=K[ue],de=n(se);if(de.size===0){B.push([se]);continue}if(ue++,ue>=K.length)throw X("invalid address: "+j);if(de.path){B.push([se,q(K.slice(ue).join("/"))]);break}B.push([se,K[ue]])}return B}function f(j){let B=[];return j.map(K=>{let ue=Z(K);return B.push(ue.name),K.length>1&&B.push(K[1]),null}),q(B.join("/"))}function h(j){return j.map(B=>{Array.isArray(B)||(B=[B]);let K=Z(B);return B.length>1?[K.code,r.toBytes(K.code,B[1])]:[K.code]})}function g(j){return j.map(B=>{let K=Z(B);return B[1]?[K.code,r.toString(K.code,B[1])]:[K.code]})}function $(j){return P(i(j.map(B=>{let K=Z(B),ue=Uint8Array.from(o.encode(K.code));return B.length>1&&(ue=i([ue,B[1]])),ue})))}function E(j,B){return j.size>0?j.size/8:j.size===0?0:o.decode(B)+o.decode.bytes}function A(j){let B=[],K=0;for(;K<j.length;){let ue=o.decode(j,K),se=o.decode.bytes,de=n(ue),ae=E(de,j.slice(K+se));if(ae===0){B.push([ue]),K+=se;continue}let _e=j.slice(K+se,K+se+ae);if(K+=ae+se,K>j.length)throw X("Invalid address Uint8Array: "+s(j,"base16"));B.push([ue,_e])}return B}function w(j){let B=A(j),K=g(B);return f(K)}function v(j){j=q(j);let B=u(j),K=h(B);return $(K)}function k(j){return v(j)}function P(j){let B=L(j);if(B)throw B;return Uint8Array.from(j)}function L(j){try{A(j)}catch(B){return B}}function N(j){return L(j)===void 0}function q(j){return"/"+j.trim().split("/").filter(B=>B).join("/")}function X(j){return new Error("Error parsing address: "+j)}function Z(j){return n(j[0])}}),Yt=S((t,e)=>{a();function r(o,i){for(let s in i)Object.defineProperty(o,s,{value:i[s],enumerable:!0,configurable:!0});return o}function n(o,i,s){if(!o||typeof o=="string")throw new TypeError("Please pass an Error to err-code");s||(s={}),typeof i=="object"&&(s=i,i=""),i&&(s.code=i);try{return r(o,s)}catch{s.message=o.message,s.stack=o.stack;let u=function(){};return u.prototype=Object.create(Object.getPrototypeOf(o)),r(new u,s)}}e.exports=n}),wu={};M(wu,{equals:()=>uh});function uh(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}var gu=F(()=>{a()}),bo=S((t,e)=>{a();var r=pu(),n=Lr(),o=pt(),{CID:i}=(Q(),R(dr)),{base58btc:s}=(Re(),R(dt)),u=Yt(),f=Symbol.for("nodejs.util.inspect.custom"),{toString:h}=(Ke(),R(Tt)),{equals:g}=(gu(),R(wu)),$=new Map,E=Symbol.for("@multiformats/js-multiaddr/multiaddr"),A=class{constructor(v){if(v==null&&(v=""),Object.defineProperty(this,E,{value:!0}),v instanceof Uint8Array)this.bytes=r.fromBytes(v);else if(typeof v=="string"){if(v.length>0&&v.charAt(0)!=="/")throw new Error(`multiaddr "${v}" must start with a "/"`);this.bytes=r.fromString(v)}else if(A.isMultiaddr(v))this.bytes=r.fromBytes(v.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr")}toString(){return r.bytesToString(this.bytes)}toJSON(){return this.toString()}toOptions(){let v={},k=this.toString().split("/");return v.family=k[1]==="ip4"?4:6,v.host=k[2],v.transport=k[3],v.port=parseInt(k[4]),v}protos(){return this.protoCodes().map(v=>Object.assign({},n(v)))}protoCodes(){let v=[],k=this.bytes,P=0;for(;P<k.length;){let L=o.decode(k,P),N=o.decode.bytes,q=n(L);P+=r.sizeForAddr(q,k.slice(P+N))+N,v.push(L)}return v}protoNames(){return this.protos().map(v=>v.name)}tuples(){return r.bytesToTuples(this.bytes)}stringTuples(){let v=r.bytesToTuples(this.bytes);return r.tuplesToStringTuples(v)}encapsulate(v){return v=new A(v),new A(this.toString()+v.toString())}decapsulate(v){let k=v.toString(),P=this.toString(),L=P.lastIndexOf(k);if(L<0)throw new Error("Address "+this+" does not contain subaddress: "+v);return new A(P.slice(0,L))}decapsulateCode(v){let k=this.tuples();for(let P=k.length-1;P>=0;P--)if(k[P][0]===v)return new A(r.tuplesToBytes(k.slice(0,P)));return this}getPeerId(){try{let v=this.stringTuples().filter(k=>k[0]===n.names.ipfs.code).pop();if(v&&v[1]){let k=v[1];return k[0]==="Q"||k[0]==="1"?h(s.decode(`z${k}`),"base58btc"):h(i.parse(k).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){let v=null;try{v=this.stringTuples().filter(k=>!!n(k[0]).path)[0][1],v||(v=null)}catch{v=null}return v}equals(v){return g(this.bytes,v.bytes)}async resolve(){let v=this.protos().find(P=>P.resolvable);if(!v)return[this];let k=$.get(v.name);if(!k)throw u(new Error(`no available resolver for ${v.name}`),"ERR_NO_AVAILABLE_RESOLVER");return(await k(this)).map(P=>new A(P))}nodeAddress(){let v=this.protoCodes(),k=this.protoNames(),P=this.toString().split("/").slice(1);if(P.length<4)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');if(v[0]!==4&&v[0]!==41&&v[0]!==54&&v[0]!==55)throw new Error(`no protocol with name: "'${k[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);if(P[2]!=="tcp"&&P[2]!=="udp")throw new Error(`no protocol with name: "'${k[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);return{family:v[0]===41||v[0]===55?6:4,address:P[1],port:parseInt(P[3])}}isThinWaistAddress(v){let k=(v||this).protos();return!(k.length!==2||k[0].code!==4&&k[0].code!==41||k[1].code!==6&&k[1].code!==273)}static fromNodeAddress(v,k){if(!v)throw new Error("requires node address object");if(!k)throw new Error("requires transport protocol");let P;switch(v.family){case 4:P="ip4";break;case 6:P="ip6";break;default:throw Error(`Invalid addr family. Got '${v.family}' instead of 4 or 6`)}return new A("/"+[P,v.address,k,v.port].join("/"))}static isName(v){return A.isMultiaddr(v)?v.protos().some(k=>k.resolvable):!1}static isMultiaddr(v){return v instanceof A||Boolean(v&&v[E])}[f](){return"<Multiaddr "+h(this.bytes,"base16")+" - "+r.bytesToString(this.bytes)+">"}inspect(){return"<Multiaddr "+h(this.bytes,"base16")+" - "+r.bytesToString(this.bytes)+">"}};A.protocols=n,A.resolvers=$;function w(v){return new A(v)}e.exports={Multiaddr:A,multiaddr:w,protocols:n,resolvers:$}}),ku=S((t,e)=>{a();var{Multiaddr:r}=bo(),n=ae("dns4"),o=ae("dns6"),i=ae("dnsaddr"),s=de(ae("dns"),i,n,o),u=de(ae("ip4"),ae("ip6")),f=de(se(u,ae("tcp")),se(s,ae("tcp"))),h=se(u,ae("udp")),g=se(h,ae("utp")),$=se(h,ae("quic")),E=de(se(f,ae("ws")),se(s,ae("ws"))),A=de(se(f,ae("wss")),se(s,ae("wss"))),w=de(se(f,ae("http")),se(u,ae("http")),se(s,ae("http"))),v=de(se(f,ae("https")),se(u,ae("https")),se(s,ae("https"))),k=de(se(E,ae("p2p-webrtc-star"),ae("p2p")),se(A,ae("p2p-webrtc-star"),ae("p2p")),se(E,ae("p2p-webrtc-star")),se(A,ae("p2p-webrtc-star"))),P=de(se(E,ae("p2p-websocket-star"),ae("p2p")),se(A,ae("p2p-websocket-star"),ae("p2p")),se(E,ae("p2p-websocket-star")),se(A,ae("p2p-websocket-star"))),L=de(se(w,ae("p2p-webrtc-direct"),ae("p2p")),se(v,ae("p2p-webrtc-direct"),ae("p2p")),se(w,ae("p2p-webrtc-direct")),se(v,ae("p2p-webrtc-direct"))),N=de(E,A,w,v,k,L,f,g,$,s),q=de(se(N,ae("p2p-stardust"),ae("p2p")),se(N,ae("p2p-stardust"))),X=de(se(N,ae("p2p")),k,L,ae("p2p")),Z=de(se(X,ae("p2p-circuit"),X),se(X,ae("p2p-circuit")),se(ae("p2p-circuit"),X),se(N,ae("p2p-circuit")),se(ae("p2p-circuit"),N),ae("p2p-circuit")),j=()=>de(se(Z,j),Z),B=j(),K=de(se(B,X,B),se(X,B),se(B,X),B,X);e.exports={DNS:s,DNS4:n,DNS6:o,DNSADDR:i,IP:u,TCP:f,UDP:h,QUIC:$,UTP:g,HTTP:w,HTTPS:v,WebSockets:E,WebSocketsSecure:A,WebSocketStar:P,WebRTCStar:k,WebRTCDirect:L,Reliable:N,Stardust:q,Circuit:B,P2P:K,IPFS:K};function ue(_e){function xe(De){if(!r.isMultiaddr(De))try{De=new r(De)}catch{return!1}let Ee=_e(De.protoNames());return Ee===null?!1:Ee===!0||Ee===!1?Ee:Ee.length===0}return xe}function se(..._e){function xe(De){if(De.length<_e.length)return null;let Ee=De;return _e.some(ie=>(Ee=typeof ie=="function"?ie().partialMatch(De):ie.partialMatch(De),Array.isArray(Ee)&&(De=Ee),Ee===null)),Ee}return{toString:function(){return"{ "+_e.join(" ")+" }"},input:_e,matches:ue(xe),partialMatch:xe}}function de(..._e){function xe(De){let Ee=null;return _e.some(ie=>{let Ve=typeof ie=="function"?ie().partialMatch(De):ie.partialMatch(De);return Ve?(Ee=Ve,!0):!1}),Ee}return{toString:function(){return"{ "+_e.join(" ")+" }"},input:_e,matches:ue(xe),partialMatch:xe}}function ae(_e){let xe=_e;function De(ie){let Ve;if(typeof ie=="string"||ie instanceof Uint8Array)try{Ve=new r(ie)}catch{return!1}else Ve=ie;let Je=Ve.protoNames();return Je.length===1&&Je[0]===xe}function Ee(ie){return ie.length===0?null:ie[0]===xe?ie.slice(1):null}return{toString:function(){return xe},matches:De,partialMatch:Ee}}}),To=S((t,e)=>{a();var r=typeof navigator<"u"&&navigator.product==="ReactNative";function n(){return r?"http://localhost":d.location?d.location.protocol+"//"+d.location.host:""}var o=d.URL,i=n(),s=class{constructor(f="",h=i){this.super=new o(f,h),this.path=this.pathname+this.search,this.auth=this.username&&this.password?this.username+":"+this.password:null,this.query=this.search&&this.search.startsWith("?")?this.search.slice(1):null}get hash(){return this.super.hash}get host(){return this.super.host}get hostname(){return this.super.hostname}get href(){return this.super.href}get origin(){return this.super.origin}get password(){return this.super.password}get pathname(){return this.super.pathname}get port(){return this.super.port}get protocol(){return this.super.protocol}get search(){return this.super.search}get searchParams(){return this.super.searchParams}get username(){return this.super.username}set hash(f){this.super.hash=f}set host(f){this.super.host=f}set hostname(f){this.super.hostname=f}set href(f){this.super.href=f}set password(f){this.super.password=f}set pathname(f){this.super.pathname=f}set port(f){this.super.port=f}set protocol(f){this.super.protocol=f}set search(f){this.super.search=f}set username(f){this.super.username=f}static createObjectURL(f){return o.createObjectURL(f)}static revokeObjectURL(f){o.revokeObjectURL(f)}toJSON(){return this.super.toJSON()}toString(){return this.super.toString()}format(){return this.toString()}};function u(f){if(typeof f=="string")return new o(f).toString();if(!(f instanceof o)){let h=f.username&&f.password?`${f.username}:${f.password}@`:"",g=f.auth?f.auth+"@":"",$=f.port?":"+f.port:"",E=f.protocol?f.protocol+"//":"",A=f.host||"",w=f.hostname||"",v=f.search||(f.query?"?"+f.query:""),k=f.hash||"",P=f.pathname||"",L=f.path||P+v;return`${E}${h||g}${A||w+$}${L}${k}`}}e.exports={URLWithLegacySupport:s,URLSearchParams:d.URLSearchParams,defaultBase:i,format:u}}),Pu=S((t,e)=>{a();var{URLWithLegacySupport:r,format:n}=To();e.exports=(o,i={},s={},u)=>{let f=i.protocol?i.protocol.replace(":",""):"http";f=(s[f]||u||f)+":";let h;try{h=new r(o)}catch{h={}}let g=Object.assign({},i,{protocol:f||h.protocol,host:i.host||h.host});return new r(o,n(g)).toString()}}),Mu=S((t,e)=>{a();var{URLWithLegacySupport:r,format:n,URLSearchParams:o,defaultBase:i}=To(),s=Pu();e.exports={URL:r,URLSearchParams:o,format:n,relative:s,defaultBase:i}}),Ku=S((t,e)=>{a();var{base58btc:r}=(Re(),R(dt)),{base32:n}=(ht(),R(Rt)),o=(Le(),R(Ue)),{Multiaddr:i}=bo(),s=ku(),{CID:u}=(Q(),R(dr)),{URL:f}=Mu(),{toString:h}=(Ke(),R(Tt)),g=/^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/,$=/^\/(ip[fn]s)\/([^/?#]+)/,E=1,A=2,w=/^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/,v=1,k=2,P=/^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;function L(ie){let Ve=ue(ie);try{o.decode(r.decode("z"+Ve))}catch{return!1}return!0}function N(ie){try{n.decode(ie)}catch{return!1}return!0}function q(ie){try{return typeof ie=="string"?Boolean(u.parse(ie)):ie instanceof Uint8Array?Boolean(u.decode(ie)):Boolean(u.asCID(ie))}catch{return!1}}function X(ie){if(!ie)return!1;if(i.isMultiaddr(ie))return!0;try{return new i(ie),!0}catch{return!1}}function Z(ie){return X(ie)&&s.P2P.matches(ie)}function j(ie,Ve,Je=E,we=A){let Te=ue(ie);if(!Te)return!1;let Ge=Te.match(Ve);if(!Ge||Ge[Je]!=="ipfs")return!1;let Ie=Ge[we];return Ie&&Ve===w&&(Ie=Ie.toLowerCase()),q(Ie)}function B(ie,Ve,Je=E,we=A){let Te=ue(ie);if(!Te)return!1;let Ge=Te.match(Ve);if(!Ge||Ge[Je]!=="ipns")return!1;let Ie=Ge[we];if(Ie&&Ve===w){if(Ie=Ie.toLowerCase(),q(Ie))return!0;try{!Ie.includes(".")&&Ie.includes("-")&&(Ie=Ie.replace(/--/g,"@").replace(/-/g,".").replace(/@/g,"-"));let{hostname:nt}=new f(`http://${Ie}`);return P.test(nt)}catch{return!1}}return!0}function K(ie){return typeof ie=="string"}function ue(ie){return ie instanceof Uint8Array?h(ie,"base58btc"):K(ie)?ie:!1}var se=ie=>j(ie,w,k,v),de=ie=>B(ie,w,k,v),ae=ie=>se(ie)||de(ie),_e=ie=>j(ie,g)||se(ie),xe=ie=>B(ie,g)||de(ie),De=ie=>_e(ie)||xe(ie)||ae(ie),Ee=ie=>j(ie,$)||B(ie,$);e.exports={multihash:L,multiaddr:X,peerMultiaddr:Z,cid:q,base32cid:ie=>N(ie)&&q(ie),ipfsSubdomain:se,ipnsSubdomain:de,subdomain:ae,subdomainGatewayPattern:w,ipfsUrl:_e,ipnsUrl:xe,url:De,pathGatewayPattern:g,ipfsPath:ie=>j(ie,$),ipnsPath:ie=>B(ie,$),path:Ee,pathPattern:$,urlOrPath:ie=>De(ie)||Ee(ie),cidPath:ie=>K(ie)&&!q(ie)&&j(`/ipfs/${ie}`,$)}}),hc=S((t,e)=>{a();function r(n){let[o,i]=n[Symbol.asyncIterator]?[n[Symbol.asyncIterator](),Symbol.asyncIterator]:[n[Symbol.iterator](),Symbol.iterator],s=[];return{peek:()=>o.next(),push:u=>{s.push(u)},next:()=>s.length?{done:!1,value:s.shift()}:o.next(),[i](){return this}}}e.exports=r}),mc=S((t,e)=>{a();var r=async n=>{for await(let o of n);};e.exports=r}),wc=S((t,e)=>{a();var r=async function*(n,o){for await(let i of n)yield o(i)};e.exports=r});a();a();Q();a();gn();var hr=({enumerable:t=!0,configurable:e=!1}={})=>({enumerable:t,configurable:e,writable:!1}),Dn=function*(t,e){if(t!=null&&!(t instanceof Uint8Array))for(let[r,n]of Object.entries(t)){let o=[...e,r];if(n!=null&&typeof n=="object")if(Array.isArray(n))for(let[i,s]of n.entries()){let u=[...o,i],f=x.asCID(s);f?yield[u.join("/"),f]:typeof s=="object"&&(yield*Dn(s,u))}else{let i=x.asCID(n);i?yield[o.join("/"),i]:yield*Dn(n,o)}}},bn=function*(t,e){if(t!=null)for(let[r,n]of Object.entries(t)){let o=[...e,r];if(yield o.join("/"),n!=null&&!(n instanceof Uint8Array)&&typeof n=="object"&&!x.asCID(n))if(Array.isArray(n))for(let[i,s]of n.entries()){let u=[...o,i];yield u.join("/"),typeof s=="object"&&!x.asCID(s)&&(yield*bn(s,u))}else yield*bn(n,o)}},Qf=(t,e)=>{let r=t;for(let[n,o]of e.entries()){if(r=r[o],r==null)throw new Error(`Object has no property at ${e.slice(0,n+1).map(s=>`[${JSON.stringify(s)}]`).join("")}`);let i=x.asCID(r);if(i)return{value:i,remaining:e.slice(n+1).join("/")}}return{value:r}},En=class{constructor({cid:t,bytes:e,value:r}){if(!t||!e||typeof r>"u")throw new Error("Missing required argument");this.cid=t,this.bytes=e,this.value=r,this.asBlock=this,Object.defineProperties(this,{cid:hr(),bytes:hr(),value:hr(),asBlock:hr()})}links(){return Dn(this.value,[])}tree(){return bn(this.value,[])}get(t="/"){return Qf(this.value,t.split("/").filter(Boolean))}},bi=({bytes:t,cid:e,value:r,codec:n})=>{let o=r!==void 0?r:n&&n.decode(t);if(o===void 0)throw new Error('Missing required argument, must either provide "value" or "codec"');return new En({cid:e,bytes:t,value:o})};a();Q();a();var Nn=J(pt(),1);a();a();a();a();var ll=["string","number","bigint","symbol"],dl=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function Fi(t){if(t===null)return"null";if(t===void 0)return"undefined";if(t===!0||t===!1)return"boolean";let e=typeof t;return ll.includes(e)?e:e==="function"?"Function":Array.isArray(t)?"Array":hl(t)?"Buffer":pl(t)||"Object"}function hl(t){return t&&t.constructor&&t.constructor.isBuffer&&t.constructor.isBuffer.call(null,t)}function pl(t){let e=Object.prototype.toString.call(t).slice(8,-1);if(dl.includes(e))return e}a();var l=class{constructor(t,e,r){this.major=t,this.majorEncoded=t<<5,this.name=e,this.terminal=r}toString(){return`Type[${this.major}].${this.name}`}compare(t){return this.major<t.major?-1:this.major>t.major?1:0}};l.uint=new l(0,"uint",!0);l.negint=new l(1,"negint",!0);l.bytes=new l(2,"bytes",!0);l.string=new l(3,"string",!0);l.array=new l(4,"array",!1);l.map=new l(5,"map",!1);l.tag=new l(6,"tag",!1);l.float=new l(7,"float",!0);l.false=new l(7,"false",!0);l.true=new l(7,"true",!0);l.null=new l(7,"null",!0);l.undefined=new l(7,"undefined",!0);l.break=new l(7,"break",!0);var b=class{constructor(t,e,r){this.type=t,this.value=e,this.encodedLength=r,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}};a();a();var mt=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function",ml=new TextDecoder,yl=new TextEncoder;function pr(t){return mt&&globalThis.Buffer.isBuffer(t)}function Bn(t){return t instanceof Uint8Array?pr(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t:Uint8Array.from(t)}var Ni=mt?(t,e,r)=>r-e>64?globalThis.Buffer.from(t.subarray(e,r)).toString("utf8"):ki(t,e,r):(t,e,r)=>r-e>64?ml.decode(t.subarray(e,r)):ki(t,e,r),$i=mt?t=>t.length>64?globalThis.Buffer.from(t):vi(t):t=>t.length>64?yl.encode(t):vi(t),Ce=t=>Uint8Array.from(t),yt=mt?(t,e,r)=>pr(t)?new Uint8Array(t.subarray(e,r)):t.slice(e,r):(t,e,r)=>t.slice(e,r),Li=mt?(t,e)=>(t=t.map(r=>r instanceof Uint8Array?r:globalThis.Buffer.from(r)),Bn(globalThis.Buffer.concat(t,e))):(t,e)=>{let r=new Uint8Array(e),n=0;for(let o of t)n+o.length>r.length&&(o=o.subarray(0,r.length-n)),r.set(o,n),n+=o.length;return r},Pi=mt?t=>globalThis.Buffer.allocUnsafe(t):t=>new Uint8Array(t);function Ri(t,e){if(pr(t)&&pr(e))return t.compare(e);for(let r=0;r<t.length;r++)if(t[r]!==e[r])return t[r]<e[r]?-1:1;return 0}function vi(t,e=1/0){let r,n=t.length,o=null,i=[];for(let s=0;s<n;++s){if(r=t.charCodeAt(s),r>55295&&r<57344){if(!o){if(r>56319){(e-=3)>-1&&i.push(239,191,189);continue}else if(s+1===n){(e-=3)>-1&&i.push(239,191,189);continue}o=r;continue}if(r<56320){(e-=3)>-1&&i.push(239,191,189),o=r;continue}r=(o-55296<<10|r-56320)+65536}else o&&(e-=3)>-1&&i.push(239,191,189);if(o=null,r<128){if((e-=1)<0)break;i.push(r)}else if(r<2048){if((e-=2)<0)break;i.push(r>>6|192,r&63|128)}else if(r<65536){if((e-=3)<0)break;i.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((e-=4)<0)break;i.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return i}function ki(t,e,r){let n=[];for(;e<r;){let o=t[e],i=null,s=o>239?4:o>223?3:o>191?2:1;if(e+s<=r){let u,f,h,g;switch(s){case 1:o<128&&(i=o);break;case 2:u=t[e+1],(u&192)===128&&(g=(o&31)<<6|u&63,g>127&&(i=g));break;case 3:u=t[e+1],f=t[e+2],(u&192)===128&&(f&192)===128&&(g=(o&15)<<12|(u&63)<<6|f&63,g>2047&&(g<55296||g>57343)&&(i=g));break;case 4:u=t[e+1],f=t[e+2],h=t[e+3],(u&192)===128&&(f&192)===128&&(h&192)===128&&(g=(o&15)<<18|(u&63)<<12|(f&63)<<6|h&63,g>65535&&g<1114112&&(i=g))}}i===null?(i=65533,s=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|i&1023),n.push(i),e+=s}return wl(n)}var _i=4096;function wl(t){let e=t.length;if(e<=_i)return String.fromCharCode.apply(String,t);let r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=_i));return r}var gl=256,Ot=class{constructor(t=gl){this.chunkSize=t,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),this._initReuseChunk!==null&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(t){let e=this.chunks[this.chunks.length-1];if(this.cursor+t.length<=this.maxCursor+1){let r=e.length-(this.maxCursor-this.cursor)-1;e.set(t,r)}else{if(e){let r=e.length-(this.maxCursor-this.cursor)-1;r<e.length&&(this.chunks[this.chunks.length-1]=e.subarray(0,r),this.maxCursor=this.cursor-1)}t.length<64&&t.length<this.chunkSize?(e=Pi(this.chunkSize),this.chunks.push(e),this.maxCursor+=e.length,this._initReuseChunk===null&&(this._initReuseChunk=e),e.set(t,0)):(this.chunks.push(t),this.maxCursor+=t.length)}this.cursor+=t.length}toBytes(t=!1){let e;if(this.chunks.length===1){let r=this.chunks[0];t&&this.cursor>r.length/2?(e=this.cursor===r.length?r:r.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):e=yt(r,0,this.cursor)}else e=Li(this.chunks,this.cursor);return t&&this.reset(),e}};a();var C="CBOR decode error:",An="CBOR encode error:";function Fe(t,e,r){if(t.length-e<r)throw new Error(`${C} not enough data for type`)}a();a();var z=[24,256,65536,4294967296,BigInt("18446744073709551616")];function ee(t,e,r){Fe(t,e,1);let n=t[e];if(r.strict===!0&&n<z[0])throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);return n}function te(t,e,r){Fe(t,e,2);let n=t[e]<<8|t[e+1];if(r.strict===!0&&n<z[1])throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);return n}function re(t,e,r){Fe(t,e,4);let n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3];if(r.strict===!0&&n<z[2])throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);return n}function ne(t,e,r){Fe(t,e,8);let n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3],o=t[e+4]*16777216+(t[e+5]<<16)+(t[e+6]<<8)+t[e+7],i=(BigInt(n)<<BigInt(32))+BigInt(o);if(r.strict===!0&&i<z[3])throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);if(i<=Number.MAX_SAFE_INTEGER)return Number(i);if(r.allowBigInt===!0)return i;throw new Error(`${C} integers outside of the safe integer range are not supported`)}function Mi(t,e,r,n){return new b(l.uint,ee(t,e+1,n),2)}function Oi(t,e,r,n){return new b(l.uint,te(t,e+1,n),3)}function zi(t,e,r,n){return new b(l.uint,re(t,e+1,n),5)}function qi(t,e,r,n){return new b(l.uint,ne(t,e+1,n),9)}function ce(t,e){return H(t,0,e.value)}function H(t,e,r){if(r<z[0]){let n=Number(r);t.push([e|n])}else if(r<z[1]){let n=Number(r);t.push([e|24,n])}else if(r<z[2]){let n=Number(r);t.push([e|25,n>>>8,n&255])}else if(r<z[3]){let n=Number(r);t.push([e|26,n>>>24&255,n>>>16&255,n>>>8&255,n&255])}else{let n=BigInt(r);if(n<z[4]){let o=[e|27,0,0,0,0,0,0,0],i=Number(n&BigInt(4294967295)),s=Number(n>>BigInt(32)&BigInt(4294967295));o[8]=i&255,i=i>>8,o[7]=i&255,i=i>>8,o[6]=i&255,i=i>>8,o[5]=i&255,o[4]=s&255,s=s>>8,o[3]=s&255,s=s>>8,o[2]=s&255,s=s>>8,o[1]=s&255,t.push(o)}else throw new Error(`${C} encountered BigInt larger than allowable range`)}}ce.encodedSize=function(t){return H.encodedSize(t.value)};H.encodedSize=function(t){return t<z[0]?1:t<z[1]?2:t<z[2]?3:t<z[3]?5:9};ce.compareTokens=function(t,e){return t.value<e.value?-1:t.value>e.value?1:0};a();function Hi(t,e,r,n){return new b(l.negint,-1-ee(t,e+1,n),2)}function ji(t,e,r,n){return new b(l.negint,-1-te(t,e+1,n),3)}function Vi(t,e,r,n){return new b(l.negint,-1-re(t,e+1,n),5)}var Tn=BigInt(-1),Gi=BigInt(1);function Wi(t,e,r,n){let o=ne(t,e+1,n);if(typeof o!="bigint"){let i=-1-o;if(i>=Number.MIN_SAFE_INTEGER)return new b(l.negint,i,9)}if(n.allowBigInt!==!0)throw new Error(`${C} integers outside of the safe integer range are not supported`);return new b(l.negint,Tn-BigInt(o),9)}function mr(t,e){let r=e.value,n=typeof r=="bigint"?r*Tn-Gi:r*-1-1;H(t,e.type.majorEncoded,n)}mr.encodedSize=function(t){let e=t.value,r=typeof e=="bigint"?e*Tn-Gi:e*-1-1;return r<z[0]?1:r<z[1]?2:r<z[2]?3:r<z[3]?5:9};mr.compareTokens=function(t,e){return t.value<e.value?1:t.value>e.value?-1:0};a();function qt(t,e,r,n){Fe(t,e,r+n);let o=yt(t,e+r,e+r+n);return new b(l.bytes,o,r+n)}function Ji(t,e,r,n){return qt(t,e,1,r)}function Xi(t,e,r,n){return qt(t,e,2,ee(t,e+1,n))}function Yi(t,e,r,n){return qt(t,e,3,te(t,e+1,n))}function Qi(t,e,r,n){return qt(t,e,5,re(t,e+1,n))}function Zi(t,e,r,n){let o=ne(t,e+1,n);if(typeof o=="bigint")throw new Error(`${C} 64-bit integer bytes lengths not supported`);return qt(t,e,9,o)}function yr(t){return t.encodedBytes===void 0&&(t.encodedBytes=t.type===l.string?$i(t.value):t.value),t.encodedBytes}function wt(t,e){let r=yr(e);H(t,e.type.majorEncoded,r.length),t.push(r)}wt.encodedSize=function(t){let e=yr(t);return H.encodedSize(e.length)+e.length};wt.compareTokens=function(t,e){return bl(yr(t),yr(e))};function bl(t,e){return t.length<e.length?-1:t.length>e.length?1:Ri(t,e)}a();function Ht(t,e,r,n,o){let i=r+n;Fe(t,e,i);let s=new b(l.string,Ni(t,e+r,e+i),i);return o.retainStringBytes===!0&&(s.byteValue=yt(t,e+r,e+i)),s}function Ki(t,e,r,n){return Ht(t,e,1,r,n)}function es(t,e,r,n){return Ht(t,e,2,ee(t,e+1,n),n)}function ts(t,e,r,n){return Ht(t,e,3,te(t,e+1,n),n)}function rs(t,e,r,n){return Ht(t,e,5,re(t,e+1,n),n)}function ns(t,e,r,n){let o=ne(t,e+1,n);if(typeof o=="bigint")throw new Error(`${C} 64-bit integer string lengths not supported`);return Ht(t,e,9,o,n)}var os=wt;a();function gt(t,e,r,n){return new b(l.array,n,r)}function is(t,e,r,n){return gt(t,e,1,r)}function ss(t,e,r,n){return gt(t,e,2,ee(t,e+1,n))}function as(t,e,r,n){return gt(t,e,3,te(t,e+1,n))}function us(t,e,r,n){return gt(t,e,5,re(t,e+1,n))}function cs(t,e,r,n){let o=ne(t,e+1,n);if(typeof o=="bigint")throw new Error(`${C} 64-bit integer array lengths not supported`);return gt(t,e,9,o)}function fs(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${C} indefinite length items not allowed`);return gt(t,e,1,1/0)}function wr(t,e){H(t,l.array.majorEncoded,e.value)}wr.compareTokens=ce.compareTokens;wr.encodedSize=function(t){return H.encodedSize(t.value)};a();function Dt(t,e,r,n){return new b(l.map,n,r)}function ls(t,e,r,n){return Dt(t,e,1,r)}function ds(t,e,r,n){return Dt(t,e,2,ee(t,e+1,n))}function hs(t,e,r,n){return Dt(t,e,3,te(t,e+1,n))}function ps(t,e,r,n){return Dt(t,e,5,re(t,e+1,n))}function ms(t,e,r,n){let o=ne(t,e+1,n);if(typeof o=="bigint")throw new Error(`${C} 64-bit integer map lengths not supported`);return Dt(t,e,9,o)}function ys(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${C} indefinite length items not allowed`);return Dt(t,e,1,1/0)}function gr(t,e){H(t,l.map.majorEncoded,e.value)}gr.compareTokens=ce.compareTokens;gr.encodedSize=function(t){return H.encodedSize(t.value)};a();function ws(t,e,r,n){return new b(l.tag,r,1)}function gs(t,e,r,n){return new b(l.tag,ee(t,e+1,n),2)}function Ds(t,e,r,n){return new b(l.tag,te(t,e+1,n),3)}function bs(t,e,r,n){return new b(l.tag,re(t,e+1,n),5)}function Es(t,e,r,n){return new b(l.tag,ne(t,e+1,n),9)}function Dr(t,e){H(t,l.tag.majorEncoded,e.value)}Dr.compareTokens=ce.compareTokens;Dr.encodedSize=function(t){return H.encodedSize(t.value)};a();var Tl=20,Il=21,Sl=22,Ul=23;function xs(t,e,r,n){if(n.allowUndefined===!1)throw new Error(`${C} undefined values are not supported`);return n.coerceUndefinedToNull===!0?new b(l.null,null,1):new b(l.undefined,void 0,1)}function Cs(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${C} indefinite length items not allowed`);return new b(l.break,void 0,1)}function In(t,e,r){if(r){if(r.allowNaN===!1&&Number.isNaN(t))throw new Error(`${C} NaN values are not supported`);if(r.allowInfinity===!1&&(t===1/0||t===-1/0))throw new Error(`${C} Infinity values are not supported`)}return new b(l.float,t,e)}function Bs(t,e,r,n){return In(Sn(t,e+1),3,n)}function As(t,e,r,n){return In(Un(t,e+1),5,n)}function Ts(t,e,r,n){return In(Fs(t,e+1),9,n)}function br(t,e,r){let n=e.value;if(n===!1)t.push([l.float.majorEncoded|Tl]);else if(n===!0)t.push([l.float.majorEncoded|Il]);else if(n===null)t.push([l.float.majorEncoded|Sl]);else if(n===void 0)t.push([l.float.majorEncoded|Ul]);else{let o,i=!1;(!r||r.float64!==!0)&&(Ss(n),o=Sn(me,1),n===o||Number.isNaN(n)?(me[0]=249,t.push(me.slice(0,3)),i=!0):(Us(n),o=Un(me,1),n===o&&(me[0]=250,t.push(me.slice(0,5)),i=!0))),i||(Fl(n),o=Fs(me,1),me[0]=251,t.push(me.slice(0,9)))}}br.encodedSize=function(t,e){let r=t.value;if(r===!1||r===!0||r===null||r===void 0)return 1;if(!e||e.float64!==!0){Ss(r);let n=Sn(me,1);if(r===n||Number.isNaN(r))return 3;if(Us(r),n=Un(me,1),r===n)return 5}return 9};var Is=new ArrayBuffer(9),fe=new DataView(Is,1),me=new Uint8Array(Is,0);function Ss(t){if(t===1/0)fe.setUint16(0,31744,!1);else if(t===-1/0)fe.setUint16(0,64512,!1);else if(Number.isNaN(t))fe.setUint16(0,32256,!1);else{fe.setFloat32(0,t);let e=fe.getUint32(0),r=(e&2139095040)>>23,n=e&8388607;if(r===255)fe.setUint16(0,31744,!1);else if(r===0)fe.setUint16(0,(t&2147483648)>>16|n>>13,!1);else{let o=r-127;o<-24?fe.setUint16(0,0):o<-14?fe.setUint16(0,(e&2147483648)>>16|1<<24+o,!1):fe.setUint16(0,(e&2147483648)>>16|o+15<<10|n>>13,!1)}}}function Sn(t,e){if(t.length-e<2)throw new Error(`${C} not enough data for float16`);let r=(t[e]<<8)+t[e+1];if(r===31744)return 1/0;if(r===64512)return-1/0;if(r===32256)return NaN;let n=r>>10&31,o=r&1023,i;return n===0?i=o*2**-24:n!==31?i=(o+1024)*2**(n-25):i=o===0?1/0:NaN,r&32768?-i:i}function Us(t){fe.setFloat32(0,t,!1)}function Un(t,e){if(t.length-e<4)throw new Error(`${C} not enough data for float32`);let r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,4).getFloat32(0,!1)}function Fl(t){fe.setFloat64(0,t,!1)}function Fs(t,e){if(t.length-e<8)throw new Error(`${C} not enough data for float64`);let r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,8).getFloat64(0,!1)}br.compareTokens=ce.compareTokens;function U(t,e,r){throw new Error(`${C} encountered invalid minor (${r}) for major ${t[e]>>>5}`)}function Er(t){return()=>{throw new Error(`${C} ${t}`)}}var D=[];for(let t=0;t<=23;t++)D[t]=U;D[24]=Mi;D[25]=Oi;D[26]=zi;D[27]=qi;D[28]=U;D[29]=U;D[30]=U;D[31]=U;for(let t=32;t<=55;t++)D[t]=U;D[56]=Hi;D[57]=ji;D[58]=Vi;D[59]=Wi;D[60]=U;D[61]=U;D[62]=U;D[63]=U;for(let t=64;t<=87;t++)D[t]=Ji;D[88]=Xi;D[89]=Yi;D[90]=Qi;D[91]=Zi;D[92]=U;D[93]=U;D[94]=U;D[95]=Er("indefinite length bytes/strings are not supported");for(let t=96;t<=119;t++)D[t]=Ki;D[120]=es;D[121]=ts;D[122]=rs;D[123]=ns;D[124]=U;D[125]=U;D[126]=U;D[127]=Er("indefinite length bytes/strings are not supported");for(let t=128;t<=151;t++)D[t]=is;D[152]=ss;D[153]=as;D[154]=us;D[155]=cs;D[156]=U;D[157]=U;D[158]=U;D[159]=fs;for(let t=160;t<=183;t++)D[t]=ls;D[184]=ds;D[185]=hs;D[186]=ps;D[187]=ms;D[188]=U;D[189]=U;D[190]=U;D[191]=ys;for(let t=192;t<=215;t++)D[t]=ws;D[216]=gs;D[217]=Ds;D[218]=bs;D[219]=Es;D[220]=U;D[221]=U;D[222]=U;D[223]=U;for(let t=224;t<=243;t++)D[t]=Er("simple values are not supported");D[244]=U;D[245]=U;D[246]=U;D[247]=xs;D[248]=Er("simple values are not supported");D[249]=Bs;D[250]=As;D[251]=Ts;D[252]=U;D[253]=U;D[254]=U;D[255]=Cs;var ye=[];for(let t=0;t<24;t++)ye[t]=new b(l.uint,t,1);for(let t=-1;t>=-24;t--)ye[31-t]=new b(l.negint,t,1);ye[64]=new b(l.bytes,new Uint8Array(0),1);ye[96]=new b(l.string,"",1);ye[128]=new b(l.array,0,1);ye[160]=new b(l.map,0,1);ye[244]=new b(l.false,!1,1);ye[245]=new b(l.true,!0,1);ye[246]=new b(l.null,null,1);function vs(t){switch(t.type){case l.false:return Ce([244]);case l.true:return Ce([245]);case l.null:return Ce([246]);case l.bytes:return t.value.length?void 0:Ce([64]);case l.string:return t.value===""?Ce([96]):void 0;case l.array:return t.value===0?Ce([128]):void 0;case l.map:return t.value===0?Ce([160]):void 0;case l.uint:return t.value<24?Ce([Number(t.value)]):void 0;case l.negint:if(t.value>=-24)return Ce([31-Number(t.value)])}}var kl={float64:!1,mapSorter:$l,quickEncodeToken:vs};function _l(){let t=[];return t[l.uint.major]=ce,t[l.negint.major]=mr,t[l.bytes.major]=wt,t[l.string.major]=os,t[l.array.major]=wr,t[l.map.major]=gr,t[l.tag.major]=Dr,t[l.float.major]=br,t}var ks=_l(),Fn=new Ot,bt=class{constructor(t,e){this.obj=t,this.parent=e}includes(t){let e=this;do if(e.obj===t)return!0;while(e=e.parent);return!1}static createCheck(t,e){if(t&&t.includes(e))throw new Error(`${An} object contains circular references`);return new bt(e,t)}},Oe={null:new b(l.null,null),undefined:new b(l.undefined,void 0),true:new b(l.true,!0),false:new b(l.false,!1),emptyArray:new b(l.array,0),emptyMap:new b(l.map,0)},ze={number(t,e,r,n){return!Number.isInteger(t)||!Number.isSafeInteger(t)?new b(l.float,t):t>=0?new b(l.uint,t):new b(l.negint,t)},bigint(t,e,r,n){return t>=BigInt(0)?new b(l.uint,t):new b(l.negint,t)},Uint8Array(t,e,r,n){return new b(l.bytes,t)},string(t,e,r,n){return new b(l.string,t)},boolean(t,e,r,n){return t?Oe.true:Oe.false},null(t,e,r,n){return Oe.null},undefined(t,e,r,n){return Oe.undefined},ArrayBuffer(t,e,r,n){return new b(l.bytes,new Uint8Array(t))},DataView(t,e,r,n){return new b(l.bytes,new Uint8Array(t.buffer,t.byteOffset,t.byteLength))},Array(t,e,r,n){if(!t.length)return r.addBreakTokens===!0?[Oe.emptyArray,new b(l.break)]:Oe.emptyArray;n=bt.createCheck(n,t);let o=[],i=0;for(let s of t)o[i++]=xr(s,r,n);return r.addBreakTokens?[new b(l.array,t.length),o,new b(l.break)]:[new b(l.array,t.length),o]},Object(t,e,r,n){let o=e!=="Object",i=o?t.keys():Object.keys(t),s=o?t.size:i.length;if(!s)return r.addBreakTokens===!0?[Oe.emptyMap,new b(l.break)]:Oe.emptyMap;n=bt.createCheck(n,t);let u=[],f=0;for(let h of i)u[f++]=[xr(h,r,n),xr(o?t.get(h):t[h],r,n)];return Nl(u,r),r.addBreakTokens?[new b(l.map,s),u,new b(l.break)]:[new b(l.map,s),u]}};ze.Map=ze.Object;ze.Buffer=ze.Uint8Array;for(let t of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))ze[`${t}Array`]=ze.DataView;function xr(t,e={},r){let n=Fi(t),o=e&&e.typeEncoders&&e.typeEncoders[n]||ze[n];if(typeof o=="function"){let s=o(t,n,e,r);if(s!=null)return s}let i=ze[n];if(!i)throw new Error(`${An} unsupported type: ${n}`);return i(t,n,e,r)}function Nl(t,e){e.mapSorter&&t.sort(e.mapSorter)}function $l(t,e){let r=Array.isArray(t[0])?t[0][0]:t[0],n=Array.isArray(e[0])?e[0][0]:e[0];if(r.type!==n.type)return r.type.compare(n.type);let o=r.type.major,i=ks[o].compareTokens(r,n);return i===0&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),i}function _s(t,e,r,n){if(Array.isArray(e))for(let o of e)_s(t,o,r,n);else r[e.type.major](t,e,n)}function Ll(t,e,r){let n=xr(t,r);if(!Array.isArray(n)&&r.quickEncodeToken){let o=r.quickEncodeToken(n);if(o)return o;let i=e[n.type.major];if(i.encodedSize){let s=i.encodedSize(n,r),u=new Ot(s);if(i(u,n,r),u.chunks.length!==1)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return Bn(u.chunks[0])}}return Fn.reset(),_s(Fn,n,e,r),Fn.toBytes(!0)}function vn(t,e){return e=Object.assign({},kl,e),Ll(t,ks,e)}a();var Pl={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0},kn=class{constructor(t,e={}){this.pos=0,this.data=t,this.options=e}done(){return this.pos>=this.data.length}next(){let t=this.data[this.pos],e=ye[t];if(e===void 0){let r=D[t];if(!r)throw new Error(`${C} no decoder for major type ${t>>>5} (byte 0x${t.toString(16).padStart(2,"0")})`);let n=t&31;e=r(this.data,this.pos,n,this.options)}return this.pos+=e.encodedLength,e}},jt=Symbol.for("DONE"),Cr=Symbol.for("BREAK");function Rl(t,e,r){let n=[];for(let o=0;o<t.value;o++){let i=Vt(e,r);if(i===Cr){if(t.value===1/0)break;throw new Error(`${C} got unexpected break to lengthed array`)}if(i===jt)throw new Error(`${C} found array but not enough entries (got ${o}, expected ${t.value})`);n[o]=i}return n}function Ml(t,e,r){let n=r.useMaps===!0,o=n?void 0:{},i=n?new Map:void 0;for(let s=0;s<t.value;s++){let u=Vt(e,r);if(u===Cr){if(t.value===1/0)break;throw new Error(`${C} got unexpected break to lengthed map`)}if(u===jt)throw new Error(`${C} found map but not enough entries (got ${s} [no key], expected ${t.value})`);if(n!==!0&&typeof u!="string")throw new Error(`${C} non-string keys not supported (got ${typeof u})`);let f=Vt(e,r);if(f===jt)throw new Error(`${C} found map but not enough entries (got ${s} [no value], expected ${t.value})`);n?i.set(u,f):o[u]=f}return n?i:o}function Vt(t,e){if(t.done())return jt;let r=t.next();if(r.type===l.break)return Cr;if(r.type.terminal)return r.value;if(r.type===l.array)return Rl(r,t,e);if(r.type===l.map)return Ml(r,t,e);if(r.type===l.tag){if(e.tags&&typeof e.tags[r.value]=="function"){let n=Vt(t,e);return e.tags[r.value](n)}throw new Error(`${C} tag not supported (${r.value})`)}throw new Error("unsupported")}function _n(t,e){if(!(t instanceof Uint8Array))throw new Error(`${C} data to decode must be a Uint8Array`);e=Object.assign({},Pl,e);let r=e.tokenizer||new kn(t,e),n=Vt(r,e);if(n===jt)throw new Error(`${C} did not find any content to decode`);if(n===Cr)throw new Error(`${C} got unexpected break`);if(!r.done())throw new Error(`${C} too many terminals, data makes no sense`);return n}Q();var Ns=42;function zl(t){if(t.asCID!==t)return null;let e=x.asCID(t);if(!e)return null;let r=new Uint8Array(e.bytes.byteLength+1);return r.set(e.bytes,1),[new b(l.tag,Ns),new b(l.bytes,r)]}function ql(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function Hl(t){if(Number.isNaN(t))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(t===1/0||t===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}var jl={float64:!0,typeEncoders:{Object:zl,undefined:ql,number:Hl}};function Vl(t){if(t[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return x.decode(t.subarray(1))}var $s={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};$s.tags[Ns]=Vl;var Ls=t=>vn(t,jl),Ps=t=>_n(t,$s);function $n(t){let e=Ls({version:1,roots:t}),r=Nn.default.encode(e.length),n=new Uint8Array(r.length+e.length);return n.set(r,0),n.set(e,r.length),n}function Rs(t){return{async setRoots(e){let r=$n(e);await t.write(r)},async writeBlock(e){let{cid:r,bytes:n}=e;await t.write(new Uint8Array(Nn.default.encode(r.bytes.length+n.length))),await t.write(r.bytes),n.length&&await t.write(n)},async close(){await t.end()}}}a();function Br(){}function Ms(){let t=[],e=null,r=Br,n=!1,o=null,i=Br,s=()=>(e||(e=new Promise(h=>{r=()=>{e=null,r=Br,h()}})),e),u={write(h){t.push(h);let g=s();return i(),g},async end(){n=!0;let h=s();i(),await h}},f={async next(){let h=t.shift();return h?(t.length===0&&r(),{done:!1,value:h}):n?(r(),{done:!0,value:void 0}):(o||(o=new Promise(g=>{i=()=>(o=null,i=Br,g(f.next()))})),o)}};return{writer:u,iterator:f}}a();var He=J(pt(),1);Q();Le();a();var qe={Null:t=>t===null,Int:t=>Number.isInteger(t),Float:t=>typeof t=="number"&&Number.isFinite(t),String:t=>typeof t=="string",Bool:t=>typeof t=="boolean",Bytes:t=>t instanceof Uint8Array,Link:t=>!qe.Null(t)&&typeof t=="object"&&t.asCID===t,List:t=>Array.isArray(t),Map:t=>!qe.Null(t)&&typeof t=="object"&&t.asCID!==t&&!qe.List(t)&&!qe.Bytes(t)},Et={Int:qe.Int,"CarHeader > version":t=>Et.Int(t),"CarHeader > roots (anon) > valueType (anon)":qe.Link,"CarHeader > roots (anon)":t=>qe.List(t)&&Array.prototype.every.call(t,Et["CarHeader > roots (anon) > valueType (anon)"]),"CarHeader > roots":t=>Et["CarHeader > roots (anon)"](t),CarHeader:t=>{let e=t&&Object.keys(t);return qe.Map(t)&&["version"].every(r=>e.includes(r))&&Object.entries(t).every(([r,n])=>Et["CarHeader > "+r]&&Et["CarHeader > "+r](n))}},Os=Et.CarHeader,Ln={SHA2_256:18,LENGTH:32,DAG_PB:112},zs=16+8+8+8;async function Ar(t){let e=await t.upTo(8);if(!e.length)throw new Error("Unexpected end of data");let r=He.default.decode(e);return t.seek(He.default.decode.bytes),r}async function Gl(t){let e=await t.exactly(zs),r=new DataView(e.buffer,e.byteOffset,e.byteLength),n=0,o={version:2,characteristics:[r.getBigUint64(n,!0),r.getBigUint64(n+=8,!0)],dataOffset:Number(r.getBigUint64(n+=8,!0)),dataSize:Number(r.getBigUint64(n+=8,!0)),indexOffset:Number(r.getBigUint64(n+=8,!0))};return t.seek(zs),o}async function Tr(t,e){let r=await Ar(t);if(r===0)throw new Error("Invalid CAR header (zero length)");let n=await t.exactly(r);t.seek(r);let o=Ps(n);if(!Os(o))throw new Error("Invalid CAR header format");if(o.version!==1&&o.version!==2||e!==void 0&&o.version!==e)throw new Error(`Invalid CAR version: ${o.version}${e!==void 0?` (expected ${e})`:""}`);let i=Array.isArray(o.roots);if(o.version===1&&!i||o.version===2&&i)throw new Error("Invalid CAR header format");if(o.version===1)return o;let s=await Gl(t);t.seek(s.dataOffset-t.pos);let u=await Tr(t,1);return Object.assign(u,s)}async function Wl(t){let e=await t.upTo(8);He.default.decode(e);let r=He.default.decode.bytes,n=He.default.decode(e.subarray(He.default.decode.bytes)),o=He.default.decode.bytes,i=r+o+n,s=await t.exactly(i);return t.seek(i),s}async function Jl(t){let e=await t.exactly(2);if(e[0]===Ln.SHA2_256&&e[1]===Ln.LENGTH){let s=await t.exactly(34);t.seek(34);let u=ft(s);return x.create(0,Ln.DAG_PB,u)}let r=await Ar(t);if(r!==1)throw new Error(`Unexpected CID version (${r})`);let n=await Ar(t),o=await Wl(t),i=ft(o);return x.create(r,n,i)}async function qs(t){let e=t.pos,r=await Ar(t);if(r===0)throw new Error("Invalid CAR section (zero length)");r+=t.pos-e;let n=await Jl(t),o=r-Number(t.pos-e);return{cid:n,length:r,blockLength:o}}async function Xl(t){let{cid:e,blockLength:r}=await qs(t),n=await t.exactly(r);return t.seek(r),{bytes:n,cid:e}}async function Yl(t){let e=t.pos,{cid:r,length:n,blockLength:o}=await qs(t),i={cid:r,length:n,blockLength:o,offset:e,blockOffset:t.pos};return t.seek(i.blockLength),i}function Hs(t){let e=(async()=>{let r=await Tr(t);if(r.version===2){let n=t.pos-r.dataOffset;t=Zl(t,r.dataSize-n)}return r})();return{header:()=>e,async*blocks(){for(await e;(await t.upTo(8)).length>0;)yield await Xl(t)},async*blocksIndex(){for(await e;(await t.upTo(8)).length>0;)yield await Yl(t)}}}function Ir(t){let e=0;return{async upTo(r){return t.subarray(e,e+Math.min(r,t.length-e))},async exactly(r){if(r>t.length-e)throw new Error("Unexpected end of data");return t.subarray(e,e+r)},seek(r){e+=r},get pos(){return e}}}function Ql(t){let e=0,r=0,n=0,o=new Uint8Array(0),i=async s=>{r=o.length-n;let u=[o.subarray(n)];for(;r<s;){let h=await t();if(h==null)break;r<0?h.length>r&&u.push(h.subarray(-r)):u.push(h),r+=h.length}o=new Uint8Array(u.reduce((h,g)=>h+g.length,0));let f=0;for(let h of u)o.set(h,f),f+=h.length;n=0};return{async upTo(s){return o.length-n<s&&await i(s),o.subarray(n,n+Math.min(o.length-n,s))},async exactly(s){if(o.length-n<s&&await i(s),o.length-n<s)throw new Error("Unexpected end of data");return o.subarray(n,n+s)},seek(s){e+=s,n+=s},get pos(){return e}}}function js(t){let e=t[Symbol.asyncIterator]();async function r(){let n=await e.next();return n.done?null:n.value}return Ql(r)}function Zl(t,e){let r=0;return{async upTo(n){let o=await t.upTo(n);return o.length+r>e&&(o=o.subarray(0,e-r)),o},async exactly(n){let o=await t.exactly(n);if(o.length+r>e)throw new Error("Unexpected end of data");return o},seek(n){r+=n,t.seek(n)},get pos(){return t.pos}}}var Qe=class{constructor(t,e){this._encoder=e,this._mutex=e.setRoots(t),this._ended=!1}async put(t){if(!(t.bytes instanceof Uint8Array)||!t.cid)throw new TypeError("Can only write {cid, bytes} objects");if(this._ended)throw new Error("Already closed");let e=x.asCID(t.cid);if(!e)throw new TypeError("Can only write {cid, bytes} objects");return this._mutex=this._mutex.then(()=>this._encoder.writeBlock({cid:e,bytes:t.bytes})),this._mutex}async close(){if(this._ended)throw new Error("Already closed");return await this._mutex,this._ended=!0,this._encoder.close()}static create(t){t=Kl(t);let{encoder:e,iterator:r}=Vs(),n=new Qe(t,e),o=new Sr(r);return{writer:n,out:o}}static createAppender(){let{encoder:t,iterator:e}=Vs();t.setRoots=()=>Promise.resolve();let r=new Qe([],t),n=new Sr(e);return{writer:r,out:n}}static async updateRootsInBytes(t,e){let r=Ir(t);await Tr(r);let n=$n(e);if(Number(r.pos)!==n.length)throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${r.pos} bytes, new header is ${n.length} bytes)`);return t.set(n,0),t}},Sr=class{constructor(t){this._iterator=t}[Symbol.asyncIterator](){if(this._iterating)throw new Error("Multiple iterator not supported");return this._iterating=!0,this._iterator}};function Vs(){let t=Ms(),{writer:e,iterator:r}=t;return{encoder:Rs(e),iterator:r}}function Kl(t){if(t===void 0)return[];if(!Array.isArray(t)){let r=x.asCID(t);if(!r)throw new TypeError("roots must be a single CID or an array of CIDs");return[r]}let e=[];for(let r of t){let n=x.asCID(r);if(!n)throw new TypeError("roots must be a single CID or an array of CIDs");e.push(n)}return e}a();var na=J(Zs(),1),oa=J(ea(),1);a();var rd=/(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;T.nanosecond=T.ns=1/1e6;T.\u00B5s=T.\u03BCs=T.us=T.microsecond=1/1e3;T.millisecond=T.ms=T[""]=1;T.second=T.sec=T.s=T.ms*1e3;T.minute=T.min=T.m=T.s*60;T.hour=T.hr=T.h=T.m*60;T.day=T.d=T.h*24;T.week=T.wk=T.w=T.d*7;T.month=T.b=T.d*(365.25/12);T.year=T.yr=T.y=T.d*365.25;function T(t="",e="ms"){var r=null;return t=(t+"").replace(/(\d)[,_](\d)/g,"$1$2"),t.replace(rd,function(n,o,i){i=ta(i),i&&(r=(r||0)+parseFloat(o,10)*i)}),r&&r/(ta(e)||1)}function ta(t){return T[t]||T[t.toLowerCase().replace(/s$/,"")]}var ra=T;a();var ve=class extends Error{constructor(t="request timed out"){super(t),this.name="TimeoutError",this.code=ve.code}};ve.code="ERR_TIMEOUT";function le(t,e){return(...r)=>{let n=r[e!=null?e:r.length-1];if(!n||!n.timeout)return t(...r);let o=typeof n.timeout=="string"?ra(n.timeout):n.timeout,i=new na.TimeoutController(o);n.signal=(0,oa.anySignal)([n.signal,i.signal]);let s=t(...r),u=new Promise((g,$)=>{i.signal.addEventListener("abort",()=>{$(new ve)})}),f=Date.now(),h=()=>{if(i.signal.aborted)throw new ve;if(Date.now()-f>o)throw i.abort(),new ve};return s[Symbol.asyncIterator]?async function*(){let g=s[Symbol.asyncIterator]();try{for(;;){let{value:$,done:E}=await Promise.race([g.next(),u]);if(E)break;h(),yield $}}catch($){throw h(),$}finally{i.clear(),g.return&&g.return()}}():(async()=>{try{let g=await Promise.race([s,u]);return h(),g}catch(g){throw h(),g}finally{i.clear()}})()}}a();var Be=J(ca(),1);Re();ht();zn();Be.default.formatters.b=t=>t==null?"undefined":Y.baseEncode(t);Be.default.formatters.t=t=>t==null?"undefined":Me.baseEncode(t);Be.default.formatters.m=t=>t==null?"undefined":Mn.baseEncode(t);Be.default.formatters.p=t=>t==null?"undefined":t.toString();Be.default.formatters.c=t=>t==null?"undefined":t.toString();Be.default.formatters.k=t=>t==null?"undefined":t.toString();function kr(t){return Object.assign((0,Be.default)(t),{error:(0,Be.default)(`${t}:error`),trace:(0,Be.default)(`${t}:trace`)})}qn();Hn();a();Re();var jn=async({cid:t,load:e,seen:r})=>{r=r||new Set;let n=t.toString(Y);if(r.has(n))return;let o=await e(t);if(r.add(n),o!==null)for(let[,i]of o.links())await jn({cid:i,load:e,seen:r})},pa=kr("ipfs:components:dag:import"),gd=[fa,da];function ma({repo:t,preload:e,codecs:r}){async function*n(o,i={}){i.preload!==!1&&e(o);let s=x.asCID(o);if(!s)throw new Error(`Unexpected error converting CID type: ${o}`);pa(`Exporting ${s} as car`);let{writer:u,out:f}=await Qe.create([s]),h=null;(async()=>{try{let g=Dd(t,u,{signal:i.signal,timeout:i.timeout},r);await jn({cid:s,load:g})}catch(g){h=g}finally{u.close()}})();for await(let g of f){if(h)break;yield g}if(h)throw h}return le(n)}function Dd(t,e,r,n){return async o=>{let i=await n.getCodec(o.code);if(!i)throw new Error(`Can't decode links in block with codec 0x${o.code.toString(16)} to form complete DAG`);let s=await t.blocks.get(o,r);return pa(`Adding block ${o} to car`),await e.put({cid:o,bytes:s}),gd.includes(o.code)?null:bi({bytes:s,cid:o,codec:i})}}a();var ic=J(wa(),1),sc=J(Da(),1);a();J(Ku(),1);Q();a();a();a();var ec=(t=21)=>crypto.getRandomValues(new Uint8Array(t)).reduce((e,r)=>(r&=63,r<36?e+=r.toString(36):r<62?e+=(r-26).toString(36).toUpperCase():r>62?e+="-":e+="_",e),"");Ke();fo();var ke="/",tc=new TextEncoder().encode(ke),Vr=tc[0],G=class{constructor(t,e){if(typeof t=="string")this._buf=co(t);else if(t instanceof Uint8Array)this._buf=t;else throw new Error("Invalid key, should be String of Uint8Array");if(e==null&&(e=!0),e&&this.clean(),this._buf.byteLength===0||this._buf[0]!==Vr)throw new Error("Invalid key")}toString(t="utf8"){return so(this._buf,t)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(t){return new G(t.join(ke))}static random(){return new G(ec().replace(/-/g,""))}static asKey(t){return t instanceof Uint8Array||typeof t=="string"?new G(t):t.uint8Array?new G(t.uint8Array()):null}clean(){if((!this._buf||this._buf.byteLength===0)&&(this._buf=tc),this._buf[0]!==Vr){let t=new Uint8Array(this._buf.byteLength+1);t.fill(Vr,0,1),t.set(this._buf,1),this._buf=t}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===Vr;)this._buf=this._buf.subarray(0,-1)}less(t){let e=this.list(),r=t.list();for(let n=0;n<e.length;n++){if(r.length<n+1)return!1;let o=e[n],i=r[n];if(o<i)return!0;if(o>i)return!1}return e.length<r.length}reverse(){return G.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){let t=this.namespaces();return t[t.length-1]}list(){return this.toString().split(ke).slice(1)}type(){return Lh(this.baseNamespace())}name(){return Ph(this.baseNamespace())}instance(t){return new G(this.toString()+":"+t)}path(){let t=this.parent().toString();return t.endsWith(ke)||(t+=ke),t+=this.type(),new G(t)}parent(){let t=this.list();return t.length===1?new G(ke):new G(t.slice(0,-1).join(ke))}child(t){return this.toString()===ke?t:t.toString()===ke?this:new G(this.toString()+t.toString(),!1)}isAncestorOf(t){return t.toString()===this.toString()?!1:t.toString().startsWith(this.toString())}isDecendantOf(t){return t.toString()===this.toString()?!1:this.toString().startsWith(t.toString())}isTopLevel(){return this.list().length===1}concat(...t){return G.withNamespaces([...this.namespaces(),...Rh(t.map(e=>e.namespaces()))])}};function Lh(t){let e=t.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function Ph(t){let e=t.split(":");return e[e.length-1]}function Rh(t){return[].concat(...t)}var _o=J(Yt(),1);a();Q();var ko=J(Yt(),1),rc="/ipfs/";function Gr(t){if(t instanceof Uint8Array)try{t=x.decode(t)}catch(o){throw(0,ko.default)(o,"ERR_INVALID_CID")}let e=x.asCID(t);if(e)return{cid:e,path:void 0};t=t.toString(),t.startsWith(rc)&&(t=t.substring(rc.length));let r=t.split("/"),n;try{e=x.parse(r.shift()||"")}catch(o){throw(0,ko.default)(o,"ERR_INVALID_CID")}return r.length&&(n=`/${r.join("/")}`),{cid:e,path:n}}a();Q();a();new TextDecoder;a();new TextEncoder;a();Q();new TextEncoder;var nc=112;new G("/local/filesroot");var oc=async function(t,e,r,n={}){let{cid:o,path:i}=Gr(r);i&&(n.path=i);let s=o,u=n.path||"";if(u.startsWith("/")&&(u=u.substring(1)),n.path)try{for await(let{value:f,remainderPath:h}of Wr(o,n.path,e,t,{signal:n.signal})){if(!x.asCID(f))break;u=h,s=f}}catch(f){throw f.message.startsWith("Object has no property")&&(f.message=`no link named "${u.split("/")[0]}" under ${s}`,f.code="ERR_NO_LINK"),f}return{cid:s,remainderPath:u||""}},Wr=async function*(t,e,r,n,o){let i=async h=>{let g=await r.getCodec(h.code),$=await n.blocks.get(h,o);return g.decode($)},s=e.split("/").filter(Boolean),u=await i(t),f=t;for(;s.length;){let h=s.shift();if(!h)throw(0,_o.default)(new Error(`Could not resolve path "${e}"`),"ERR_INVALID_PATH");if(t.code===nc&&Array.isArray(u.Links)){let g=u.Links.find($=>$.Name===h);if(g){yield{value:g.Hash,remainderPath:s.join("/")},u=await i(g.Hash),f=g.Hash;continue}}if(Object.prototype.hasOwnProperty.call(u,h))u=u[h],yield{value:u,remainderPath:s.join("/")};else throw(0,_o.default)(new Error(`no link named "${h}" under ${f}`),"ERR_NO_LINK");x.asCID(u)&&(f=u,u=await i(u))}yield{value:u,remainderPath:""}},ac=J(Yt(),1);function uc({codecs:t,repo:e,preload:r}){return le(async function(n,o={}){if(o.preload!==!1&&r(n),o.path){let u=o.localResolve?await(0,ic.default)(Wr(n,o.path,t,e,o)):await(0,sc.default)(Wr(n,o.path,t,e,o));if(!u)throw(0,ac.default)(new Error("Not found"),"ERR_NOT_FOUND");return u}let i=await t.getCodec(n.code),s=await e.blocks.get(n,o);return{value:i.decode(s),remainderPath:""}})}a();a();var Jr=class{constructor(t,e,r){this._version=t,this._roots=e,this._iterable=r,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}},tt=class extends Jr{[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(t){let{version:e,roots:r,iterator:n}=await cc(t);return new tt(e,r,n)}static async fromIterable(t){let{version:e,roots:r,iterator:n}=await fc(t);return new tt(e,r,n)}};async function cc(t){if(!(t instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return lc(Ir(t))}async function fc(t){if(!t||typeof t[Symbol.asyncIterator]!="function")throw new TypeError("fromIterable() requires an async iterable");return lc(js(t))}async function lc(t){let e=Hs(t),{version:r,roots:n}=await e.header();return{version:r,roots:n,iterator:e.blocks()}}var gc=J(hc(),1),Dc=J(mc(),1),bc=J(wc(),1),Ec=kr("ipfs:components:dag:import");function xc({repo:t}){async function*e(r,n={}){let o=await t.gcLock.readLock();try{let i={signal:n.signal,timeout:n.timeout},s=(0,gc.default)(r),{value:u,done:f}=await s.peek();if(f)return;u&&s.push(u);let h;u instanceof Uint8Array?h=[s]:h=s;for await(let g of h){let $=await jh(t,i,g);if(n.pinRoots!==!1)for(let E of $){let A="";try{await t.blocks.has(E)?(Ec(`Pinning root ${E}`),await t.pins.pinRecursively(E)):A="blockstore: block not found"}catch(w){A=w.message}yield{root:{cid:E,pinErrorMsg:A}}}}}finally{o()}}return le(e)}async function jh(t,e,r){let n=await tt.fromIterable(r),o=await n.getRoots();return await(0,Dc.default)(t.blocks.putMany((0,bc.default)(n,({cid:i,bytes:s})=>(Ec(`Import block ${i}`),{key:i,value:s})),{signal:e.signal})),o}a();Q();function Cc({repo:t,codecs:e,hashers:r,preload:n}){async function o(i,s={}){let u=s.pin?await t.gcLock.readLock():null;try{let f=await e.getCodec(s.storeCodec||"dag-cbor");if(!f)throw new Error(`Unknown storeCodec ${s.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);if(s.inputCodec){if(!(i instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");let w=await e.getCodec(s.inputCodec);if(!w)throw new Error(`Unknown inputCodec ${s.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);i=w.decode(i)}let h=s.version!=null?s.version:1,g=await r.getHasher(s.hashAlg||"sha2-256");if(!g)throw new Error(`Unknown hash algorithm ${s.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);let $=f.encode(i),E=await g.digest($),A=x.create(h,f.code,E);return await t.blocks.put(A,$,{signal:s.signal}),s.pin&&await t.pins.pinRecursively(A),s.preload!==!1&&n(A),A}finally{u&&u()}}return le(o)}a();function Bc({repo:t,codecs:e,preload:r}){async function n(o,i={}){let{cid:s}=Gr(o);return i.preload!==!1&&r(s),oc(t,e,o,i)}return le(n)}var Ac=class{constructor({repo:t,codecs:e,hashers:r,preload:n}){this.export=ma({repo:t,preload:n,codecs:e}),this.get=uc({codecs:e,repo:t,preload:n}),this.import=xc({repo:t}),this.resolve=Bc({repo:t,codecs:e,preload:n}),this.put=Cc({repo:t,codecs:e,hashers:r,preload:n})}};/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*//*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */class JSONEncoder extends Array{constructor(){super(),this.inRecursive=[]}prefix(e){const r=this.inRecursive[this.inRecursive.length-1];r&&(r.type===Type.array&&(r.elements++,r.elements!==1&&e.push([44])),r.type===Type.map&&(r.elements++,r.elements!==1&&(r.elements%2===1?e.push([44]):e.push([58]))))}[Type.uint.major](e,r){this.prefix(e);const n=String(r.value),o=[];for(let i=0;i<n.length;i++)o[i]=n.charCodeAt(i);e.push(o)}[Type.negint.major](e,r){this[Type.uint.major](e,r)}[Type.bytes.major](e,r){throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)}[Type.string.major](e,r){this.prefix(e);const n=fromString$7(JSON.stringify(r.value));e.push(n.length>32?asU8A(n):n)}[Type.array.major](e,r){this.prefix(e),this.inRecursive.push({type:Type.array,elements:0}),e.push([91])}[Type.map.major](e,r){this.prefix(e),this.inRecursive.push({type:Type.map,elements:0}),e.push([123])}[Type.tag.major](e,r){}[Type.float.major](e,r){if(r.type.name==="break"){const s=this.inRecursive.pop();if(s){if(s.type===Type.array)e.push([93]);else if(s.type===Type.map)e.push([125]);else throw new Error("Unexpected recursive type; this should not happen!");return}throw new Error("Unexpected break; this should not happen!")}if(r.value===void 0)throw new Error(`${encodeErrPrefix} unsupported type: undefined`);if(this.prefix(e),r.type.name==="true"){e.push([116,114,117,101]);return}else if(r.type.name==="false"){e.push([102,97,108,115,101]);return}else if(r.type.name==="null"){e.push([110,117,108,108]);return}const n=String(r.value),o=[];let i=!1;for(let s=0;s<n.length;s++)o[s]=n.charCodeAt(s),!i&&(o[s]===46||o[s]===101||o[s]===69)&&(i=!0);i||(o.push(46),o.push(48)),e.push(o)}}function mapSorter(t,e){if(Array.isArray(t[0])||Array.isArray(e[0]))throw new Error(`${encodeErrPrefix} complex map keys are not supported`);const r=t[0],n=e[0];if(r.type!==Type.string||n.type!==Type.string)throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);if(r<n)return-1;if(r>n)return 1;throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)}const defaultEncodeOptions={addBreakTokens:!0,mapSorter};function encode$6(t,e){return e=Object.assign({},defaultEncodeOptions,e),encodeCustom(t,new JSONEncoder,e)}class Tokenizer{constructor(e,r={}){this.pos=0,this.data=e,this.options=r,this.modeStack=["value"],this.lastToken=""}done(){return this.pos>=this.data.length}ch(){return this.data[this.pos]}currentMode(){return this.modeStack[this.modeStack.length-1]}skipWhitespace(){let e=this.ch();for(;e===32||e===9||e===13||e===10;)e=this.data[++this.pos]}expect(e){if(this.data.length-this.pos<e.length)throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);for(let r=0;r<e.length;r++)if(this.data[this.pos++]!==e[r])throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...e)}'`)}parseNumber(){const e=this.pos;let r=!1,n=!1;const o=u=>{for(;!this.done();){const f=this.ch();if(u.includes(f))this.pos++;else break}};if(this.ch()===45&&(r=!0,this.pos++),this.ch()===48)if(this.pos++,this.ch()===46)this.pos++,n=!0;else return new Token(Type.uint,0,this.pos-e);if(o([48,49,50,51,52,53,54,55,56,57]),r&&this.pos===e+1)throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);if(!this.done()&&this.ch()===46){if(n)throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);n=!0,this.pos++,o([48,49,50,51,52,53,54,55,56,57])}!this.done()&&(this.ch()===101||this.ch()===69)&&(n=!0,this.pos++,!this.done()&&(this.ch()===43||this.ch()===45)&&this.pos++,o([48,49,50,51,52,53,54,55,56,57]));const i=String.fromCharCode.apply(null,this.data.subarray(e,this.pos)),s=parseFloat(i);return n?new Token(Type.float,s,this.pos-e):this.options.allowBigInt!==!0||Number.isSafeInteger(s)?new Token(s>=0?Type.uint:Type.negint,s,this.pos-e):new Token(s>=0?Type.uint:Type.negint,BigInt(i),this.pos-e)}parseString(){if(this.ch()!==34)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);this.pos++;for(let i=this.pos,s=0;i<this.data.length&&s<65536;i++,s++){const u=this.data[i];if(u===92||u<32||u>=128)break;if(u===34){const f=String.fromCharCode.apply(null,this.data.subarray(this.pos,i));return this.pos=i+1,new Token(Type.string,f,s)}}const e=this.pos,r=[],n=()=>{if(this.pos+4>=this.data.length)throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);let i=0;for(let s=0;s<4;s++){let u=this.ch();if(u>=48&&u<=57)u-=48;else if(u>=97&&u<=102)u=u-97+10;else if(u>=65&&u<=70)u=u-65+10;else throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);i=i*16+u,this.pos++}return i},o=()=>{const i=this.ch();let s=null,u=i>239?4:i>223?3:i>191?2:1;if(this.pos+u>this.data.length)throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);let f,h,g,$;switch(u){case 1:i<128&&(s=i);break;case 2:f=this.data[this.pos+1],(f&192)===128&&($=(i&31)<<6|f&63,$>127&&(s=$));break;case 3:f=this.data[this.pos+1],h=this.data[this.pos+2],(f&192)===128&&(h&192)===128&&($=(i&15)<<12|(f&63)<<6|h&63,$>2047&&($<55296||$>57343)&&(s=$));break;case 4:f=this.data[this.pos+1],h=this.data[this.pos+2],g=this.data[this.pos+3],(f&192)===128&&(h&192)===128&&(g&192)===128&&($=(i&15)<<18|(f&63)<<12|(h&63)<<6|g&63,$>65535&&$<1114112&&(s=$))}s===null?(s=65533,u=1):s>65535&&(s-=65536,r.push(s>>>10&1023|55296),s=56320|s&1023),r.push(s),this.pos+=u};for(;!this.done();){const i=this.ch();let s;switch(i){case 92:if(this.pos++,this.done())throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);switch(s=this.ch(),this.pos++,s){case 34:case 39:case 92:case 47:r.push(s);break;case 98:r.push(8);break;case 116:r.push(9);break;case 110:r.push(10);break;case 102:r.push(12);break;case 114:r.push(13);break;case 117:r.push(n());break;default:throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`)}break;case 34:return this.pos++,new Token(Type.string,decodeCodePointsArray(r),this.pos-e);default:if(i<32)throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);i<128?(r.push(i),this.pos++):o()}}throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`)}parseValue(){switch(this.ch()){case 123:return this.modeStack.push("obj-start"),this.pos++,new Token(Type.map,1/0,1);case 91:return this.modeStack.push("array-start"),this.pos++,new Token(Type.array,1/0,1);case 34:return this.parseString();case 110:return this.expect([110,117,108,108]),new Token(Type.null,null,4);case 102:return this.expect([102,97,108,115,101]),new Token(Type.false,!1,5);case 116:return this.expect([116,114,117,101]),new Token(Type.true,!0,4);case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.parseNumber();default:throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`)}}next(){switch(this.skipWhitespace(),this.currentMode()){case"value":return this.modeStack.pop(),this.parseValue();case"array-value":{if(this.modeStack.pop(),this.ch()===93)return this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);if(this.ch()!==44)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);return this.pos++,this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue()}case"array-start":return this.modeStack.pop(),this.ch()===93?(this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1)):(this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue());case"obj-key":if(this.ch()===125)return this.modeStack.pop(),this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);if(this.ch()!==44)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);this.pos++,this.skipWhitespace();case"obj-start":{if(this.modeStack.pop(),this.ch()===125)return this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);const e=this.parseString();if(this.skipWhitespace(),this.ch()!==58)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);return this.pos++,this.modeStack.push("obj-value"),e}case"obj-value":return this.modeStack.pop(),this.modeStack.push("obj-key"),this.skipWhitespace(),this.parseValue();default:throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`)}}}function decode$8(t,e){return e=Object.assign({tokenizer:new Tokenizer(t,e)},e),decode$s(t,e)}function cidEncoder(t){if(t.asCID!==t)return null;const e=CID$2.asCID(t);if(!e)return null;const r=e.toString();return[new Token(Type.map,1/0,1),new Token(Type.string,"/",1),new Token(Type.string,r,r.length),new Token(Type.break,void 0,1)]}function bytesEncoder(t){const e=base64$3.encode(t).slice(1);return[new Token(Type.map,1/0,1),new Token(Type.string,"/",1),new Token(Type.map,1/0,1),new Token(Type.string,"bytes",5),new Token(Type.string,e,e.length),new Token(Type.break,void 0,1),new Token(Type.break,void 0,1)]}function undefinedEncoder(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder(t){if(Number.isNaN(t))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(t===1/0||t===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const encodeOptions={typeEncoders:{Object:cidEncoder,Uint8Array:bytesEncoder,Buffer:bytesEncoder,undefined:undefinedEncoder,number:numberEncoder}};class DagJsonTokenizer extends Tokenizer{constructor(e,r){super(e,r),this.tokenBuffer=[]}done(){return this.tokenBuffer.length===0&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const e=this._next();if(e.type===Type.map){const r=this._next();if(r.type===Type.string&&r.value==="/"){const n=this._next();if(n.type===Type.string){if(this._next().type!==Type.break)throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(n),new Token(Type.tag,42,0)}if(n.type===Type.map){const o=this._next();if(o.type===Type.string&&o.value==="bytes"){const i=this._next();if(i.type===Type.string){for(let u=0;u<2;u++)if(this._next().type!==Type.break)throw new Error("Invalid encoded Bytes form");const s=base64$3.decode(`m${i.value}`);return new Token(Type.bytes,s,i.value.length)}this.tokenBuffer.push(i)}this.tokenBuffer.push(o)}this.tokenBuffer.push(n)}this.tokenBuffer.push(r)}return e}}const decodeOptions={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions.tags[42]=CID$2.parse;const name$1="dag-json",code$2=297,encode$5=t=>encode$6(t,encodeOptions),decode$7=t=>{const e=Object.assign(decodeOptions,{tokenizer:new DagJsonTokenizer(t,decodeOptions)});return decode$8(t,e)},dagJSON=Object.freeze(Object.defineProperty({__proto__:null,name:name$1,code:code$2,encode:encode$5,decode:decode$7},Symbol.toStringTag,{value:"Module"}));function toBase64url(t){return base64url$1.encode(t).slice(1)}function fromBase64url(t){return base64url$1.decode(`u${t}`)}function fromSplit$1(t){const[e,r,n]=t;return{payload:r,signatures:[{protected:e,signature:n}],link:CID$2.decode(fromBase64url(r))}}function encodeSignature(t){const e={signature:fromBase64url(t.signature)};return t.header&&(e.header=t.header),t.protected&&(e.protected=fromBase64url(t.protected)),e}function encode$4(t){const e=fromBase64url(t.payload);try{CID$2.decode(e)}catch{throw new Error("Not a valid DagJWS")}return{payload:e,signatures:t.signatures.map(encodeSignature)}}function decodeSignature(t){const e={signature:toBase64url(t.signature)};return t.header&&(e.header=t.header),t.protected&&(e.protected=toBase64url(t.protected)),e}function decode$6(t){const e={payload:toBase64url(t.payload),signatures:t.signatures.map(decodeSignature)};return e.link=CID$2.decode(new Uint8Array(t.payload)),e}function fromSplit(t){const[e,r,n,o,i]=t,s={ciphertext:o,iv:n,protected:e,tag:i};return r&&(s.recipients=[{encrypted_key:r}]),s}function encodeRecipient(t){const e={};return t.encrypted_key&&(e.encrypted_key=fromBase64url(t.encrypted_key)),t.header&&(e.header=t.header),e}function encode$3(t){const e={ciphertext:fromBase64url(t.ciphertext),protected:fromBase64url(t.protected),iv:fromBase64url(t.iv),tag:fromBase64url(t.tag)};return t.aad&&(e.aad=fromBase64url(t.aad)),t.recipients&&(e.recipients=t.recipients.map(encodeRecipient)),t.unprotected&&(e.unprotected=t.unprotected),e}function decodeRecipient(t){const e={};return t.encrypted_key&&(e.encrypted_key=toBase64url(t.encrypted_key)),t.header&&(e.header=t.header),e}function decode$5(t){const e={ciphertext:toBase64url(t.ciphertext),protected:toBase64url(t.protected),iv:toBase64url(t.iv),tag:toBase64url(t.tag)};return t.aad&&(e.aad=toBase64url(t.aad)),t.recipients&&(e.recipients=t.recipients.map(decodeRecipient)),t.unprotected&&(e.unprotected=t.unprotected),e}const name="dag-jose",code$1=133;function isDagJWS(t){return"payload"in t&&typeof t.payload=="string"&&"signatures"in t&&Array.isArray(t.signatures)}function isEncodedJWS(t){return"payload"in t&&t.payload instanceof Uint8Array&&"signatures"in t&&Array.isArray(t.signatures)}function isEncodedJWE(t){return"ciphertext"in t&&t.ciphertext instanceof Uint8Array&&"iv"in t&&t.iv instanceof Uint8Array&&"protected"in t&&t.protected instanceof Uint8Array&&"tag"in t&&t.tag instanceof Uint8Array}function isDagJWE(t){return"ciphertext"in t&&typeof t.ciphertext=="string"&&"iv"in t&&typeof t.iv=="string"&&"protected"in t&&typeof t.protected=="string"&&"tag"in t&&typeof t.tag=="string"}function toGeneral(t){if(typeof t=="string"){const e=t.split(".");if(e.length===3)return fromSplit$1(e);if(e.length===5)return fromSplit(e);throw new Error("Not a valid JOSE string")}if(isDagJWS(t)||isDagJWE(t))return t;throw new Error("Not a valid unencoded JOSE object")}function encode$2(t){typeof t=="string"&&(t=toGeneral(t));let e;if(isDagJWS(t))e=encode$4(t);else if(isDagJWE(t))e=encode$3(t);else throw new Error("Not a valid JOSE object");return new Uint8Array(encode$n(e))}function decode$4(t){let e;try{e=decode$n(t)}catch{throw new Error("Not a valid DAG-JOSE object")}if(isEncodedJWS(e))return decode$6(e);if(isEncodedJWE(e))return decode$5(e);throw new Error("Not a valid DAG-JOSE object")}const dagJOSE=Object.freeze(Object.defineProperty({__proto__:null,name,code:code$1,toGeneral,encode:encode$2,decode:decode$4},Symbol.toStringTag,{value:"Module"})),LOAD_CODEC=t=>Promise.reject(new Error(`No codec found for "${t}"`));class Multicodecs{constructor(e){this._codecsByName={},this._codecsByCode={},this._loadCodec=e.loadCodec||LOAD_CODEC;for(const r of e.codecs)this.addCodec(r)}addCodec(e){if(this._codecsByName[e.name]||this._codecsByCode[e.code])throw new Error(`Resolver already exists for codec "${e.name}"`);this._codecsByName[e.name]=e,this._codecsByCode[e.code]=e}removeCodec(e){delete this._codecsByName[e.name],delete this._codecsByCode[e.code]}async getCodec(e){const r=typeof e=="string"?this._codecsByName:this._codecsByCode;if(r[e])return r[e];const n=await this._loadCodec(e);return r[e]==null&&this.addCodec(n),n}listCodecs(){return Object.values(this._codecsByName)}}const LOAD_HASHER=t=>Promise.reject(new Error(`No hasher found for "${t}"`));class Multihashes{constructor(e){this._hashersByName={},this._hashersByCode={},this._loadHasher=e.loadHasher||LOAD_HASHER;for(const r of e.hashers)this.addHasher(r)}addHasher(e){if(this._hashersByName[e.name]||this._hashersByCode[e.code])throw new Error(`Resolver already exists for codec "${e.name}"`);this._hashersByName[e.name]=e,this._hashersByCode[e.code]=e}removeHasher(e){delete this._hashersByName[e.name],delete this._hashersByCode[e.code]}async getHasher(e){const r=typeof e=="string"?this._hashersByName:this._hashersByCode;if(r[e])return r[e];const n=await this._loadHasher(e);return r[e]==null&&this.addHasher(n),n}listHashers(){return Object.values(this._hashersByName)}}async function*makeIterable(t){let e=0;for(;e<t.length;)yield t[e++]}function base(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var i=t.charAt(o),s=i.charCodeAt(0);if(r[s]!==255)throw new TypeError(i+" is ambiguous");r[s]=o}var u=t.length,f=t.charAt(0),h=Math.log(u)/Math.log(256),g=Math.log(256)/Math.log(u);function $(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var v=0,k=0,P=0,L=w.length;P!==L&&w[P]===0;)P++,v++;for(var N=(L-P)*g+1>>>0,q=new Uint8Array(N);P!==L;){for(var X=w[P],Z=0,j=N-1;(X!==0||Z<k)&&j!==-1;j--,Z++)X+=256*q[j]>>>0,q[j]=X%u>>>0,X=X/u>>>0;if(X!==0)throw new Error("Non-zero carry");k=Z,P++}for(var B=N-k;B!==N&&q[B]===0;)B++;for(var K=f.repeat(v);B<N;++B)K+=t.charAt(q[B]);return K}function E(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var v=0;if(w[v]!==" "){for(var k=0,P=0;w[v]===f;)k++,v++;for(var L=(w.length-v)*h+1>>>0,N=new Uint8Array(L);w[v];){var q=r[w.charCodeAt(v)];if(q===255)return;for(var X=0,Z=L-1;(q!==0||X<P)&&Z!==-1;Z--,X++)q+=u*N[Z]>>>0,N[Z]=q%256>>>0,q=q/256>>>0;if(q!==0)throw new Error("Non-zero carry");P=X,v++}if(w[v]!==" "){for(var j=L-P;j!==L&&N[j]===0;)j++;for(var B=new Uint8Array(k+(L-j)),K=k;j!==L;)B[K++]=N[j++];return B}}}function A(w){var v=E(w);if(v)return v;throw new Error(`Non-${e} character`)}return{encode:$,decodeUnsafe:E,decode:A}}var src=base,_brrp__multiformats_scope_baseX=src;const equals$1=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},coerce=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")};class Encoder{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Decoder{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or(this,e)}}class ComposedDecoder{constructor(e){this.decoders=e}or(e){return or(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or=(t,e)=>new ComposedDecoder({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});class Codec{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder(e,r,n),this.decoder=new Decoder(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const from=({name:t,prefix:e,encode:r,decode:n})=>new Codec(t,e,r,n),baseX=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX(r,e);return from({prefix:t,name:e,encode:n,decode:i=>coerce(o(i))})},decode$3=(t,e,r,n)=>{const o={};for(let g=0;g<e.length;++g)o[e[g]]=g;let i=t.length;for(;t[i-1]==="=";)--i;const s=new Uint8Array(i*r/8|0);let u=0,f=0,h=0;for(let g=0;g<i;++g){const $=o[t[g]];if($===void 0)throw new SyntaxError(`Non-${n} character`);f=f<<r|$,u+=r,u>=8&&(u-=8,s[h++]=255&f>>u)}if(u>=r||255&f<<8-u)throw new SyntaxError("Unexpected end of data");return s},encode$1=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let i="",s=0,u=0;for(let f=0;f<t.length;++f)for(u=u<<8|t[f],s+=8;s>r;)s-=r,i+=e[o&u>>s];if(s&&(i+=e[o&u<<r-s]),n)for(;i.length*r&7;)i+="=";return i},rfc4648=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from({prefix:e,name:t,encode(o){return encode$1(o,n,r)},decode(o){return decode$3(o,n,r,t)}}),base32=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const code=85;var encode_1=encode,MSB=128,REST=127,MSBALL=~REST,INT=Math.pow(2,31);function encode(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT;)e[r++]=t&255|MSB,t/=128;for(;t&MSBALL;)e[r++]=t&255|MSB,t>>>=7;return e[r]=t|0,encode.bytes=r-n+1,e}var decode$2=read,MSB$1=128,REST$1=127;function read(t,n){var r=0,n=n||0,o=0,i=n,s,u=t.length;do{if(i>=u)throw read.bytes=0,new RangeError("Could not decode varint");s=t[i++],r+=o<28?(s&REST$1)<<o:(s&REST$1)*Math.pow(2,o),o+=7}while(s>=MSB$1);return read.bytes=i-n,r}var N1=Math.pow(2,7),N2=Math.pow(2,14),N3=Math.pow(2,21),N4=Math.pow(2,28),N5=Math.pow(2,35),N6=Math.pow(2,42),N7=Math.pow(2,49),N8=Math.pow(2,56),N9=Math.pow(2,63),length=function(t){return t<N1?1:t<N2?2:t<N3?3:t<N4?4:t<N5?5:t<N6?6:t<N7?7:t<N8?8:t<N9?9:10},varint={encode:encode_1,decode:decode$2,encodingLength:length},_brrp_varint=varint;const decode$1=(t,e=0)=>[_brrp_varint.decode(t,e),_brrp_varint.decode.bytes],encodeTo=(t,e,r=0)=>(_brrp_varint.encode(t,e,r),e),encodingLength=t=>_brrp_varint.encodingLength(t),create=(t,e)=>{const r=e.byteLength,n=encodingLength(t),o=n+encodingLength(r),i=new Uint8Array(o+r);return encodeTo(t,i,0),encodeTo(r,i,n),i.set(e,o),new Digest(t,r,e,i)},decode=t=>{const e=coerce(t),[r,n]=decode$1(e),[o,i]=decode$1(e.subarray(n)),s=e.subarray(n+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new Digest(r,o,s,e)},equals=(t,e)=>{if(t===e)return!0;{const r=e;return t.code===r.code&&t.size===r.size&&r.bytes instanceof Uint8Array&&equals$1(t.bytes,r.bytes)}};class Digest{constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}}const base58btc=baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});const format=(t,e)=>{const{bytes:r,version:n}=t;switch(n){case 0:return toStringV0(r,baseCache(t),e||base58btc.encoder);default:return toStringV1(r,baseCache(t),e||base32.encoder)}},cache=new WeakMap,baseCache=t=>{const e=cache.get(t);if(e==null){const r=new Map;return cache.set(t,r),r}return e};class CID{constructor(e,r,n,o){this.code=r,this.version=e,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID.createV0(r)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create(e,r);return CID.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return CID.equals(this,e)}static equals(e,r){const n=r;return n&&e.code===n.code&&e.version===n.version&&equals(e.multihash,n.multihash)}toString(e){return format(this,e)}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const r=e;if(r instanceof CID)return r;if(r["/"]!=null&&r["/"]===r.bytes||r.asCID===r){const{version:n,code:o,multihash:i,bytes:s}=r;return new CID(n,o,i,s||encodeCID(n,o,i.bytes))}else if(r[cidSymbol]===!0){const{version:n,multihash:o,code:i}=r,s=decode(o);return CID.create(n,i,s)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(r!==DAG_PB_CODE)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);return new CID(e,r,n,n.bytes)}case 1:{const o=encodeCID(e,r,n.bytes);return new CID(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return CID.create(0,DAG_PB_CODE,e)}static createV1(e,r){return CID.create(1,e,r)}static decode(e){const[r,n]=CID.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=CID.inspectBytes(e),n=r.size-r.multihashSize,o=coerce(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");const i=o.subarray(r.multihashSize-r.digestSize),s=new Digest(r.multihashCode,r.digestSize,i,o);return[r.version===0?CID.createV0(s):CID.createV1(r.codec,s),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[$,E]=decode$1(e.subarray(r));return r+=E,$};let o=n(),i=DAG_PB_CODE;if(o===18?(o=0,r=0):i=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const s=r,u=n(),f=n(),h=r+f,g=h-s;return{version:o,codec:i,multihashCode:u,digestSize:f,multihashSize:g,size:h}}static parse(e,r){const[n,o]=parseCIDtoBytes(e,r),i=CID.decode(o);return baseCache(i).set(n,e),i}}const parseCIDtoBytes=(t,e)=>{switch(t[0]){case"Q":{const r=e||base58btc;return[base58btc.prefix,r.decode(`${base58btc.prefix}${t}`)]}case base58btc.prefix:{const r=e||base58btc;return[base58btc.prefix,r.decode(t)]}case base32.prefix:{const r=e||base32;return[base32.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},toStringV0=(t,e,r)=>{const{prefix:n}=r;if(n!==base58btc.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=e.get(n);if(o==null){const i=r.encode(t).slice(1);return e.set(n,i),i}else return o},toStringV1=(t,e,r)=>{const{prefix:n}=r,o=e.get(n);if(o==null){const i=r.encode(t);return e.set(n,i),i}else return o},DAG_PB_CODE=112,SHA_256_CODE=18,encodeCID=(t,e,r)=>{const n=encodingLength(t),o=n+encodingLength(e),i=new Uint8Array(o+r.byteLength);return encodeTo(t,i,0),encodeTo(e,i,n),i.set(r,o),i},cidSymbol=Symbol.for("@ipld/js-cid/CID");function notFoundError(t){return t=t||new Error("Not Found"),errCode(t,"ERR_NOT_FOUND")}class MemoryBlockstore extends BaseBlockstore{constructor(){super(),this.data={}}open(){return Promise.resolve()}close(){return Promise.resolve()}async put(e,r){this.data[base32.encode(e.multihash.bytes)]=r}async get(e){if(!await this.has(e))throw notFoundError();return this.data[base32.encode(e.multihash.bytes)]}async has(e){return this.data[base32.encode(e.multihash.bytes)]!==void 0}async delete(e){delete this.data[base32.encode(e.multihash.bytes)]}async*_all(){yield*Object.entries(this.data).map(([e,r])=>({key:CID.createV1(code,decode(base32.decode(e))),value:r}))}async*_allKeys(){yield*Object.entries(this.data).map(([e])=>CID.createV1(code,decode(base32.decode(e))))}}class DagRepo extends Ac{constructor({repo:e,codecs:r,options:n}){const o=Object.values(hashes);(n.ipld&&n.ipld.hashers?n.ipld.hashers:[]).forEach(s=>o.push(s));const i=new Multihashes({hashers:o,loadHasher:n.ipld&&n.ipld.loadHasher});super({repo:e,codecs:r,hashers:i,preload:s=>{}}),Object.assign(this,mitt()),this.repo=e,this.rootCID,this.tx={pending:Transaction.create(),checkSize:async s=>{const u=Transaction.create();return await u.add(s),u.size},getExistingTx:async()=>{let s={};try{let u=this.tx.pending.last;if(!u)return;s=(await this.tx.pending.get(u)).value}catch{return s}return s},addData:async s=>await this.tx.pending.add(s),addTag:async(s,u)=>await this.tx.add(s,u),add:async(s,u)=>{if(!u)return;u=Object.fromEntries(Object.entries(u).map(([w,v])=>v===void 0?[w,null]:[w,v]));let f=!1,h=await this.tx.getExistingTx()||null;if(h&&h[s])f=h[s]?h[s]:!1;else if(this.rootCID)try{let w=(await this.get(this.rootCID)).value;f=w[s]?w[s]:!1}catch{}let g=await this.tx.pending.add(u),$=h&&Object.keys(h).length!==0?Object.fromEntries(Object.entries(h).filter(([w,v])=>v.hasOwnProperty("obj")&&v.hasOwnProperty("prev"))):null,E=$&&Object.keys($).length!==0?Object.assign({},$,{[s]:{obj:g,prev:f}}):{[s]:{obj:g,prev:f}},A=await this.tx.pending.add(E);return this.emit("added",A),A},commit:async()=>{let s=await this.tx.getExistingTx(),u={};try{this.rootCID&&(u=(await this.get(this.rootCID)).value);let h=Object.assign({},u,Object.fromEntries(Object.entries(s).filter(([g,$])=>$.hasOwnProperty("obj")&&$.hasOwnProperty("prev"))));this.rootCID=await this.tx.pending.add(h)}catch(h){this.rootCID&&console.log("thats odd",{error:h})}const f=await this.tx.pending.commit();return await this.importBuffer(f),this.tx.pending=Transaction.create(),f}}}async latest(e){return(await this.get(this.rootCID,{path:`/${e}/obj`})).value}async importBuffers(e){let r;for(const n of e)r=await this.importBuffer(n);return r}async importBuffer(e){return importBuffer(this,e)}}async function importBuffer(t,e){const r=await makeIterable([e]),[{root:n}]=await itAll(t.import(r));return n.cid}async function createDagRepo(t={}){const e={name:identity$3.name,code:identity$3.code,encode:f=>f,decode:f=>f},r=Object.values(codecs);[dagCBOR,dagJSON,dagJOSE,e].concat(t.ipld&&t.ipld.codecs||[]).forEach(f=>r.push(f));const n=new Multicodecs({codecs:r,loadCodec:t.ipld&&t.ipld.loadCodec}),o=t.path||"ipfs";let i;t!=null&&t.persist?i=createRepo(console.log,n,{path:o,autoMigrate:!0}):i=createRepo$1(o,f=>n.getCodec(f),{blocks:new MemoryBlockstore,datastore:new MemoryDatastore,root:new MemoryDatastore,keys:new MemoryDatastore,pins:new MemoryDatastore},t);const s={};try{await i.init(s),await i.open()}catch(f){throw f}const u=await i.config.getAll();return new DagRepo({repo:i,codecs:n,options:{...t,repoConfig:u}})}export{DagRepo,Transaction,createDagRepo,encode$k as encode,importBuffer};

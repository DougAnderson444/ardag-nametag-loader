function _mergeNamespaces(o, n) {
  for (var c = 0; c < n.length; c++) {
    const u = n[c];
    if (typeof u != "string" && !Array.isArray(u)) {
      for (const h in u)
        if (h !== "default" && !(h in o)) {
          const g = Object.getOwnPropertyDescriptor(u, h);
          g && Object.defineProperty(o, h, g.get ? g : { enumerable: !0, get: () => u[h] });
        }
    }
  }
  return Object.freeze(Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }));
}
function noop$3() {
}
function assign$1(o, n) {
  for (const c in n)
    o[c] = n[c];
  return o;
}
function run$1(o) {
  return o();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(o) {
  o.forEach(run$1);
}
function is_function(o) {
  return typeof o == "function";
}
function safe_not_equal(o, n) {
  return o != o ? n == n : o !== n || o && typeof o == "object" || typeof o == "function";
}
function is_empty(o) {
  return Object.keys(o).length === 0;
}
function create_slot(o, n, c, u) {
  if (o) {
    const h = get_slot_context(o, n, c, u);
    return o[0](h);
  }
}
function get_slot_context(o, n, c, u) {
  return o[1] && u ? assign$1(c.ctx.slice(), o[1](u(n))) : c.ctx;
}
function get_slot_changes(o, n, c, u) {
  if (o[2] && u) {
    const h = o[2](u(c));
    if (n.dirty === void 0)
      return h;
    if (typeof h == "object") {
      const g = [], y = Math.max(n.dirty.length, h.length);
      for (let $ = 0; $ < y; $ += 1)
        g[$] = n.dirty[$] | h[$];
      return g;
    }
    return n.dirty | h;
  }
  return n.dirty;
}
function update_slot_base(o, n, c, u, h, g) {
  if (h) {
    const y = get_slot_context(n, c, u, g);
    o.p(y, h);
  }
}
function get_all_dirty_from_scope(o) {
  if (o.ctx.length > 32) {
    const n = [], c = o.ctx.length / 32;
    for (let u = 0; u < c; u++)
      n[u] = -1;
    return n;
  }
  return -1;
}
function append(o, n) {
  o.appendChild(n);
}
function append_styles(o, n, c) {
  const u = get_root_for_style(o);
  if (!u.getElementById(n)) {
    const h = element("style");
    h.id = n, h.textContent = c, append_stylesheet(u, h);
  }
}
function get_root_for_style(o) {
  if (!o)
    return document;
  const n = o.getRootNode ? o.getRootNode() : o.ownerDocument;
  return n && n.host ? n : o.ownerDocument;
}
function append_stylesheet(o, n) {
  return append(o.head || o, n), n.sheet;
}
function insert(o, n, c) {
  o.insertBefore(n, c || null);
}
function detach(o) {
  o.parentNode.removeChild(o);
}
function element(o) {
  return document.createElement(o);
}
function svg_element(o) {
  return document.createElementNS("http://www.w3.org/2000/svg", o);
}
function text(o) {
  return document.createTextNode(o);
}
function space() {
  return text(" ");
}
function empty$1() {
  return text("");
}
function listen(o, n, c, u) {
  return o.addEventListener(n, c, u), () => o.removeEventListener(n, c, u);
}
function attr(o, n, c) {
  c == null ? o.removeAttribute(n) : o.getAttribute(n) !== c && o.setAttribute(n, c);
}
function children(o) {
  return Array.from(o.childNodes);
}
function set_data(o, n) {
  n = "" + n, o.wholeText !== n && (o.data = n);
}
function set_style(o, n, c, u) {
  c === null ? o.style.removeProperty(n) : o.style.setProperty(n, c, u ? "important" : "");
}
let crossorigin, current_component;
function is_crossorigin() {
  if (crossorigin === void 0) {
    crossorigin = !1;
    try {
      typeof window < "u" && window.parent && window.parent.document;
    } catch {
      crossorigin = !0;
    }
  }
  return crossorigin;
}
function add_resize_listener(o, n) {
  getComputedStyle(o).position === "static" && (o.style.position = "relative");
  const c = element("iframe");
  c.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"), c.setAttribute("aria-hidden", "true"), c.tabIndex = -1;
  const u = is_crossorigin();
  let h;
  return u ? (c.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>", h = listen(window, "message", (g) => {
    g.source === c.contentWindow && n();
  })) : (c.src = "about:blank", c.onload = () => {
    h = listen(c.contentWindow, "resize", n);
  }), append(o, c), () => {
    (u || h && c.contentWindow) && h(), detach(c);
  };
}
function custom_event(o, n, { bubbles: c = !1, cancelable: u = !1 } = {}) {
  const h = document.createEvent("CustomEvent");
  return h.initCustomEvent(o, c, u, n), h;
}
class HtmlTag {
  constructor(n = !1) {
    this.is_svg = !1, this.is_svg = n, this.e = this.n = null;
  }
  c(n) {
    this.h(n);
  }
  m(n, c, u = null) {
    this.e || (this.is_svg ? this.e = svg_element(c.nodeName) : this.e = element(c.nodeName), this.t = c, this.c(n)), this.i(u);
  }
  h(n) {
    this.e.innerHTML = n, this.n = Array.from(this.e.childNodes);
  }
  i(n) {
    for (let c = 0; c < this.n.length; c += 1)
      insert(this.t, this.n[c], n);
  }
  p(n) {
    this.d(), this.h(n), this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component(o, n) {
  return new o(n);
}
function set_current_component(o) {
  current_component = o;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(o) {
  get_current_component().$$.on_mount.push(o);
}
function onDestroy(o) {
  get_current_component().$$.on_destroy.push(o);
}
function createEventDispatcher() {
  const o = get_current_component();
  return (n, c, { cancelable: u = !1 } = {}) => {
    const h = o.$$.callbacks[n];
    if (h) {
      const g = custom_event(n, c, { cancelable: u });
      return h.slice().forEach((y) => {
        y.call(o, g);
      }), !g.defaultPrevented;
    }
    return !0;
  };
}
function bubble(o, n) {
  const c = o.$$.callbacks[n.type];
  c && c.slice().forEach((u) => u.call(this, n));
}
const dirty_components = [], binding_callbacks = [], render_callbacks = [], flush_callbacks = [], resolved_promise = Promise.resolve();
let update_scheduled = !1;
function schedule_update() {
  update_scheduled || (update_scheduled = !0, resolved_promise.then(flush));
}
function add_render_callback(o) {
  render_callbacks.push(o);
}
function add_flush_callback(o) {
  flush_callbacks.push(o);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  const o = current_component;
  do {
    for (; flushidx < dirty_components.length; ) {
      const n = dirty_components[flushidx];
      flushidx++, set_current_component(n), update(n.$$);
    }
    for (set_current_component(null), dirty_components.length = 0, flushidx = 0; binding_callbacks.length; )
      binding_callbacks.pop()();
    for (let n = 0; n < render_callbacks.length; n += 1) {
      const c = render_callbacks[n];
      seen_callbacks.has(c) || (seen_callbacks.add(c), c());
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  for (; flush_callbacks.length; )
    flush_callbacks.pop()();
  update_scheduled = !1, seen_callbacks.clear(), set_current_component(o);
}
function update(o) {
  if (o.fragment !== null) {
    o.update(), run_all(o.before_update);
    const n = o.dirty;
    o.dirty = [-1], o.fragment && o.fragment.p(o.ctx, n), o.after_update.forEach(add_render_callback);
  }
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = { r: 0, c: [], p: outros };
}
function check_outros() {
  outros.r || run_all(outros.c), outros = outros.p;
}
function transition_in(o, n) {
  o && o.i && (outroing.delete(o), o.i(n));
}
function transition_out(o, n, c, u) {
  if (o && o.o) {
    if (outroing.has(o))
      return;
    outroing.add(o), outros.c.push(() => {
      outroing.delete(o), u && (c && o.d(1), u());
    }), o.o(n);
  } else
    u && u();
}
function bind$3(o, n, c) {
  const u = o.$$.props[n];
  u !== void 0 && (o.$$.bound[u] = c, c(o.$$.ctx[u]));
}
function create_component(o) {
  o && o.c();
}
function mount_component(o, n, c, u) {
  const { fragment: h, after_update: g } = o.$$;
  h && h.m(n, c), u || add_render_callback(() => {
    const y = o.$$.on_mount.map(run$1).filter(is_function);
    o.$$.on_destroy ? o.$$.on_destroy.push(...y) : run_all(y), o.$$.on_mount = [];
  }), g.forEach(add_render_callback);
}
function destroy_component(o, n) {
  const c = o.$$;
  c.fragment !== null && (run_all(c.on_destroy), c.fragment && c.fragment.d(n), c.on_destroy = c.fragment = null, c.ctx = []);
}
function make_dirty(o, n) {
  o.$$.dirty[0] === -1 && (dirty_components.push(o), schedule_update(), o.$$.dirty.fill(0)), o.$$.dirty[n / 31 | 0] |= 1 << n % 31;
}
function init$1(o, n, c, u, h, g, y, $ = [-1]) {
  const I = current_component;
  set_current_component(o);
  const P = o.$$ = { fragment: null, ctx: [], props: g, update: noop$3, not_equal: h, bound: blank_object(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(n.context || (I ? I.$$.context : [])), callbacks: blank_object(), dirty: $, skip_bound: !1, root: n.target || I.$$.root };
  y && y(P.root);
  let L = !1;
  if (P.ctx = c ? c(o, n.props || {}, (q, N, ...X) => {
    const rt = X.length ? X[0] : N;
    return P.ctx && h(P.ctx[q], P.ctx[q] = rt) && (!P.skip_bound && P.bound[q] && P.bound[q](rt), L && make_dirty(o, q)), N;
  }) : [], P.update(), L = !0, run_all(P.before_update), P.fragment = !!u && u(P.ctx), n.target) {
    if (n.hydrate) {
      const q = children(n.target);
      P.fragment && P.fragment.l(q), q.forEach(detach);
    } else
      P.fragment && P.fragment.c();
    n.intro && transition_in(o.$$.fragment), mount_component(o, n.target, n.anchor, n.customElement), flush();
  }
  set_current_component(I);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1), this.$destroy = noop$3;
  }
  $on(n, c) {
    if (!is_function(c))
      return noop$3;
    const u = this.$$.callbacks[n] || (this.$$.callbacks[n] = []);
    return u.push(c), () => {
      const h = u.indexOf(c);
      h !== -1 && u.splice(h, 1);
    };
  }
  $set(n) {
    this.$$set && !is_empty(n) && (this.$$.skip_bound = !0, this.$$set(n), this.$$.skip_bound = !1);
  }
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
function getAugmentedNamespace(o) {
  var n = o.default;
  if (typeof n == "function") {
    var c = function() {
      return n.apply(this, arguments);
    };
    c.prototype = n.prototype;
  } else
    c = {};
  return Object.defineProperty(c, "__esModule", { value: !0 }), Object.keys(o).forEach(function(u) {
    var h = Object.getOwnPropertyDescriptor(o, u);
    Object.defineProperty(c, u, h.get ? h : { enumerable: !0, get: function() {
      return o[u];
    } });
  }), c;
}
var base64$9 = {}, __extends = commonjsGlobal && commonjsGlobal.__extends || (extendStatics = function(o, n) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, u) {
    c.__proto__ = u;
  } || function(c, u) {
    for (var h in u)
      u.hasOwnProperty(h) && (c[h] = u[h]);
  }, extendStatics(o, n);
}, function(o, n) {
  function c() {
    this.constructor = o;
  }
  extendStatics(o, n), o.prototype = n === null ? Object.create(n) : (c.prototype = n.prototype, new c());
}), extendStatics;
Object.defineProperty(base64$9, "__esModule", { value: !0 });
var INVALID_BYTE = 256, Coder = function() {
  function o(n) {
    n === void 0 && (n = "="), this._paddingCharacter = n;
  }
  return o.prototype.encodedLength = function(n) {
    return this._paddingCharacter ? (n + 2) / 3 * 4 | 0 : (8 * n + 5) / 6 | 0;
  }, o.prototype.encode = function(n) {
    for (var c = "", u = 0; u < n.length - 2; u += 3) {
      var h = n[u] << 16 | n[u + 1] << 8 | n[u + 2];
      c += this._encodeByte(h >>> 18 & 63), c += this._encodeByte(h >>> 12 & 63), c += this._encodeByte(h >>> 6 & 63), c += this._encodeByte(h >>> 0 & 63);
    }
    var g = n.length - u;
    return g > 0 && (h = n[u] << 16 | (g === 2 ? n[u + 1] << 8 : 0), c += this._encodeByte(h >>> 18 & 63), c += this._encodeByte(h >>> 12 & 63), c += g === 2 ? this._encodeByte(h >>> 6 & 63) : this._paddingCharacter || "", c += this._paddingCharacter || ""), c;
  }, o.prototype.maxDecodedLength = function(n) {
    return this._paddingCharacter ? n / 4 * 3 | 0 : (6 * n + 7) / 8 | 0;
  }, o.prototype.decodedLength = function(n) {
    return this.maxDecodedLength(n.length - this._getPaddingLength(n));
  }, o.prototype.decode = function(n) {
    if (n.length === 0)
      return new Uint8Array(0);
    for (var c = this._getPaddingLength(n), u = n.length - c, h = new Uint8Array(this.maxDecodedLength(u)), g = 0, y = 0, $ = 0, I = 0, P = 0, L = 0, q = 0; y < u - 4; y += 4)
      I = this._decodeChar(n.charCodeAt(y + 0)), P = this._decodeChar(n.charCodeAt(y + 1)), L = this._decodeChar(n.charCodeAt(y + 2)), q = this._decodeChar(n.charCodeAt(y + 3)), h[g++] = I << 2 | P >>> 4, h[g++] = P << 4 | L >>> 2, h[g++] = L << 6 | q, $ |= I & INVALID_BYTE, $ |= P & INVALID_BYTE, $ |= L & INVALID_BYTE, $ |= q & INVALID_BYTE;
    if (y < u - 1 && (I = this._decodeChar(n.charCodeAt(y)), P = this._decodeChar(n.charCodeAt(y + 1)), h[g++] = I << 2 | P >>> 4, $ |= I & INVALID_BYTE, $ |= P & INVALID_BYTE), y < u - 2 && (L = this._decodeChar(n.charCodeAt(y + 2)), h[g++] = P << 4 | L >>> 2, $ |= L & INVALID_BYTE), y < u - 3 && (q = this._decodeChar(n.charCodeAt(y + 3)), h[g++] = L << 6 | q, $ |= q & INVALID_BYTE), $ !== 0)
      throw new Error("Base64Coder: incorrect characters for decoding");
    return h;
  }, o.prototype._encodeByte = function(n) {
    var c = n;
    return c += 65, c += 25 - n >>> 8 & 6, c += 51 - n >>> 8 & -75, c += 61 - n >>> 8 & -15, c += 62 - n >>> 8 & 3, String.fromCharCode(c);
  }, o.prototype._decodeChar = function(n) {
    var c = INVALID_BYTE;
    return c += (42 - n & n - 44) >>> 8 & -INVALID_BYTE + n - 43 + 62, c += (46 - n & n - 48) >>> 8 & -INVALID_BYTE + n - 47 + 63, c += (47 - n & n - 58) >>> 8 & -INVALID_BYTE + n - 48 + 52, (c += (64 - n & n - 91) >>> 8 & -INVALID_BYTE + n - 65 + 0) + ((96 - n & n - 123) >>> 8 & -INVALID_BYTE + n - 97 + 26);
  }, o.prototype._getPaddingLength = function(n) {
    var c = 0;
    if (this._paddingCharacter) {
      for (var u = n.length - 1; u >= 0 && n[u] === this._paddingCharacter; u--)
        c++;
      if (n.length < 4 || c > 2)
        throw new Error("Base64Coder: incorrect padding");
    }
    return c;
  }, o;
}();
base64$9.Coder = Coder;
var stdCoder = new Coder();
function encode$v(o) {
  return stdCoder.encode(o);
}
function decode$w(o) {
  return stdCoder.decode(o);
}
base64$9.encode = encode$v, base64$9.decode = decode$w;
var URLSafeCoder = function(o) {
  function n() {
    return o !== null && o.apply(this, arguments) || this;
  }
  return __extends(n, o), n.prototype._encodeByte = function(c) {
    var u = c;
    return u += 65, u += 25 - c >>> 8 & 6, u += 51 - c >>> 8 & -75, u += 61 - c >>> 8 & -13, u += 62 - c >>> 8 & 49, String.fromCharCode(u);
  }, n.prototype._decodeChar = function(c) {
    var u = INVALID_BYTE;
    return u += (44 - c & c - 46) >>> 8 & -INVALID_BYTE + c - 45 + 62, u += (94 - c & c - 96) >>> 8 & -INVALID_BYTE + c - 95 + 63, u += (47 - c & c - 58) >>> 8 & -INVALID_BYTE + c - 48 + 52, (u += (64 - c & c - 91) >>> 8 & -INVALID_BYTE + c - 65 + 0) + ((96 - c & c - 123) >>> 8 & -INVALID_BYTE + c - 97 + 26);
  }, n;
}(Coder);
base64$9.URLSafeCoder = URLSafeCoder;
var urlSafeCoder = new URLSafeCoder();
function encodeURLSafe(o) {
  return urlSafeCoder.encode(o);
}
var encodeURLSafe_1 = base64$9.encodeURLSafe = encodeURLSafe;
function decodeURLSafe(o) {
  return urlSafeCoder.decode(o);
}
var decodeURLSafe_1 = base64$9.decodeURLSafe = decodeURLSafe;
base64$9.encodedLength = function(o) {
  return stdCoder.encodedLength(o);
}, base64$9.maxDecodedLength = function(o) {
  return stdCoder.maxDecodedLength(o);
}, base64$9.decodedLength = function(o) {
  return stdCoder.decodedLength(o);
};
const REGISTRY = "bLAgYxAdX2Ry-nt6aH2ixgvJXbpsEYm28NgJgyqfs-U";
async function arnsResolver(o, { CacheOptions: n } = {}) {
  const c = await init({ CacheOptions: n }), u = await c.resolveARNS(o), h = await c.resolveANT(u);
  return await c.resolveDID(h);
}
async function init({ local: o, CacheOptions: n } = { local: !1, CacheOptions: {} }) {
  const { WarpFactory: c } = await Promise.resolve().then(() => index$2);
  return { warp: o ? c.forLocal(n) : c.forMainnet(n), resolveARNS, resolveANT, resolveDID };
}
async function resolveARNS(o) {
  return (await this.warp.contract(REGISTRY).readState()).cachedValue.state.records[o];
}
async function resolveANT(o) {
  return `did:ar:${(await this.warp.contract(o).readState()).cachedValue.state.records["did-ar"].transactionId}`;
}
async function resolveDID(o) {
  const n = o.replace("did:ar:", "");
  return (await this.warp.contract(n).readState()).cachedValue.state;
}
var web = {}, common$9 = {}, ar$1 = {}, bignumber = { exports: {} }, e;
e = bignumber, function(o) {
  var n, c = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, u = Math.ceil, h = Math.floor, g = "[BigNumber Error] ", y = g + "Number primitive has more than 15 significant digits: ", $ = 1e14, I = 14, P = 9007199254740991, L = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], q = 1e7, N = 1e9;
  function X(et) {
    var at = 0 | et;
    return et > 0 || et === at ? at : at - 1;
  }
  function rt(et) {
    for (var at, _t, Nt = 1, m = et.length, A = et[0] + ""; Nt < m; ) {
      for (at = et[Nt++] + "", _t = I - at.length; _t--; at = "0" + at)
        ;
      A += at;
    }
    for (m = A.length; A.charCodeAt(--m) === 48; )
      ;
    return A.slice(0, m + 1 || 1);
  }
  function nt(et, at) {
    var _t, Nt, m = et.c, A = at.c, E = et.s, w = at.s, v = et.e, k = at.e;
    if (!E || !w)
      return null;
    if (_t = m && !m[0], Nt = A && !A[0], _t || Nt)
      return _t ? Nt ? 0 : -w : E;
    if (E != w)
      return E;
    if (_t = E < 0, Nt = v == k, !m || !A)
      return Nt ? 0 : !m ^ _t ? 1 : -1;
    if (!Nt)
      return v > k ^ _t ? 1 : -1;
    for (w = (v = m.length) < (k = A.length) ? v : k, E = 0; E < w; E++)
      if (m[E] != A[E])
        return m[E] > A[E] ^ _t ? 1 : -1;
    return v == k ? 0 : v > k ^ _t ? 1 : -1;
  }
  function st(et, at, _t, Nt) {
    if (et < at || et > _t || et !== h(et))
      throw Error(g + (Nt || "Argument") + (typeof et == "number" ? et < at || et > _t ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(et));
  }
  function ot(et) {
    var at = et.c.length - 1;
    return X(et.e / I) == at && et.c[at] % 2 != 0;
  }
  function St(et, at) {
    return (et.length > 1 ? et.charAt(0) + "." + et.slice(1) : et) + (at < 0 ? "e" : "e+") + at;
  }
  function Ct(et, at, _t) {
    var Nt, m;
    if (at < 0) {
      for (m = _t + "."; ++at; m += _t)
        ;
      et = m + et;
    } else if (++at > (Nt = et.length)) {
      for (m = _t, at -= Nt; --at; m += _t)
        ;
      et += m;
    } else
      at < Nt && (et = et.slice(0, at) + "." + et.slice(at));
    return et;
  }
  n = function et(at) {
    var _t, Nt, m, A, E, w, v, k, O, W, it = se.prototype = { constructor: se, toString: null, valueOf: null }, vt = new se(1), xt = 20, It = 4, Wt = -7, Ut = 21, zt = -1e7, Jt = 1e7, Xt = !1, ie = 1, oe = 0, De = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "\xA0", suffix: "" }, ue = "0123456789abcdefghijklmnopqrstuvwxyz", xe = !0;
    function se(B, j) {
      var Z, kt, $t, At, Bt, Ft, Kt, Zt, Gt = this;
      if (!(Gt instanceof se))
        return new se(B, j);
      if (j == null) {
        if (B && B._isBigNumber === !0)
          return Gt.s = B.s, void (!B.c || B.e > Jt ? Gt.c = Gt.e = null : B.e < zt ? Gt.c = [Gt.e = 0] : (Gt.e = B.e, Gt.c = B.c.slice()));
        if ((Ft = typeof B == "number") && 0 * B == 0) {
          if (Gt.s = 1 / B < 0 ? (B = -B, -1) : 1, B === ~~B) {
            for (At = 0, Bt = B; Bt >= 10; Bt /= 10, At++)
              ;
            return void (At > Jt ? Gt.c = Gt.e = null : (Gt.e = At, Gt.c = [B]));
          }
          Zt = String(B);
        } else {
          if (!c.test(Zt = String(B)))
            return m(Gt, Zt, Ft);
          Gt.s = Zt.charCodeAt(0) == 45 ? (Zt = Zt.slice(1), -1) : 1;
        }
        (At = Zt.indexOf(".")) > -1 && (Zt = Zt.replace(".", "")), (Bt = Zt.search(/e/i)) > 0 ? (At < 0 && (At = Bt), At += +Zt.slice(Bt + 1), Zt = Zt.substring(0, Bt)) : At < 0 && (At = Zt.length);
      } else {
        if (st(j, 2, ue.length, "Base"), j == 10 && xe)
          return de(Gt = new se(B), xt + Gt.e + 1, It);
        if (Zt = String(B), Ft = typeof B == "number") {
          if (0 * B != 0)
            return m(Gt, Zt, Ft, j);
          if (Gt.s = 1 / B < 0 ? (Zt = Zt.slice(1), -1) : 1, se.DEBUG && Zt.replace(/^0\.0*|\./, "").length > 15)
            throw Error(y + B);
        } else
          Gt.s = Zt.charCodeAt(0) === 45 ? (Zt = Zt.slice(1), -1) : 1;
        for (Z = ue.slice(0, j), At = Bt = 0, Kt = Zt.length; Bt < Kt; Bt++)
          if (Z.indexOf(kt = Zt.charAt(Bt)) < 0) {
            if (kt == ".") {
              if (Bt > At) {
                At = Kt;
                continue;
              }
            } else if (!$t && (Zt == Zt.toUpperCase() && (Zt = Zt.toLowerCase()) || Zt == Zt.toLowerCase() && (Zt = Zt.toUpperCase()))) {
              $t = !0, Bt = -1, At = 0;
              continue;
            }
            return m(Gt, String(B), Ft, j);
          }
        Ft = !1, (At = (Zt = Nt(Zt, j, 10, Gt.s)).indexOf(".")) > -1 ? Zt = Zt.replace(".", "") : At = Zt.length;
      }
      for (Bt = 0; Zt.charCodeAt(Bt) === 48; Bt++)
        ;
      for (Kt = Zt.length; Zt.charCodeAt(--Kt) === 48; )
        ;
      if (Zt = Zt.slice(Bt, ++Kt)) {
        if (Kt -= Bt, Ft && se.DEBUG && Kt > 15 && (B > P || B !== h(B)))
          throw Error(y + Gt.s * B);
        if ((At = At - Bt - 1) > Jt)
          Gt.c = Gt.e = null;
        else if (At < zt)
          Gt.c = [Gt.e = 0];
        else {
          if (Gt.e = At, Gt.c = [], Bt = (At + 1) % I, At < 0 && (Bt += I), Bt < Kt) {
            for (Bt && Gt.c.push(+Zt.slice(0, Bt)), Kt -= I; Bt < Kt; )
              Gt.c.push(+Zt.slice(Bt, Bt += I));
            Bt = I - (Zt = Zt.slice(Bt)).length;
          } else
            Bt -= Kt;
          for (; Bt--; Zt += "0")
            ;
          Gt.c.push(+Zt);
        }
      } else
        Gt.c = [Gt.e = 0];
    }
    function he(B, j, Z, kt) {
      var $t, At, Bt, Ft, Kt;
      if (Z == null ? Z = It : st(Z, 0, 8), !B.c)
        return B.toString();
      if ($t = B.c[0], Bt = B.e, j == null)
        Kt = rt(B.c), Kt = kt == 1 || kt == 2 && (Bt <= Wt || Bt >= Ut) ? St(Kt, Bt) : Ct(Kt, Bt, "0");
      else if (At = (B = de(new se(B), j, Z)).e, Ft = (Kt = rt(B.c)).length, kt == 1 || kt == 2 && (j <= At || At <= Wt)) {
        for (; Ft < j; Kt += "0", Ft++)
          ;
        Kt = St(Kt, At);
      } else if (j -= Bt, Kt = Ct(Kt, At, "0"), At + 1 > Ft) {
        if (--j > 0)
          for (Kt += "."; j--; Kt += "0")
            ;
      } else if ((j += At - Ft) > 0)
        for (At + 1 == Ft && (Kt += "."); j--; Kt += "0")
          ;
      return B.s < 0 && $t ? "-" + Kt : Kt;
    }
    function je(B, j) {
      for (var Z, kt = 1, $t = new se(B[0]); kt < B.length; kt++) {
        if (!(Z = new se(B[kt])).s) {
          $t = Z;
          break;
        }
        j.call($t, Z) && ($t = Z);
      }
      return $t;
    }
    function jr(B, j, Z) {
      for (var kt = 1, $t = j.length; !j[--$t]; j.pop())
        ;
      for ($t = j[0]; $t >= 10; $t /= 10, kt++)
        ;
      return (Z = kt + Z * I - 1) > Jt ? B.c = B.e = null : Z < zt ? B.c = [B.e = 0] : (B.e = Z, B.c = j), B;
    }
    function de(B, j, Z, kt) {
      var $t, At, Bt, Ft, Kt, Zt, Gt, Qt = B.c, Ae = L;
      if (Qt) {
        t: {
          for ($t = 1, Ft = Qt[0]; Ft >= 10; Ft /= 10, $t++)
            ;
          if ((At = j - $t) < 0)
            At += I, Bt = j, Gt = (Kt = Qt[Zt = 0]) / Ae[$t - Bt - 1] % 10 | 0;
          else if ((Zt = u((At + 1) / I)) >= Qt.length) {
            if (!kt)
              break t;
            for (; Qt.length <= Zt; Qt.push(0))
              ;
            Kt = Gt = 0, $t = 1, Bt = (At %= I) - I + 1;
          } else {
            for (Kt = Ft = Qt[Zt], $t = 1; Ft >= 10; Ft /= 10, $t++)
              ;
            Gt = (Bt = (At %= I) - I + $t) < 0 ? 0 : Kt / Ae[$t - Bt - 1] % 10 | 0;
          }
          if (kt = kt || j < 0 || Qt[Zt + 1] != null || (Bt < 0 ? Kt : Kt % Ae[$t - Bt - 1]), kt = Z < 4 ? (Gt || kt) && (Z == 0 || Z == (B.s < 0 ? 3 : 2)) : Gt > 5 || Gt == 5 && (Z == 4 || kt || Z == 6 && (At > 0 ? Bt > 0 ? Kt / Ae[$t - Bt] : 0 : Qt[Zt - 1]) % 10 & 1 || Z == (B.s < 0 ? 8 : 7)), j < 1 || !Qt[0])
            return Qt.length = 0, kt ? (j -= B.e + 1, Qt[0] = Ae[(I - j % I) % I], B.e = -j || 0) : Qt[0] = B.e = 0, B;
          if (At == 0 ? (Qt.length = Zt, Ft = 1, Zt--) : (Qt.length = Zt + 1, Ft = Ae[I - At], Qt[Zt] = Bt > 0 ? h(Kt / Ae[$t - Bt] % Ae[Bt]) * Ft : 0), kt)
            for (; ; ) {
              if (Zt == 0) {
                for (At = 1, Bt = Qt[0]; Bt >= 10; Bt /= 10, At++)
                  ;
                for (Bt = Qt[0] += Ft, Ft = 1; Bt >= 10; Bt /= 10, Ft++)
                  ;
                At != Ft && (B.e++, Qt[0] == $ && (Qt[0] = 1));
                break;
              }
              if (Qt[Zt] += Ft, Qt[Zt] != $)
                break;
              Qt[Zt--] = 0, Ft = 1;
            }
          for (At = Qt.length; Qt[--At] === 0; Qt.pop())
            ;
        }
        B.e > Jt ? B.c = B.e = null : B.e < zt && (B.c = [B.e = 0]);
      }
      return B;
    }
    function We(B) {
      var j, Z = B.e;
      return Z === null ? B.toString() : (j = rt(B.c), j = Z <= Wt || Z >= Ut ? St(j, Z) : Ct(j, Z, "0"), B.s < 0 ? "-" + j : j);
    }
    return se.clone = et, se.ROUND_UP = 0, se.ROUND_DOWN = 1, se.ROUND_CEIL = 2, se.ROUND_FLOOR = 3, se.ROUND_HALF_UP = 4, se.ROUND_HALF_DOWN = 5, se.ROUND_HALF_EVEN = 6, se.ROUND_HALF_CEIL = 7, se.ROUND_HALF_FLOOR = 8, se.EUCLID = 9, se.config = se.set = function(B) {
      var j, Z;
      if (B != null) {
        if (typeof B != "object")
          throw Error(g + "Object expected: " + B);
        if (B.hasOwnProperty(j = "DECIMAL_PLACES") && (st(Z = B[j], 0, N, j), xt = Z), B.hasOwnProperty(j = "ROUNDING_MODE") && (st(Z = B[j], 0, 8, j), It = Z), B.hasOwnProperty(j = "EXPONENTIAL_AT") && ((Z = B[j]) && Z.pop ? (st(Z[0], -N, 0, j), st(Z[1], 0, N, j), Wt = Z[0], Ut = Z[1]) : (st(Z, -N, N, j), Wt = -(Ut = Z < 0 ? -Z : Z))), B.hasOwnProperty(j = "RANGE"))
          if ((Z = B[j]) && Z.pop)
            st(Z[0], -N, -1, j), st(Z[1], 1, N, j), zt = Z[0], Jt = Z[1];
          else {
            if (st(Z, -N, N, j), !Z)
              throw Error(g + j + " cannot be zero: " + Z);
            zt = -(Jt = Z < 0 ? -Z : Z);
          }
        if (B.hasOwnProperty(j = "CRYPTO")) {
          if ((Z = B[j]) !== !!Z)
            throw Error(g + j + " not true or false: " + Z);
          if (Z) {
            if (typeof crypto > "u" || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
              throw Xt = !Z, Error(g + "crypto unavailable");
            Xt = Z;
          } else
            Xt = Z;
        }
        if (B.hasOwnProperty(j = "MODULO_MODE") && (st(Z = B[j], 0, 9, j), ie = Z), B.hasOwnProperty(j = "POW_PRECISION") && (st(Z = B[j], 0, N, j), oe = Z), B.hasOwnProperty(j = "FORMAT")) {
          if (typeof (Z = B[j]) != "object")
            throw Error(g + j + " not an object: " + Z);
          De = Z;
        }
        if (B.hasOwnProperty(j = "ALPHABET")) {
          if (typeof (Z = B[j]) != "string" || /^.?$|[+\-.\s]|(.).*\1/.test(Z))
            throw Error(g + j + " invalid: " + Z);
          xe = Z.slice(0, 10) == "0123456789", ue = Z;
        }
      }
      return { DECIMAL_PLACES: xt, ROUNDING_MODE: It, EXPONENTIAL_AT: [Wt, Ut], RANGE: [zt, Jt], CRYPTO: Xt, MODULO_MODE: ie, POW_PRECISION: oe, FORMAT: De, ALPHABET: ue };
    }, se.isBigNumber = function(B) {
      if (!B || B._isBigNumber !== !0)
        return !1;
      if (!se.DEBUG)
        return !0;
      var j, Z, kt = B.c, $t = B.e, At = B.s;
      t:
        if ({}.toString.call(kt) == "[object Array]") {
          if ((At === 1 || At === -1) && $t >= -N && $t <= N && $t === h($t)) {
            if (kt[0] === 0) {
              if ($t === 0 && kt.length === 1)
                return !0;
              break t;
            }
            if ((j = ($t + 1) % I) < 1 && (j += I), String(kt[0]).length == j) {
              for (j = 0; j < kt.length; j++)
                if ((Z = kt[j]) < 0 || Z >= $ || Z !== h(Z))
                  break t;
              if (Z !== 0)
                return !0;
            }
          }
        } else if (kt === null && $t === null && (At === null || At === 1 || At === -1))
          return !0;
      throw Error(g + "Invalid BigNumber: " + B);
    }, se.maximum = se.max = function() {
      return je(arguments, it.lt);
    }, se.minimum = se.min = function() {
      return je(arguments, it.gt);
    }, se.random = (A = 9007199254740992, E = Math.random() * A & 2097151 ? function() {
      return h(Math.random() * A);
    } : function() {
      return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
    }, function(B) {
      var j, Z, kt, $t, At, Bt = 0, Ft = [], Kt = new se(vt);
      if (B == null ? B = xt : st(B, 0, N), $t = u(B / I), Xt)
        if (crypto.getRandomValues) {
          for (j = crypto.getRandomValues(new Uint32Array($t *= 2)); Bt < $t; )
            (At = 131072 * j[Bt] + (j[Bt + 1] >>> 11)) >= 9e15 ? (Z = crypto.getRandomValues(new Uint32Array(2)), j[Bt] = Z[0], j[Bt + 1] = Z[1]) : (Ft.push(At % 1e14), Bt += 2);
          Bt = $t / 2;
        } else {
          if (!crypto.randomBytes)
            throw Xt = !1, Error(g + "crypto unavailable");
          for (j = crypto.randomBytes($t *= 7); Bt < $t; )
            (At = 281474976710656 * (31 & j[Bt]) + 1099511627776 * j[Bt + 1] + 4294967296 * j[Bt + 2] + 16777216 * j[Bt + 3] + (j[Bt + 4] << 16) + (j[Bt + 5] << 8) + j[Bt + 6]) >= 9e15 ? crypto.randomBytes(7).copy(j, Bt) : (Ft.push(At % 1e14), Bt += 7);
          Bt = $t / 7;
        }
      if (!Xt)
        for (; Bt < $t; )
          (At = E()) < 9e15 && (Ft[Bt++] = At % 1e14);
      for ($t = Ft[--Bt], B %= I, $t && B && (At = L[I - B], Ft[Bt] = h($t / At) * At); Ft[Bt] === 0; Ft.pop(), Bt--)
        ;
      if (Bt < 0)
        Ft = [kt = 0];
      else {
        for (kt = -1; Ft[0] === 0; Ft.splice(0, 1), kt -= I)
          ;
        for (Bt = 1, At = Ft[0]; At >= 10; At /= 10, Bt++)
          ;
        Bt < I && (kt -= I - Bt);
      }
      return Kt.e = kt, Kt.c = Ft, Kt;
    }), se.sum = function() {
      for (var B = 1, j = arguments, Z = new se(j[0]); B < j.length; )
        Z = Z.plus(j[B++]);
      return Z;
    }, Nt = function() {
      var B = "0123456789";
      function j(Z, kt, $t, At) {
        for (var Bt, Ft, Kt = [0], Zt = 0, Gt = Z.length; Zt < Gt; ) {
          for (Ft = Kt.length; Ft--; Kt[Ft] *= kt)
            ;
          for (Kt[0] += At.indexOf(Z.charAt(Zt++)), Bt = 0; Bt < Kt.length; Bt++)
            Kt[Bt] > $t - 1 && (Kt[Bt + 1] == null && (Kt[Bt + 1] = 0), Kt[Bt + 1] += Kt[Bt] / $t | 0, Kt[Bt] %= $t);
        }
        return Kt.reverse();
      }
      return function(Z, kt, $t, At, Bt) {
        var Ft, Kt, Zt, Gt, Qt, Ae, ae, we, ir = Z.indexOf("."), ge = xt, _e = It;
        for (ir >= 0 && (Gt = oe, oe = 0, Z = Z.replace(".", ""), Ae = (we = new se(kt)).pow(Z.length - ir), oe = Gt, we.c = j(Ct(rt(Ae.c), Ae.e, "0"), 10, $t, B), we.e = we.c.length), Zt = Gt = (ae = j(Z, kt, $t, Bt ? (Ft = ue, B) : (Ft = B, ue))).length; ae[--Gt] == 0; ae.pop())
          ;
        if (!ae[0])
          return Ft.charAt(0);
        if (ir < 0 ? --Zt : (Ae.c = ae, Ae.e = Zt, Ae.s = At, ae = (Ae = _t(Ae, we, ge, _e, $t)).c, Qt = Ae.r, Zt = Ae.e), ir = ae[Kt = Zt + ge + 1], Gt = $t / 2, Qt = Qt || Kt < 0 || ae[Kt + 1] != null, Qt = _e < 4 ? (ir != null || Qt) && (_e == 0 || _e == (Ae.s < 0 ? 3 : 2)) : ir > Gt || ir == Gt && (_e == 4 || Qt || _e == 6 && 1 & ae[Kt - 1] || _e == (Ae.s < 0 ? 8 : 7)), Kt < 1 || !ae[0])
          Z = Qt ? Ct(Ft.charAt(1), -ge, Ft.charAt(0)) : Ft.charAt(0);
        else {
          if (ae.length = Kt, Qt)
            for (--$t; ++ae[--Kt] > $t; )
              ae[Kt] = 0, Kt || (++Zt, ae = [1].concat(ae));
          for (Gt = ae.length; !ae[--Gt]; )
            ;
          for (ir = 0, Z = ""; ir <= Gt; Z += Ft.charAt(ae[ir++]))
            ;
          Z = Ct(Z, Zt, Ft.charAt(0));
        }
        return Z;
      };
    }(), _t = function() {
      function B(kt, $t, At) {
        var Bt, Ft, Kt, Zt, Gt = 0, Qt = kt.length, Ae = $t % q, ae = $t / q | 0;
        for (kt = kt.slice(); Qt--; )
          Gt = ((Ft = Ae * (Kt = kt[Qt] % q) + (Bt = ae * Kt + (Zt = kt[Qt] / q | 0) * Ae) % q * q + Gt) / At | 0) + (Bt / q | 0) + ae * Zt, kt[Qt] = Ft % At;
        return Gt && (kt = [Gt].concat(kt)), kt;
      }
      function j(kt, $t, At, Bt) {
        var Ft, Kt;
        if (At != Bt)
          Kt = At > Bt ? 1 : -1;
        else
          for (Ft = Kt = 0; Ft < At; Ft++)
            if (kt[Ft] != $t[Ft]) {
              Kt = kt[Ft] > $t[Ft] ? 1 : -1;
              break;
            }
        return Kt;
      }
      function Z(kt, $t, At, Bt) {
        for (var Ft = 0; At--; )
          kt[At] -= Ft, Ft = kt[At] < $t[At] ? 1 : 0, kt[At] = Ft * Bt + kt[At] - $t[At];
        for (; !kt[0] && kt.length > 1; kt.splice(0, 1))
          ;
      }
      return function(kt, $t, At, Bt, Ft) {
        var Kt, Zt, Gt, Qt, Ae, ae, we, ir, ge, _e, rr, be, Ge, Rr, Te, Ie, Pr, Ee = kt.s == $t.s ? 1 : -1, er = kt.c, Or = $t.c;
        if (!(er && er[0] && Or && Or[0]))
          return new se(kt.s && $t.s && (er ? !Or || er[0] != Or[0] : Or) ? er && er[0] == 0 || !Or ? 0 * Ee : Ee / 0 : NaN);
        for (ge = (ir = new se(Ee)).c = [], Ee = At + (Zt = kt.e - $t.e) + 1, Ft || (Ft = $, Zt = X(kt.e / I) - X($t.e / I), Ee = Ee / I | 0), Gt = 0; Or[Gt] == (er[Gt] || 0); Gt++)
          ;
        if (Or[Gt] > (er[Gt] || 0) && Zt--, Ee < 0)
          ge.push(1), Qt = !0;
        else {
          for (Rr = er.length, Ie = Or.length, Gt = 0, Ee += 2, (Ae = h(Ft / (Or[0] + 1))) > 1 && (Or = B(Or, Ae, Ft), er = B(er, Ae, Ft), Ie = Or.length, Rr = er.length), Ge = Ie, rr = (_e = er.slice(0, Ie)).length; rr < Ie; _e[rr++] = 0)
            ;
          Pr = Or.slice(), Pr = [0].concat(Pr), Te = Or[0], Or[1] >= Ft / 2 && Te++;
          do {
            if (Ae = 0, (Kt = j(Or, _e, Ie, rr)) < 0) {
              if (be = _e[0], Ie != rr && (be = be * Ft + (_e[1] || 0)), (Ae = h(be / Te)) > 1)
                for (Ae >= Ft && (Ae = Ft - 1), we = (ae = B(Or, Ae, Ft)).length, rr = _e.length; j(ae, _e, we, rr) == 1; )
                  Ae--, Z(ae, Ie < we ? Pr : Or, we, Ft), we = ae.length, Kt = 1;
              else
                Ae == 0 && (Kt = Ae = 1), we = (ae = Or.slice()).length;
              if (we < rr && (ae = [0].concat(ae)), Z(_e, ae, rr, Ft), rr = _e.length, Kt == -1)
                for (; j(Or, _e, Ie, rr) < 1; )
                  Ae++, Z(_e, Ie < rr ? Pr : Or, rr, Ft), rr = _e.length;
            } else
              Kt === 0 && (Ae++, _e = [0]);
            ge[Gt++] = Ae, _e[0] ? _e[rr++] = er[Ge] || 0 : (_e = [er[Ge]], rr = 1);
          } while ((Ge++ < Rr || _e[0] != null) && Ee--);
          Qt = _e[0] != null, ge[0] || ge.splice(0, 1);
        }
        if (Ft == $) {
          for (Gt = 1, Ee = ge[0]; Ee >= 10; Ee /= 10, Gt++)
            ;
          de(ir, At + (ir.e = Gt + Zt * I - 1) + 1, Bt, Qt);
        } else
          ir.e = Zt, ir.r = +Qt;
        return ir;
      };
    }(), w = /^(-?)0([xbo])(?=\w[\w.]*$)/i, v = /^([^.]+)\.$/, k = /^\.([^.]+)$/, O = /^-?(Infinity|NaN)$/, W = /^\s*\+(?=[\w.])|^\s+|\s+$/g, m = function(B, j, Z, kt) {
      var $t, At = Z ? j : j.replace(W, "");
      if (O.test(At))
        B.s = isNaN(At) ? null : At < 0 ? -1 : 1;
      else {
        if (!Z && (At = At.replace(w, function(Bt, Ft, Kt) {
          return $t = (Kt = Kt.toLowerCase()) == "x" ? 16 : Kt == "b" ? 2 : 8, kt && kt != $t ? Bt : Ft;
        }), kt && ($t = kt, At = At.replace(v, "$1").replace(k, "0.$1")), j != At))
          return new se(At, $t);
        if (se.DEBUG)
          throw Error(g + "Not a" + (kt ? " base " + kt : "") + " number: " + j);
        B.s = null;
      }
      B.c = B.e = null;
    }, it.absoluteValue = it.abs = function() {
      var B = new se(this);
      return B.s < 0 && (B.s = 1), B;
    }, it.comparedTo = function(B, j) {
      return nt(this, new se(B, j));
    }, it.decimalPlaces = it.dp = function(B, j) {
      var Z, kt, $t, At = this;
      if (B != null)
        return st(B, 0, N), j == null ? j = It : st(j, 0, 8), de(new se(At), B + At.e + 1, j);
      if (!(Z = At.c))
        return null;
      if (kt = (($t = Z.length - 1) - X(this.e / I)) * I, $t = Z[$t])
        for (; $t % 10 == 0; $t /= 10, kt--)
          ;
      return kt < 0 && (kt = 0), kt;
    }, it.dividedBy = it.div = function(B, j) {
      return _t(this, new se(B, j), xt, It);
    }, it.dividedToIntegerBy = it.idiv = function(B, j) {
      return _t(this, new se(B, j), 0, 1);
    }, it.exponentiatedBy = it.pow = function(B, j) {
      var Z, kt, $t, At, Bt, Ft, Kt, Zt, Gt = this;
      if ((B = new se(B)).c && !B.isInteger())
        throw Error(g + "Exponent not an integer: " + We(B));
      if (j != null && (j = new se(j)), Bt = B.e > 14, !Gt.c || !Gt.c[0] || Gt.c[0] == 1 && !Gt.e && Gt.c.length == 1 || !B.c || !B.c[0])
        return Zt = new se(Math.pow(+We(Gt), Bt ? 2 - ot(B) : +We(B))), j ? Zt.mod(j) : Zt;
      if (Ft = B.s < 0, j) {
        if (j.c ? !j.c[0] : !j.s)
          return new se(NaN);
        (kt = !Ft && Gt.isInteger() && j.isInteger()) && (Gt = Gt.mod(j));
      } else {
        if (B.e > 9 && (Gt.e > 0 || Gt.e < -1 || (Gt.e == 0 ? Gt.c[0] > 1 || Bt && Gt.c[1] >= 24e7 : Gt.c[0] < 8e13 || Bt && Gt.c[0] <= 9999975e7)))
          return At = Gt.s < 0 && ot(B) ? -0 : 0, Gt.e > -1 && (At = 1 / At), new se(Ft ? 1 / At : At);
        oe && (At = u(oe / I + 2));
      }
      for (Bt ? (Z = new se(0.5), Ft && (B.s = 1), Kt = ot(B)) : Kt = ($t = Math.abs(+We(B))) % 2, Zt = new se(vt); ; ) {
        if (Kt) {
          if (!(Zt = Zt.times(Gt)).c)
            break;
          At ? Zt.c.length > At && (Zt.c.length = At) : kt && (Zt = Zt.mod(j));
        }
        if ($t) {
          if (($t = h($t / 2)) === 0)
            break;
          Kt = $t % 2;
        } else if (de(B = B.times(Z), B.e + 1, 1), B.e > 14)
          Kt = ot(B);
        else {
          if (($t = +We(B)) == 0)
            break;
          Kt = $t % 2;
        }
        Gt = Gt.times(Gt), At ? Gt.c && Gt.c.length > At && (Gt.c.length = At) : kt && (Gt = Gt.mod(j));
      }
      return kt ? Zt : (Ft && (Zt = vt.div(Zt)), j ? Zt.mod(j) : At ? de(Zt, oe, It, void 0) : Zt);
    }, it.integerValue = function(B) {
      var j = new se(this);
      return B == null ? B = It : st(B, 0, 8), de(j, j.e + 1, B);
    }, it.isEqualTo = it.eq = function(B, j) {
      return nt(this, new se(B, j)) === 0;
    }, it.isFinite = function() {
      return !!this.c;
    }, it.isGreaterThan = it.gt = function(B, j) {
      return nt(this, new se(B, j)) > 0;
    }, it.isGreaterThanOrEqualTo = it.gte = function(B, j) {
      return (j = nt(this, new se(B, j))) === 1 || j === 0;
    }, it.isInteger = function() {
      return !!this.c && X(this.e / I) > this.c.length - 2;
    }, it.isLessThan = it.lt = function(B, j) {
      return nt(this, new se(B, j)) < 0;
    }, it.isLessThanOrEqualTo = it.lte = function(B, j) {
      return (j = nt(this, new se(B, j))) === -1 || j === 0;
    }, it.isNaN = function() {
      return !this.s;
    }, it.isNegative = function() {
      return this.s < 0;
    }, it.isPositive = function() {
      return this.s > 0;
    }, it.isZero = function() {
      return !!this.c && this.c[0] == 0;
    }, it.minus = function(B, j) {
      var Z, kt, $t, At, Bt = this, Ft = Bt.s;
      if (j = (B = new se(B, j)).s, !Ft || !j)
        return new se(NaN);
      if (Ft != j)
        return B.s = -j, Bt.plus(B);
      var Kt = Bt.e / I, Zt = B.e / I, Gt = Bt.c, Qt = B.c;
      if (!Kt || !Zt) {
        if (!Gt || !Qt)
          return Gt ? (B.s = -j, B) : new se(Qt ? Bt : NaN);
        if (!Gt[0] || !Qt[0])
          return Qt[0] ? (B.s = -j, B) : new se(Gt[0] ? Bt : It == 3 ? -0 : 0);
      }
      if (Kt = X(Kt), Zt = X(Zt), Gt = Gt.slice(), Ft = Kt - Zt) {
        for ((At = Ft < 0) ? (Ft = -Ft, $t = Gt) : (Zt = Kt, $t = Qt), $t.reverse(), j = Ft; j--; $t.push(0))
          ;
        $t.reverse();
      } else
        for (kt = (At = (Ft = Gt.length) < (j = Qt.length)) ? Ft : j, Ft = j = 0; j < kt; j++)
          if (Gt[j] != Qt[j]) {
            At = Gt[j] < Qt[j];
            break;
          }
      if (At && ($t = Gt, Gt = Qt, Qt = $t, B.s = -B.s), (j = (kt = Qt.length) - (Z = Gt.length)) > 0)
        for (; j--; Gt[Z++] = 0)
          ;
      for (j = $ - 1; kt > Ft; ) {
        if (Gt[--kt] < Qt[kt]) {
          for (Z = kt; Z && !Gt[--Z]; Gt[Z] = j)
            ;
          --Gt[Z], Gt[kt] += $;
        }
        Gt[kt] -= Qt[kt];
      }
      for (; Gt[0] == 0; Gt.splice(0, 1), --Zt)
        ;
      return Gt[0] ? jr(B, Gt, Zt) : (B.s = It == 3 ? -1 : 1, B.c = [B.e = 0], B);
    }, it.modulo = it.mod = function(B, j) {
      var Z, kt, $t = this;
      return B = new se(B, j), !$t.c || !B.s || B.c && !B.c[0] ? new se(NaN) : !B.c || $t.c && !$t.c[0] ? new se($t) : (ie == 9 ? (kt = B.s, B.s = 1, Z = _t($t, B, 0, 3), B.s = kt, Z.s *= kt) : Z = _t($t, B, 0, ie), (B = $t.minus(Z.times(B))).c[0] || ie != 1 || (B.s = $t.s), B);
    }, it.multipliedBy = it.times = function(B, j) {
      var Z, kt, $t, At, Bt, Ft, Kt, Zt, Gt, Qt, Ae, ae, we, ir, ge, _e = this, rr = _e.c, be = (B = new se(B, j)).c;
      if (!(rr && be && rr[0] && be[0]))
        return !_e.s || !B.s || rr && !rr[0] && !be || be && !be[0] && !rr ? B.c = B.e = B.s = null : (B.s *= _e.s, rr && be ? (B.c = [0], B.e = 0) : B.c = B.e = null), B;
      for (kt = X(_e.e / I) + X(B.e / I), B.s *= _e.s, (Kt = rr.length) < (Qt = be.length) && (we = rr, rr = be, be = we, $t = Kt, Kt = Qt, Qt = $t), $t = Kt + Qt, we = []; $t--; we.push(0))
        ;
      for (ir = $, ge = q, $t = Qt; --$t >= 0; ) {
        for (Z = 0, Ae = be[$t] % ge, ae = be[$t] / ge | 0, At = $t + (Bt = Kt); At > $t; )
          Z = ((Zt = Ae * (Zt = rr[--Bt] % ge) + (Ft = ae * Zt + (Gt = rr[Bt] / ge | 0) * Ae) % ge * ge + we[At] + Z) / ir | 0) + (Ft / ge | 0) + ae * Gt, we[At--] = Zt % ir;
        we[At] = Z;
      }
      return Z ? ++kt : we.splice(0, 1), jr(B, we, kt);
    }, it.negated = function() {
      var B = new se(this);
      return B.s = -B.s || null, B;
    }, it.plus = function(B, j) {
      var Z, kt = this, $t = kt.s;
      if (j = (B = new se(B, j)).s, !$t || !j)
        return new se(NaN);
      if ($t != j)
        return B.s = -j, kt.minus(B);
      var At = kt.e / I, Bt = B.e / I, Ft = kt.c, Kt = B.c;
      if (!At || !Bt) {
        if (!Ft || !Kt)
          return new se($t / 0);
        if (!Ft[0] || !Kt[0])
          return Kt[0] ? B : new se(Ft[0] ? kt : 0 * $t);
      }
      if (At = X(At), Bt = X(Bt), Ft = Ft.slice(), $t = At - Bt) {
        for ($t > 0 ? (Bt = At, Z = Kt) : ($t = -$t, Z = Ft), Z.reverse(); $t--; Z.push(0))
          ;
        Z.reverse();
      }
      for (($t = Ft.length) - (j = Kt.length) < 0 && (Z = Kt, Kt = Ft, Ft = Z, j = $t), $t = 0; j; )
        $t = (Ft[--j] = Ft[j] + Kt[j] + $t) / $ | 0, Ft[j] = $ === Ft[j] ? 0 : Ft[j] % $;
      return $t && (Ft = [$t].concat(Ft), ++Bt), jr(B, Ft, Bt);
    }, it.precision = it.sd = function(B, j) {
      var Z, kt, $t, At = this;
      if (B != null && B !== !!B)
        return st(B, 1, N), j == null ? j = It : st(j, 0, 8), de(new se(At), B, j);
      if (!(Z = At.c))
        return null;
      if (kt = ($t = Z.length - 1) * I + 1, $t = Z[$t]) {
        for (; $t % 10 == 0; $t /= 10, kt--)
          ;
        for ($t = Z[0]; $t >= 10; $t /= 10, kt++)
          ;
      }
      return B && At.e + 1 > kt && (kt = At.e + 1), kt;
    }, it.shiftedBy = function(B) {
      return st(B, -9007199254740991, P), this.times("1e" + B);
    }, it.squareRoot = it.sqrt = function() {
      var B, j, Z, kt, $t, At = this, Bt = At.c, Ft = At.s, Kt = At.e, Zt = xt + 4, Gt = new se("0.5");
      if (Ft !== 1 || !Bt || !Bt[0])
        return new se(!Ft || Ft < 0 && (!Bt || Bt[0]) ? NaN : Bt ? At : 1 / 0);
      if ((Ft = Math.sqrt(+We(At))) == 0 || Ft == 1 / 0 ? (((j = rt(Bt)).length + Kt) % 2 == 0 && (j += "0"), Ft = Math.sqrt(+j), Kt = X((Kt + 1) / 2) - (Kt < 0 || Kt % 2), Z = new se(j = Ft == 1 / 0 ? "5e" + Kt : (j = Ft.toExponential()).slice(0, j.indexOf("e") + 1) + Kt)) : Z = new se(Ft + ""), Z.c[0]) {
        for ((Ft = (Kt = Z.e) + Zt) < 3 && (Ft = 0); ; )
          if ($t = Z, Z = Gt.times($t.plus(_t(At, $t, Zt, 1))), rt($t.c).slice(0, Ft) === (j = rt(Z.c)).slice(0, Ft)) {
            if (Z.e < Kt && --Ft, (j = j.slice(Ft - 3, Ft + 1)) != "9999" && (kt || j != "4999")) {
              +j && (+j.slice(1) || j.charAt(0) != "5") || (de(Z, Z.e + xt + 2, 1), B = !Z.times(Z).eq(At));
              break;
            }
            if (!kt && (de($t, $t.e + xt + 2, 0), $t.times($t).eq(At))) {
              Z = $t;
              break;
            }
            Zt += 4, Ft += 4, kt = 1;
          }
      }
      return de(Z, Z.e + xt + 1, It, B);
    }, it.toExponential = function(B, j) {
      return B != null && (st(B, 0, N), B++), he(this, B, j, 1);
    }, it.toFixed = function(B, j) {
      return B != null && (st(B, 0, N), B = B + this.e + 1), he(this, B, j);
    }, it.toFormat = function(B, j, Z) {
      var kt, $t = this;
      if (Z == null)
        B != null && j && typeof j == "object" ? (Z = j, j = null) : B && typeof B == "object" ? (Z = B, B = j = null) : Z = De;
      else if (typeof Z != "object")
        throw Error(g + "Argument not an object: " + Z);
      if (kt = $t.toFixed(B, j), $t.c) {
        var At, Bt = kt.split("."), Ft = +Z.groupSize, Kt = +Z.secondaryGroupSize, Zt = Z.groupSeparator || "", Gt = Bt[0], Qt = Bt[1], Ae = $t.s < 0, ae = Ae ? Gt.slice(1) : Gt, we = ae.length;
        if (Kt && (At = Ft, Ft = Kt, Kt = At, we -= At), Ft > 0 && we > 0) {
          for (At = we % Ft || Ft, Gt = ae.substr(0, At); At < we; At += Ft)
            Gt += Zt + ae.substr(At, Ft);
          Kt > 0 && (Gt += Zt + ae.slice(At)), Ae && (Gt = "-" + Gt);
        }
        kt = Qt ? Gt + (Z.decimalSeparator || "") + ((Kt = +Z.fractionGroupSize) ? Qt.replace(new RegExp("\\d{" + Kt + "}\\B", "g"), "$&" + (Z.fractionGroupSeparator || "")) : Qt) : Gt;
      }
      return (Z.prefix || "") + kt + (Z.suffix || "");
    }, it.toFraction = function(B) {
      var j, Z, kt, $t, At, Bt, Ft, Kt, Zt, Gt, Qt, Ae, ae = this, we = ae.c;
      if (B != null && (!(Ft = new se(B)).isInteger() && (Ft.c || Ft.s !== 1) || Ft.lt(vt)))
        throw Error(g + "Argument " + (Ft.isInteger() ? "out of range: " : "not an integer: ") + We(Ft));
      if (!we)
        return new se(ae);
      for (j = new se(vt), Zt = Z = new se(vt), kt = Kt = new se(vt), Ae = rt(we), At = j.e = Ae.length - ae.e - 1, j.c[0] = L[(Bt = At % I) < 0 ? I + Bt : Bt], B = !B || Ft.comparedTo(j) > 0 ? At > 0 ? j : Zt : Ft, Bt = Jt, Jt = 1 / 0, Ft = new se(Ae), Kt.c[0] = 0; Gt = _t(Ft, j, 0, 1), ($t = Z.plus(Gt.times(kt))).comparedTo(B) != 1; )
        Z = kt, kt = $t, Zt = Kt.plus(Gt.times($t = Zt)), Kt = $t, j = Ft.minus(Gt.times($t = j)), Ft = $t;
      return $t = _t(B.minus(Z), kt, 0, 1), Kt = Kt.plus($t.times(Zt)), Z = Z.plus($t.times(kt)), Kt.s = Zt.s = ae.s, Qt = _t(Zt, kt, At *= 2, It).minus(ae).abs().comparedTo(_t(Kt, Z, At, It).minus(ae).abs()) < 1 ? [Zt, kt] : [Kt, Z], Jt = Bt, Qt;
    }, it.toNumber = function() {
      return +We(this);
    }, it.toPrecision = function(B, j) {
      return B != null && st(B, 1, N), he(this, B, j, 2);
    }, it.toString = function(B) {
      var j, Z = this, kt = Z.s, $t = Z.e;
      return $t === null ? kt ? (j = "Infinity", kt < 0 && (j = "-" + j)) : j = "NaN" : (B == null ? j = $t <= Wt || $t >= Ut ? St(rt(Z.c), $t) : Ct(rt(Z.c), $t, "0") : B === 10 && xe ? j = Ct(rt((Z = de(new se(Z), xt + $t + 1, It)).c), Z.e, "0") : (st(B, 2, ue.length, "Base"), j = Nt(Ct(rt(Z.c), $t, "0"), 10, B, kt, !0)), kt < 0 && Z.c[0] && (j = "-" + j)), j;
    }, it.valueOf = it.toJSON = function() {
      return We(this);
    }, it._isBigNumber = !0, at != null && se.set(at), se;
  }(), n.default = n.BigNumber = n, e.exports ? e.exports = n : (o || (o = typeof self < "u" && self ? self : window), o.BigNumber = n);
}(commonjsGlobal), Object.defineProperty(ar$1, "__esModule", { value: !0 });
const bignumber_js_1$2 = bignumber.exports;
class Ar$2 {
  constructor() {
    this.BigNum = (n, c) => new (bignumber_js_1$2.BigNumber.clone({ DECIMAL_PLACES: c }))(n);
  }
  winstonToAr(n, { formatted: c = !1, decimals: u = 12, trim: h = !0 } = {}) {
    let g = this.stringToBigNum(n, u).shiftedBy(-12);
    return c ? g.toFormat(u) : g.toFixed(u);
  }
  arToWinston(n, { formatted: c = !1 } = {}) {
    let u = this.stringToBigNum(n).shiftedBy(12);
    return c ? u.toFormat() : u.toFixed(0);
  }
  compare(n, c) {
    let u = this.stringToBigNum(n), h = this.stringToBigNum(c);
    return u.comparedTo(h);
  }
  isEqual(n, c) {
    return this.compare(n, c) === 0;
  }
  isLessThan(n, c) {
    let u = this.stringToBigNum(n), h = this.stringToBigNum(c);
    return u.isLessThan(h);
  }
  isGreaterThan(n, c) {
    let u = this.stringToBigNum(n), h = this.stringToBigNum(c);
    return u.isGreaterThan(h);
  }
  add(n, c) {
    let u = this.stringToBigNum(n);
    return this.stringToBigNum(c), u.plus(c).toFixed(0);
  }
  sub(n, c) {
    let u = this.stringToBigNum(n);
    return this.stringToBigNum(c), u.minus(c).toFixed(0);
  }
  stringToBigNum(n, c = 12) {
    return this.BigNum(n, c);
  }
}
ar$1.default = Ar$2;
var api$2 = {}, axios$3 = { exports: {} }, axios$2 = { exports: {} }, bind$2 = function(o, n) {
  return function() {
    for (var c = new Array(arguments.length), u = 0; u < c.length; u++)
      c[u] = arguments[u];
    return o.apply(n, c);
  };
}, bind$1 = bind$2, toString$a = Object.prototype.toString, kindOf = function(o) {
  return function(n) {
    var c = toString$a.call(n);
    return o[c] || (o[c] = c.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
function kindOfTest(o) {
  return o = o.toLowerCase(), function(n) {
    return kindOf(n) === o;
  };
}
function isArray$4(o) {
  return Array.isArray(o);
}
function isUndefined(o) {
  return o === void 0;
}
function isBuffer$5(o) {
  return o !== null && !isUndefined(o) && o.constructor !== null && !isUndefined(o.constructor) && typeof o.constructor.isBuffer == "function" && o.constructor.isBuffer(o);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(o) {
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(o) : o && o.buffer && isArrayBuffer(o.buffer);
}
function isString(o) {
  return typeof o == "string";
}
function isNumber(o) {
  return typeof o == "number";
}
function isObject$7(o) {
  return o !== null && typeof o == "object";
}
function isPlainObject$1(o) {
  if (kindOf(o) !== "object")
    return !1;
  var n = Object.getPrototypeOf(o);
  return n === null || n === Object.prototype;
}
var isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob$1 = kindOfTest("Blob"), isFileList = kindOfTest("FileList");
function isFunction$3(o) {
  return toString$a.call(o) === "[object Function]";
}
function isStream(o) {
  return isObject$7(o) && isFunction$3(o.pipe);
}
function isFormData(o) {
  var n = "[object FormData]";
  return o && (typeof FormData == "function" && o instanceof FormData || toString$a.call(o) === n || isFunction$3(o.toString) && o.toString() === n);
}
var isURLSearchParams = kindOfTest("URLSearchParams");
function trim(o) {
  return o.trim ? o.trim() : o.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  return (typeof navigator > "u" || navigator.product !== "ReactNative" && navigator.product !== "NativeScript" && navigator.product !== "NS") && typeof window < "u" && typeof document < "u";
}
function forEach(o, n) {
  if (o != null)
    if (typeof o != "object" && (o = [o]), isArray$4(o))
      for (var c = 0, u = o.length; c < u; c++)
        n.call(null, o[c], c, o);
    else
      for (var h in o)
        Object.prototype.hasOwnProperty.call(o, h) && n.call(null, o[h], h, o);
}
function merge$2() {
  var o = {};
  function n(h, g) {
    isPlainObject$1(o[g]) && isPlainObject$1(h) ? o[g] = merge$2(o[g], h) : isPlainObject$1(h) ? o[g] = merge$2({}, h) : isArray$4(h) ? o[g] = h.slice() : o[g] = h;
  }
  for (var c = 0, u = arguments.length; c < u; c++)
    forEach(arguments[c], n);
  return o;
}
function extend(o, n, c) {
  return forEach(n, function(u, h) {
    o[h] = c && typeof u == "function" ? bind$1(u, c) : u;
  }), o;
}
function stripBOM(o) {
  return o.charCodeAt(0) === 65279 && (o = o.slice(1)), o;
}
function inherits$a(o, n, c, u) {
  o.prototype = Object.create(n.prototype, u), o.prototype.constructor = o, c && Object.assign(o.prototype, c);
}
function toFlatObject(o, n, c) {
  var u, h, g, y = {};
  n = n || {};
  do {
    for (h = (u = Object.getOwnPropertyNames(o)).length; h-- > 0; )
      y[g = u[h]] || (n[g] = o[g], y[g] = !0);
    o = Object.getPrototypeOf(o);
  } while (o && (!c || c(o, n)) && o !== Object.prototype);
  return n;
}
function endsWith(o, n, c) {
  o = String(o), (c === void 0 || c > o.length) && (c = o.length), c -= n.length;
  var u = o.indexOf(n, c);
  return u !== -1 && u === c;
}
function toArray$1(o) {
  if (!o)
    return null;
  var n = o.length;
  if (isUndefined(n))
    return null;
  for (var c = new Array(n); n-- > 0; )
    c[n] = o[n];
  return c;
}
var isTypedArray$3 = (TypedArray = typeof Uint8Array < "u" && Object.getPrototypeOf(Uint8Array), function(o) {
  return TypedArray && o instanceof TypedArray;
}), TypedArray, utils$C = { isArray: isArray$4, isArrayBuffer, isBuffer: isBuffer$5, isFormData, isArrayBufferView, isString, isNumber, isObject: isObject$7, isPlainObject: isPlainObject$1, isUndefined, isDate, isFile, isBlob: isBlob$1, isFunction: isFunction$3, isStream, isURLSearchParams, isStandardBrowserEnv, forEach, merge: merge$2, extend, trim, stripBOM, inherits: inherits$a, toFlatObject, kindOf, kindOfTest, endsWith, toArray: toArray$1, isTypedArray: isTypedArray$3, isFileList }, utils$B = utils$C;
function encode$u(o) {
  return encodeURIComponent(o).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function(o, n, c) {
  if (!n)
    return o;
  var u;
  if (c)
    u = c(n);
  else if (utils$B.isURLSearchParams(n))
    u = n.toString();
  else {
    var h = [];
    utils$B.forEach(n, function(y, $) {
      y != null && (utils$B.isArray(y) ? $ += "[]" : y = [y], utils$B.forEach(y, function(I) {
        utils$B.isDate(I) ? I = I.toISOString() : utils$B.isObject(I) && (I = JSON.stringify(I)), h.push(encode$u($) + "=" + encode$u(I));
      }));
    }), u = h.join("&");
  }
  if (u) {
    var g = o.indexOf("#");
    g !== -1 && (o = o.slice(0, g)), o += (o.indexOf("?") === -1 ? "?" : "&") + u;
  }
  return o;
}, utils$A = utils$C;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function(o, n, c) {
  return this.handlers.push({ fulfilled: o, rejected: n, synchronous: !!c && c.synchronous, runWhen: c ? c.runWhen : null }), this.handlers.length - 1;
}, InterceptorManager$1.prototype.eject = function(o) {
  this.handlers[o] && (this.handlers[o] = null);
}, InterceptorManager$1.prototype.forEach = function(o) {
  utils$A.forEach(this.handlers, function(n) {
    n !== null && o(n);
  });
};
var InterceptorManager_1 = InterceptorManager$1, utils$z = utils$C, normalizeHeaderName$1 = function(o, n) {
  utils$z.forEach(o, function(c, u) {
    u !== n && u.toUpperCase() === n.toUpperCase() && (o[n] = c, delete o[u]);
  });
}, utils$y = utils$C;
function AxiosError$2(o, n, c, u, h) {
  Error.call(this), this.message = o, this.name = "AxiosError", n && (this.code = n), c && (this.config = c), u && (this.request = u), h && (this.response = h);
}
utils$y.inherits(AxiosError$2, Error, { toJSON: function() {
  return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
} });
var prototype = AxiosError$2.prototype, descriptors = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(o) {
  descriptors[o] = { value: o };
}), Object.defineProperties(AxiosError$2, descriptors), Object.defineProperty(prototype, "isAxiosError", { value: !0 }), AxiosError$2.from = function(o, n, c, u, h, g) {
  var y = Object.create(prototype);
  return utils$y.toFlatObject(o, y, function($) {
    return $ !== Error.prototype;
  }), AxiosError$2.call(y, o.message, n, c, u, h), y.name = o.name, g && Object.assign(y, g), y;
};
var AxiosError_1 = AxiosError$2, transitional = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, utils$x = utils$C;
function toFormData$1(o, n) {
  n = n || new FormData();
  var c = [];
  function u(h) {
    return h === null ? "" : utils$x.isDate(h) ? h.toISOString() : utils$x.isArrayBuffer(h) || utils$x.isTypedArray(h) ? typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  return function h(g, y) {
    if (utils$x.isPlainObject(g) || utils$x.isArray(g)) {
      if (c.indexOf(g) !== -1)
        throw Error("Circular reference detected in " + y);
      c.push(g), utils$x.forEach(g, function($, I) {
        if (!utils$x.isUndefined($)) {
          var P, L = y ? y + "." + I : I;
          if ($ && !y && typeof $ == "object") {
            if (utils$x.endsWith(I, "{}"))
              $ = JSON.stringify($);
            else if (utils$x.endsWith(I, "[]") && (P = utils$x.toArray($)))
              return void P.forEach(function(q) {
                !utils$x.isUndefined(q) && n.append(L, u(q));
              });
          }
          h($, L);
        }
      }), c.pop();
    } else
      n.append(y, u(g));
  }(o), n;
}
var toFormData_1 = toFormData$1, settle, hasRequiredSettle, cookies, hasRequiredCookies;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var o = AxiosError_1;
  return settle = function(n, c, u) {
    var h = u.config.validateStatus;
    u.status && h && !h(u.status) ? c(new o("Request failed with status code " + u.status, [o.ERR_BAD_REQUEST, o.ERR_BAD_RESPONSE][Math.floor(u.status / 100) - 4], u.config, u.request, u)) : n(u);
  };
}
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var o = utils$C;
  return cookies = o.isStandardBrowserEnv() ? { write: function(n, c, u, h, g, y) {
    var $ = [];
    $.push(n + "=" + encodeURIComponent(c)), o.isNumber(u) && $.push("expires=" + new Date(u).toGMTString()), o.isString(h) && $.push("path=" + h), o.isString(g) && $.push("domain=" + g), y === !0 && $.push("secure"), document.cookie = $.join("; ");
  }, read: function(n) {
    var c = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
    return c ? decodeURIComponent(c[3]) : null;
  }, remove: function(n) {
    this.write(n, "", Date.now() - 864e5);
  } } : { write: function() {
  }, read: function() {
    return null;
  }, remove: function() {
  } }, cookies;
}
var isAbsoluteURL$1 = function(o) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(o);
}, combineURLs$1 = function(o, n) {
  return n ? o.replace(/\/+$/, "") + "/" + n.replace(/^\/+/, "") : o;
}, isAbsoluteURL = isAbsoluteURL$1, combineURLs = combineURLs$1, buildFullPath$1 = function(o, n) {
  return o && !isAbsoluteURL(n) ? combineURLs(o, n) : n;
}, parseHeaders, hasRequiredParseHeaders, isURLSameOrigin, hasRequiredIsURLSameOrigin, CanceledError_1, hasRequiredCanceledError, parseProtocol, hasRequiredParseProtocol, xhr, hasRequiredXhr, _null, hasRequired_null;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var o = utils$C, n = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
  return parseHeaders = function(c) {
    var u, h, g, y = {};
    return c && o.forEach(c.split(`
`), function($) {
      if (g = $.indexOf(":"), u = o.trim($.substr(0, g)).toLowerCase(), h = o.trim($.substr(g + 1)), u) {
        if (y[u] && n.indexOf(u) >= 0)
          return;
        y[u] = u === "set-cookie" ? (y[u] ? y[u] : []).concat([h]) : y[u] ? y[u] + ", " + h : h;
      }
    }), y;
  }, parseHeaders;
}
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var o = utils$C;
  return isURLSameOrigin = o.isStandardBrowserEnv() ? function() {
    var n, c = /(msie|trident)/i.test(navigator.userAgent), u = document.createElement("a");
    function h(g) {
      var y = g;
      return c && (u.setAttribute("href", y), y = u.href), u.setAttribute("href", y), { href: u.href, protocol: u.protocol ? u.protocol.replace(/:$/, "") : "", host: u.host, search: u.search ? u.search.replace(/^\?/, "") : "", hash: u.hash ? u.hash.replace(/^#/, "") : "", hostname: u.hostname, port: u.port, pathname: u.pathname.charAt(0) === "/" ? u.pathname : "/" + u.pathname };
    }
    return n = h(window.location.href), function(g) {
      var y = o.isString(g) ? h(g) : g;
      return y.protocol === n.protocol && y.host === n.host;
    };
  }() : function() {
    return !0;
  };
}
function requireCanceledError() {
  if (hasRequiredCanceledError)
    return CanceledError_1;
  hasRequiredCanceledError = 1;
  var o = AxiosError_1;
  function n(c) {
    o.call(this, c == null ? "canceled" : c, o.ERR_CANCELED), this.name = "CanceledError";
  }
  return utils$C.inherits(n, o, { __CANCEL__: !0 }), CanceledError_1 = n;
}
function requireParseProtocol() {
  return hasRequiredParseProtocol ? parseProtocol : (hasRequiredParseProtocol = 1, parseProtocol = function(o) {
    var n = /^([-+\w]{1,25})(:?\/\/|:)/.exec(o);
    return n && n[1] || "";
  });
}
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var o = utils$C, n = requireSettle(), c = requireCookies(), u = buildURL$1, h = buildFullPath$1, g = requireParseHeaders(), y = requireIsURLSameOrigin(), $ = transitional, I = AxiosError_1, P = requireCanceledError(), L = requireParseProtocol();
  return xhr = function(q) {
    return new Promise(function(N, X) {
      var rt, nt = q.data, st = q.headers, ot = q.responseType;
      function St() {
        q.cancelToken && q.cancelToken.unsubscribe(rt), q.signal && q.signal.removeEventListener("abort", rt);
      }
      o.isFormData(nt) && o.isStandardBrowserEnv() && delete st["Content-Type"];
      var Ct = new XMLHttpRequest();
      if (q.auth) {
        var et = q.auth.username || "", at = q.auth.password ? unescape(encodeURIComponent(q.auth.password)) : "";
        st.Authorization = "Basic " + btoa(et + ":" + at);
      }
      var _t = h(q.baseURL, q.url);
      function Nt() {
        if (Ct) {
          var E = "getAllResponseHeaders" in Ct ? g(Ct.getAllResponseHeaders()) : null, w = { data: ot && ot !== "text" && ot !== "json" ? Ct.response : Ct.responseText, status: Ct.status, statusText: Ct.statusText, headers: E, config: q, request: Ct };
          n(function(v) {
            N(v), St();
          }, function(v) {
            X(v), St();
          }, w), Ct = null;
        }
      }
      if (Ct.open(q.method.toUpperCase(), u(_t, q.params, q.paramsSerializer), !0), Ct.timeout = q.timeout, "onloadend" in Ct ? Ct.onloadend = Nt : Ct.onreadystatechange = function() {
        Ct && Ct.readyState === 4 && (Ct.status !== 0 || Ct.responseURL && Ct.responseURL.indexOf("file:") === 0) && setTimeout(Nt);
      }, Ct.onabort = function() {
        Ct && (X(new I("Request aborted", I.ECONNABORTED, q, Ct)), Ct = null);
      }, Ct.onerror = function() {
        X(new I("Network Error", I.ERR_NETWORK, q, Ct, Ct)), Ct = null;
      }, Ct.ontimeout = function() {
        var E = q.timeout ? "timeout of " + q.timeout + "ms exceeded" : "timeout exceeded", w = q.transitional || $;
        q.timeoutErrorMessage && (E = q.timeoutErrorMessage), X(new I(E, w.clarifyTimeoutError ? I.ETIMEDOUT : I.ECONNABORTED, q, Ct)), Ct = null;
      }, o.isStandardBrowserEnv()) {
        var m = (q.withCredentials || y(_t)) && q.xsrfCookieName ? c.read(q.xsrfCookieName) : void 0;
        m && (st[q.xsrfHeaderName] = m);
      }
      "setRequestHeader" in Ct && o.forEach(st, function(E, w) {
        nt === void 0 && w.toLowerCase() === "content-type" ? delete st[w] : Ct.setRequestHeader(w, E);
      }), o.isUndefined(q.withCredentials) || (Ct.withCredentials = !!q.withCredentials), ot && ot !== "json" && (Ct.responseType = q.responseType), typeof q.onDownloadProgress == "function" && Ct.addEventListener("progress", q.onDownloadProgress), typeof q.onUploadProgress == "function" && Ct.upload && Ct.upload.addEventListener("progress", q.onUploadProgress), (q.cancelToken || q.signal) && (rt = function(E) {
        Ct && (X(!E || E && E.type ? new P() : E), Ct.abort(), Ct = null);
      }, q.cancelToken && q.cancelToken.subscribe(rt), q.signal && (q.signal.aborted ? rt() : q.signal.addEventListener("abort", rt))), nt || (nt = null);
      var A = L(_t);
      A && ["http", "https", "file"].indexOf(A) === -1 ? X(new I("Unsupported protocol " + A + ":", I.ERR_BAD_REQUEST, q)) : Ct.send(nt);
    });
  }, xhr;
}
function require_null() {
  return hasRequired_null ? _null : (hasRequired_null = 1, _null = null);
}
var utils$w = utils$C, normalizeHeaderName = normalizeHeaderName$1, AxiosError$1 = AxiosError_1, transitionalDefaults = transitional, toFormData = toFormData_1, DEFAULT_CONTENT_TYPE = { "Content-Type": "application/x-www-form-urlencoded" };
function setContentTypeIfUnset(o, n) {
  !utils$w.isUndefined(o) && utils$w.isUndefined(o["Content-Type"]) && (o["Content-Type"] = n);
}
function getDefaultAdapter() {
  var o;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (o = requireXhr()), o;
}
function stringifySafely(o, n, c) {
  if (utils$w.isString(o))
    try {
      return (n || JSON.parse)(o), utils$w.trim(o);
    } catch (u) {
      if (u.name !== "SyntaxError")
        throw u;
    }
  return (c || JSON.stringify)(o);
}
var defaults$3 = { transitional: transitionalDefaults, adapter: getDefaultAdapter(), transformRequest: [function(o, n) {
  if (normalizeHeaderName(n, "Accept"), normalizeHeaderName(n, "Content-Type"), utils$w.isFormData(o) || utils$w.isArrayBuffer(o) || utils$w.isBuffer(o) || utils$w.isStream(o) || utils$w.isFile(o) || utils$w.isBlob(o))
    return o;
  if (utils$w.isArrayBufferView(o))
    return o.buffer;
  if (utils$w.isURLSearchParams(o))
    return setContentTypeIfUnset(n, "application/x-www-form-urlencoded;charset=utf-8"), o.toString();
  var c, u = utils$w.isObject(o), h = n && n["Content-Type"];
  if ((c = utils$w.isFileList(o)) || u && h === "multipart/form-data") {
    var g = this.env && this.env.FormData;
    return toFormData(c ? { "files[]": o } : o, g && new g());
  }
  return u || h === "application/json" ? (setContentTypeIfUnset(n, "application/json"), stringifySafely(o)) : o;
}], transformResponse: [function(o) {
  var n = this.transitional || defaults$3.transitional, c = n && n.silentJSONParsing, u = n && n.forcedJSONParsing, h = !c && this.responseType === "json";
  if (h || u && utils$w.isString(o) && o.length)
    try {
      return JSON.parse(o);
    } catch (g) {
      if (h)
        throw g.name === "SyntaxError" ? AxiosError$1.from(g, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response) : g;
    }
  return o;
}], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: require_null() }, validateStatus: function(o) {
  return o >= 200 && o < 300;
}, headers: { common: { Accept: "application/json, text/plain, */*" } } };
utils$w.forEach(["delete", "get", "head"], function(o) {
  defaults$3.headers[o] = {};
}), utils$w.forEach(["post", "put", "patch"], function(o) {
  defaults$3.headers[o] = utils$w.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3, utils$v = utils$C, defaults$2 = defaults_1, transformData$1 = function(o, n, c) {
  var u = this || defaults$2;
  return utils$v.forEach(c, function(h) {
    o = h.call(u, o, n);
  }), o;
}, isCancel$1, hasRequiredIsCancel;
function requireIsCancel() {
  return hasRequiredIsCancel ? isCancel$1 : (hasRequiredIsCancel = 1, isCancel$1 = function(o) {
    return !(!o || !o.__CANCEL__);
  });
}
var utils$u = utils$C, transformData = transformData$1, isCancel = requireIsCancel(), defaults$1 = defaults_1, CanceledError = requireCanceledError();
function throwIfCancellationRequested(o) {
  if (o.cancelToken && o.cancelToken.throwIfRequested(), o.signal && o.signal.aborted)
    throw new CanceledError();
}
var dispatchRequest$1 = function(o) {
  return throwIfCancellationRequested(o), o.headers = o.headers || {}, o.data = transformData.call(o, o.data, o.headers, o.transformRequest), o.headers = utils$u.merge(o.headers.common || {}, o.headers[o.method] || {}, o.headers), utils$u.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(n) {
    delete o.headers[n];
  }), (o.adapter || defaults$1.adapter)(o).then(function(n) {
    return throwIfCancellationRequested(o), n.data = transformData.call(o, n.data, n.headers, o.transformResponse), n;
  }, function(n) {
    return isCancel(n) || (throwIfCancellationRequested(o), n && n.response && (n.response.data = transformData.call(o, n.response.data, n.response.headers, o.transformResponse))), Promise.reject(n);
  });
}, utils$t = utils$C, mergeConfig$2 = function(o, n) {
  n = n || {};
  var c = {};
  function u(P, L) {
    return utils$t.isPlainObject(P) && utils$t.isPlainObject(L) ? utils$t.merge(P, L) : utils$t.isPlainObject(L) ? utils$t.merge({}, L) : utils$t.isArray(L) ? L.slice() : L;
  }
  function h(P) {
    return utils$t.isUndefined(n[P]) ? utils$t.isUndefined(o[P]) ? void 0 : u(void 0, o[P]) : u(o[P], n[P]);
  }
  function g(P) {
    if (!utils$t.isUndefined(n[P]))
      return u(void 0, n[P]);
  }
  function y(P) {
    return utils$t.isUndefined(n[P]) ? utils$t.isUndefined(o[P]) ? void 0 : u(void 0, o[P]) : u(void 0, n[P]);
  }
  function $(P) {
    return P in n ? u(o[P], n[P]) : P in o ? u(void 0, o[P]) : void 0;
  }
  var I = { url: g, method: g, data: g, baseURL: y, transformRequest: y, transformResponse: y, paramsSerializer: y, timeout: y, timeoutMessage: y, withCredentials: y, adapter: y, responseType: y, xsrfCookieName: y, xsrfHeaderName: y, onUploadProgress: y, onDownloadProgress: y, decompress: y, maxContentLength: y, maxBodyLength: y, beforeRedirect: y, transport: y, httpAgent: y, httpsAgent: y, cancelToken: y, socketPath: y, responseEncoding: y, validateStatus: $ };
  return utils$t.forEach(Object.keys(o).concat(Object.keys(n)), function(P) {
    var L = I[P] || h, q = L(P);
    utils$t.isUndefined(q) && L !== $ || (c[P] = q);
  }), c;
}, data$1, hasRequiredData;
function requireData() {
  return hasRequiredData ? data$1 : (hasRequiredData = 1, data$1 = { version: "0.27.2" });
}
var VERSION = requireData().version, AxiosError = AxiosError_1, validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(o, n) {
  validators$1[o] = function(c) {
    return typeof c === o || "a" + (n < 1 ? "n " : " ") + o;
  };
});
var deprecatedWarnings = {};
function assertOptions(o, n, c) {
  if (typeof o != "object")
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  for (var u = Object.keys(o), h = u.length; h-- > 0; ) {
    var g = u[h], y = n[g];
    if (y) {
      var $ = o[g], I = $ === void 0 || y($, g, o);
      if (I !== !0)
        throw new AxiosError("option " + g + " must be " + I, AxiosError.ERR_BAD_OPTION_VALUE);
    } else if (c !== !0)
      throw new AxiosError("Unknown option " + g, AxiosError.ERR_BAD_OPTION);
  }
}
validators$1.transitional = function(o, n, c) {
  function u(h, g) {
    return "[Axios v" + VERSION + "] Transitional option '" + h + "'" + g + (c ? ". " + c : "");
  }
  return function(h, g, y) {
    if (o === !1)
      throw new AxiosError(u(g, " has been removed" + (n ? " in " + n : "")), AxiosError.ERR_DEPRECATED);
    return n && !deprecatedWarnings[g] && (deprecatedWarnings[g] = !0, console.warn(u(g, " has been deprecated since v" + n + " and will be removed in the near future"))), !o || o(h, g, y);
  };
};
var validator$1 = { assertOptions, validators: validators$1 }, utils$s = utils$C, buildURL = buildURL$1, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, buildFullPath = buildFullPath$1, validator = validator$1, validators = validator.validators;
function Axios$1(o) {
  this.defaults = o, this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() };
}
Axios$1.prototype.request = function(o, n) {
  typeof o == "string" ? (n = n || {}).url = o : n = o || {}, (n = mergeConfig$1(this.defaults, n)).method ? n.method = n.method.toLowerCase() : this.defaults.method ? n.method = this.defaults.method.toLowerCase() : n.method = "get";
  var c = n.transitional;
  c !== void 0 && validator.assertOptions(c, { silentJSONParsing: validators.transitional(validators.boolean), forcedJSONParsing: validators.transitional(validators.boolean), clarifyTimeoutError: validators.transitional(validators.boolean) }, !1);
  var u = [], h = !0;
  this.interceptors.request.forEach(function(q) {
    typeof q.runWhen == "function" && q.runWhen(n) === !1 || (h = h && q.synchronous, u.unshift(q.fulfilled, q.rejected));
  });
  var g, y = [];
  if (this.interceptors.response.forEach(function(q) {
    y.push(q.fulfilled, q.rejected);
  }), !h) {
    var $ = [dispatchRequest, void 0];
    for (Array.prototype.unshift.apply($, u), $ = $.concat(y), g = Promise.resolve(n); $.length; )
      g = g.then($.shift(), $.shift());
    return g;
  }
  for (var I = n; u.length; ) {
    var P = u.shift(), L = u.shift();
    try {
      I = P(I);
    } catch (q) {
      L(q);
      break;
    }
  }
  try {
    g = dispatchRequest(I);
  } catch (q) {
    return Promise.reject(q);
  }
  for (; y.length; )
    g = g.then(y.shift(), y.shift());
  return g;
}, Axios$1.prototype.getUri = function(o) {
  o = mergeConfig$1(this.defaults, o);
  var n = buildFullPath(o.baseURL, o.url);
  return buildURL(n, o.params, o.paramsSerializer);
}, utils$s.forEach(["delete", "get", "head", "options"], function(o) {
  Axios$1.prototype[o] = function(n, c) {
    return this.request(mergeConfig$1(c || {}, { method: o, url: n, data: (c || {}).data }));
  };
}), utils$s.forEach(["post", "put", "patch"], function(o) {
  function n(c) {
    return function(u, h, g) {
      return this.request(mergeConfig$1(g || {}, { method: o, headers: c ? { "Content-Type": "multipart/form-data" } : {}, url: u, data: h }));
    };
  }
  Axios$1.prototype[o] = n(), Axios$1.prototype[o + "Form"] = n(!0);
});
var Axios_1 = Axios$1, CancelToken_1, hasRequiredCancelToken, spread, hasRequiredSpread, isAxiosError, hasRequiredIsAxiosError;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var o = requireCanceledError();
  function n(c) {
    if (typeof c != "function")
      throw new TypeError("executor must be a function.");
    var u;
    this.promise = new Promise(function(g) {
      u = g;
    });
    var h = this;
    this.promise.then(function(g) {
      if (h._listeners) {
        var y, $ = h._listeners.length;
        for (y = 0; y < $; y++)
          h._listeners[y](g);
        h._listeners = null;
      }
    }), this.promise.then = function(g) {
      var y, $ = new Promise(function(I) {
        h.subscribe(I), y = I;
      }).then(g);
      return $.cancel = function() {
        h.unsubscribe(y);
      }, $;
    }, c(function(g) {
      h.reason || (h.reason = new o(g), u(h.reason));
    });
  }
  return n.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, n.prototype.subscribe = function(c) {
    this.reason ? c(this.reason) : this._listeners ? this._listeners.push(c) : this._listeners = [c];
  }, n.prototype.unsubscribe = function(c) {
    if (this._listeners) {
      var u = this._listeners.indexOf(c);
      u !== -1 && this._listeners.splice(u, 1);
    }
  }, n.source = function() {
    var c;
    return { token: new n(function(u) {
      c = u;
    }), cancel: c };
  }, CancelToken_1 = n;
}
function requireSpread() {
  return hasRequiredSpread ? spread : (hasRequiredSpread = 1, spread = function(o) {
    return function(n) {
      return o.apply(null, n);
    };
  });
}
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var o = utils$C;
  return isAxiosError = function(n) {
    return o.isObject(n) && n.isAxiosError === !0;
  };
}
var utils$r = utils$C, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults = defaults_1;
function createInstance(o) {
  var n = new Axios(o), c = bind(Axios.prototype.request, n);
  return utils$r.extend(c, Axios.prototype, n), utils$r.extend(c, n), c.create = function(u) {
    return createInstance(mergeConfig(o, u));
  }, c;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios, axios$1.CanceledError = requireCanceledError(), axios$1.CancelToken = requireCancelToken(), axios$1.isCancel = requireIsCancel(), axios$1.VERSION = requireData().version, axios$1.toFormData = toFormData_1, axios$1.AxiosError = AxiosError_1, axios$1.Cancel = axios$1.CanceledError, axios$1.all = function(o) {
  return Promise.all(o);
}, axios$1.spread = requireSpread(), axios$1.isAxiosError = requireIsAxiosError(), axios$2.exports = axios$1, axios$2.exports.default = axios$1, axios$3.exports = axios$2.exports;
const axios = getDefaultExportFromCjs(axios$3.exports);
Object.defineProperty(api$2, "__esModule", { value: !0 });
const axios_1$1 = axios$3.exports;
class Api$1 {
  constructor(n) {
    this.METHOD_GET = "GET", this.METHOD_POST = "POST", this.applyConfig(n);
  }
  applyConfig(n) {
    this.config = this.mergeDefaults(n);
  }
  getConfig() {
    return this.config;
  }
  mergeDefaults(n) {
    const c = n.protocol || "http", u = n.port || (c === "https" ? 443 : 80);
    return { host: n.host || "127.0.0.1", protocol: c, port: u, timeout: n.timeout || 2e4, logging: n.logging || !1, logger: n.logger || console.log, network: n.network };
  }
  async get(n, c) {
    try {
      return await this.request().get(n, c);
    } catch (u) {
      if (u.response && u.response.status)
        return u.response;
      throw u;
    }
  }
  async post(n, c, u) {
    try {
      return await this.request().post(n, c, u);
    } catch (h) {
      if (h.response && h.response.status)
        return h.response;
      throw h;
    }
  }
  request() {
    const n = {};
    this.config.network && (n["x-network"] = this.config.network);
    let c = axios_1$1.default.create({ baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`, timeout: this.config.timeout, maxContentLength: 536870912, headers: n });
    return this.config.logging && (c.interceptors.request.use((u) => (this.config.logger(`Requesting: ${u.baseURL}/${u.url}`), u)), c.interceptors.response.use((u) => (this.config.logger(`Response:   ${u.config.url} - ${u.status}`), u))), c;
  }
}
api$2.default = Api$1;
var webcryptoDriver = {}, utils$q = {}, base64Js = {};
base64Js.byteLength = byteLength, base64Js.toByteArray = toByteArray, base64Js.fromByteArray = fromByteArray;
for (var lookup$1 = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code$b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code$b.length; i < len; ++i)
  lookup$1[i] = code$b[i], revLookup[code$b.charCodeAt(i)] = i;
function getLens(o) {
  var n = o.length;
  if (n % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var c = o.indexOf("=");
  return c === -1 && (c = n), [c, c === n ? 0 : 4 - c % 4];
}
function byteLength(o) {
  var n = getLens(o), c = n[0], u = n[1];
  return 3 * (c + u) / 4 - u;
}
function _byteLength(o, n, c) {
  return 3 * (n + c) / 4 - c;
}
function toByteArray(o) {
  var n, c, u = getLens(o), h = u[0], g = u[1], y = new Arr(_byteLength(o, h, g)), $ = 0, I = g > 0 ? h - 4 : h;
  for (c = 0; c < I; c += 4)
    n = revLookup[o.charCodeAt(c)] << 18 | revLookup[o.charCodeAt(c + 1)] << 12 | revLookup[o.charCodeAt(c + 2)] << 6 | revLookup[o.charCodeAt(c + 3)], y[$++] = n >> 16 & 255, y[$++] = n >> 8 & 255, y[$++] = 255 & n;
  return g === 2 && (n = revLookup[o.charCodeAt(c)] << 2 | revLookup[o.charCodeAt(c + 1)] >> 4, y[$++] = 255 & n), g === 1 && (n = revLookup[o.charCodeAt(c)] << 10 | revLookup[o.charCodeAt(c + 1)] << 4 | revLookup[o.charCodeAt(c + 2)] >> 2, y[$++] = n >> 8 & 255, y[$++] = 255 & n), y;
}
function tripletToBase64(o) {
  return lookup$1[o >> 18 & 63] + lookup$1[o >> 12 & 63] + lookup$1[o >> 6 & 63] + lookup$1[63 & o];
}
function encodeChunk(o, n, c) {
  for (var u, h = [], g = n; g < c; g += 3)
    u = (o[g] << 16 & 16711680) + (o[g + 1] << 8 & 65280) + (255 & o[g + 2]), h.push(tripletToBase64(u));
  return h.join("");
}
function fromByteArray(o) {
  for (var n, c = o.length, u = c % 3, h = [], g = 16383, y = 0, $ = c - u; y < $; y += g)
    h.push(encodeChunk(o, y, y + g > $ ? $ : y + g));
  return u === 1 ? (n = o[c - 1], h.push(lookup$1[n >> 2] + lookup$1[n << 4 & 63] + "==")) : u === 2 && (n = (o[c - 2] << 8) + o[c - 1], h.push(lookup$1[n >> 10] + lookup$1[n >> 4 & 63] + lookup$1[n << 2 & 63] + "=")), h.join("");
}
revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
var util$5 = {}, types = {}, shams$1, hasRequiredShams$1, shams, hasRequiredShams, hasSymbols, hasRequiredHasSymbols, implementation$1, hasRequiredImplementation, functionBind, hasRequiredFunctionBind, src$5, hasRequiredSrc, getIntrinsic, hasRequiredGetIntrinsic;
function requireShams$1() {
  return hasRequiredShams$1 ? shams$1 : (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var o = {}, n = Symbol("test"), c = Object(n);
    if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(c) !== "[object Symbol]")
      return !1;
    for (n in o[n] = 42, o)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(o).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(o).length !== 0)
      return !1;
    var u = Object.getOwnPropertySymbols(o);
    if (u.length !== 1 || u[0] !== n || !Object.prototype.propertyIsEnumerable.call(o, n))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var h = Object.getOwnPropertyDescriptor(o, n);
      if (h.value !== 42 || h.enumerable !== !0)
        return !1;
    }
    return !0;
  });
}
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var o = requireShams$1();
  return shams = function() {
    return o() && !!Symbol.toStringTag;
  };
}
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols;
  hasRequiredHasSymbols = 1;
  var o = typeof Symbol < "u" && Symbol, n = requireShams$1();
  return hasSymbols = function() {
    return typeof o == "function" && typeof Symbol == "function" && typeof o("foo") == "symbol" && typeof Symbol("bar") == "symbol" && n();
  };
}
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation$1;
  hasRequiredImplementation = 1;
  var o = "Function.prototype.bind called on incompatible ", n = Array.prototype.slice, c = Object.prototype.toString, u = "[object Function]";
  return implementation$1 = function(h) {
    var g = this;
    if (typeof g != "function" || c.call(g) !== u)
      throw new TypeError(o + g);
    for (var y, $ = n.call(arguments, 1), I = function() {
      if (this instanceof y) {
        var X = g.apply(this, $.concat(n.call(arguments)));
        return Object(X) === X ? X : this;
      }
      return g.apply(h, $.concat(n.call(arguments)));
    }, P = Math.max(0, g.length - $.length), L = [], q = 0; q < P; q++)
      L.push("$" + q);
    if (y = Function("binder", "return function (" + L.join(",") + "){ return binder.apply(this,arguments); }")(I), g.prototype) {
      var N = function() {
      };
      N.prototype = g.prototype, y.prototype = new N(), N.prototype = null;
    }
    return y;
  }, implementation$1;
}
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var o = requireImplementation();
  return functionBind = Function.prototype.bind || o;
}
function requireSrc() {
  if (hasRequiredSrc)
    return src$5;
  hasRequiredSrc = 1;
  var o = requireFunctionBind();
  return src$5 = o.call(Function.call, Object.prototype.hasOwnProperty);
}
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic;
  var o;
  hasRequiredGetIntrinsic = 1;
  var n = SyntaxError, c = Function, u = TypeError, h = function(E) {
    try {
      return c('"use strict"; return (' + E + ").constructor;")();
    } catch {
    }
  }, g = Object.getOwnPropertyDescriptor;
  if (g)
    try {
      g({}, "");
    } catch {
      g = null;
    }
  var y = function() {
    throw new u();
  }, $ = g ? function() {
    try {
      return y;
    } catch {
      try {
        return g(arguments, "callee").get;
      } catch {
        return y;
      }
    }
  }() : y, I = requireHasSymbols()(), P = Object.getPrototypeOf || function(E) {
    return E.__proto__;
  }, L = {}, q = typeof Uint8Array > "u" ? o : P(Uint8Array), N = { "%AggregateError%": typeof AggregateError > "u" ? o : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? o : ArrayBuffer, "%ArrayIteratorPrototype%": I ? P([][Symbol.iterator]()) : o, "%AsyncFromSyncIteratorPrototype%": o, "%AsyncFunction%": L, "%AsyncGenerator%": L, "%AsyncGeneratorFunction%": L, "%AsyncIteratorPrototype%": L, "%Atomics%": typeof Atomics > "u" ? o : Atomics, "%BigInt%": typeof BigInt > "u" ? o : BigInt, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? o : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? o : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? o : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? o : FinalizationRegistry, "%Function%": c, "%GeneratorFunction%": L, "%Int8Array%": typeof Int8Array > "u" ? o : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? o : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? o : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": I ? P(P([][Symbol.iterator]())) : o, "%JSON%": typeof JSON == "object" ? JSON : o, "%Map%": typeof Map > "u" ? o : Map, "%MapIteratorPrototype%": typeof Map < "u" && I ? P((/* @__PURE__ */ new Map())[Symbol.iterator]()) : o, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? o : Promise, "%Proxy%": typeof Proxy > "u" ? o : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? o : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? o : Set, "%SetIteratorPrototype%": typeof Set < "u" && I ? P((/* @__PURE__ */ new Set())[Symbol.iterator]()) : o, "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? o : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": I ? P(""[Symbol.iterator]()) : o, "%Symbol%": I ? Symbol : o, "%SyntaxError%": n, "%ThrowTypeError%": $, "%TypedArray%": q, "%TypeError%": u, "%Uint8Array%": typeof Uint8Array > "u" ? o : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? o : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? o : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? o : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? o : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? o : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? o : WeakSet }, X = function E(w) {
    var v;
    if (w === "%AsyncFunction%")
      v = h("async function () {}");
    else if (w === "%GeneratorFunction%")
      v = h("function* () {}");
    else if (w === "%AsyncGeneratorFunction%")
      v = h("async function* () {}");
    else if (w === "%AsyncGenerator%") {
      var k = E("%AsyncGeneratorFunction%");
      k && (v = k.prototype);
    } else if (w === "%AsyncIteratorPrototype%") {
      var O = E("%AsyncGenerator%");
      O && (v = P(O.prototype));
    }
    return N[w] = v, v;
  }, rt = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, nt = requireFunctionBind(), st = requireSrc(), ot = nt.call(Function.call, Array.prototype.concat), St = nt.call(Function.apply, Array.prototype.splice), Ct = nt.call(Function.call, String.prototype.replace), et = nt.call(Function.call, String.prototype.slice), at = nt.call(Function.call, RegExp.prototype.exec), _t = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Nt = /\\(\\)?/g, m = function(E) {
    var w = et(E, 0, 1), v = et(E, -1);
    if (w === "%" && v !== "%")
      throw new n("invalid intrinsic syntax, expected closing `%`");
    if (v === "%" && w !== "%")
      throw new n("invalid intrinsic syntax, expected opening `%`");
    var k = [];
    return Ct(E, _t, function(O, W, it, vt) {
      k[k.length] = it ? Ct(vt, Nt, "$1") : W || O;
    }), k;
  }, A = function(E, w) {
    var v, k = E;
    if (st(rt, k) && (k = "%" + (v = rt[k])[0] + "%"), st(N, k)) {
      var O = N[k];
      if (O === L && (O = X(k)), O === void 0 && !w)
        throw new u("intrinsic " + E + " exists, but is not available. Please file an issue!");
      return { alias: v, name: k, value: O };
    }
    throw new n("intrinsic " + E + " does not exist!");
  };
  return getIntrinsic = function(E, w) {
    if (typeof E != "string" || E.length === 0)
      throw new u("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof w != "boolean")
      throw new u('"allowMissing" argument must be a boolean');
    if (at(/^%?[^%]*%?$/, E) === null)
      throw new n("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var v = m(E), k = v.length > 0 ? v[0] : "", O = A("%" + k + "%", w), W = O.name, it = O.value, vt = !1, xt = O.alias;
    xt && (k = xt[0], St(v, ot([0, 1], xt)));
    for (var It = 1, Wt = !0; It < v.length; It += 1) {
      var Ut = v[It], zt = et(Ut, 0, 1), Jt = et(Ut, -1);
      if ((zt === '"' || zt === "'" || zt === "`" || Jt === '"' || Jt === "'" || Jt === "`") && zt !== Jt)
        throw new n("property names with quotes must have matching quotes");
      if (Ut !== "constructor" && Wt || (vt = !0), st(N, W = "%" + (k += "." + Ut) + "%"))
        it = N[W];
      else if (it != null) {
        if (!(Ut in it)) {
          if (!w)
            throw new u("base intrinsic for " + E + " exists, but the property is not available.");
          return;
        }
        if (g && It + 1 >= v.length) {
          var Xt = g(it, Ut);
          it = (Wt = !!Xt) && "get" in Xt && !("originalValue" in Xt.get) ? Xt.get : it[Ut];
        } else
          Wt = st(it, Ut), it = it[Ut];
        Wt && !vt && (N[W] = it);
      }
    }
    return it;
  }, getIntrinsic;
}
var callBind = { exports: {} }, hasRequiredCallBind, callBound, hasRequiredCallBound, isArguments$2, hasRequiredIsArguments, isGeneratorFunction, hasRequiredIsGeneratorFunction, isCallable, hasRequiredIsCallable, forEach_1, hasRequiredForEach, availableTypedArrays, hasRequiredAvailableTypedArrays, getOwnPropertyDescriptor, hasRequiredGetOwnPropertyDescriptor, isTypedArray$2, hasRequiredIsTypedArray, whichTypedArray, hasRequiredWhichTypedArray, hasRequiredTypes, isBufferBrowser, hasRequiredIsBufferBrowser;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(o) {
    var n = requireFunctionBind(), c = requireGetIntrinsic(), u = c("%Function.prototype.apply%"), h = c("%Function.prototype.call%"), g = c("%Reflect.apply%", !0) || n.call(h, u), y = c("%Object.getOwnPropertyDescriptor%", !0), $ = c("%Object.defineProperty%", !0), I = c("%Math.max%");
    if ($)
      try {
        $({}, "a", { value: 1 });
      } catch {
        $ = null;
      }
    o.exports = function(L) {
      var q = g(n, h, arguments);
      if (y && $) {
        var N = y(q, "length");
        N.configurable && $(q, "length", { value: 1 + I(0, L.length - (arguments.length - 1)) });
      }
      return q;
    };
    var P = function() {
      return g(n, u, arguments);
    };
    $ ? $(o.exports, "apply", { value: P }) : o.exports.apply = P;
  }(callBind)), callBind.exports;
}
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var o = requireGetIntrinsic(), n = requireCallBind(), c = n(o("String.prototype.indexOf"));
  return callBound = function(u, h) {
    var g = o(u, !!h);
    return typeof g == "function" && c(u, ".prototype.") > -1 ? n(g) : g;
  }, callBound;
}
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments$2;
  hasRequiredIsArguments = 1;
  var o = requireShams()(), n = requireCallBound()("Object.prototype.toString"), c = function(g) {
    return !(o && g && typeof g == "object" && Symbol.toStringTag in g) && n(g) === "[object Arguments]";
  }, u = function(g) {
    return !!c(g) || g !== null && typeof g == "object" && typeof g.length == "number" && g.length >= 0 && n(g) !== "[object Array]" && n(g.callee) === "[object Function]";
  }, h = function() {
    return c(arguments);
  }();
  return c.isLegacyArguments = u, isArguments$2 = h ? c : u;
}
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction)
    return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var o, n = Object.prototype.toString, c = Function.prototype.toString, u = /^\s*(?:function)?\*/, h = requireShams()(), g = Object.getPrototypeOf;
  return isGeneratorFunction = function(y) {
    if (typeof y != "function")
      return !1;
    if (u.test(c.call(y)))
      return !0;
    if (!h)
      return n.call(y) === "[object GeneratorFunction]";
    if (!g)
      return !1;
    if (o === void 0) {
      var $ = function() {
        if (!h)
          return !1;
        try {
          return Function("return function*() {}")();
        } catch {
        }
      }();
      o = !!$ && g($);
    }
    return g(y) === o;
  }, isGeneratorFunction;
}
function requireIsCallable() {
  if (hasRequiredIsCallable)
    return isCallable;
  hasRequiredIsCallable = 1;
  var o, n, c = Function.prototype.toString, u = typeof Reflect == "object" && Reflect !== null && Reflect.apply;
  if (typeof u == "function" && typeof Object.defineProperty == "function")
    try {
      o = Object.defineProperty({}, "length", { get: function() {
        throw n;
      } }), n = {}, u(function() {
        throw 42;
      }, null, o);
    } catch (N) {
      N !== n && (u = null);
    }
  else
    u = null;
  var h = /^\s*class\b/, g = function(N) {
    try {
      var X = c.call(N);
      return h.test(X);
    } catch {
      return !1;
    }
  }, y = function(N) {
    try {
      return !g(N) && (c.call(N), !0);
    } catch {
      return !1;
    }
  }, $ = Object.prototype.toString, I = typeof Symbol == "function" && !!Symbol.toStringTag, P = !(0 in [,]), L = function() {
    return !1;
  };
  if (typeof document == "object") {
    var q = document.all;
    $.call(q) === $.call(document.all) && (L = function(N) {
      if ((P || !N) && (N === void 0 || typeof N == "object"))
        try {
          var X = $.call(N);
          return (X === "[object HTMLAllCollection]" || X === "[object HTML document.all class]" || X === "[object HTMLCollection]" || X === "[object Object]") && N("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = u ? function(N) {
    if (L(N))
      return !0;
    if (!N || typeof N != "function" && typeof N != "object")
      return !1;
    try {
      u(N, null, o);
    } catch (X) {
      if (X !== n)
        return !1;
    }
    return !g(N) && y(N);
  } : function(N) {
    if (L(N))
      return !0;
    if (!N || typeof N != "function" && typeof N != "object")
      return !1;
    if (I)
      return y(N);
    if (g(N))
      return !1;
    var X = $.call(N);
    return !(X !== "[object Function]" && X !== "[object GeneratorFunction]" && !/^\[object HTML/.test(X)) && y(N);
  };
}
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var o = requireIsCallable(), n = Object.prototype.toString, c = Object.prototype.hasOwnProperty, u = function(y, $, I) {
    for (var P = 0, L = y.length; P < L; P++)
      c.call(y, P) && (I == null ? $(y[P], P, y) : $.call(I, y[P], P, y));
  }, h = function(y, $, I) {
    for (var P = 0, L = y.length; P < L; P++)
      I == null ? $(y.charAt(P), P, y) : $.call(I, y.charAt(P), P, y);
  }, g = function(y, $, I) {
    for (var P in y)
      c.call(y, P) && (I == null ? $(y[P], P, y) : $.call(I, y[P], P, y));
  };
  return forEach_1 = function(y, $, I) {
    if (!o($))
      throw new TypeError("iterator must be a function");
    var P;
    arguments.length >= 3 && (P = I), n.call(y) === "[object Array]" ? u(y, $, P) : typeof y == "string" ? h(y, $, P) : g(y, $, P);
  }, forEach_1;
}
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays)
    return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var o = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], n = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var c = [], u = 0; u < o.length; u++)
      typeof n[o[u]] == "function" && (c[c.length] = o[u]);
    return c;
  }, availableTypedArrays;
}
function requireGetOwnPropertyDescriptor() {
  if (hasRequiredGetOwnPropertyDescriptor)
    return getOwnPropertyDescriptor;
  hasRequiredGetOwnPropertyDescriptor = 1;
  var o = requireGetIntrinsic()("%Object.getOwnPropertyDescriptor%", !0);
  if (o)
    try {
      o([], "length");
    } catch {
      o = null;
    }
  return getOwnPropertyDescriptor = o;
}
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray$2;
  hasRequiredIsTypedArray = 1;
  var o = requireForEach(), n = requireAvailableTypedArrays(), c = requireCallBound(), u = c("Object.prototype.toString"), h = requireShams()(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, y = n(), $ = c("Array.prototype.indexOf", !0) || function(N, X) {
    for (var rt = 0; rt < N.length; rt += 1)
      if (N[rt] === X)
        return rt;
    return -1;
  }, I = c("String.prototype.slice"), P = {}, L = requireGetOwnPropertyDescriptor(), q = Object.getPrototypeOf;
  return h && L && q && o(y, function(N) {
    var X = new g[N]();
    if (Symbol.toStringTag in X) {
      var rt = q(X), nt = L(rt, Symbol.toStringTag);
      if (!nt) {
        var st = q(rt);
        nt = L(st, Symbol.toStringTag);
      }
      P[N] = nt.get;
    }
  }), isTypedArray$2 = function(N) {
    if (!N || typeof N != "object")
      return !1;
    if (!h || !(Symbol.toStringTag in N)) {
      var X = I(u(N), 8, -1);
      return $(y, X) > -1;
    }
    return !!L && function(rt) {
      var nt = !1;
      return o(P, function(st, ot) {
        if (!nt)
          try {
            nt = st.call(rt) === ot;
          } catch {
          }
      }), nt;
    }(N);
  };
}
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray)
    return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var o = requireForEach(), n = requireAvailableTypedArrays(), c = requireCallBound(), u = c("Object.prototype.toString"), h = requireShams()(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, y = n(), $ = c("String.prototype.slice"), I = {}, P = requireGetOwnPropertyDescriptor(), L = Object.getPrototypeOf;
  h && P && L && o(y, function(N) {
    if (typeof g[N] == "function") {
      var X = new g[N]();
      if (Symbol.toStringTag in X) {
        var rt = L(X), nt = P(rt, Symbol.toStringTag);
        if (!nt) {
          var st = L(rt);
          nt = P(st, Symbol.toStringTag);
        }
        I[N] = nt.get;
      }
    }
  });
  var q = requireIsTypedArray();
  return whichTypedArray = function(N) {
    return !!q(N) && (h && Symbol.toStringTag in N ? function(X) {
      var rt = !1;
      return o(I, function(nt, st) {
        if (!rt)
          try {
            var ot = nt.call(X);
            ot === st && (rt = ot);
          } catch {
          }
      }), rt;
    }(N) : $(u(N), 8, -1));
  }, whichTypedArray;
}
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(o) {
    var n = requireIsArguments(), c = requireIsGeneratorFunction(), u = requireWhichTypedArray(), h = requireIsTypedArray();
    function g(W) {
      return W.call.bind(W);
    }
    var y = typeof BigInt < "u", $ = typeof Symbol < "u", I = g(Object.prototype.toString), P = g(Number.prototype.valueOf), L = g(String.prototype.valueOf), q = g(Boolean.prototype.valueOf);
    if (y)
      var N = g(BigInt.prototype.valueOf);
    if ($)
      var X = g(Symbol.prototype.valueOf);
    function rt(W, it) {
      if (typeof W != "object")
        return !1;
      try {
        return it(W), !0;
      } catch {
        return !1;
      }
    }
    function nt(W) {
      return I(W) === "[object Map]";
    }
    function st(W) {
      return I(W) === "[object Set]";
    }
    function ot(W) {
      return I(W) === "[object WeakMap]";
    }
    function St(W) {
      return I(W) === "[object WeakSet]";
    }
    function Ct(W) {
      return I(W) === "[object ArrayBuffer]";
    }
    function et(W) {
      return typeof ArrayBuffer < "u" && (Ct.working ? Ct(W) : W instanceof ArrayBuffer);
    }
    function at(W) {
      return I(W) === "[object DataView]";
    }
    function _t(W) {
      return typeof DataView < "u" && (at.working ? at(W) : W instanceof DataView);
    }
    o.isArgumentsObject = n, o.isGeneratorFunction = c, o.isTypedArray = h, o.isPromise = function(W) {
      return typeof Promise < "u" && W instanceof Promise || W !== null && typeof W == "object" && typeof W.then == "function" && typeof W.catch == "function";
    }, o.isArrayBufferView = function(W) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(W) : h(W) || _t(W);
    }, o.isUint8Array = function(W) {
      return u(W) === "Uint8Array";
    }, o.isUint8ClampedArray = function(W) {
      return u(W) === "Uint8ClampedArray";
    }, o.isUint16Array = function(W) {
      return u(W) === "Uint16Array";
    }, o.isUint32Array = function(W) {
      return u(W) === "Uint32Array";
    }, o.isInt8Array = function(W) {
      return u(W) === "Int8Array";
    }, o.isInt16Array = function(W) {
      return u(W) === "Int16Array";
    }, o.isInt32Array = function(W) {
      return u(W) === "Int32Array";
    }, o.isFloat32Array = function(W) {
      return u(W) === "Float32Array";
    }, o.isFloat64Array = function(W) {
      return u(W) === "Float64Array";
    }, o.isBigInt64Array = function(W) {
      return u(W) === "BigInt64Array";
    }, o.isBigUint64Array = function(W) {
      return u(W) === "BigUint64Array";
    }, nt.working = typeof Map < "u" && nt(/* @__PURE__ */ new Map()), o.isMap = function(W) {
      return typeof Map < "u" && (nt.working ? nt(W) : W instanceof Map);
    }, st.working = typeof Set < "u" && st(/* @__PURE__ */ new Set()), o.isSet = function(W) {
      return typeof Set < "u" && (st.working ? st(W) : W instanceof Set);
    }, ot.working = typeof WeakMap < "u" && ot(/* @__PURE__ */ new WeakMap()), o.isWeakMap = function(W) {
      return typeof WeakMap < "u" && (ot.working ? ot(W) : W instanceof WeakMap);
    }, St.working = typeof WeakSet < "u" && St(/* @__PURE__ */ new WeakSet()), o.isWeakSet = function(W) {
      return St(W);
    }, Ct.working = typeof ArrayBuffer < "u" && Ct(new ArrayBuffer()), o.isArrayBuffer = et, at.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && at(new DataView(new ArrayBuffer(1), 0, 1)), o.isDataView = _t;
    var Nt = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function m(W) {
      return I(W) === "[object SharedArrayBuffer]";
    }
    function A(W) {
      return Nt !== void 0 && (m.working === void 0 && (m.working = m(new Nt())), m.working ? m(W) : W instanceof Nt);
    }
    function E(W) {
      return rt(W, P);
    }
    function w(W) {
      return rt(W, L);
    }
    function v(W) {
      return rt(W, q);
    }
    function k(W) {
      return y && rt(W, N);
    }
    function O(W) {
      return $ && rt(W, X);
    }
    o.isSharedArrayBuffer = A, o.isAsyncFunction = function(W) {
      return I(W) === "[object AsyncFunction]";
    }, o.isMapIterator = function(W) {
      return I(W) === "[object Map Iterator]";
    }, o.isSetIterator = function(W) {
      return I(W) === "[object Set Iterator]";
    }, o.isGeneratorObject = function(W) {
      return I(W) === "[object Generator]";
    }, o.isWebAssemblyCompiledModule = function(W) {
      return I(W) === "[object WebAssembly.Module]";
    }, o.isNumberObject = E, o.isStringObject = w, o.isBooleanObject = v, o.isBigIntObject = k, o.isSymbolObject = O, o.isBoxedPrimitive = function(W) {
      return E(W) || w(W) || v(W) || k(W) || O(W);
    }, o.isAnyArrayBuffer = function(W) {
      return typeof Uint8Array < "u" && (et(W) || A(W));
    }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(W) {
      Object.defineProperty(o, W, { enumerable: !1, value: function() {
        throw new Error(W + " is not supported in userland");
      } });
    });
  }(types)), types;
}
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser ? isBufferBrowser : (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(o) {
    return o && typeof o == "object" && typeof o.copy == "function" && typeof o.fill == "function" && typeof o.readUInt8 == "function";
  });
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser, hasRequiredUtil;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(o, n) {
    n && (o.super_ = n, o.prototype = Object.create(n.prototype, { constructor: { value: o, enumerable: !1, writable: !0, configurable: !0 } }));
  } : inherits_browser.exports = function(o, n) {
    if (n) {
      o.super_ = n;
      var c = function() {
      };
      c.prototype = n.prototype, o.prototype = new c(), o.prototype.constructor = o;
    }
  }), inherits_browser.exports;
}
function requireUtil() {
  return hasRequiredUtil || (hasRequiredUtil = 1, function(o) {
    var n = Object.getOwnPropertyDescriptors || function(O) {
      for (var W = Object.keys(O), it = {}, vt = 0; vt < W.length; vt++)
        it[W[vt]] = Object.getOwnPropertyDescriptor(O, W[vt]);
      return it;
    }, c = /%[sdj%]/g;
    o.format = function(O) {
      if (!st(O)) {
        for (var W = [], it = 0; it < arguments.length; it++)
          W.push(y(arguments[it]));
        return W.join(" ");
      }
      it = 1;
      for (var vt = arguments, xt = vt.length, It = String(O).replace(c, function(Ut) {
        if (Ut === "%%")
          return "%";
        if (it >= xt)
          return Ut;
        switch (Ut) {
          case "%s":
            return String(vt[it++]);
          case "%d":
            return Number(vt[it++]);
          case "%j":
            try {
              return JSON.stringify(vt[it++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Ut;
        }
      }), Wt = vt[it]; it < xt; Wt = vt[++it])
        rt(Wt) || !Ct(Wt) ? It += " " + Wt : It += " " + y(Wt);
      return It;
    }, o.deprecate = function(O, W) {
      if (typeof process < "u" && process.noDeprecation === !0)
        return O;
      if (typeof process > "u")
        return function() {
          return o.deprecate(O, W).apply(this, arguments);
        };
      var it = !1;
      return function() {
        if (!it) {
          if (process.throwDeprecation)
            throw new Error(W);
          process.traceDeprecation ? console.trace(W) : console.error(W), it = !0;
        }
        return O.apply(this, arguments);
      };
    };
    var u = {}, h = /^$/;
    if (process.env.NODE_DEBUG) {
      var g = process.env.NODE_DEBUG;
      g = g.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), h = new RegExp("^" + g + "$", "i");
    }
    function y(O, W) {
      var it = { seen: [], stylize: I };
      return arguments.length >= 3 && (it.depth = arguments[2]), arguments.length >= 4 && (it.colors = arguments[3]), X(W) ? it.showHidden = W : W && o._extend(it, W), ot(it.showHidden) && (it.showHidden = !1), ot(it.depth) && (it.depth = 2), ot(it.colors) && (it.colors = !1), ot(it.customInspect) && (it.customInspect = !0), it.colors && (it.stylize = $), P(it, O, it.depth);
    }
    function $(O, W) {
      var it = y.styles[W];
      return it ? "\x1B[" + y.colors[it][0] + "m" + O + "\x1B[" + y.colors[it][1] + "m" : O;
    }
    function I(O, W) {
      return O;
    }
    function P(O, W, it) {
      if (O.customInspect && W && _t(W.inspect) && W.inspect !== o.inspect && (!W.constructor || W.constructor.prototype !== W)) {
        var vt = W.inspect(it, O);
        return st(vt) || (vt = P(O, vt, it)), vt;
      }
      var xt = function(oe, De) {
        if (ot(De))
          return oe.stylize("undefined", "undefined");
        if (st(De)) {
          var ue = "'" + JSON.stringify(De).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return oe.stylize(ue, "string");
        }
        return nt(De) ? oe.stylize("" + De, "number") : X(De) ? oe.stylize("" + De, "boolean") : rt(De) ? oe.stylize("null", "null") : void 0;
      }(O, W);
      if (xt)
        return xt;
      var It = Object.keys(W), Wt = function(oe) {
        var De = {};
        return oe.forEach(function(ue, xe) {
          De[ue] = !0;
        }), De;
      }(It);
      if (O.showHidden && (It = Object.getOwnPropertyNames(W)), at(W) && (It.indexOf("message") >= 0 || It.indexOf("description") >= 0))
        return L(W);
      if (It.length === 0) {
        if (_t(W)) {
          var Ut = W.name ? ": " + W.name : "";
          return O.stylize("[Function" + Ut + "]", "special");
        }
        if (St(W))
          return O.stylize(RegExp.prototype.toString.call(W), "regexp");
        if (et(W))
          return O.stylize(Date.prototype.toString.call(W), "date");
        if (at(W))
          return L(W);
      }
      var zt, Jt = "", Xt = !1, ie = ["{", "}"];
      return N(W) && (Xt = !0, ie = ["[", "]"]), _t(W) && (Jt = " [Function" + (W.name ? ": " + W.name : "") + "]"), St(W) && (Jt = " " + RegExp.prototype.toString.call(W)), et(W) && (Jt = " " + Date.prototype.toUTCString.call(W)), at(W) && (Jt = " " + L(W)), It.length !== 0 || Xt && W.length != 0 ? it < 0 ? St(W) ? O.stylize(RegExp.prototype.toString.call(W), "regexp") : O.stylize("[Object]", "special") : (O.seen.push(W), zt = Xt ? function(oe, De, ue, xe, se) {
        for (var he = [], je = 0, jr = De.length; je < jr; ++je)
          w(De, String(je)) ? he.push(q(oe, De, ue, xe, String(je), !0)) : he.push("");
        return se.forEach(function(de) {
          de.match(/^\d+$/) || he.push(q(oe, De, ue, xe, de, !0));
        }), he;
      }(O, W, it, Wt, It) : It.map(function(oe) {
        return q(O, W, it, Wt, oe, Xt);
      }), O.seen.pop(), function(oe, De, ue) {
        return oe.reduce(function(xe, se) {
          return se.indexOf(`
`), xe + se.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60 ? ue[0] + (De === "" ? "" : De + `
 `) + " " + oe.join(`,
  `) + " " + ue[1] : ue[0] + De + " " + oe.join(", ") + " " + ue[1];
      }(zt, Jt, ie)) : ie[0] + Jt + ie[1];
    }
    function L(O) {
      return "[" + Error.prototype.toString.call(O) + "]";
    }
    function q(O, W, it, vt, xt, It) {
      var Wt, Ut, zt;
      if ((zt = Object.getOwnPropertyDescriptor(W, xt) || { value: W[xt] }).get ? Ut = zt.set ? O.stylize("[Getter/Setter]", "special") : O.stylize("[Getter]", "special") : zt.set && (Ut = O.stylize("[Setter]", "special")), w(vt, xt) || (Wt = "[" + xt + "]"), Ut || (O.seen.indexOf(zt.value) < 0 ? (Ut = rt(it) ? P(O, zt.value, null) : P(O, zt.value, it - 1)).indexOf(`
`) > -1 && (Ut = It ? Ut.split(`
`).map(function(Jt) {
        return "  " + Jt;
      }).join(`
`).slice(2) : `
` + Ut.split(`
`).map(function(Jt) {
        return "   " + Jt;
      }).join(`
`)) : Ut = O.stylize("[Circular]", "special")), ot(Wt)) {
        if (It && xt.match(/^\d+$/))
          return Ut;
        (Wt = JSON.stringify("" + xt)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Wt = Wt.slice(1, -1), Wt = O.stylize(Wt, "name")) : (Wt = Wt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Wt = O.stylize(Wt, "string"));
      }
      return Wt + ": " + Ut;
    }
    function N(O) {
      return Array.isArray(O);
    }
    function X(O) {
      return typeof O == "boolean";
    }
    function rt(O) {
      return O === null;
    }
    function nt(O) {
      return typeof O == "number";
    }
    function st(O) {
      return typeof O == "string";
    }
    function ot(O) {
      return O === void 0;
    }
    function St(O) {
      return Ct(O) && Nt(O) === "[object RegExp]";
    }
    function Ct(O) {
      return typeof O == "object" && O !== null;
    }
    function et(O) {
      return Ct(O) && Nt(O) === "[object Date]";
    }
    function at(O) {
      return Ct(O) && (Nt(O) === "[object Error]" || O instanceof Error);
    }
    function _t(O) {
      return typeof O == "function";
    }
    function Nt(O) {
      return Object.prototype.toString.call(O);
    }
    function m(O) {
      return O < 10 ? "0" + O.toString(10) : O.toString(10);
    }
    o.debuglog = function(O) {
      if (O = O.toUpperCase(), !u[O])
        if (h.test(O)) {
          var W = process.pid;
          u[O] = function() {
            var it = o.format.apply(o, arguments);
            console.error("%s %d: %s", O, W, it);
          };
        } else
          u[O] = function() {
          };
      return u[O];
    }, o.inspect = y, y.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, y.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, o.types = requireTypes(), o.isArray = N, o.isBoolean = X, o.isNull = rt, o.isNullOrUndefined = function(O) {
      return O == null;
    }, o.isNumber = nt, o.isString = st, o.isSymbol = function(O) {
      return typeof O == "symbol";
    }, o.isUndefined = ot, o.isRegExp = St, o.types.isRegExp = St, o.isObject = Ct, o.isDate = et, o.types.isDate = et, o.isError = at, o.types.isNativeError = at, o.isFunction = _t, o.isPrimitive = function(O) {
      return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || O === void 0;
    }, o.isBuffer = requireIsBufferBrowser();
    var A = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function E() {
      var O = new Date(), W = [m(O.getHours()), m(O.getMinutes()), m(O.getSeconds())].join(":");
      return [O.getDate(), A[O.getMonth()], W].join(" ");
    }
    function w(O, W) {
      return Object.prototype.hasOwnProperty.call(O, W);
    }
    o.log = function() {
      console.log("%s - %s", E(), o.format.apply(o, arguments));
    }, o.inherits = requireInherits_browser(), o._extend = function(O, W) {
      if (!W || !Ct(W))
        return O;
      for (var it = Object.keys(W), vt = it.length; vt--; )
        O[it[vt]] = W[it[vt]];
      return O;
    };
    var v = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    function k(O, W) {
      if (!O) {
        var it = new Error("Promise was rejected with a falsy value");
        it.reason = O, O = it;
      }
      return W(O);
    }
    o.promisify = function(O) {
      if (typeof O != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (v && O[v]) {
        var W;
        if (typeof (W = O[v]) != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(W, v, { value: W, enumerable: !1, writable: !1, configurable: !0 }), W;
      }
      function W() {
        for (var it, vt, xt = new Promise(function(Ut, zt) {
          it = Ut, vt = zt;
        }), It = [], Wt = 0; Wt < arguments.length; Wt++)
          It.push(arguments[Wt]);
        It.push(function(Ut, zt) {
          Ut ? vt(Ut) : it(zt);
        });
        try {
          O.apply(this, It);
        } catch (Ut) {
          vt(Ut);
        }
        return xt;
      }
      return Object.setPrototypeOf(W, Object.getPrototypeOf(O)), v && Object.defineProperty(W, v, { value: W, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(W, n(O));
    }, o.promisify.custom = v, o.callbackify = function(O) {
      if (typeof O != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function W() {
        for (var it = [], vt = 0; vt < arguments.length; vt++)
          it.push(arguments[vt]);
        var xt = it.pop();
        if (typeof xt != "function")
          throw new TypeError("The last argument must be of type Function");
        var It = this, Wt = function() {
          return xt.apply(It, arguments);
        };
        O.apply(this, it).then(function(Ut) {
          process.nextTick(Wt.bind(null, null, Ut));
        }, function(Ut) {
          process.nextTick(k.bind(null, Ut, Wt));
        });
      }
      return Object.setPrototypeOf(W, Object.getPrototypeOf(O)), Object.defineProperties(W, n(O)), W;
    };
  }(util$5)), util$5;
}
Object.defineProperty(utils$q, "__esModule", { value: !0 }), utils$q.b64UrlDecode = utils$q.b64UrlEncode = utils$q.bufferTob64Url = utils$q.bufferTob64 = utils$q.b64UrlToBuffer = utils$q.stringToB64Url = utils$q.stringToBuffer = utils$q.bufferToString = utils$q.b64UrlToString = utils$q.concatBuffers = void 0;
const B64js$1 = base64Js;
function concatBuffers$1(o) {
  let n = 0;
  for (let h = 0; h < o.length; h++)
    n += o[h].byteLength;
  let c = new Uint8Array(n), u = 0;
  c.set(new Uint8Array(o[0]), u), u += o[0].byteLength;
  for (let h = 1; h < o.length; h++)
    c.set(new Uint8Array(o[h]), u), u += o[h].byteLength;
  return c;
}
function b64UrlToString$1(o) {
  return bufferToString$1(b64UrlToBuffer$1(o));
}
function bufferToString$1(o) {
  return typeof TextDecoder > "u" ? new (requireUtil()).TextDecoder("utf-8", { fatal: !0 }).decode(o) : new TextDecoder("utf-8", { fatal: !0 }).decode(o);
}
function stringToBuffer$1(o) {
  return typeof TextEncoder > "u" ? new (requireUtil()).TextEncoder().encode(o) : new TextEncoder().encode(o);
}
function stringToB64Url$1(o) {
  return bufferTob64Url$1(stringToBuffer$1(o));
}
function b64UrlToBuffer$1(o) {
  return new Uint8Array(B64js$1.toByteArray(b64UrlDecode$1(o)));
}
function bufferTob64$1(o) {
  return B64js$1.fromByteArray(new Uint8Array(o));
}
function bufferTob64Url$1(o) {
  return b64UrlEncode$1(bufferTob64$1(o));
}
function b64UrlEncode$1(o) {
  return o.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode$1(o) {
  let n;
  return n = (o = o.replace(/\-/g, "+").replace(/\_/g, "/")).length % 4 == 0 ? 0 : 4 - o.length % 4, o.concat("=".repeat(n));
}
utils$q.concatBuffers = concatBuffers$1, utils$q.b64UrlToString = b64UrlToString$1, utils$q.bufferToString = bufferToString$1, utils$q.stringToBuffer = stringToBuffer$1, utils$q.stringToB64Url = stringToB64Url$1, utils$q.b64UrlToBuffer = b64UrlToBuffer$1, utils$q.bufferTob64 = bufferTob64$1, utils$q.bufferTob64Url = bufferTob64Url$1, utils$q.b64UrlEncode = b64UrlEncode$1, utils$q.b64UrlDecode = b64UrlDecode$1, Object.defineProperty(webcryptoDriver, "__esModule", { value: !0 });
const ArweaveUtils$6 = utils$q;
class WebCryptoDriver {
  constructor() {
    if (this.keyLength = 4096, this.publicExponent = 65537, this.hashAlgorithm = "sha256", !this.detectWebCrypto())
      throw new Error("SubtleCrypto not available!");
    this.driver = crypto.subtle;
  }
  async generateJWK() {
    let n = await this.driver.generateKey({ name: "RSA-PSS", modulusLength: 4096, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, !0, ["sign"]), c = await this.driver.exportKey("jwk", n.privateKey);
    return { kty: c.kty, e: c.e, n: c.n, d: c.d, p: c.p, q: c.q, dp: c.dp, dq: c.dq, qi: c.qi };
  }
  async sign(n, c, { saltLength: u } = {}) {
    let h = await this.driver.sign({ name: "RSA-PSS", saltLength: 32 }, await this.jwkToCryptoKey(n), c);
    return new Uint8Array(h);
  }
  async hash(n, c = "SHA-256") {
    let u = await this.driver.digest(c, n);
    return new Uint8Array(u);
  }
  async verify(n, c, u) {
    const h = { kty: "RSA", e: "AQAB", n }, g = await this.jwkToPublicCryptoKey(h), y = this.driver.verify({ name: "RSA-PSS", saltLength: 32 }, g, u, c), $ = this.driver.verify({ name: "RSA-PSS", saltLength: 0 }, g, u, c);
    return y || $;
  }
  async jwkToCryptoKey(n) {
    return this.driver.importKey("jwk", n, { name: "RSA-PSS", hash: { name: "SHA-256" } }, !1, ["sign"]);
  }
  async jwkToPublicCryptoKey(n) {
    return this.driver.importKey("jwk", n, { name: "RSA-PSS", hash: { name: "SHA-256" } }, !1, ["verify"]);
  }
  detectWebCrypto() {
    if (typeof crypto > "u")
      return !1;
    const n = crypto == null ? void 0 : crypto.subtle;
    return n !== void 0 && ["generateKey", "importKey", "exportKey", "digest", "sign"].every((c) => typeof n[c] == "function");
  }
  async encrypt(n, c, u) {
    const h = await this.driver.importKey("raw", typeof c == "string" ? ArweaveUtils$6.stringToBuffer(c) : c, { name: "PBKDF2", length: 32 }, !1, ["deriveKey"]), g = await this.driver.deriveKey({ name: "PBKDF2", salt: u ? ArweaveUtils$6.stringToBuffer(u) : ArweaveUtils$6.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, h, { name: "AES-CBC", length: 256 }, !1, ["encrypt", "decrypt"]), y = new Uint8Array(16);
    crypto.getRandomValues(y);
    const $ = await this.driver.encrypt({ name: "AES-CBC", iv: y }, g, n);
    return ArweaveUtils$6.concatBuffers([y, $]);
  }
  async decrypt(n, c, u) {
    const h = await this.driver.importKey("raw", typeof c == "string" ? ArweaveUtils$6.stringToBuffer(c) : c, { name: "PBKDF2", length: 32 }, !1, ["deriveKey"]), g = await this.driver.deriveKey({ name: "PBKDF2", salt: u ? ArweaveUtils$6.stringToBuffer(u) : ArweaveUtils$6.stringToBuffer("salt"), iterations: 1e5, hash: "SHA-256" }, h, { name: "AES-CBC", length: 256 }, !1, ["encrypt", "decrypt"]), y = n.slice(0, 16), $ = await this.driver.decrypt({ name: "AES-CBC", iv: y }, g, n.slice(16));
    return ArweaveUtils$6.concatBuffers([$]);
  }
}
webcryptoDriver.default = WebCryptoDriver;
var network$1 = {};
Object.defineProperty(network$1, "__esModule", { value: !0 });
class Network$1 {
  constructor(n) {
    this.api = n;
  }
  getInfo() {
    return this.api.get("info").then((n) => n.data);
  }
  getPeers() {
    return this.api.get("peers").then((n) => n.data);
  }
}
network$1.default = Network$1;
var transactions$1 = {}, error$1 = {};
Object.defineProperty(error$1, "__esModule", { value: !0 }), error$1.getError = void 0;
class ArweaveError$1 extends Error {
  constructor(n, c = {}) {
    c.message ? super(c.message) : super(), this.type = n, this.response = c.response;
  }
  getType() {
    return this.type;
  }
}
function getError$1(o) {
  let n = o.data;
  if (typeof o.data == "string")
    try {
      n = JSON.parse(o.data);
    } catch {
    }
  if (o.data instanceof ArrayBuffer || o.data instanceof Uint8Array)
    try {
      n = JSON.parse(n.toString());
    } catch {
    }
  return n ? n.error || n : o.statusText || "unknown";
}
error$1.default = ArweaveError$1, error$1.getError = getError$1;
var transaction$1 = {}, deepHash$1 = {}, hasRequiredDeepHash$1;
function requireDeepHash$1() {
  if (hasRequiredDeepHash$1)
    return deepHash$1;
  hasRequiredDeepHash$1 = 1, Object.defineProperty(deepHash$1, "__esModule", { value: !0 });
  const o = requireCommon$1();
  async function n(u) {
    if (Array.isArray(u)) {
      const y = o.default.utils.concatBuffers([o.default.utils.stringToBuffer("list"), o.default.utils.stringToBuffer(u.length.toString())]);
      return await c(u, await o.default.crypto.hash(y, "SHA-384"));
    }
    const h = o.default.utils.concatBuffers([o.default.utils.stringToBuffer("blob"), o.default.utils.stringToBuffer(u.byteLength.toString())]), g = o.default.utils.concatBuffers([await o.default.crypto.hash(h, "SHA-384"), await o.default.crypto.hash(u, "SHA-384")]);
    return await o.default.crypto.hash(g, "SHA-384");
  }
  async function c(u, h) {
    if (u.length < 1)
      return h;
    const g = o.default.utils.concatBuffers([h, await n(u[0])]), y = await o.default.crypto.hash(g, "SHA-384");
    return await c(u.slice(1), y);
  }
  return deepHash$1.default = n, deepHash$1;
}
var merkle$1 = {}, hasRequiredMerkle$1, hasRequiredTransaction$1;
function requireMerkle$1() {
  return hasRequiredMerkle$1 || (hasRequiredMerkle$1 = 1, function(o) {
    Object.defineProperty(o, "__esModule", { value: !0 }), o.debug = o.validatePath = o.arrayCompare = o.bufferToInt = o.intToBuffer = o.arrayFlatten = o.generateProofs = o.buildLayers = o.generateTransactionChunks = o.generateTree = o.computeRootHash = o.generateLeaves = o.chunkData = o.MIN_CHUNK_SIZE = o.MAX_CHUNK_SIZE = void 0;
    const n = requireCommon$1(), c = utils$q;
    o.MAX_CHUNK_SIZE = 262144, o.MIN_CHUNK_SIZE = 32768;
    async function u(rt) {
      let nt = [], st = rt, ot = 0;
      for (; st.byteLength >= o.MAX_CHUNK_SIZE; ) {
        let St = o.MAX_CHUNK_SIZE, Ct = st.byteLength - o.MAX_CHUNK_SIZE;
        Ct > 0 && Ct < o.MIN_CHUNK_SIZE && (St = Math.ceil(st.byteLength / 2));
        const et = st.slice(0, St), at = await n.default.crypto.hash(et);
        ot += et.byteLength, nt.push({ dataHash: at, minByteRange: ot - et.byteLength, maxByteRange: ot }), st = st.slice(St);
      }
      return nt.push({ dataHash: await n.default.crypto.hash(st), minByteRange: ot, maxByteRange: ot + st.byteLength }), nt;
    }
    async function h(rt) {
      return Promise.all(rt.map(async ({ dataHash: nt, minByteRange: st, maxByteRange: ot }) => ({ type: "leaf", id: await q(await Promise.all([q(nt), q(N(ot))])), dataHash: nt, minByteRange: st, maxByteRange: ot })));
    }
    async function g(rt) {
      return await y(await h(await u(rt)));
    }
    async function y(rt, nt = 0) {
      if (rt.length < 2)
        return rt[0];
      const st = [];
      for (let ot = 0; ot < rt.length; ot += 2)
        st.push(await L(rt[ot], rt[ot + 1]));
      return y(st, nt + 1);
    }
    function $(rt) {
      const nt = I(rt);
      return Array.isArray(nt) ? P(nt) : [nt];
    }
    function I(rt, nt = new Uint8Array(), st = 0) {
      if (rt.type == "leaf")
        return { offset: rt.maxByteRange - 1, proof: (0, c.concatBuffers)([nt, rt.dataHash, N(rt.maxByteRange)]) };
      if (rt.type == "branch") {
        const ot = (0, c.concatBuffers)([nt, rt.leftChild.id, rt.rightChild.id, N(rt.byteRange)]);
        return [I(rt.leftChild, ot, st + 1), I(rt.rightChild, ot, st + 1)];
      }
      throw new Error("Unexpected node type");
    }
    function P(rt) {
      const nt = [];
      return rt.forEach((st) => {
        Array.isArray(st) ? nt.push(...P(st)) : nt.push(st);
      }), nt;
    }
    async function L(rt, nt) {
      return nt ? { type: "branch", id: await q([await q(rt.id), await q(nt.id), await q(N(rt.maxByteRange))]), byteRange: rt.maxByteRange, maxByteRange: nt.maxByteRange, leftChild: rt, rightChild: nt } : rt;
    }
    async function q(rt) {
      return Array.isArray(rt) && (rt = n.default.utils.concatBuffers(rt)), new Uint8Array(await n.default.crypto.hash(rt));
    }
    function N(rt) {
      const nt = new Uint8Array(32);
      for (var st = nt.length - 1; st >= 0; st--) {
        var ot = rt % 256;
        nt[st] = ot, rt = (rt - ot) / 256;
      }
      return nt;
    }
    function X(rt) {
      let nt = 0;
      for (var st = 0; st < rt.length; st++)
        nt *= 256, nt += rt[st];
      return nt;
    }
    o.chunkData = u, o.generateLeaves = h, o.computeRootHash = async function(rt) {
      return (await g(rt)).id;
    }, o.generateTree = g, o.generateTransactionChunks = async function(rt) {
      const nt = await u(rt), st = await h(nt), ot = await y(st), St = await $(ot), Ct = nt.slice(-1)[0];
      return Ct.maxByteRange - Ct.minByteRange == 0 && (nt.splice(nt.length - 1, 1), St.splice(St.length - 1, 1)), { data_root: ot.id, chunks: nt, proofs: St };
    }, o.buildLayers = y, o.generateProofs = $, o.arrayFlatten = P, o.intToBuffer = N, o.bufferToInt = X, o.arrayCompare = (rt, nt) => rt.every((st, ot) => nt[ot] === st), o.validatePath = async function rt(nt, st, ot, St, Ct) {
      if (St <= 0)
        return !1;
      if (st >= St)
        return rt(nt, 0, St - 1, St, Ct);
      if (st < 0)
        return rt(nt, 0, 0, St, Ct);
      if (Ct.length == 64) {
        const E = Ct.slice(0, 32), w = Ct.slice(E.length, E.length + 32), v = await q([await q(E), await q(w)]);
        return !!(0, o.arrayCompare)(nt, v) && { offset: St - 1, leftBound: ot, rightBound: St, chunkSize: St - ot };
      }
      const et = Ct.slice(0, 32), at = Ct.slice(et.length, et.length + 32), _t = Ct.slice(et.length + at.length, et.length + at.length + 32), Nt = X(_t), m = Ct.slice(et.length + at.length + _t.length), A = await q([await q(et), await q(at), await q(_t)]);
      return !!(0, o.arrayCompare)(nt, A) && (st < Nt ? await rt(et, st, ot, Math.min(St, Nt), m) : await rt(at, st, Math.max(ot, Nt), St, m));
    }, o.debug = async function rt(nt, st = "") {
      if (nt.byteLength < 1)
        return st;
      const ot = nt.slice(0, 32), St = nt.slice(ot.length, ot.length + 32), Ct = nt.slice(ot.length + St.length, ot.length + St.length + 32), et = X(Ct), at = nt.slice(ot.length + St.length + Ct.length), _t = await q([await q(ot), await q(St), await q(Ct)]);
      return rt(at, `${st}
${JSON.stringify(Buffer.from(ot))},${JSON.stringify(Buffer.from(St))},${et} => ${JSON.stringify(_t)}`);
    };
  }(merkle$1)), merkle$1;
}
function requireTransaction$1() {
  if (hasRequiredTransaction$1)
    return transaction$1;
  hasRequiredTransaction$1 = 1, Object.defineProperty(transaction$1, "__esModule", { value: !0 }), transaction$1.Tag = void 0;
  const o = utils$q, n = requireDeepHash$1(), c = requireMerkle$1();
  class u {
    get(y, $) {
      if (!Object.getOwnPropertyNames(this).includes(y))
        throw new Error(`Field "${y}" is not a property of the Arweave Transaction class.`);
      return this[y] instanceof Uint8Array ? $ && $.decode && $.string ? o.bufferToString(this[y]) : $ && $.decode && !$.string ? this[y] : o.bufferTob64Url(this[y]) : $ && $.decode == 1 ? $ && $.string ? o.b64UrlToString(this[y]) : o.b64UrlToBuffer(this[y]) : this[y];
    }
  }
  class h extends u {
    constructor(y, $, I = !1) {
      super(), this.name = y, this.value = $;
    }
  }
  return transaction$1.Tag = h, transaction$1.default = class extends u {
    constructor(g = {}) {
      super(), this.format = 2, this.id = "", this.last_tx = "", this.owner = "", this.tags = [], this.target = "", this.quantity = "0", this.data_size = "0", this.data = new Uint8Array(), this.data_root = "", this.reward = "0", this.signature = "", Object.assign(this, g), typeof this.data == "string" && (this.data = o.b64UrlToBuffer(this.data)), g.tags && (this.tags = g.tags.map((y) => new h(y.name, y.value)));
    }
    addTag(g, y) {
      this.tags.push(new h(o.stringToB64Url(g), o.stringToB64Url(y)));
    }
    toJSON() {
      return { format: this.format, id: this.id, last_tx: this.last_tx, owner: this.owner, tags: this.tags, target: this.target, quantity: this.quantity, data: o.bufferTob64Url(this.data), data_size: this.data_size, data_root: this.data_root, data_tree: this.data_tree, reward: this.reward, signature: this.signature };
    }
    setOwner(g) {
      this.owner = g;
    }
    setSignature({ id: g, owner: y, reward: $, tags: I, signature: P }) {
      this.id = g, this.owner = y, $ && (this.reward = $), I && (this.tags = I), this.signature = P;
    }
    async prepareChunks(g) {
      !this.chunks && g.byteLength > 0 && (this.chunks = await (0, c.generateTransactionChunks)(g), this.data_root = o.bufferTob64Url(this.chunks.data_root)), this.chunks || g.byteLength !== 0 || (this.chunks = { chunks: [], data_root: new Uint8Array(), proofs: [] }, this.data_root = "");
    }
    getChunk(g, y) {
      if (!this.chunks)
        throw new Error("Chunks have not been prepared");
      const $ = this.chunks.proofs[g], I = this.chunks.chunks[g];
      return { data_root: this.data_root, data_size: this.data_size, data_path: o.bufferTob64Url($.proof), offset: $.offset.toString(), chunk: o.bufferTob64Url(y.slice(I.minByteRange, I.maxByteRange)) };
    }
    async getSignatureData() {
      switch (this.format) {
        case 1:
          let g = this.tags.reduce(($, I) => o.concatBuffers([$, I.get("name", { decode: !0, string: !1 }), I.get("value", { decode: !0, string: !1 })]), new Uint8Array());
          return o.concatBuffers([this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), this.get("data", { decode: !0, string: !1 }), o.stringToBuffer(this.quantity), o.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), g]);
        case 2:
          this.data_root || await this.prepareChunks(this.data);
          const y = this.tags.map(($) => [$.get("name", { decode: !0, string: !1 }), $.get("value", { decode: !0, string: !1 })]);
          return await (0, n.default)([o.stringToBuffer(this.format.toString()), this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), o.stringToBuffer(this.quantity), o.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), y, o.stringToBuffer(this.data_size), this.get("data_root", { decode: !0, string: !1 })]);
        default:
          throw new Error(`Unexpected transaction format: ${this.format}`);
      }
    }
  }, transaction$1;
}
var transactionUploader$1 = {}, hasRequiredTransactionUploader$1, hasRequiredTransactions$1;
function requireTransactionUploader$1() {
  if (hasRequiredTransactionUploader$1)
    return transactionUploader$1;
  hasRequiredTransactionUploader$1 = 1, Object.defineProperty(transactionUploader$1, "__esModule", { value: !0 }), transactionUploader$1.TransactionUploader = void 0;
  const o = requireTransaction$1(), n = utils$q, c = error$1, u = requireMerkle$1(), h = ["invalid_json", "chunk_too_big", "data_path_too_big", "offset_too_big", "data_size_too_big", "chunk_proof_ratio_not_attractive", "invalid_proof"];
  class g {
    constructor($, I) {
      if (this.api = $, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = "", !I.id)
        throw new Error("Transaction is not signed");
      if (!I.chunks)
        throw new Error("Transaction chunks not prepared");
      this.data = I.data, this.transaction = new o.default(Object.assign({}, I, { data: new Uint8Array(0) }));
    }
    get isComplete() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
      return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
      return this.chunkIndex;
    }
    get pctComplete() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    async uploadChunk($) {
      if (this.isComplete)
        throw new Error("Upload is already complete");
      if (this.lastResponseError !== "" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)
        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
      let I = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + 4e4 - Date.now(), 4e4);
      if (I > 0 && (I -= I * Math.random() * 0.3, await new Promise((q) => setTimeout(q, I))), this.lastResponseError = "", !this.txPosted)
        return void await this.postTransaction();
      $ && (this.chunkIndex = $);
      const P = this.transaction.getChunk($ || this.chunkIndex, this.data);
      if (!await (0, u.validatePath)(this.transaction.chunks.data_root, parseInt(P.offset), 0, parseInt(P.data_size), n.b64UrlToBuffer(P.data_path)))
        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
      const L = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((q) => (console.error(q.message), { status: -1, data: { error: q.message } }));
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = L.status, this.lastResponseStatus == 200)
        this.chunkIndex++;
      else if (this.lastResponseError = (0, c.getError)(L), h.includes(this.lastResponseError))
        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
    }
    static async fromSerialized($, I, P) {
      if (!I || typeof I.chunkIndex != "number" || typeof I.transaction != "object")
        throw new Error("Serialized object does not match expected format.");
      var L = new o.default(I.transaction);
      L.chunks || await L.prepareChunks(P);
      const q = new g($, L);
      if (q.chunkIndex = I.chunkIndex, q.lastRequestTimeEnd = I.lastRequestTimeEnd, q.lastResponseError = I.lastResponseError, q.lastResponseStatus = I.lastResponseStatus, q.txPosted = I.txPosted, q.data = P, q.transaction.data_root !== I.transaction.data_root)
        throw new Error("Data mismatch: Uploader doesn't match provided data.");
      return q;
    }
    static async fromTransactionId($, I) {
      const P = await $.get(`tx/${I}`);
      if (P.status !== 200)
        throw new Error(`Tx ${I} not found: ${P.status}`);
      const L = P.data;
      return L.data = new Uint8Array(0), { txPosted: !0, chunkIndex: 0, lastResponseError: "", lastRequestTimeEnd: 0, lastResponseStatus: 0, transaction: L };
    }
    toJSON() {
      return { chunkIndex: this.chunkIndex, transaction: this.transaction, lastRequestTimeEnd: this.lastRequestTimeEnd, lastResponseStatus: this.lastResponseStatus, lastResponseError: this.lastResponseError, txPosted: this.txPosted };
    }
    async postTransaction() {
      if (this.totalChunks <= 1) {
        this.transaction.data = this.data;
        const I = await this.api.post("tx", this.transaction).catch((P) => (console.error(P), { status: -1, data: { error: P.message } }));
        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = I.status, this.transaction.data = new Uint8Array(0), I.status >= 200 && I.status < 300)
          return this.txPosted = !0, void (this.chunkIndex = 1);
        throw this.lastResponseError = (0, c.getError)(I), new Error(`Unable to upload transaction: ${I.status}, ${this.lastResponseError}`);
      }
      const $ = await this.api.post("tx", this.transaction);
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = $.status, !($.status >= 200 && $.status < 300))
        throw this.lastResponseError = (0, c.getError)($), new Error(`Unable to upload transaction: ${$.status}, ${this.lastResponseError}`);
      this.txPosted = !0;
    }
  }
  return transactionUploader$1.TransactionUploader = g, transactionUploader$1;
}
function requireTransactions$1() {
  if (hasRequiredTransactions$1)
    return transactions$1;
  hasRequiredTransactions$1 = 1;
  var o = commonjsGlobal && commonjsGlobal.__await || function(y) {
    return this instanceof o ? (this.v = y, this) : new o(y);
  }, n = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(y, $, I) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var P, L = I.apply(y, $ || []), q = [];
    return P = {}, N("next"), N("throw"), N("return"), P[Symbol.asyncIterator] = function() {
      return this;
    }, P;
    function N(ot) {
      L[ot] && (P[ot] = function(St) {
        return new Promise(function(Ct, et) {
          q.push([ot, St, Ct, et]) > 1 || X(ot, St);
        });
      });
    }
    function X(ot, St) {
      try {
        (function(Ct) {
          Ct.value instanceof o ? Promise.resolve(Ct.value.v).then(rt, nt) : st(q[0][2], Ct);
        })(L[ot](St));
      } catch (Ct) {
        st(q[0][3], Ct);
      }
    }
    function rt(ot) {
      X("next", ot);
    }
    function nt(ot) {
      X("throw", ot);
    }
    function st(ot, St) {
      ot(St), q.shift(), q.length && X(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(transactions$1, "__esModule", { value: !0 });
  const c = error$1, u = requireTransaction$1(), h = utils$q, g = requireTransactionUploader$1();
  return transactions$1.default = class {
    constructor(y, $, I) {
      this.api = y, this.crypto = $, this.chunks = I;
    }
    getTransactionAnchor() {
      return this.api.get("tx_anchor", { transformResponse: [] }).then((y) => y.data);
    }
    getPrice(y, $) {
      let I = $ ? `price/${y}/${$}` : `price/${y}`;
      return this.api.get(I, { transformResponse: [function(P) {
        return P;
      }] }).then((P) => P.data);
    }
    async get(y) {
      const $ = await this.api.get(`tx/${y}`);
      if ($.status == 200) {
        const I = parseInt($.data.data_size);
        if ($.data.format >= 2 && I > 0 && I <= 12582912) {
          const P = await this.getData(y);
          return new u.default(Object.assign(Object.assign({}, $.data), { data: P }));
        }
        return new u.default(Object.assign(Object.assign({}, $.data), { format: $.data.format || 1 }));
      }
      throw $.status == 404 ? new c.default("TX_NOT_FOUND") : $.status == 410 ? new c.default("TX_FAILED") : new c.default("TX_INVALID");
    }
    fromRaw(y) {
      return new u.default(y);
    }
    async search(y, $) {
      return this.api.post("arql", { op: "equals", expr1: y, expr2: $ }).then((I) => I.data ? I.data : []);
    }
    getStatus(y) {
      return this.api.get(`tx/${y}/status`).then(($) => $.status == 200 ? { status: 200, confirmed: $.data } : { status: $.status, confirmed: null });
    }
    async getData(y, $) {
      let I;
      try {
        I = await this.chunks.downloadChunkedData(y);
      } catch (P) {
        console.error(`Error while trying to download chunked data for ${y}`), console.error(P);
      }
      if (!I) {
        console.warn(`Falling back to gateway cache for ${y}`);
        try {
          I = (await this.api.get(`/${y}`)).data;
        } catch (P) {
          console.error(`Error while trying to download contiguous data from gateway cache for ${y}`), console.error(P);
        }
      }
      if (!I)
        throw new Error(`${y} was not found!`);
      return $ && $.decode && !$.string ? I : $ && $.decode && $.string ? h.bufferToString(I) : h.bufferTob64Url(I);
    }
    async sign(y, $, I) {
      if (!($ || typeof window < "u" && window.arweaveWallet))
        throw new Error("A new Arweave transaction must provide the jwk parameter.");
      if ($ && $ !== "use_wallet") {
        y.setOwner($.n);
        let P = await y.getSignatureData(), L = await this.crypto.sign($, P, I), q = await this.crypto.hash(L);
        y.setSignature({ id: h.bufferTob64Url(q), owner: $.n, signature: h.bufferTob64Url(L) });
      } else {
        try {
          (await window.arweaveWallet.getPermissions()).includes("SIGN_TRANSACTION") || await window.arweaveWallet.connect(["SIGN_TRANSACTION"]);
        } catch {
        }
        const P = await window.arweaveWallet.sign(y, I);
        y.setSignature({ id: P.id, owner: P.owner, reward: P.reward, tags: P.tags, signature: P.signature });
      }
    }
    async verify(y) {
      const $ = await y.getSignatureData(), I = y.get("signature", { decode: !0, string: !1 }), P = h.bufferTob64Url(await this.crypto.hash(I));
      if (y.id !== P)
        throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
      return this.crypto.verify(y.owner, $, I);
    }
    async post(y) {
      if (typeof y == "string" ? y = new u.default(JSON.parse(y)) : typeof y.readInt32BE == "function" ? y = new u.default(JSON.parse(y.toString())) : typeof y != "object" || y instanceof u.default || (y = new u.default(y)), !(y instanceof u.default))
        throw new Error("Must be Transaction object");
      y.chunks || await y.prepareChunks(y.data);
      const $ = await this.getUploader(y, y.data);
      try {
        for (; !$.isComplete; )
          await $.uploadChunk();
      } catch (I) {
        if ($.lastResponseStatus > 0)
          return { status: $.lastResponseStatus, statusText: $.lastResponseError, data: { error: $.lastResponseError } };
        throw I;
      }
      return { status: 200, statusText: "OK", data: {} };
    }
    async getUploader(y, $) {
      let I;
      if ($ instanceof ArrayBuffer && ($ = new Uint8Array($)), y instanceof u.default) {
        if ($ || ($ = y.data), !($ instanceof Uint8Array))
          throw new Error("Data format is invalid");
        y.chunks || await y.prepareChunks($), I = new g.TransactionUploader(this.api, y), I.data && I.data.length !== 0 || (I.data = $);
      } else {
        if (typeof y == "string" && (y = await g.TransactionUploader.fromTransactionId(this.api, y)), !($ && $ instanceof Uint8Array))
          throw new Error("Must provide data when resuming upload");
        I = await g.TransactionUploader.fromSerialized(this.api, y, $);
      }
      return I;
    }
    upload(y, $) {
      return n(this, arguments, function* () {
        const I = yield o(this.getUploader(y, $));
        for (; !I.isComplete; )
          yield o(I.uploadChunk()), yield yield o(I);
        return yield o(I);
      });
    }
  }, transactions$1;
}
var wallets$1 = {};
Object.defineProperty(wallets$1, "__esModule", { value: !0 });
const ArweaveUtils$5 = utils$q;
class Wallets$1 {
  constructor(n, c) {
    this.api = n, this.crypto = c;
  }
  getBalance(n) {
    return this.api.get(`wallet/${n}/balance`, { transformResponse: [function(c) {
      return c;
    }] }).then((c) => c.data);
  }
  getLastTransactionID(n) {
    return this.api.get(`wallet/${n}/last_tx`).then((c) => c.data);
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(n) {
    return n && n !== "use_wallet" ? this.getAddress(n) : this.getAddress();
  }
  async getAddress(n) {
    if (n && n !== "use_wallet")
      return this.ownerToAddress(n.n);
    try {
      await window.arweaveWallet.connect(["ACCESS_ADDRESS"]);
    } catch {
    }
    return window.arweaveWallet.getActiveAddress();
  }
  async ownerToAddress(n) {
    return ArweaveUtils$5.bufferTob64Url(await this.crypto.hash(ArweaveUtils$5.b64UrlToBuffer(n)));
  }
}
wallets$1.default = Wallets$1;
var silo$1 = {};
Object.defineProperty(silo$1, "__esModule", { value: !0 }), silo$1.SiloResource = void 0;
const ArweaveUtils$4 = utils$q;
class Silo$1 {
  constructor(n, c, u) {
    this.api = n, this.crypto = c, this.transactions = u;
  }
  async get(n) {
    if (!n)
      throw new Error("No Silo URI specified");
    const c = await this.parseUri(n), u = await this.transactions.search("Silo-Name", c.getAccessKey());
    if (u.length == 0)
      throw new Error(`No data could be found for the Silo URI: ${n}`);
    const h = await this.transactions.get(u[0]);
    if (!h)
      throw new Error(`No data could be found for the Silo URI: ${n}`);
    const g = h.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(g, c.getEncryptionKey());
  }
  async readTransactionData(n, c) {
    if (!c)
      throw new Error("No Silo URI specified");
    const u = await this.parseUri(c), h = n.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(h, u.getEncryptionKey());
  }
  async parseUri(n) {
    const c = n.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
    if (!c)
      throw new Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
    const u = c[1], h = Math.pow(2, parseInt(c[2])), g = await this.hash(ArweaveUtils$4.stringToBuffer(u), h), y = ArweaveUtils$4.bufferTob64(g.slice(0, 15)), $ = await this.hash(g.slice(16, 31), 1);
    return new SiloResource$1(n, y, $);
  }
  async hash(n, c) {
    let u = await this.crypto.hash(n);
    for (let h = 0; h < c - 1; h++)
      u = await this.crypto.hash(u);
    return u;
  }
}
silo$1.default = Silo$1;
class SiloResource$1 {
  constructor(n, c, u) {
    this.uri = n, this.accessKey = c, this.encryptionKey = u;
  }
  getUri() {
    return this.uri;
  }
  getAccessKey() {
    return this.accessKey;
  }
  getEncryptionKey() {
    return this.encryptionKey;
  }
}
silo$1.SiloResource = SiloResource$1;
var chunks$1 = {};
Object.defineProperty(chunks$1, "__esModule", { value: !0 });
const error_1$3 = error$1, ArweaveUtils$3 = utils$q;
class Chunks$1 {
  constructor(n) {
    this.api = n;
  }
  async getTransactionOffset(n) {
    const c = await this.api.get(`tx/${n}/offset`);
    if (c.status === 200)
      return c.data;
    throw new Error(`Unable to get transaction offset: ${(0, error_1$3.getError)(c)}`);
  }
  async getChunk(n) {
    const c = await this.api.get(`chunk/${n}`);
    if (c.status === 200)
      return c.data;
    throw new Error(`Unable to get chunk: ${(0, error_1$3.getError)(c)}`);
  }
  async getChunkData(n) {
    const c = await this.getChunk(n);
    return ArweaveUtils$3.b64UrlToBuffer(c.chunk);
  }
  firstChunkOffset(n) {
    return parseInt(n.offset) - parseInt(n.size) + 1;
  }
  async downloadChunkedData(n) {
    const c = await this.getTransactionOffset(n), u = parseInt(c.size), h = parseInt(c.offset) - u + 1, g = new Uint8Array(u);
    let y = 0;
    for (; y < u; ) {
      let $;
      this.api.config.logging && console.log(`[chunk] ${y}/${u}`);
      try {
        $ = await this.getChunkData(h + y);
      } catch {
        console.error(`[chunk] Failed to fetch chunk at offset ${h + y}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
      }
      if (!$)
        throw new Error(`Couldn't complete data download at ${y}/${u}`);
      g.set($, y), y += $.length;
    }
    return g;
  }
}
chunks$1.default = Chunks$1;
var blocks$1 = {};
Object.defineProperty(blocks$1, "__esModule", { value: !0 });
const error_1$2 = error$1;
class Blocks$1 {
  constructor(n, c) {
    this.api = n, this.network = c;
  }
  async get(n) {
    const c = await this.api.get(`${Blocks$1.ENDPOINT}${n}`);
    if (c.status === 200)
      return c.data;
    throw c.status === 404 ? new error_1$2.default("BLOCK_NOT_FOUND") : new Error(`Error while loading block data: ${c}`);
  }
  async getCurrent() {
    const { current: n } = await this.network.getInfo();
    return await this.get(n);
  }
}
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1)
    return common$9;
  hasRequiredCommon$1 = 1, Object.defineProperty(common$9, "__esModule", { value: !0 });
  const o = ar$1, n = api$2, c = webcryptoDriver, u = network$1, h = requireTransactions$1(), g = wallets$1, y = requireTransaction$1(), $ = utils$q, I = silo$1, P = chunks$1, L = blocks$1;
  class q {
    constructor(X) {
      this.api = new n.default(X), this.wallets = new g.default(this.api, q.crypto), this.chunks = new P.default(this.api), this.transactions = new h.default(this.api, q.crypto, this.chunks), this.silo = new I.default(this.api, this.crypto, this.transactions), this.network = new u.default(this.api), this.blocks = new L.default(this.api, this.network), this.ar = new o.default();
    }
    get crypto() {
      return q.crypto;
    }
    get utils() {
      return q.utils;
    }
    getConfig() {
      return { api: this.api.getConfig(), crypto: null };
    }
    async createTransaction(X, rt) {
      const nt = {};
      if (Object.assign(nt, X), !(X.data || X.target && X.quantity))
        throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
      if (X.owner == null && rt && rt !== "use_wallet" && (nt.owner = rt.n), X.last_tx == null && (nt.last_tx = await this.transactions.getTransactionAnchor()), typeof X.data == "string" && (X.data = $.stringToBuffer(X.data)), X.data instanceof ArrayBuffer && (X.data = new Uint8Array(X.data)), X.data && !(X.data instanceof Uint8Array))
        throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
      if (X.reward == null) {
        const ot = X.data ? X.data.byteLength : 0;
        nt.reward = await this.transactions.getPrice(ot, nt.target);
      }
      nt.data_root = "", nt.data_size = X.data ? X.data.byteLength.toString() : "0", nt.data = X.data || new Uint8Array(0);
      const st = new y.default(nt);
      return await st.getSignatureData(), st;
    }
    async createSiloTransaction(X, rt, nt) {
      const st = {};
      if (Object.assign(st, X), !X.data)
        throw new Error("Silo transactions must have a 'data' value");
      if (!nt)
        throw new Error("No Silo URI specified.");
      if (X.target || X.quantity)
        throw new Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
      if (X.owner == null) {
        if (!rt || !rt.n)
          throw new Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
        st.owner = rt.n;
      }
      X.last_tx == null && (st.last_tx = await this.transactions.getTransactionAnchor());
      const ot = await this.silo.parseUri(nt);
      if (typeof X.data == "string") {
        const Ct = await this.crypto.encrypt($.stringToBuffer(X.data), ot.getEncryptionKey());
        st.reward = await this.transactions.getPrice(Ct.byteLength), st.data = $.bufferTob64Url(Ct);
      }
      if (X.data instanceof Uint8Array) {
        const Ct = await this.crypto.encrypt(X.data, ot.getEncryptionKey());
        st.reward = await this.transactions.getPrice(Ct.byteLength), st.data = $.bufferTob64Url(Ct);
      }
      const St = new y.default(st);
      return St.addTag("Silo-Name", ot.getAccessKey()), St.addTag("Silo-Version", "0.1.0"), St;
    }
    arql(X) {
      return this.api.post("/arql", X).then((rt) => rt.data || []);
    }
  }
  return common$9.default = q, q.crypto = new c.default(), q.utils = $, common$9;
}
blocks$1.default = Blocks$1, Blocks$1.ENDPOINT = "block/hash/", function(o) {
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(h, g, y, $) {
    $ === void 0 && ($ = y);
    var I = Object.getOwnPropertyDescriptor(g, y);
    I && !("get" in I ? !g.__esModule : I.writable || I.configurable) || (I = { enumerable: !0, get: function() {
      return g[y];
    } }), Object.defineProperty(h, $, I);
  } : function(h, g, y, $) {
    $ === void 0 && ($ = y), h[$] = g[y];
  }), c = commonjsGlobal && commonjsGlobal.__exportStar || function(h, g) {
    for (var y in h)
      y === "default" || Object.prototype.hasOwnProperty.call(g, y) || n(g, h, y);
  };
  Object.defineProperty(o, "__esModule", { value: !0 });
  const u = requireCommon$1();
  u.default.init = function(h = {}) {
    const g = function() {
      const P = { host: "arweave.net", port: 443, protocol: "https" };
      if (!(window && window.location && window.location.protocol && window.location.hostname))
        return P;
      const L = window.location.protocol.replace(":", ""), q = window.location.hostname, N = window.location.port ? parseInt(window.location.port) : L == "https" ? 443 : 80;
      return ["localhost", "127.0.0.1"].includes(q) || L == "file" ? P : { host: q, port: N, protocol: L };
    }(), y = h.protocol || g.protocol, $ = h.host || g.host, I = h.port || g.port;
    return new u.default(Object.assign(Object.assign({}, h), { host: $, protocol: y, port: I }));
  }, window.Arweave = u.default, c(requireCommon$1(), o), o.default = u.default;
}(web);
const Arweave = getDefaultExportFromCjs(web);
function create_fragment$5(o) {
  let n;
  return { c() {
    n = element("div");
  }, m(c, u) {
    insert(c, n, u), o[3](n);
  }, p: noop$3, i: noop$3, o: noop$3, d(c) {
    c && detach(n), o[3](null);
  } };
}
function instance$5(o, n, c) {
  let u, { src: h } = n, { props: g = {} } = n;
  const y = createEventDispatcher();
  return onMount(async () => {
    h && async function({ text: $, target: I, props: P }) {
      y("target", I);
      const L = new Blob([$], { type: "text/javascript" }), q = URL.createObjectURL(L), N = (await import(q)).default;
      y("ready", N), I.innerHTML = "";
      const X = new N({ target: I, props: P });
      q && URL.revokeObjectURL(q), y("mounted", X), X.$on("change", (rt) => {
        y("change", rt);
      });
    }({ text: h, target: u, props: g });
  }), o.$$set = ($) => {
    "src" in $ && c(1, h = $.src), "props" in $ && c(2, g = $.props);
  }, [u, h, g, function($) {
    binding_callbacks[$ ? "unshift" : "push"](() => {
      u = $, c(0, u);
    });
  }];
}
class Mount extends SvelteComponent {
  constructor(n) {
    super(), init$1(this, n, instance$5, create_fragment$5, safe_not_equal, { src: 1, props: 2 });
  }
}
var encode_1$4 = encode$t, MSB$6 = 128, REST$6 = 127, MSBALL$4 = ~REST$6, INT$4 = Math.pow(2, 31);
function encode$t(o, n, c) {
  if (Number.MAX_SAFE_INTEGER && o > Number.MAX_SAFE_INTEGER)
    throw encode$t.bytes = 0, new RangeError("Could not encode varint");
  n = n || [];
  for (var u = c = c || 0; o >= INT$4; )
    n[c++] = 255 & o | MSB$6, o /= 128;
  for (; o & MSBALL$4; )
    n[c++] = 255 & o | MSB$6, o >>>= 7;
  return n[c] = 0 | o, encode$t.bytes = c - u + 1, n;
}
var decode$v = read$6, MSB$5 = 128, REST$5 = 127;
function read$6(o, n) {
  var c, u = 0, h = 0, g = n = n || 0, y = o.length;
  do {
    if (g >= y || h > 49)
      throw read$6.bytes = 0, new RangeError("Could not decode varint");
    c = o[g++], u += h < 28 ? (c & REST$5) << h : (c & REST$5) * Math.pow(2, h), h += 7;
  } while (c >= MSB$5);
  return read$6.bytes = g - n, u;
}
var N1$4 = Math.pow(2, 7), N2$4 = Math.pow(2, 14), N3$4 = Math.pow(2, 21), N4$4 = Math.pow(2, 28), N5$4 = Math.pow(2, 35), N6$4 = Math.pow(2, 42), N7$4 = Math.pow(2, 49), N8$4 = Math.pow(2, 56), N9$4 = Math.pow(2, 63), length$5 = function(o) {
  return o < N1$4 ? 1 : o < N2$4 ? 2 : o < N3$4 ? 3 : o < N4$4 ? 4 : o < N5$4 ? 5 : o < N6$4 ? 6 : o < N7$4 ? 7 : o < N8$4 ? 8 : o < N9$4 ? 9 : 10;
}, varint$4 = { encode: encode_1$4, decode: decode$v, encodingLength: length$5 };
const typeofs = ["string", "number", "bigint", "symbol"], objectTypeNames = ["Function", "Generator", "AsyncGenerator", "GeneratorFunction", "AsyncGeneratorFunction", "AsyncFunction", "Observable", "Array", "Buffer", "Object", "RegExp", "Date", "Error", "Map", "Set", "WeakMap", "WeakSet", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Promise", "URL", "HTMLElement", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array"];
function is$1(o) {
  if (o === null)
    return "null";
  if (o === void 0)
    return "undefined";
  if (o === !0 || o === !1)
    return "boolean";
  const n = typeof o;
  return typeofs.includes(n) ? n : n === "function" ? "Function" : Array.isArray(o) ? "Array" : isBuffer$4(o) ? "Buffer" : getObjectType(o) || "Object";
}
function isBuffer$4(o) {
  return o && o.constructor && o.constructor.isBuffer && o.constructor.isBuffer.call(null, o);
}
function getObjectType(o) {
  const n = Object.prototype.toString.call(o).slice(8, -1);
  if (objectTypeNames.includes(n))
    return n;
}
class Type {
  constructor(n, c, u) {
    this.major = n, this.majorEncoded = n << 5, this.name = c, this.terminal = u;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(n) {
    return this.major < n.major ? -1 : this.major > n.major ? 1 : 0;
  }
}
Type.uint = new Type(0, "uint", !0), Type.negint = new Type(1, "negint", !0), Type.bytes = new Type(2, "bytes", !0), Type.string = new Type(3, "string", !0), Type.array = new Type(4, "array", !1), Type.map = new Type(5, "map", !1), Type.tag = new Type(6, "tag", !1), Type.float = new Type(7, "float", !0), Type.false = new Type(7, "false", !0), Type.true = new Type(7, "true", !0), Type.null = new Type(7, "null", !0), Type.undefined = new Type(7, "undefined", !0), Type.break = new Type(7, "break", !0);
class Token {
  constructor(n, c, u) {
    this.type = n, this.value = c, this.encodedLength = u, this.encodedBytes = void 0, this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
}
const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer == "function", textDecoder$3 = new TextDecoder(), textEncoder$5 = new TextEncoder();
function isBuffer$3(o) {
  return useBuffer && globalThis.Buffer.isBuffer(o);
}
function asU8A(o) {
  return o instanceof Uint8Array ? isBuffer$3(o) ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength) : o : Uint8Array.from(o);
}
const toString$9 = useBuffer ? (o, n, c) => c - n > 64 ? globalThis.Buffer.from(o.subarray(n, c)).toString("utf8") : utf8Slice(o, n, c) : (o, n, c) => c - n > 64 ? textDecoder$3.decode(o.subarray(n, c)) : utf8Slice(o, n, c), fromString$7 = useBuffer ? (o) => o.length > 64 ? globalThis.Buffer.from(o) : utf8ToBytes(o) : (o) => o.length > 64 ? textEncoder$5.encode(o) : utf8ToBytes(o), fromArray = (o) => Uint8Array.from(o), slice = useBuffer ? (o, n, c) => isBuffer$3(o) ? new Uint8Array(o.subarray(n, c)) : o.slice(n, c) : (o, n, c) => o.slice(n, c), concat$2 = useBuffer ? (o, n) => (o = o.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c)), asU8A(globalThis.Buffer.concat(o, n))) : (o, n) => {
  const c = new Uint8Array(n);
  let u = 0;
  for (let h of o)
    u + h.length > c.length && (h = h.subarray(0, c.length - u)), c.set(h, u), u += h.length;
  return c;
}, alloc = useBuffer ? (o) => globalThis.Buffer.allocUnsafe(o) : (o) => new Uint8Array(o);
function compare$2(o, n) {
  if (isBuffer$3(o) && isBuffer$3(n))
    return o.compare(n);
  for (let c = 0; c < o.length; c++)
    if (o[c] !== n[c])
      return o[c] < n[c] ? -1 : 1;
  return 0;
}
function utf8ToBytes(o, n = 1 / 0) {
  let c;
  const u = o.length;
  let h = null;
  const g = [];
  for (let y = 0; y < u; ++y) {
    if (c = o.charCodeAt(y), c > 55295 && c < 57344) {
      if (!h) {
        if (c > 56319) {
          (n -= 3) > -1 && g.push(239, 191, 189);
          continue;
        }
        if (y + 1 === u) {
          (n -= 3) > -1 && g.push(239, 191, 189);
          continue;
        }
        h = c;
        continue;
      }
      if (c < 56320) {
        (n -= 3) > -1 && g.push(239, 191, 189), h = c;
        continue;
      }
      c = 65536 + (h - 55296 << 10 | c - 56320);
    } else
      h && (n -= 3) > -1 && g.push(239, 191, 189);
    if (h = null, c < 128) {
      if ((n -= 1) < 0)
        break;
      g.push(c);
    } else if (c < 2048) {
      if ((n -= 2) < 0)
        break;
      g.push(c >> 6 | 192, 63 & c | 128);
    } else if (c < 65536) {
      if ((n -= 3) < 0)
        break;
      g.push(c >> 12 | 224, c >> 6 & 63 | 128, 63 & c | 128);
    } else {
      if (!(c < 1114112))
        throw new Error("Invalid code point");
      if ((n -= 4) < 0)
        break;
      g.push(c >> 18 | 240, c >> 12 & 63 | 128, c >> 6 & 63 | 128, 63 & c | 128);
    }
  }
  return g;
}
function utf8Slice(o, n, c) {
  const u = [];
  for (; n < c; ) {
    const h = o[n];
    let g = null, y = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
    if (n + y <= c) {
      let $, I, P, L;
      switch (y) {
        case 1:
          h < 128 && (g = h);
          break;
        case 2:
          $ = o[n + 1], (192 & $) == 128 && (L = (31 & h) << 6 | 63 & $, L > 127 && (g = L));
          break;
        case 3:
          $ = o[n + 1], I = o[n + 2], (192 & $) == 128 && (192 & I) == 128 && (L = (15 & h) << 12 | (63 & $) << 6 | 63 & I, L > 2047 && (L < 55296 || L > 57343) && (g = L));
          break;
        case 4:
          $ = o[n + 1], I = o[n + 2], P = o[n + 3], (192 & $) == 128 && (192 & I) == 128 && (192 & P) == 128 && (L = (15 & h) << 18 | (63 & $) << 12 | (63 & I) << 6 | 63 & P, L > 65535 && L < 1114112 && (g = L));
      }
    }
    g === null ? (g = 65533, y = 1) : g > 65535 && (g -= 65536, u.push(g >>> 10 & 1023 | 55296), g = 56320 | 1023 & g), u.push(g), n += y;
  }
  return decodeCodePointsArray(u);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(o) {
  const n = o.length;
  if (n <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, o);
  let c = "", u = 0;
  for (; u < n; )
    c += String.fromCharCode.apply(String, o.slice(u, u += MAX_ARGUMENTS_LENGTH));
  return c;
}
const defaultChunkSize = 256;
class Bl {
  constructor(n = defaultChunkSize) {
    this.chunkSize = n, this.cursor = 0, this.maxCursor = -1, this.chunks = [], this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0, this.maxCursor = -1, this.chunks.length && (this.chunks = []), this._initReuseChunk !== null && (this.chunks.push(this._initReuseChunk), this.maxCursor = this._initReuseChunk.length - 1);
  }
  push(n) {
    let c = this.chunks[this.chunks.length - 1];
    if (this.cursor + n.length <= this.maxCursor + 1) {
      const u = c.length - (this.maxCursor - this.cursor) - 1;
      c.set(n, u);
    } else {
      if (c) {
        const u = c.length - (this.maxCursor - this.cursor) - 1;
        u < c.length && (this.chunks[this.chunks.length - 1] = c.subarray(0, u), this.maxCursor = this.cursor - 1);
      }
      n.length < 64 && n.length < this.chunkSize ? (c = alloc(this.chunkSize), this.chunks.push(c), this.maxCursor += c.length, this._initReuseChunk === null && (this._initReuseChunk = c), c.set(n, 0)) : (this.chunks.push(n), this.maxCursor += n.length);
    }
    this.cursor += n.length;
  }
  toBytes(n = !1) {
    let c;
    if (this.chunks.length === 1) {
      const u = this.chunks[0];
      n && this.cursor > u.length / 2 ? (c = this.cursor === u.length ? u : u.subarray(0, this.cursor), this._initReuseChunk = null, this.chunks = []) : c = slice(u, 0, this.cursor);
    } else
      c = concat$2(this.chunks, this.cursor);
    return n && this.reset(), c;
  }
}
const decodeErrPrefix = "CBOR decode error:", encodeErrPrefix = "CBOR encode error:";
function assertEnoughData(o, n, c) {
  if (o.length - n < c)
    throw new Error(`${decodeErrPrefix} not enough data for type`);
}
const uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function readUint8(o, n, c) {
  assertEnoughData(o, n, 1);
  const u = o[n];
  if (c.strict === !0 && u < uintBoundaries[0])
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  return u;
}
function readUint16(o, n, c) {
  assertEnoughData(o, n, 2);
  const u = o[n] << 8 | o[n + 1];
  if (c.strict === !0 && u < uintBoundaries[1])
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  return u;
}
function readUint32(o, n, c) {
  assertEnoughData(o, n, 4);
  const u = 16777216 * o[n] + (o[n + 1] << 16) + (o[n + 2] << 8) + o[n + 3];
  if (c.strict === !0 && u < uintBoundaries[2])
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  return u;
}
function readUint64(o, n, c) {
  assertEnoughData(o, n, 8);
  const u = 16777216 * o[n] + (o[n + 1] << 16) + (o[n + 2] << 8) + o[n + 3], h = 16777216 * o[n + 4] + (o[n + 5] << 16) + (o[n + 6] << 8) + o[n + 7], g = (BigInt(u) << BigInt(32)) + BigInt(h);
  if (c.strict === !0 && g < uintBoundaries[3])
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  if (g <= Number.MAX_SAFE_INTEGER)
    return Number(g);
  if (c.allowBigInt === !0)
    return g;
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(o, n, c, u) {
  return new Token(Type.uint, readUint8(o, n + 1, u), 2);
}
function decodeUint16(o, n, c, u) {
  return new Token(Type.uint, readUint16(o, n + 1, u), 3);
}
function decodeUint32(o, n, c, u) {
  return new Token(Type.uint, readUint32(o, n + 1, u), 5);
}
function decodeUint64(o, n, c, u) {
  return new Token(Type.uint, readUint64(o, n + 1, u), 9);
}
function encodeUint(o, n) {
  return encodeUintValue(o, 0, n.value);
}
function encodeUintValue(o, n, c) {
  if (c < uintBoundaries[0]) {
    const u = Number(c);
    o.push([n | u]);
  } else if (c < uintBoundaries[1]) {
    const u = Number(c);
    o.push([24 | n, u]);
  } else if (c < uintBoundaries[2]) {
    const u = Number(c);
    o.push([25 | n, u >>> 8, 255 & u]);
  } else if (c < uintBoundaries[3]) {
    const u = Number(c);
    o.push([26 | n, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u]);
  } else {
    const u = BigInt(c);
    if (!(u < uintBoundaries[4]))
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    {
      const h = [27 | n, 0, 0, 0, 0, 0, 0, 0];
      let g = Number(u & BigInt(4294967295)), y = Number(u >> BigInt(32) & BigInt(4294967295));
      h[8] = 255 & g, g >>= 8, h[7] = 255 & g, g >>= 8, h[6] = 255 & g, g >>= 8, h[5] = 255 & g, h[4] = 255 & y, y >>= 8, h[3] = 255 & y, y >>= 8, h[2] = 255 & y, y >>= 8, h[1] = 255 & y, o.push(h);
    }
  }
}
function decodeNegint8(o, n, c, u) {
  return new Token(Type.negint, -1 - readUint8(o, n + 1, u), 2);
}
function decodeNegint16(o, n, c, u) {
  return new Token(Type.negint, -1 - readUint16(o, n + 1, u), 3);
}
function decodeNegint32(o, n, c, u) {
  return new Token(Type.negint, -1 - readUint32(o, n + 1, u), 5);
}
encodeUint.encodedSize = function(o) {
  return encodeUintValue.encodedSize(o.value);
}, encodeUintValue.encodedSize = function(o) {
  return o < uintBoundaries[0] ? 1 : o < uintBoundaries[1] ? 2 : o < uintBoundaries[2] ? 3 : o < uintBoundaries[3] ? 5 : 9;
}, encodeUint.compareTokens = function(o, n) {
  return o.value < n.value ? -1 : o.value > n.value ? 1 : 0;
};
const neg1b = BigInt(-1), pos1b = BigInt(1);
function decodeNegint64(o, n, c, u) {
  const h = readUint64(o, n + 1, u);
  if (typeof h != "bigint") {
    const g = -1 - h;
    if (g >= Number.MIN_SAFE_INTEGER)
      return new Token(Type.negint, g, 9);
  }
  if (u.allowBigInt !== !0)
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  return new Token(Type.negint, neg1b - BigInt(h), 9);
}
function encodeNegint(o, n) {
  const c = n.value, u = typeof c == "bigint" ? c * neg1b - pos1b : -1 * c - 1;
  encodeUintValue(o, n.type.majorEncoded, u);
}
function toToken$3(o, n, c, u) {
  assertEnoughData(o, n, c + u);
  const h = slice(o, n + c, n + c + u);
  return new Token(Type.bytes, h, c + u);
}
function decodeBytesCompact(o, n, c, u) {
  return toToken$3(o, n, 1, c);
}
function decodeBytes8(o, n, c, u) {
  return toToken$3(o, n, 2, readUint8(o, n + 1, u));
}
function decodeBytes16(o, n, c, u) {
  return toToken$3(o, n, 3, readUint16(o, n + 1, u));
}
function decodeBytes32(o, n, c, u) {
  return toToken$3(o, n, 5, readUint32(o, n + 1, u));
}
function decodeBytes64(o, n, c, u) {
  const h = readUint64(o, n + 1, u);
  if (typeof h == "bigint")
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  return toToken$3(o, n, 9, h);
}
function tokenBytes(o) {
  return o.encodedBytes === void 0 && (o.encodedBytes = o.type === Type.string ? fromString$7(o.value) : o.value), o.encodedBytes;
}
function encodeBytes(o, n) {
  const c = tokenBytes(n);
  encodeUintValue(o, n.type.majorEncoded, c.length), o.push(c);
}
function compareBytes(o, n) {
  return o.length < n.length ? -1 : o.length > n.length ? 1 : compare$2(o, n);
}
function toToken$2(o, n, c, u, h) {
  const g = c + u;
  assertEnoughData(o, n, g);
  const y = new Token(Type.string, toString$9(o, n + c, n + g), g);
  return h.retainStringBytes === !0 && (y.byteValue = slice(o, n + c, n + g)), y;
}
function decodeStringCompact(o, n, c, u) {
  return toToken$2(o, n, 1, c, u);
}
function decodeString8(o, n, c, u) {
  return toToken$2(o, n, 2, readUint8(o, n + 1, u), u);
}
function decodeString16(o, n, c, u) {
  return toToken$2(o, n, 3, readUint16(o, n + 1, u), u);
}
function decodeString32(o, n, c, u) {
  return toToken$2(o, n, 5, readUint32(o, n + 1, u), u);
}
function decodeString64(o, n, c, u) {
  const h = readUint64(o, n + 1, u);
  if (typeof h == "bigint")
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  return toToken$2(o, n, 9, h, u);
}
encodeNegint.encodedSize = function(o) {
  const n = o.value, c = typeof n == "bigint" ? n * neg1b - pos1b : -1 * n - 1;
  return c < uintBoundaries[0] ? 1 : c < uintBoundaries[1] ? 2 : c < uintBoundaries[2] ? 3 : c < uintBoundaries[3] ? 5 : 9;
}, encodeNegint.compareTokens = function(o, n) {
  return o.value < n.value ? 1 : o.value > n.value ? -1 : 0;
}, encodeBytes.encodedSize = function(o) {
  const n = tokenBytes(o);
  return encodeUintValue.encodedSize(n.length) + n.length;
}, encodeBytes.compareTokens = function(o, n) {
  return compareBytes(tokenBytes(o), tokenBytes(n));
};
const encodeString = encodeBytes;
function toToken$1(o, n, c, u) {
  return new Token(Type.array, u, c);
}
function decodeArrayCompact(o, n, c, u) {
  return toToken$1(o, n, 1, c);
}
function decodeArray8(o, n, c, u) {
  return toToken$1(o, n, 2, readUint8(o, n + 1, u));
}
function decodeArray16(o, n, c, u) {
  return toToken$1(o, n, 3, readUint16(o, n + 1, u));
}
function decodeArray32(o, n, c, u) {
  return toToken$1(o, n, 5, readUint32(o, n + 1, u));
}
function decodeArray64(o, n, c, u) {
  const h = readUint64(o, n + 1, u);
  if (typeof h == "bigint")
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  return toToken$1(o, n, 9, h);
}
function decodeArrayIndefinite(o, n, c, u) {
  if (u.allowIndefinite === !1)
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  return toToken$1(o, n, 1, 1 / 0);
}
function encodeArray(o, n) {
  encodeUintValue(o, Type.array.majorEncoded, n.value);
}
function toToken(o, n, c, u) {
  return new Token(Type.map, u, c);
}
function decodeMapCompact(o, n, c, u) {
  return toToken(o, n, 1, c);
}
function decodeMap8(o, n, c, u) {
  return toToken(o, n, 2, readUint8(o, n + 1, u));
}
function decodeMap16(o, n, c, u) {
  return toToken(o, n, 3, readUint16(o, n + 1, u));
}
function decodeMap32(o, n, c, u) {
  return toToken(o, n, 5, readUint32(o, n + 1, u));
}
function decodeMap64(o, n, c, u) {
  const h = readUint64(o, n + 1, u);
  if (typeof h == "bigint")
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  return toToken(o, n, 9, h);
}
function decodeMapIndefinite(o, n, c, u) {
  if (u.allowIndefinite === !1)
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  return toToken(o, n, 1, 1 / 0);
}
function encodeMap(o, n) {
  encodeUintValue(o, Type.map.majorEncoded, n.value);
}
function decodeTagCompact(o, n, c, u) {
  return new Token(Type.tag, c, 1);
}
function decodeTag8(o, n, c, u) {
  return new Token(Type.tag, readUint8(o, n + 1, u), 2);
}
function decodeTag16(o, n, c, u) {
  return new Token(Type.tag, readUint16(o, n + 1, u), 3);
}
function decodeTag32(o, n, c, u) {
  return new Token(Type.tag, readUint32(o, n + 1, u), 5);
}
function decodeTag64(o, n, c, u) {
  return new Token(Type.tag, readUint64(o, n + 1, u), 9);
}
function encodeTag$1(o, n) {
  encodeUintValue(o, Type.tag.majorEncoded, n.value);
}
encodeArray.compareTokens = encodeUint.compareTokens, encodeArray.encodedSize = function(o) {
  return encodeUintValue.encodedSize(o.value);
}, encodeMap.compareTokens = encodeUint.compareTokens, encodeMap.encodedSize = function(o) {
  return encodeUintValue.encodedSize(o.value);
}, encodeTag$1.compareTokens = encodeUint.compareTokens, encodeTag$1.encodedSize = function(o) {
  return encodeUintValue.encodedSize(o.value);
};
const MINOR_FALSE = 20, MINOR_TRUE = 21, MINOR_NULL = 22, MINOR_UNDEFINED = 23;
function decodeUndefined(o, n, c, u) {
  if (u.allowUndefined === !1)
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  return u.coerceUndefinedToNull === !0 ? new Token(Type.null, null, 1) : new Token(Type.undefined, void 0, 1);
}
function decodeBreak(o, n, c, u) {
  if (u.allowIndefinite === !1)
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  return new Token(Type.break, void 0, 1);
}
function createToken(o, n, c) {
  if (c) {
    if (c.allowNaN === !1 && Number.isNaN(o))
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    if (c.allowInfinity === !1 && (o === 1 / 0 || o === -1 / 0))
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
  }
  return new Token(Type.float, o, n);
}
function decodeFloat16(o, n, c, u) {
  return createToken(readFloat16(o, n + 1), 3, u);
}
function decodeFloat32(o, n, c, u) {
  return createToken(readFloat32(o, n + 1), 5, u);
}
function decodeFloat64(o, n, c, u) {
  return createToken(readFloat64(o, n + 1), 9, u);
}
function encodeFloat(o, n, c) {
  const u = n.value;
  if (u === !1)
    o.push([Type.float.majorEncoded | MINOR_FALSE]);
  else if (u === !0)
    o.push([Type.float.majorEncoded | MINOR_TRUE]);
  else if (u === null)
    o.push([Type.float.majorEncoded | MINOR_NULL]);
  else if (u === void 0)
    o.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  else {
    let h, g = !1;
    c && c.float64 === !0 || (encodeFloat16(u), h = readFloat16(ui8a, 1), u === h || Number.isNaN(u) ? (ui8a[0] = 249, o.push(ui8a.slice(0, 3)), g = !0) : (encodeFloat32(u), h = readFloat32(ui8a, 1), u === h && (ui8a[0] = 250, o.push(ui8a.slice(0, 5)), g = !0))), g || (encodeFloat64(u), h = readFloat64(ui8a, 1), ui8a[0] = 251, o.push(ui8a.slice(0, 9)));
  }
}
encodeFloat.encodedSize = function(o, n) {
  const c = o.value;
  if (c === !1 || c === !0 || c == null)
    return 1;
  if (!n || n.float64 !== !0) {
    encodeFloat16(c);
    let u = readFloat16(ui8a, 1);
    if (c === u || Number.isNaN(c))
      return 3;
    if (encodeFloat32(c), u = readFloat32(ui8a, 1), c === u)
      return 5;
  }
  return 9;
};
const buffer$3 = new ArrayBuffer(9), dataView = new DataView(buffer$3, 1), ui8a = new Uint8Array(buffer$3, 0);
function encodeFloat16(o) {
  if (o === 1 / 0)
    dataView.setUint16(0, 31744, !1);
  else if (o === -1 / 0)
    dataView.setUint16(0, 64512, !1);
  else if (Number.isNaN(o))
    dataView.setUint16(0, 32256, !1);
  else {
    dataView.setFloat32(0, o);
    const n = dataView.getUint32(0), c = (2139095040 & n) >> 23, u = 8388607 & n;
    if (c === 255)
      dataView.setUint16(0, 31744, !1);
    else if (c === 0)
      dataView.setUint16(0, (2147483648 & o) >> 16 | u >> 13, !1);
    else {
      const h = c - 127;
      h < -24 ? dataView.setUint16(0, 0) : h < -14 ? dataView.setUint16(0, (2147483648 & n) >> 16 | 1 << 24 + h, !1) : dataView.setUint16(0, (2147483648 & n) >> 16 | h + 15 << 10 | u >> 13, !1);
    }
  }
}
function readFloat16(o, n) {
  if (o.length - n < 2)
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  const c = (o[n] << 8) + o[n + 1];
  if (c === 31744)
    return 1 / 0;
  if (c === 64512)
    return -1 / 0;
  if (c === 32256)
    return NaN;
  const u = c >> 10 & 31, h = 1023 & c;
  let g;
  return g = u === 0 ? h * 2 ** -24 : u !== 31 ? (h + 1024) * 2 ** (u - 25) : h === 0 ? 1 / 0 : NaN, 32768 & c ? -g : g;
}
function encodeFloat32(o) {
  dataView.setFloat32(0, o, !1);
}
function readFloat32(o, n) {
  if (o.length - n < 4)
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  const c = (o.byteOffset || 0) + n;
  return new DataView(o.buffer, c, 4).getFloat32(0, !1);
}
function encodeFloat64(o) {
  dataView.setFloat64(0, o, !1);
}
function readFloat64(o, n) {
  if (o.length - n < 8)
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  const c = (o.byteOffset || 0) + n;
  return new DataView(o.buffer, c, 8).getFloat64(0, !1);
}
function invalidMinor(o, n, c) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${c}) for major ${o[n] >>> 5}`);
}
function errorer(o) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${o}`);
  };
}
encodeFloat.compareTokens = encodeUint.compareTokens;
const jump = [];
for (let o = 0; o <= 23; o++)
  jump[o] = invalidMinor;
jump[24] = decodeUint8, jump[25] = decodeUint16, jump[26] = decodeUint32, jump[27] = decodeUint64, jump[28] = invalidMinor, jump[29] = invalidMinor, jump[30] = invalidMinor, jump[31] = invalidMinor;
for (let o = 32; o <= 55; o++)
  jump[o] = invalidMinor;
jump[56] = decodeNegint8, jump[57] = decodeNegint16, jump[58] = decodeNegint32, jump[59] = decodeNegint64, jump[60] = invalidMinor, jump[61] = invalidMinor, jump[62] = invalidMinor, jump[63] = invalidMinor;
for (let o = 64; o <= 87; o++)
  jump[o] = decodeBytesCompact;
jump[88] = decodeBytes8, jump[89] = decodeBytes16, jump[90] = decodeBytes32, jump[91] = decodeBytes64, jump[92] = invalidMinor, jump[93] = invalidMinor, jump[94] = invalidMinor, jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let o = 96; o <= 119; o++)
  jump[o] = decodeStringCompact;
jump[120] = decodeString8, jump[121] = decodeString16, jump[122] = decodeString32, jump[123] = decodeString64, jump[124] = invalidMinor, jump[125] = invalidMinor, jump[126] = invalidMinor, jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let o = 128; o <= 151; o++)
  jump[o] = decodeArrayCompact;
jump[152] = decodeArray8, jump[153] = decodeArray16, jump[154] = decodeArray32, jump[155] = decodeArray64, jump[156] = invalidMinor, jump[157] = invalidMinor, jump[158] = invalidMinor, jump[159] = decodeArrayIndefinite;
for (let o = 160; o <= 183; o++)
  jump[o] = decodeMapCompact;
jump[184] = decodeMap8, jump[185] = decodeMap16, jump[186] = decodeMap32, jump[187] = decodeMap64, jump[188] = invalidMinor, jump[189] = invalidMinor, jump[190] = invalidMinor, jump[191] = decodeMapIndefinite;
for (let o = 192; o <= 215; o++)
  jump[o] = decodeTagCompact;
jump[216] = decodeTag8, jump[217] = decodeTag16, jump[218] = decodeTag32, jump[219] = decodeTag64, jump[220] = invalidMinor, jump[221] = invalidMinor, jump[222] = invalidMinor, jump[223] = invalidMinor;
for (let o = 224; o <= 243; o++)
  jump[o] = errorer("simple values are not supported");
jump[244] = invalidMinor, jump[245] = invalidMinor, jump[246] = invalidMinor, jump[247] = decodeUndefined, jump[248] = errorer("simple values are not supported"), jump[249] = decodeFloat16, jump[250] = decodeFloat32, jump[251] = decodeFloat64, jump[252] = invalidMinor, jump[253] = invalidMinor, jump[254] = invalidMinor, jump[255] = decodeBreak;
const quick = [];
for (let o = 0; o < 24; o++)
  quick[o] = new Token(Type.uint, o, 1);
for (let o = -1; o >= -24; o--)
  quick[31 - o] = new Token(Type.negint, o, 1);
function quickEncodeToken(o) {
  switch (o.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      return o.value.length ? void 0 : fromArray([64]);
    case Type.string:
      return o.value === "" ? fromArray([96]) : void 0;
    case Type.array:
      return o.value === 0 ? fromArray([128]) : void 0;
    case Type.map:
      return o.value === 0 ? fromArray([160]) : void 0;
    case Type.uint:
      return o.value < 24 ? fromArray([Number(o.value)]) : void 0;
    case Type.negint:
      if (o.value >= -24)
        return fromArray([31 - Number(o.value)]);
  }
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1), quick[96] = new Token(Type.string, "", 1), quick[128] = new Token(Type.array, 0, 1), quick[160] = new Token(Type.map, 0, 1), quick[244] = new Token(Type.false, !1, 1), quick[245] = new Token(Type.true, !0, 1), quick[246] = new Token(Type.null, null, 1);
const defaultEncodeOptions$2 = { float64: !1, mapSorter: mapSorter$1, quickEncodeToken };
function makeCborEncoders() {
  const o = [];
  return o[Type.uint.major] = encodeUint, o[Type.negint.major] = encodeNegint, o[Type.bytes.major] = encodeBytes, o[Type.string.major] = encodeString, o[Type.array.major] = encodeArray, o[Type.map.major] = encodeMap, o[Type.tag.major] = encodeTag$1, o[Type.float.major] = encodeFloat, o;
}
const cborEncoders$1 = makeCborEncoders(), buf = new Bl();
class Ref {
  constructor(n, c) {
    this.obj = n, this.parent = c;
  }
  includes(n) {
    let c = this;
    do
      if (c.obj === n)
        return !0;
    while (c = c.parent);
    return !1;
  }
  static createCheck(n, c) {
    if (n && n.includes(c))
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    return new Ref(c, n);
  }
}
const simpleTokens = { null: new Token(Type.null, null), undefined: new Token(Type.undefined, void 0), true: new Token(Type.true, !0), false: new Token(Type.false, !1), emptyArray: new Token(Type.array, 0), emptyMap: new Token(Type.map, 0) }, typeEncoders = { number: (o, n, c, u) => Number.isInteger(o) && Number.isSafeInteger(o) ? new Token(o >= 0 ? Type.uint : Type.negint, o) : new Token(Type.float, o), bigint: (o, n, c, u) => o >= BigInt(0) ? new Token(Type.uint, o) : new Token(Type.negint, o), Uint8Array: (o, n, c, u) => new Token(Type.bytes, o), string: (o, n, c, u) => new Token(Type.string, o), boolean: (o, n, c, u) => o ? simpleTokens.true : simpleTokens.false, null: (o, n, c, u) => simpleTokens.null, undefined: (o, n, c, u) => simpleTokens.undefined, ArrayBuffer: (o, n, c, u) => new Token(Type.bytes, new Uint8Array(o)), DataView: (o, n, c, u) => new Token(Type.bytes, new Uint8Array(o.buffer, o.byteOffset, o.byteLength)), Array(o, n, c, u) {
  if (!o.length)
    return c.addBreakTokens === !0 ? [simpleTokens.emptyArray, new Token(Type.break)] : simpleTokens.emptyArray;
  u = Ref.createCheck(u, o);
  const h = [];
  let g = 0;
  for (const y of o)
    h[g++] = objectToTokens(y, c, u);
  return c.addBreakTokens ? [new Token(Type.array, o.length), h, new Token(Type.break)] : [new Token(Type.array, o.length), h];
}, Object(o, n, c, u) {
  const h = n !== "Object", g = h ? o.keys() : Object.keys(o), y = h ? o.size : g.length;
  if (!y)
    return c.addBreakTokens === !0 ? [simpleTokens.emptyMap, new Token(Type.break)] : simpleTokens.emptyMap;
  u = Ref.createCheck(u, o);
  const $ = [];
  let I = 0;
  for (const P of g)
    $[I++] = [objectToTokens(P, c, u), objectToTokens(h ? o.get(P) : o[P], c, u)];
  return sortMapEntries($, c), c.addBreakTokens ? [new Token(Type.map, y), $, new Token(Type.break)] : [new Token(Type.map, y), $];
} };
typeEncoders.Map = typeEncoders.Object, typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const o of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))
  typeEncoders[`${o}Array`] = typeEncoders.DataView;
function objectToTokens(o, n = {}, c) {
  const u = is$1(o), h = n && n.typeEncoders && n.typeEncoders[u] || typeEncoders[u];
  if (typeof h == "function") {
    const y = h(o, u, n, c);
    if (y != null)
      return y;
  }
  const g = typeEncoders[u];
  if (!g)
    throw new Error(`${encodeErrPrefix} unsupported type: ${u}`);
  return g(o, u, n, c);
}
function sortMapEntries(o, n) {
  n.mapSorter && o.sort(n.mapSorter);
}
function mapSorter$1(o, n) {
  const c = Array.isArray(o[0]) ? o[0][0] : o[0], u = Array.isArray(n[0]) ? n[0][0] : n[0];
  if (c.type !== u.type)
    return c.type.compare(u.type);
  const h = c.type.major, g = cborEncoders$1[h].compareTokens(c, u);
  return g === 0 && console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"), g;
}
function tokensToEncoded(o, n, c, u) {
  if (Array.isArray(n))
    for (const h of n)
      tokensToEncoded(o, h, c, u);
  else
    c[n.type.major](o, n, u);
}
function encodeCustom(o, n, c) {
  const u = objectToTokens(o, c);
  if (!Array.isArray(u) && c.quickEncodeToken) {
    const h = c.quickEncodeToken(u);
    if (h)
      return h;
    const g = n[u.type.major];
    if (g.encodedSize) {
      const y = g.encodedSize(u, c), $ = new Bl(y);
      if (g($, u, c), $.chunks.length !== 1)
        throw new Error(`Unexpected error: pre-calculated length for ${u} was wrong`);
      return asU8A($.chunks[0]);
    }
  }
  return buf.reset(), tokensToEncoded(buf, u, n, c), buf.toBytes(!0);
}
function encode$s(o, n) {
  return n = Object.assign({}, defaultEncodeOptions$2, n), encodeCustom(o, cborEncoders$1, n);
}
const defaultDecodeOptions = { strict: !1, allowIndefinite: !0, allowUndefined: !0, allowBigInt: !0 };
class Tokeniser {
  constructor(n, c = {}) {
    this.pos = 0, this.data = n, this.options = c;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const n = this.data[this.pos];
    let c = quick[n];
    if (c === void 0) {
      const u = jump[n];
      if (!u)
        throw new Error(`${decodeErrPrefix} no decoder for major type ${n >>> 5} (byte 0x${n.toString(16).padStart(2, "0")})`);
      const h = 31 & n;
      c = u(this.data, this.pos, h, this.options);
    }
    return this.pos += c.encodedLength, c;
  }
}
const DONE = Symbol.for("DONE"), BREAK = Symbol.for("BREAK");
function tokenToArray(o, n, c) {
  const u = [];
  for (let h = 0; h < o.value; h++) {
    const g = tokensToObject(n, c);
    if (g === BREAK) {
      if (o.value === 1 / 0)
        break;
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (g === DONE)
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${h}, expected ${o.value})`);
    u[h] = g;
  }
  return u;
}
function tokenToMap(o, n, c) {
  const u = c.useMaps === !0, h = u ? void 0 : {}, g = u ? /* @__PURE__ */ new Map() : void 0;
  for (let y = 0; y < o.value; y++) {
    const $ = tokensToObject(n, c);
    if ($ === BREAK) {
      if (o.value === 1 / 0)
        break;
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if ($ === DONE)
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${y} [no key], expected ${o.value})`);
    if (u !== !0 && typeof $ != "string")
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof $})`);
    const I = tokensToObject(n, c);
    if (I === DONE)
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${y} [no value], expected ${o.value})`);
    u ? g.set($, I) : h[$] = I;
  }
  return u ? g : h;
}
function tokensToObject(o, n) {
  if (o.done())
    return DONE;
  const c = o.next();
  if (c.type === Type.break)
    return BREAK;
  if (c.type.terminal)
    return c.value;
  if (c.type === Type.array)
    return tokenToArray(c, o, n);
  if (c.type === Type.map)
    return tokenToMap(c, o, n);
  if (c.type === Type.tag) {
    if (n.tags && typeof n.tags[c.value] == "function") {
      const u = tokensToObject(o, n);
      return n.tags[c.value](u);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${c.value})`);
  }
  throw new Error("unsupported");
}
function decode$u(o, n) {
  if (!(o instanceof Uint8Array))
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  const c = (n = Object.assign({}, defaultDecodeOptions, n)).tokenizer || new Tokeniser(o, n), u = tokensToObject(c, n);
  if (u === DONE)
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  if (u === BREAK)
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  if (!c.done())
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  return u;
}
const cborEncoders = makeCborEncoders(), defaultEncodeOptions$1 = { float64: !1, quickEncodeToken };
function tokensToLength(o, n = cborEncoders, c = defaultEncodeOptions$1) {
  if (Array.isArray(o)) {
    let u = 0;
    for (const h of o)
      u += tokensToLength(h, n, c);
    return u;
  }
  {
    const u = n[o.type.major];
    if (u.encodedSize === void 0 || typeof u.encodedSize != "function")
      throw new Error(`Encoder for ${o.type.name} does not have an encodedSize()`);
    return u.encodedSize(o, c);
  }
}
var encode_1$3 = encode$r, MSB$4 = 128, REST$4 = 127, MSBALL$3 = ~REST$4, INT$3 = Math.pow(2, 31);
function encode$r(o, n, c) {
  n = n || [];
  for (var u = c = c || 0; o >= INT$3; )
    n[c++] = 255 & o | MSB$4, o /= 128;
  for (; o & MSBALL$3; )
    n[c++] = 255 & o | MSB$4, o >>>= 7;
  return n[c] = 0 | o, encode$r.bytes = c - u + 1, n;
}
var decode$t = read$5, MSB$1$3 = 128, REST$1$3 = 127;
function read$5(o, n) {
  var c, u = 0, h = 0, g = n = n || 0, y = o.length;
  do {
    if (g >= y)
      throw read$5.bytes = 0, new RangeError("Could not decode varint");
    c = o[g++], u += h < 28 ? (c & REST$1$3) << h : (c & REST$1$3) * Math.pow(2, h), h += 7;
  } while (c >= MSB$1$3);
  return read$5.bytes = g - n, u;
}
var N1$3 = Math.pow(2, 7), N2$3 = Math.pow(2, 14), N3$3 = Math.pow(2, 21), N4$3 = Math.pow(2, 28), N5$3 = Math.pow(2, 35), N6$3 = Math.pow(2, 42), N7$3 = Math.pow(2, 49), N8$3 = Math.pow(2, 56), N9$3 = Math.pow(2, 63), length$4 = function(o) {
  return o < N1$3 ? 1 : o < N2$3 ? 2 : o < N3$3 ? 3 : o < N4$3 ? 4 : o < N5$3 ? 5 : o < N6$3 ? 6 : o < N7$3 ? 7 : o < N8$3 ? 8 : o < N9$3 ? 9 : 10;
}, varint$3 = { encode: encode_1$3, decode: decode$t, encodingLength: length$4 }, _brrp_varint$3 = varint$3;
const decode$s = (o, n = 0) => [_brrp_varint$3.decode(o, n), _brrp_varint$3.decode.bytes], encodeTo$3 = (o, n, c = 0) => (_brrp_varint$3.encode(o, n, c), n), encodingLength$3 = (o) => _brrp_varint$3.encodingLength(o), empty = new Uint8Array(0), toHex$1 = (o) => o.reduce((n, c) => n + c.toString(16).padStart(2, "0"), ""), fromHex = (o) => {
  const n = o.match(/../g);
  return n ? new Uint8Array(n.map((c) => parseInt(c, 16))) : empty;
}, equals$6 = (o, n) => {
  if (o === n)
    return !0;
  if (o.byteLength !== n.byteLength)
    return !1;
  for (let c = 0; c < o.byteLength; c++)
    if (o[c] !== n[c])
      return !1;
  return !0;
}, coerce$4 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o))
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  throw new Error("Unknown type, must be binary type");
}, isBinary$1 = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o), fromString$6 = (o) => new TextEncoder().encode(o), toString$8 = (o) => new TextDecoder().decode(o), byteslib = Object.freeze(Object.defineProperty({ __proto__: null, equals: equals$6, coerce: coerce$4, isBinary: isBinary$1, fromHex, toHex: toHex$1, fromString: fromString$6, toString: toString$8, empty }, Symbol.toStringTag, { value: "Module" })), create$6 = (o, n) => {
  const c = n.byteLength, u = encodingLength$3(o), h = u + encodingLength$3(c), g = new Uint8Array(h + c);
  return encodeTo$3(o, g, 0), encodeTo$3(c, g, u), g.set(n, h), new Digest$3(o, c, n, g);
}, decode$r = (o) => {
  const n = coerce$4(o), [c, u] = decode$s(n), [h, g] = decode$s(n.subarray(u)), y = n.subarray(u + g);
  if (y.byteLength !== h)
    throw new Error("Incorrect length");
  return new Digest$3(c, h, y, n);
}, equals$5 = (o, n) => o === n || o.code === n.code && o.size === n.size && equals$6(o.bytes, n.bytes);
class Digest$3 {
  constructor(n, c, u, h) {
    this.code = n, this.size = c, this.digest = u, this.bytes = h;
  }
}
function base$6(o, n) {
  if (o.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var c = new Uint8Array(256), u = 0; u < c.length; u++)
    c[u] = 255;
  for (var h = 0; h < o.length; h++) {
    var g = o.charAt(h), y = g.charCodeAt(0);
    if (c[y] !== 255)
      throw new TypeError(g + " is ambiguous");
    c[y] = h;
  }
  var $ = o.length, I = o.charAt(0), P = Math.log($) / Math.log(256), L = Math.log(256) / Math.log($);
  function q(N) {
    if (typeof N != "string")
      throw new TypeError("Expected String");
    if (N.length === 0)
      return new Uint8Array();
    var X = 0;
    if (N[X] !== " ") {
      for (var rt = 0, nt = 0; N[X] === I; )
        rt++, X++;
      for (var st = (N.length - X) * P + 1 >>> 0, ot = new Uint8Array(st); N[X]; ) {
        var St = c[N.charCodeAt(X)];
        if (St === 255)
          return;
        for (var Ct = 0, et = st - 1; (St !== 0 || Ct < nt) && et !== -1; et--, Ct++)
          St += $ * ot[et] >>> 0, ot[et] = St % 256 >>> 0, St = St / 256 >>> 0;
        if (St !== 0)
          throw new Error("Non-zero carry");
        nt = Ct, X++;
      }
      if (N[X] !== " ") {
        for (var at = st - nt; at !== st && ot[at] === 0; )
          at++;
        for (var _t = new Uint8Array(rt + (st - at)), Nt = rt; at !== st; )
          _t[Nt++] = ot[at++];
        return _t;
      }
    }
  }
  return { encode: function(N) {
    if (N instanceof Uint8Array || (ArrayBuffer.isView(N) ? N = new Uint8Array(N.buffer, N.byteOffset, N.byteLength) : Array.isArray(N) && (N = Uint8Array.from(N))), !(N instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (N.length === 0)
      return "";
    for (var X = 0, rt = 0, nt = 0, st = N.length; nt !== st && N[nt] === 0; )
      nt++, X++;
    for (var ot = (st - nt) * L + 1 >>> 0, St = new Uint8Array(ot); nt !== st; ) {
      for (var Ct = N[nt], et = 0, at = ot - 1; (Ct !== 0 || et < rt) && at !== -1; at--, et++)
        Ct += 256 * St[at] >>> 0, St[at] = Ct % $ >>> 0, Ct = Ct / $ >>> 0;
      if (Ct !== 0)
        throw new Error("Non-zero carry");
      rt = et, nt++;
    }
    for (var _t = ot - rt; _t !== ot && St[_t] === 0; )
      _t++;
    for (var Nt = I.repeat(X); _t < ot; ++_t)
      Nt += o.charAt(St[_t]);
    return Nt;
  }, decodeUnsafe: q, decode: function(N) {
    var X = q(N);
    if (X)
      return X;
    throw new Error(`Non-${n} character`);
  } };
}
var src$4 = base$6, _brrp__multiformats_scope_baseX$4 = src$4;
class Encoder$4 {
  constructor(n, c, u) {
    this.name = n, this.prefix = c, this.baseEncode = u;
  }
  encode(n) {
    if (n instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(n)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Decoder$4 {
  constructor(n, c, u) {
    if (this.name = n, this.prefix = c, c.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = c.codePointAt(0), this.baseDecode = u;
  }
  decode(n) {
    if (typeof n == "string") {
      if (n.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(n)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(n.slice(this.prefix.length));
    }
    throw Error("Can only multibase decode strings");
  }
  or(n) {
    return or$4(this, n);
  }
}
class ComposedDecoder$4 {
  constructor(n) {
    this.decoders = n;
  }
  or(n) {
    return or$4(this, n);
  }
  decode(n) {
    const c = n[0], u = this.decoders[c];
    if (u)
      return u.decode(n);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(n)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or$4 = (o, n) => new ComposedDecoder$4({ ...o.decoders || { [o.prefix]: o }, ...n.decoders || { [n.prefix]: n } });
class Codec$4 {
  constructor(n, c, u, h) {
    this.name = n, this.prefix = c, this.baseEncode = u, this.baseDecode = h, this.encoder = new Encoder$4(n, c, u), this.decoder = new Decoder$4(n, c, h);
  }
  encode(n) {
    return this.encoder.encode(n);
  }
  decode(n) {
    return this.decoder.decode(n);
  }
}
const from$8 = ({ name: o, prefix: n, encode: c, decode: u }) => new Codec$4(o, n, c, u), baseX$4 = ({ prefix: o, name: n, alphabet: c }) => {
  const { encode: u, decode: h } = _brrp__multiformats_scope_baseX$4(c, n);
  return from$8({ prefix: o, name: n, encode: u, decode: (g) => coerce$4(h(g)) });
}, decode$q = (o, n, c, u) => {
  const h = {};
  for (let L = 0; L < n.length; ++L)
    h[n[L]] = L;
  let g = o.length;
  for (; o[g - 1] === "="; )
    --g;
  const y = new Uint8Array(g * c / 8 | 0);
  let $ = 0, I = 0, P = 0;
  for (let L = 0; L < g; ++L) {
    const q = h[o[L]];
    if (q === void 0)
      throw new SyntaxError(`Non-${u} character`);
    I = I << c | q, $ += c, $ >= 8 && ($ -= 8, y[P++] = 255 & I >> $);
  }
  if ($ >= c || 255 & I << 8 - $)
    throw new SyntaxError("Unexpected end of data");
  return y;
}, encode$q = (o, n, c) => {
  const u = n[n.length - 1] === "=", h = (1 << c) - 1;
  let g = "", y = 0, $ = 0;
  for (let I = 0; I < o.length; ++I)
    for ($ = $ << 8 | o[I], y += 8; y > c; )
      y -= c, g += n[h & $ >> y];
  if (y && (g += n[h & $ << c - y]), u)
    for (; g.length * c & 7; )
      g += "=";
  return g;
}, rfc4648$4 = ({ name: o, prefix: n, bitsPerChar: c, alphabet: u }) => from$8({ prefix: n, name: o, encode: (h) => encode$q(h, u, c), decode: (h) => decode$q(h, u, c, o) }), base58btc$4 = baseX$4({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), base58flickr$2 = baseX$4({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" }), base58$2 = Object.freeze(Object.defineProperty({ __proto__: null, base58btc: base58btc$4, base58flickr: base58flickr$2 }, Symbol.toStringTag, { value: "Module" })), base32$6 = rfc4648$4({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), base32upper$2 = rfc4648$4({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), base32pad$2 = rfc4648$4({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), base32padupper$2 = rfc4648$4({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), base32hex$2 = rfc4648$4({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), base32hexupper$2 = rfc4648$4({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), base32hexpad$2 = rfc4648$4({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), base32hexpadupper$2 = rfc4648$4({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), base32z$2 = rfc4648$4({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 }), base32$7 = Object.freeze(Object.defineProperty({ __proto__: null, base32: base32$6, base32upper: base32upper$2, base32pad: base32pad$2, base32padupper: base32padupper$2, base32hex: base32hex$2, base32hexupper: base32hexupper$2, base32hexpad: base32hexpad$2, base32hexpadupper: base32hexpadupper$2, base32z: base32z$2 }, Symbol.toStringTag, { value: "Module" }));
class CID$2 {
  constructor(n, c, u, h) {
    this.code = c, this.version = n, this.multihash = u, this.bytes = h, this.byteOffset = h.byteOffset, this.byteLength = h.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, { byteOffset: hidden, byteLength: hidden, code: readonly$1, version: readonly$1, multihash: readonly$1, bytes: readonly$1, _baseCache: hidden, asCID: hidden });
  }
  toV0() {
    if (this.version === 0)
      return this;
    {
      const { code: n, multihash: c } = this;
      if (n !== DAG_PB_CODE$2)
        throw new Error("Cannot convert a non dag-pb CID to CIDv0");
      if (c.code !== SHA_256_CODE$2)
        throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
      return CID$2.createV0(c);
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: n, digest: c } = this.multihash, u = create$6(n, c);
        return CID$2.createV1(this.code, u);
      }
      case 1:
        return this;
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  equals(n) {
    return n && this.code === n.code && this.version === n.version && equals$5(this.multihash, n.multihash);
  }
  toString(n) {
    const { bytes: c, version: u, _baseCache: h } = this;
    return u === 0 ? toStringV0$2(c, h, n || base58btc$4.encoder) : toStringV1$2(c, h, n || base32$6.encoder);
  }
  toJSON() {
    return { code: this.code, version: this.version, hash: this.multihash.bytes };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(n) {
    return deprecate(/^0\.0/, IS_CID_DEPRECATION), !(!n || !n[cidSymbol$2] && n.asCID !== n);
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(n) {
    if (n instanceof CID$2)
      return n;
    if (n != null && n.asCID === n) {
      const { version: c, code: u, multihash: h, bytes: g } = n;
      return new CID$2(c, u, h, g || encodeCID$2(c, u, h.bytes));
    }
    if (n != null && n[cidSymbol$2] === !0) {
      const { version: c, multihash: u, code: h } = n, g = decode$r(u);
      return CID$2.create(c, h, g);
    }
    return null;
  }
  static create(n, c, u) {
    if (typeof c != "number")
      throw new Error("String codecs are no longer supported");
    switch (n) {
      case 0:
        if (c !== DAG_PB_CODE$2)
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$2}) block encoding`);
        return new CID$2(n, c, u, u.bytes);
      case 1: {
        const h = encodeCID$2(n, c, u.bytes);
        return new CID$2(n, c, u, h);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(n) {
    return CID$2.create(0, DAG_PB_CODE$2, n);
  }
  static createV1(n, c) {
    return CID$2.create(1, n, c);
  }
  static decode(n) {
    const [c, u] = CID$2.decodeFirst(n);
    if (u.length)
      throw new Error("Incorrect length");
    return c;
  }
  static decodeFirst(n) {
    const c = CID$2.inspectBytes(n), u = c.size - c.multihashSize, h = coerce$4(n.subarray(u, u + c.multihashSize));
    if (h.byteLength !== c.multihashSize)
      throw new Error("Incorrect length");
    const g = h.subarray(c.multihashSize - c.digestSize), y = new Digest$3(c.multihashCode, c.digestSize, g, h);
    return [c.version === 0 ? CID$2.createV0(y) : CID$2.createV1(c.codec, y), n.subarray(c.size)];
  }
  static inspectBytes(n) {
    let c = 0;
    const u = () => {
      const [L, q] = decode$s(n.subarray(c));
      return c += q, L;
    };
    let h = u(), g = DAG_PB_CODE$2;
    if (h === 18 ? (h = 0, c = 0) : h === 1 && (g = u()), h !== 0 && h !== 1)
      throw new RangeError(`Invalid CID version ${h}`);
    const y = c, $ = u(), I = u(), P = c + I;
    return { version: h, codec: g, multihashCode: $, digestSize: I, multihashSize: P - y, size: P };
  }
  static parse(n, c) {
    const [u, h] = parseCIDtoBytes$2(n, c), g = CID$2.decode(h);
    return g._baseCache.set(u, n), g;
  }
}
const parseCIDtoBytes$2 = (o, n) => {
  switch (o[0]) {
    case "Q": {
      const c = n || base58btc$4;
      return [base58btc$4.prefix, c.decode(`${base58btc$4.prefix}${o}`)];
    }
    case base58btc$4.prefix: {
      const c = n || base58btc$4;
      return [base58btc$4.prefix, c.decode(o)];
    }
    case base32$6.prefix: {
      const c = n || base32$6;
      return [base32$6.prefix, c.decode(o)];
    }
    default:
      if (n == null)
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      return [o[0], n.decode(o)];
  }
}, toStringV0$2 = (o, n, c) => {
  const { prefix: u } = c;
  if (u !== base58btc$4.prefix)
    throw Error(`Cannot string encode V0 in ${c.name} encoding`);
  const h = n.get(u);
  if (h == null) {
    const g = c.encode(o).slice(1);
    return n.set(u, g), g;
  }
  return h;
}, toStringV1$2 = (o, n, c) => {
  const { prefix: u } = c, h = n.get(u);
  if (h == null) {
    const g = c.encode(o);
    return n.set(u, g), g;
  }
  return h;
}, DAG_PB_CODE$2 = 112, SHA_256_CODE$2 = 18, encodeCID$2 = (o, n, c) => {
  const u = encodingLength$3(o), h = u + encodingLength$3(n), g = new Uint8Array(h + c.byteLength);
  return encodeTo$3(o, g, 0), encodeTo$3(n, g, u), g.set(c, h), g;
}, cidSymbol$2 = Symbol.for("@ipld/js-cid/CID"), readonly$1 = { writable: !1, configurable: !1, enumerable: !0 }, hidden = { writable: !1, enumerable: !1, configurable: !1 }, version$2 = "0.0.0-dev", deprecate = (o, n) => {
  if (!o.test(version$2))
    throw new Error(n);
  console.warn(n);
}, IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`, CID_CBOR_TAG = 42;
function cidEncoder$1(o) {
  if (o.asCID !== o)
    return null;
  const n = CID$2.asCID(o);
  if (!n)
    return null;
  const c = new Uint8Array(n.bytes.byteLength + 1);
  return c.set(n.bytes, 1), [new Token(Type.tag, CID_CBOR_TAG), new Token(Type.bytes, c)];
}
function undefinedEncoder$1() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder$1(o) {
  if (Number.isNaN(o))
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  if (o === 1 / 0 || o === -1 / 0)
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  return null;
}
const encodeOptions$1 = { float64: !0, typeEncoders: { Object: cidEncoder$1, undefined: undefinedEncoder$1, number: numberEncoder$1 } };
function cidDecoder(o) {
  if (o[0] !== 0)
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  return CID$2.decode(o.subarray(1));
}
const decodeOptions$1 = { allowIndefinite: !1, coerceUndefinedToNull: !0, allowNaN: !1, allowInfinity: !1, allowBigInt: !0, strict: !0, useMaps: !1, tags: [] };
decodeOptions$1.tags[CID_CBOR_TAG] = cidDecoder;
const name$8 = "dag-cbor", code$a = 113, encode$p = (o) => encode$s(o, encodeOptions$1), decode$p = (o) => decode$u(o, decodeOptions$1), dagCBOR = Object.freeze(Object.defineProperty({ __proto__: null, name: name$8, code: code$a, encode: encode$p, decode: decode$p }, Symbol.toStringTag, { value: "Module" }));
class CarBufferWriter {
  constructor(n, c) {
    this.bytes = n, this.byteOffset = c, this.roots = [], this.headerSize = c;
  }
  addRoot(n, c) {
    return addRoot(this, n, c), this;
  }
  write(n) {
    return addBlock(this, n), this;
  }
  close(n) {
    return close(this, n);
  }
}
const addRoot = (o, n, c = {}) => {
  const { resize: u = !1 } = c, { bytes: h, headerSize: g, byteOffset: y, roots: $ } = o;
  o.roots.push(n);
  const I = headerLength(o);
  if (I > g) {
    if (!(I - g + y < h.byteLength))
      throw $.pop(), new RangeError(`Buffer has no capacity for a new root ${n}`);
    if (!u)
      throw $.pop(), new RangeError(`Header of size ${g} has no capacity for new root ${n}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
    resizeHeader(o, I);
  }
}, blockLength = ({ cid: o, bytes: n }) => {
  const c = o.bytes.byteLength + n.byteLength;
  return varint$4.encodingLength(c) + c;
}, addBlock = (o, { cid: n, bytes: c }) => {
  const u = n.bytes.byteLength + c.byteLength, h = varint$4.encode(u);
  if (o.byteOffset + h.length + u > o.bytes.byteLength)
    throw new RangeError("Buffer has no capacity for this block");
  writeBytes$1(o, h), writeBytes$1(o, n.bytes), writeBytes$1(o, c);
}, close = (o, n = {}) => {
  const { resize: c = !1 } = n, { roots: u, bytes: h, byteOffset: g, headerSize: y } = o, $ = encode$p({ version: 1, roots: u }), I = varint$4.encode($.length), P = I.length + $.byteLength;
  if (y - P == 0)
    return writeHeader(o, I, $), h.subarray(0, g);
  if (c)
    return resizeHeader(o, P), writeHeader(o, I, $), h.subarray(0, o.byteOffset);
  throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
}, resizeHeader = (o, n) => {
  const { bytes: c, headerSize: u } = o;
  c.set(c.subarray(u, o.byteOffset), n), o.byteOffset += n - u, o.headerSize = n;
}, writeBytes$1 = (o, n) => {
  o.bytes.set(n, o.byteOffset), o.byteOffset += n.length;
}, writeHeader = ({ bytes: o }, n, c) => {
  o.set(n), o.set(c, n.length);
}, headerPreludeTokens = [new Token(Type.map, 2), new Token(Type.string, "version"), new Token(Type.uint, 1), new Token(Type.string, "roots")], CID_TAG = new Token(Type.tag, 42), calculateHeaderLength = (o) => {
  const n = [...headerPreludeTokens];
  n.push(new Token(Type.array, o.length));
  for (const u of o)
    n.push(CID_TAG), n.push(new Token(Type.bytes, { length: u + 1 }));
  const c = tokensToLength(n);
  return varint$4.encodingLength(c) + c;
}, headerLength = ({ roots: o }) => calculateHeaderLength(o.map((n) => n.bytes.byteLength)), createWriter = (o, n = {}) => {
  const { roots: c = [], byteOffset: u = 0, byteLength: h = o.byteLength, headerSize: g = headerLength({ roots: c }) } = n, y = new Uint8Array(o, u, h), $ = new CarBufferWriter(y, g);
  for (const I of c)
    $.addRoot(I);
  return $;
}, Kinds = { Null: (o) => o === null, Int: (o) => Number.isInteger(o), Float: (o) => typeof o == "number" && Number.isFinite(o), String: (o) => typeof o == "string", Bool: (o) => typeof o == "boolean", Bytes: (o) => o instanceof Uint8Array, Link: (o) => !Kinds.Null(o) && typeof o == "object" && o.asCID === o, List: (o) => Array.isArray(o), Map: (o) => !Kinds.Null(o) && typeof o == "object" && o.asCID !== o && !Kinds.List(o) && !Kinds.Bytes(o) }, Types = { Int: Kinds.Int, "CarHeader > version": (o) => Types.Int(o), "CarHeader > roots (anon) > valueType (anon)": Kinds.Link, "CarHeader > roots (anon)": (o) => Kinds.List(o) && Array.prototype.every.call(o, Types["CarHeader > roots (anon) > valueType (anon)"]), "CarHeader > roots": (o) => Types["CarHeader > roots (anon)"](o), CarHeader: (o) => {
  const n = o && Object.keys(o);
  return Kinds.Map(o) && ["version"].every((c) => n.includes(c)) && Object.entries(o).every(([c, u]) => Types["CarHeader > " + c] && Types["CarHeader > " + c](u));
} }, CarHeader = Types.CarHeader, CIDV0_BYTES = { SHA2_256: 18, LENGTH: 32, DAG_PB: 112 }, V2_HEADER_LENGTH = 40;
async function readVarint(o) {
  const n = await o.upTo(8);
  if (!n.length)
    throw new Error("Unexpected end of data");
  const c = varint$4.decode(n);
  return o.seek(varint$4.decode.bytes), c;
}
async function readV2Header(o) {
  const n = await o.exactly(V2_HEADER_LENGTH), c = new DataView(n.buffer, n.byteOffset, n.byteLength);
  let u = 0;
  const h = { version: 2, characteristics: [c.getBigUint64(u, !0), c.getBigUint64(u += 8, !0)], dataOffset: Number(c.getBigUint64(u += 8, !0)), dataSize: Number(c.getBigUint64(u += 8, !0)), indexOffset: Number(c.getBigUint64(u += 8, !0)) };
  return o.seek(V2_HEADER_LENGTH), h;
}
async function readHeader$1(o, n) {
  const c = await readVarint(o);
  if (c === 0)
    throw new Error("Invalid CAR header (zero length)");
  const u = await o.exactly(c);
  o.seek(c);
  const h = decode$p(u);
  if (!CarHeader(h))
    throw new Error("Invalid CAR header format");
  if (h.version !== 1 && h.version !== 2 || n !== void 0 && h.version !== n)
    throw new Error(`Invalid CAR version: ${h.version}${n !== void 0 ? ` (expected ${n})` : ""}`);
  const g = Array.isArray(h.roots);
  if (h.version === 1 && !g || h.version === 2 && g)
    throw new Error("Invalid CAR header format");
  if (h.version === 1)
    return h;
  const y = await readV2Header(o);
  o.seek(y.dataOffset - o.pos);
  const $ = await readHeader$1(o, 1);
  return Object.assign($, y);
}
async function readMultihash(o) {
  const n = await o.upTo(8);
  varint$4.decode(n);
  const c = varint$4.decode.bytes, u = varint$4.decode(n.subarray(varint$4.decode.bytes)), h = c + varint$4.decode.bytes + u, g = await o.exactly(h);
  return o.seek(h), g;
}
async function readCid(o) {
  const n = await o.exactly(2);
  if (n[0] === CIDV0_BYTES.SHA2_256 && n[1] === CIDV0_BYTES.LENGTH) {
    const y = await o.exactly(34);
    o.seek(34);
    const $ = decode$r(y);
    return CID$2.create(0, CIDV0_BYTES.DAG_PB, $);
  }
  const c = await readVarint(o);
  if (c !== 1)
    throw new Error(`Unexpected CID version (${c})`);
  const u = await readVarint(o), h = await readMultihash(o), g = decode$r(h);
  return CID$2.create(c, u, g);
}
async function readBlockHead(o) {
  const n = o.pos;
  let c = await readVarint(o);
  if (c === 0)
    throw new Error("Invalid CAR section (zero length)");
  return c += o.pos - n, { cid: await readCid(o), length: c, blockLength: c - Number(o.pos - n) };
}
async function readBlock(o) {
  const { cid: n, blockLength: c } = await readBlockHead(o), u = await o.exactly(c);
  return o.seek(c), { bytes: u, cid: n };
}
async function readBlockIndex(o) {
  const n = o.pos, { cid: c, length: u, blockLength: h } = await readBlockHead(o), g = { cid: c, length: u, blockLength: h, offset: n, blockOffset: o.pos };
  return o.seek(g.blockLength), g;
}
function createDecoder(o) {
  const n = (async () => {
    const c = await readHeader$1(o);
    if (c.version === 2) {
      const u = o.pos - c.dataOffset;
      o = limitReader(o, c.dataSize - u);
    }
    return c;
  })();
  return { header: () => n, async *blocks() {
    for (await n; (await o.upTo(8)).length > 0; )
      yield await readBlock(o);
  }, async *blocksIndex() {
    for (await n; (await o.upTo(8)).length > 0; )
      yield await readBlockIndex(o);
  } };
}
function bytesReader(o) {
  let n = 0;
  return { upTo: async (c) => o.subarray(n, n + Math.min(c, o.length - n)), async exactly(c) {
    if (c > o.length - n)
      throw new Error("Unexpected end of data");
    return o.subarray(n, n + c);
  }, seek(c) {
    n += c;
  }, get pos() {
    return n;
  } };
}
function chunkReader(o) {
  let n = 0, c = 0, u = 0, h = new Uint8Array(0);
  const g = async (y) => {
    c = h.length - u;
    const $ = [h.subarray(u)];
    for (; c < y; ) {
      const P = await o();
      if (P == null)
        break;
      c < 0 ? P.length > c && $.push(P.subarray(-c)) : $.push(P), c += P.length;
    }
    h = new Uint8Array($.reduce((P, L) => P + L.length, 0));
    let I = 0;
    for (const P of $)
      h.set(P, I), I += P.length;
    u = 0;
  };
  return { upTo: async (y) => (h.length - u < y && await g(y), h.subarray(u, u + Math.min(h.length - u, y))), async exactly(y) {
    if (h.length - u < y && await g(y), h.length - u < y)
      throw new Error("Unexpected end of data");
    return h.subarray(u, u + y);
  }, seek(y) {
    n += y, u += y;
  }, get pos() {
    return n;
  } };
}
function asyncIterableReader(o) {
  const n = o[Symbol.asyncIterator]();
  return chunkReader(async function() {
    const c = await n.next();
    return c.done ? null : c.value;
  });
}
function limitReader(o, n) {
  let c = 0;
  return { async upTo(u) {
    let h = await o.upTo(u);
    return h.length + c > n && (h = h.subarray(0, n - c)), h;
  }, async exactly(u) {
    const h = await o.exactly(u);
    if (h.length + c > n)
      throw new Error("Unexpected end of data");
    return h;
  }, seek(u) {
    c += u, o.seek(u);
  }, get pos() {
    return o.pos;
  } };
}
class CarReader {
  constructor(n, c) {
    this._header = n, this._blocks = c, this._keys = c.map((u) => u.cid.toString());
  }
  get version() {
    return this._header.version;
  }
  async getRoots() {
    return this._header.roots;
  }
  async has(n) {
    return this._keys.indexOf(n.toString()) > -1;
  }
  async get(n) {
    const c = this._keys.indexOf(n.toString());
    return c > -1 ? this._blocks[c] : void 0;
  }
  async *blocks() {
    for (const n of this._blocks)
      yield n;
  }
  async *cids() {
    for (const n of this._blocks)
      yield n.cid;
  }
  static async fromBytes(n) {
    if (!(n instanceof Uint8Array))
      throw new TypeError("fromBytes() requires a Uint8Array");
    return decodeReaderComplete(bytesReader(n));
  }
  static async fromIterable(n) {
    if (!n || typeof n[Symbol.asyncIterator] != "function")
      throw new TypeError("fromIterable() requires an async iterable");
    return decodeReaderComplete(asyncIterableReader(n));
  }
}
async function decodeReaderComplete(o) {
  const n = createDecoder(o), c = await n.header(), u = [];
  for await (const h of n.blocks())
    u.push(h);
  return new CarReader(c, u);
}
const from$7 = ({ name: o, code: n, encode: c }) => new Hasher$2(o, n, c);
class Hasher$2 {
  constructor(n, c, u) {
    this.name = n, this.code = c, this.encode = u;
  }
  digest(n) {
    if (n instanceof Uint8Array) {
      const c = this.encode(n);
      return c instanceof Uint8Array ? create$6(this.code, c) : c.then((u) => create$6(this.code, u));
    }
    throw Error("Unknown type, must be binary type");
  }
}
const name$7 = "raw", code$9 = 85, encode$o = (o) => coerce$4(o), decode$o = (o) => coerce$4(o), raw = Object.freeze(Object.defineProperty({ __proto__: null, name: name$7, code: code$9, encode: encode$o, decode: decode$o }, Symbol.toStringTag, { value: "Module" })), sha$3 = (o) => async (n) => new Uint8Array(await crypto.subtle.digest(o, n)), sha256$5 = from$7({ name: "sha2-256", code: 18, encode: sha$3("SHA-256") }), sha512$4 = from$7({ name: "sha2-512", code: 19, encode: sha$3("SHA-512") }), sha2$2 = Object.freeze(Object.defineProperty({ __proto__: null, sha256: sha256$5, sha512: sha512$4 }, Symbol.toStringTag, { value: "Module" })), readonly = ({ enumerable: o = !0, configurable: n = !1 } = {}) => ({ enumerable: o, configurable: n, writable: !1 }), links = function* (o, n) {
  if (o != null && !(o instanceof Uint8Array))
    for (const [c, u] of Object.entries(o)) {
      const h = [...n, c];
      if (u != null && typeof u == "object")
        if (Array.isArray(u))
          for (const [g, y] of u.entries()) {
            const $ = [...h, g], I = CID$2.asCID(y);
            I ? yield [$.join("/"), I] : typeof y == "object" && (yield* links(y, $));
          }
        else {
          const g = CID$2.asCID(u);
          g ? yield [h.join("/"), g] : yield* links(u, h);
        }
    }
}, tree = function* (o, n) {
  if (o != null)
    for (const [c, u] of Object.entries(o)) {
      const h = [...n, c];
      if (yield h.join("/"), !(u == null || u instanceof Uint8Array || typeof u != "object" || CID$2.asCID(u)))
        if (Array.isArray(u))
          for (const [g, y] of u.entries()) {
            const $ = [...h, g];
            yield $.join("/"), typeof y != "object" || CID$2.asCID(y) || (yield* tree(y, $));
          }
        else
          yield* tree(u, h);
    }
}, get$2 = (o, n) => {
  let c = o;
  for (const [u, h] of n.entries()) {
    if (c = c[h], c == null)
      throw new Error(`Object has no property at ${n.slice(0, u + 1).map((y) => `[${JSON.stringify(y)}]`).join("")}`);
    const g = CID$2.asCID(c);
    if (g)
      return { value: g, remaining: n.slice(u + 1).join("/") };
  }
  return { value: c };
};
class Block$1 {
  constructor({ cid: n, bytes: c, value: u }) {
    if (!n || !c || u === void 0)
      throw new Error("Missing required argument");
    this.cid = n, this.bytes = c, this.value = u, this.asBlock = this, Object.defineProperties(this, { cid: readonly(), bytes: readonly(), value: readonly(), asBlock: readonly() });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(n = "/") {
    return get$2(this.value, n.split("/").filter(Boolean));
  }
}
const encode$n = async ({ value: o, codec: n, hasher: c }) => {
  if (o === void 0)
    throw new Error('Missing required argument "value"');
  if (!n || !c)
    throw new Error("Missing required argument: codec or hasher");
  const u = n.encode(o), h = await c.digest(u), g = CID$2.create(1, n.code, h);
  return new Block$1({ value: o, bytes: u, cid: g });
}, createUnsafe = ({ bytes: o, cid: n, value: c, codec: u }) => {
  const h = c !== void 0 ? c : u && u.decode(o);
  if (h === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block$1({ cid: n, bytes: o, value: h });
}, create$5 = async ({ bytes: o, cid: n, hasher: c, codec: u }) => {
  if (!o)
    throw new Error('Missing required argument "bytes"');
  if (!c)
    throw new Error('Missing required argument "hasher"');
  const h = u.decode(o), g = await c.digest(o);
  if (!equals$6(n.multihash.bytes, g.bytes))
    throw new Error("CID hash does not match bytes");
  return createUnsafe({ bytes: o, cid: n, value: h, codec: u });
};
function mitt(o) {
  return { all: o = o || /* @__PURE__ */ new Map(), on: function(n, c) {
    var u = o.get(n);
    u ? u.push(c) : o.set(n, [c]);
  }, off: function(n, c) {
    var u = o.get(n);
    u && (c ? u.splice(u.indexOf(c) >>> 0, 1) : o.set(n, []));
  }, emit: function(n, c) {
    var u = o.get(n);
    u && u.slice().map(function(h) {
      h(c);
    }), (u = o.get("*")) && u.slice().map(function(h) {
      h(n, c);
    });
  } };
}
const { isBinary } = byteslib, encode$m = (o) => isBinary(o) ? encode$n({ value: o, hasher: sha256$5, codec: raw }) : encode$n({ value: o, hasher: sha256$5, codec: dagCBOR }), decode$n = ({ bytes: o, cid: n }) => {
  let c, u;
  const { code: h } = n, g = n.multihash.code || decode$r(n.multihash).code;
  if (g !== 18)
    throw new Error("Unsupported hash function: " + g);
  if (c = sha256$5, h === 113)
    u = dagCBOR;
  else {
    if (h !== 85)
      throw new Error("Unsupported codec: " + h);
    u = raw;
  }
  return create$5({ bytes: o, cid: n, codec: u, hasher: c });
};
class Transaction$1 {
  constructor() {
    Object.assign(this, mitt()), this.blocks = [];
  }
  static create() {
    return new this();
  }
  static async load(n) {
    const c = await CarReader.fromBytes(n), [u] = await c.getRoots();
    return { root: u, get: (h) => c.get(h).then((g) => decode$n(g)).then(({ value: g }) => g) };
  }
  async add(n) {
    const c = await encode$m(n);
    return this.last = c, this.blocks.push(c), this.emit("size", this.size), c.cid;
  }
  async get(n) {
    const { cid: c, bytes: u, value: h } = await decode$n(n);
    return { cid: c, bytes: u, value: h };
  }
  undo() {
    return this.blocks.pop();
  }
  async commit() {
    const n = this.last.cid;
    let c = 0, u = headerLength({ roots: [n] });
    c += u;
    for (const y of this.blocks)
      c += blockLength(y);
    const h = new Uint8Array(c), g = await createWriter(h, { headerSize: u });
    g.addRoot(n);
    for (const y of this.blocks)
      g.write(y);
    return await g.close(), g.bytes;
  }
  get size() {
    if (!(this != null && this.last))
      return 0;
    const n = this.last.cid;
    let c = 0;
    c += headerLength({ roots: [n] });
    for (const u of this.blocks)
      c += blockLength(u);
    return c;
  }
}
var objectSafeGet = get$1;
function get$1(o, n, c) {
  if (!o)
    return c;
  var u, h;
  if (Array.isArray(n) && (u = n.slice(0)), typeof n == "string" && (u = n.split(".")), typeof n == "symbol" && (u = [n]), !Array.isArray(u))
    throw new Error("props arg must be an array, a string or a symbol");
  for (; u.length; )
    if (h = u.shift(), !o || (o = o[h]) === void 0)
      return c;
  return o;
}
var browser$1 = { exports: {} }, ms$1, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms$1;
  hasRequiredMs = 1;
  var o = 1e3, n = 60 * o, c = 60 * n, u = 24 * c;
  function h(g, y, $, I) {
    var P = y >= 1.5 * $;
    return Math.round(g / $) + " " + I + (P ? "s" : "");
  }
  return ms$1 = function(g, y) {
    y = y || {};
    var $ = typeof g;
    if ($ === "string" && g.length > 0)
      return function(I) {
        if (!((I = String(I)).length > 100)) {
          var P = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(I);
          if (P) {
            var L = parseFloat(P[1]);
            switch ((P[2] || "ms").toLowerCase()) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return 315576e5 * L;
              case "weeks":
              case "week":
              case "w":
                return 6048e5 * L;
              case "days":
              case "day":
              case "d":
                return L * u;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return L * c;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return L * n;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return L * o;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return L;
              default:
                return;
            }
          }
        }
      }(g);
    if ($ === "number" && isFinite(g))
      return y.long ? function(I) {
        var P = Math.abs(I);
        return P >= u ? h(I, P, u, "day") : P >= c ? h(I, P, c, "hour") : P >= n ? h(I, P, n, "minute") : P >= o ? h(I, P, o, "second") : I + " ms";
      }(g) : function(I) {
        var P = Math.abs(I);
        return P >= u ? Math.round(I / u) + "d" : P >= c ? Math.round(I / c) + "h" : P >= n ? Math.round(I / n) + "m" : P >= o ? Math.round(I / o) + "s" : I + "ms";
      }(g);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(g));
  }, ms$1;
}
function setup(o) {
  function n(h) {
    let g, y, $, I = null;
    function P(...L) {
      if (!P.enabled)
        return;
      const q = P, N = Number(new Date()), X = N - (g || N);
      q.diff = X, q.prev = g, q.curr = N, g = N, L[0] = n.coerce(L[0]), typeof L[0] != "string" && L.unshift("%O");
      let rt = 0;
      L[0] = L[0].replace(/%([a-zA-Z%])/g, (nt, st) => {
        if (nt === "%%")
          return "%";
        rt++;
        const ot = n.formatters[st];
        if (typeof ot == "function") {
          const St = L[rt];
          nt = ot.call(q, St), L.splice(rt, 1), rt--;
        }
        return nt;
      }), n.formatArgs.call(q, L), (q.log || n.log).apply(q, L);
    }
    return P.namespace = h, P.useColors = n.useColors(), P.color = n.selectColor(h), P.extend = c, P.destroy = n.destroy, Object.defineProperty(P, "enabled", { enumerable: !0, configurable: !1, get: () => I !== null ? I : (y !== n.namespaces && (y = n.namespaces, $ = n.enabled(h)), $), set: (L) => {
      I = L;
    } }), typeof n.init == "function" && n.init(P), P;
  }
  function c(h, g) {
    const y = n(this.namespace + (g === void 0 ? ":" : g) + h);
    return y.log = this.log, y;
  }
  function u(h) {
    return h.toString().substring(2, h.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  return n.debug = n, n.default = n, n.coerce = function(h) {
    return h instanceof Error ? h.stack || h.message : h;
  }, n.disable = function() {
    const h = [...n.names.map(u), ...n.skips.map(u).map((g) => "-" + g)].join(",");
    return n.enable(""), h;
  }, n.enable = function(h) {
    let g;
    n.save(h), n.namespaces = h, n.names = [], n.skips = [];
    const y = (typeof h == "string" ? h : "").split(/[\s,]+/), $ = y.length;
    for (g = 0; g < $; g++)
      y[g] && ((h = y[g].replace(/\*/g, ".*?"))[0] === "-" ? n.skips.push(new RegExp("^" + h.slice(1) + "$")) : n.names.push(new RegExp("^" + h + "$")));
  }, n.enabled = function(h) {
    if (h[h.length - 1] === "*")
      return !0;
    let g, y;
    for (g = 0, y = n.skips.length; g < y; g++)
      if (n.skips[g].test(h))
        return !1;
    for (g = 0, y = n.names.length; g < y; g++)
      if (n.names[g].test(h))
        return !0;
    return !1;
  }, n.humanize = requireMs(), n.destroy = function() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }, Object.keys(o).forEach((h) => {
    n[h] = o[h];
  }), n.names = [], n.skips = [], n.formatters = {}, n.selectColor = function(h) {
    let g = 0;
    for (let y = 0; y < h.length; y++)
      g = (g << 5) - g + h.charCodeAt(y), g |= 0;
    return n.colors[Math.abs(g) % n.colors.length];
  }, n.enable(n.load()), n;
}
var common$8 = setup;
(function(o, n) {
  n.formatArgs = function(u) {
    if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + o.exports.humanize(this.diff), !this.useColors)
      return;
    const h = "color: " + this.color;
    u.splice(1, 0, h, "color: inherit");
    let g = 0, y = 0;
    u[0].replace(/%[a-zA-Z%]/g, ($) => {
      $ !== "%%" && (g++, $ === "%c" && (y = g));
    }), u.splice(y, 0, h);
  }, n.save = function(u) {
    try {
      u ? n.storage.setItem("debug", u) : n.storage.removeItem("debug");
    } catch {
    }
  }, n.load = function() {
    let u;
    try {
      u = n.storage.getItem("debug");
    } catch {
    }
    return !u && typeof process < "u" && "env" in process && (u = process.env.DEBUG), u;
  }, n.useColors = function() {
    return !(typeof window > "u" || !window.process || window.process.type !== "renderer" && !window.process.__nwjs) || (typeof navigator > "u" || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && (typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }, n.storage = function() {
    try {
      return localStorage;
    } catch {
    }
  }(), n.destroy = (() => {
    let u = !1;
    return () => {
      u || (u = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), n.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], n.log = console.debug || console.log || (() => {
  }), o.exports = common$8(n);
  const { formatters: c } = o.exports;
  c.j = function(u) {
    try {
      return JSON.stringify(u);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
})(browser$1, browser$1.exports);
const debug = browser$1.exports;
function assign(o, n) {
  for (const c in n)
    Object.defineProperty(o, c, { value: n[c], enumerable: !0, configurable: !0 });
  return o;
}
function createError(o, n, c) {
  if (!o || typeof o == "string")
    throw new TypeError("Please pass an Error to err-code");
  c || (c = {}), typeof n == "object" && (c = n, n = ""), n && (c.code = n);
  try {
    return assign(o, c);
  } catch {
    c.message = o.message, c.stack = o.stack;
    const h = function() {
    };
    return h.prototype = Object.create(Object.getPrototypeOf(o)), assign(new h(), c);
  }
}
var errCode = createError;
let nanoid$1 = (o = 21) => crypto.getRandomValues(new Uint8Array(o)).reduce((n, c) => n + ((c &= 63) < 36 ? c.toString(36) : c < 62 ? (c - 26).toString(36).toUpperCase() : c > 62 ? "-" : "_"), "");
function base$5(o, n) {
  if (o.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var c = new Uint8Array(256), u = 0; u < c.length; u++)
    c[u] = 255;
  for (var h = 0; h < o.length; h++) {
    var g = o.charAt(h), y = g.charCodeAt(0);
    if (c[y] !== 255)
      throw new TypeError(g + " is ambiguous");
    c[y] = h;
  }
  var $ = o.length, I = o.charAt(0), P = Math.log($) / Math.log(256), L = Math.log(256) / Math.log($);
  function q(N) {
    if (typeof N != "string")
      throw new TypeError("Expected String");
    if (N.length === 0)
      return new Uint8Array();
    var X = 0;
    if (N[X] !== " ") {
      for (var rt = 0, nt = 0; N[X] === I; )
        rt++, X++;
      for (var st = (N.length - X) * P + 1 >>> 0, ot = new Uint8Array(st); N[X]; ) {
        var St = c[N.charCodeAt(X)];
        if (St === 255)
          return;
        for (var Ct = 0, et = st - 1; (St !== 0 || Ct < nt) && et !== -1; et--, Ct++)
          St += $ * ot[et] >>> 0, ot[et] = St % 256 >>> 0, St = St / 256 >>> 0;
        if (St !== 0)
          throw new Error("Non-zero carry");
        nt = Ct, X++;
      }
      if (N[X] !== " ") {
        for (var at = st - nt; at !== st && ot[at] === 0; )
          at++;
        for (var _t = new Uint8Array(rt + (st - at)), Nt = rt; at !== st; )
          _t[Nt++] = ot[at++];
        return _t;
      }
    }
  }
  return { encode: function(N) {
    if (N instanceof Uint8Array || (ArrayBuffer.isView(N) ? N = new Uint8Array(N.buffer, N.byteOffset, N.byteLength) : Array.isArray(N) && (N = Uint8Array.from(N))), !(N instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (N.length === 0)
      return "";
    for (var X = 0, rt = 0, nt = 0, st = N.length; nt !== st && N[nt] === 0; )
      nt++, X++;
    for (var ot = (st - nt) * L + 1 >>> 0, St = new Uint8Array(ot); nt !== st; ) {
      for (var Ct = N[nt], et = 0, at = ot - 1; (Ct !== 0 || et < rt) && at !== -1; at--, et++)
        Ct += 256 * St[at] >>> 0, St[at] = Ct % $ >>> 0, Ct = Ct / $ >>> 0;
      if (Ct !== 0)
        throw new Error("Non-zero carry");
      rt = et, nt++;
    }
    for (var _t = ot - rt; _t !== ot && St[_t] === 0; )
      _t++;
    for (var Nt = I.repeat(X); _t < ot; ++_t)
      Nt += o.charAt(St[_t]);
    return Nt;
  }, decodeUnsafe: q, decode: function(N) {
    var X = q(N);
    if (X)
      return X;
    throw new Error(`Non-${n} character`);
  } };
}
var src$3 = base$5, _brrp__multiformats_scope_baseX$3 = src$3;
const coerce$3 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o))
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  throw new Error("Unknown type, must be binary type");
}, fromString$5 = (o) => new TextEncoder().encode(o), toString$7 = (o) => new TextDecoder().decode(o);
class Encoder$3 {
  constructor(n, c, u) {
    this.name = n, this.prefix = c, this.baseEncode = u;
  }
  encode(n) {
    if (n instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(n)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Decoder$3 {
  constructor(n, c, u) {
    if (this.name = n, this.prefix = c, c.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = c.codePointAt(0), this.baseDecode = u;
  }
  decode(n) {
    if (typeof n == "string") {
      if (n.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(n)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(n.slice(this.prefix.length));
    }
    throw Error("Can only multibase decode strings");
  }
  or(n) {
    return or$3(this, n);
  }
}
class ComposedDecoder$3 {
  constructor(n) {
    this.decoders = n;
  }
  or(n) {
    return or$3(this, n);
  }
  decode(n) {
    const c = n[0], u = this.decoders[c];
    if (u)
      return u.decode(n);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(n)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or$3 = (o, n) => new ComposedDecoder$3({ ...o.decoders || { [o.prefix]: o }, ...n.decoders || { [n.prefix]: n } });
class Codec$3 {
  constructor(n, c, u, h) {
    this.name = n, this.prefix = c, this.baseEncode = u, this.baseDecode = h, this.encoder = new Encoder$3(n, c, u), this.decoder = new Decoder$3(n, c, h);
  }
  encode(n) {
    return this.encoder.encode(n);
  }
  decode(n) {
    return this.decoder.decode(n);
  }
}
const from$6 = ({ name: o, prefix: n, encode: c, decode: u }) => new Codec$3(o, n, c, u), baseX$3 = ({ prefix: o, name: n, alphabet: c }) => {
  const { encode: u, decode: h } = _brrp__multiformats_scope_baseX$3(c, n);
  return from$6({ prefix: o, name: n, encode: u, decode: (g) => coerce$3(h(g)) });
}, decode$m = (o, n, c, u) => {
  const h = {};
  for (let L = 0; L < n.length; ++L)
    h[n[L]] = L;
  let g = o.length;
  for (; o[g - 1] === "="; )
    --g;
  const y = new Uint8Array(g * c / 8 | 0);
  let $ = 0, I = 0, P = 0;
  for (let L = 0; L < g; ++L) {
    const q = h[o[L]];
    if (q === void 0)
      throw new SyntaxError(`Non-${u} character`);
    I = I << c | q, $ += c, $ >= 8 && ($ -= 8, y[P++] = 255 & I >> $);
  }
  if ($ >= c || 255 & I << 8 - $)
    throw new SyntaxError("Unexpected end of data");
  return y;
}, encode$l = (o, n, c) => {
  const u = n[n.length - 1] === "=", h = (1 << c) - 1;
  let g = "", y = 0, $ = 0;
  for (let I = 0; I < o.length; ++I)
    for ($ = $ << 8 | o[I], y += 8; y > c; )
      y -= c, g += n[h & $ >> y];
  if (y && (g += n[h & $ << c - y]), u)
    for (; g.length * c & 7; )
      g += "=";
  return g;
}, rfc4648$3 = ({ name: o, prefix: n, bitsPerChar: c, alphabet: u }) => from$6({ prefix: n, name: o, encode: (h) => encode$l(h, u, c), decode: (h) => decode$m(h, u, c, o) }), identity$9 = from$6({ prefix: "\0", name: "identity", encode: (o) => toString$7(o), decode: (o) => fromString$5(o) }), identityBase$2 = Object.freeze(Object.defineProperty({ __proto__: null, identity: identity$9 }, Symbol.toStringTag, { value: "Module" })), base2$4 = rfc4648$3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }), base2$5 = Object.freeze(Object.defineProperty({ __proto__: null, base2: base2$4 }, Symbol.toStringTag, { value: "Module" })), base8$4 = rfc4648$3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 }), base8$5 = Object.freeze(Object.defineProperty({ __proto__: null, base8: base8$4 }, Symbol.toStringTag, { value: "Module" })), base10$4 = baseX$3({ prefix: "9", name: "base10", alphabet: "0123456789" }), base10$5 = Object.freeze(Object.defineProperty({ __proto__: null, base10: base10$4 }, Symbol.toStringTag, { value: "Module" })), base16$4 = rfc4648$3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), base16upper$2 = rfc4648$3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 }), base16$5 = Object.freeze(Object.defineProperty({ __proto__: null, base16: base16$4, base16upper: base16upper$2 }, Symbol.toStringTag, { value: "Module" })), base32$4 = rfc4648$3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), base32upper$1 = rfc4648$3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), base32pad$1 = rfc4648$3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), base32padupper$1 = rfc4648$3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), base32hex$1 = rfc4648$3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), base32hexupper$1 = rfc4648$3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), base32hexpad$1 = rfc4648$3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), base32hexpadupper$1 = rfc4648$3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), base32z$1 = rfc4648$3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 }), base32$5 = Object.freeze(Object.defineProperty({ __proto__: null, base32: base32$4, base32upper: base32upper$1, base32pad: base32pad$1, base32padupper: base32padupper$1, base32hex: base32hex$1, base32hexupper: base32hexupper$1, base32hexpad: base32hexpad$1, base32hexpadupper: base32hexpadupper$1, base32z: base32z$1 }, Symbol.toStringTag, { value: "Module" })), base36$4 = baseX$3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), base36upper$2 = baseX$3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" }), base36$5 = Object.freeze(Object.defineProperty({ __proto__: null, base36: base36$4, base36upper: base36upper$2 }, Symbol.toStringTag, { value: "Module" })), base58btc$3 = baseX$3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), base58flickr$1 = baseX$3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" }), base58$1 = Object.freeze(Object.defineProperty({ __proto__: null, base58btc: base58btc$3, base58flickr: base58flickr$1 }, Symbol.toStringTag, { value: "Module" })), base64$7 = rfc4648$3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), base64pad$2 = rfc4648$3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), base64url$2 = rfc4648$3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), base64urlpad$2 = rfc4648$3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 }), base64$8 = Object.freeze(Object.defineProperty({ __proto__: null, base64: base64$7, base64pad: base64pad$2, base64url: base64url$2, base64urlpad: base64urlpad$2 }, Symbol.toStringTag, { value: "Module" })), alphabet$2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"), alphabetBytesToChars$2 = alphabet$2.reduce((o, n, c) => (o[c] = n, o), []), alphabetCharsToBytes$2 = alphabet$2.reduce((o, n, c) => (o[n.codePointAt(0)] = c, o), []);
function encode$k(o) {
  return o.reduce((n, c) => n + alphabetBytesToChars$2[c], "");
}
function decode$l(o) {
  const n = [];
  for (const c of o) {
    const u = alphabetCharsToBytes$2[c.codePointAt(0)];
    if (u === void 0)
      throw new Error(`Non-base256emoji character: ${c}`);
    n.push(u);
  }
  return new Uint8Array(n);
}
const base256emoji$4 = from$6({ prefix: "\u{1F680}", name: "base256emoji", encode: encode$k, decode: decode$l }), base256emoji$5 = Object.freeze(Object.defineProperty({ __proto__: null, base256emoji: base256emoji$4 }, Symbol.toStringTag, { value: "Module" }));
var encode_1$2 = encode$j, MSB$3 = 128, REST$3 = 127, MSBALL$2 = ~REST$3, INT$2 = Math.pow(2, 31);
function encode$j(o, n, c) {
  n = n || [];
  for (var u = c = c || 0; o >= INT$2; )
    n[c++] = 255 & o | MSB$3, o /= 128;
  for (; o & MSBALL$2; )
    n[c++] = 255 & o | MSB$3, o >>>= 7;
  return n[c] = 0 | o, encode$j.bytes = c - u + 1, n;
}
var decode$k = read$4, MSB$1$2 = 128, REST$1$2 = 127;
function read$4(o, n) {
  var c, u = 0, h = 0, g = n = n || 0, y = o.length;
  do {
    if (g >= y)
      throw read$4.bytes = 0, new RangeError("Could not decode varint");
    c = o[g++], u += h < 28 ? (c & REST$1$2) << h : (c & REST$1$2) * Math.pow(2, h), h += 7;
  } while (c >= MSB$1$2);
  return read$4.bytes = g - n, u;
}
var N1$2 = Math.pow(2, 7), N2$2 = Math.pow(2, 14), N3$2 = Math.pow(2, 21), N4$2 = Math.pow(2, 28), N5$2 = Math.pow(2, 35), N6$2 = Math.pow(2, 42), N7$2 = Math.pow(2, 49), N8$2 = Math.pow(2, 56), N9$2 = Math.pow(2, 63), length$3 = function(o) {
  return o < N1$2 ? 1 : o < N2$2 ? 2 : o < N3$2 ? 3 : o < N4$2 ? 4 : o < N5$2 ? 5 : o < N6$2 ? 6 : o < N7$2 ? 7 : o < N8$2 ? 8 : o < N9$2 ? 9 : 10;
}, varint$2 = { encode: encode_1$2, decode: decode$k, encodingLength: length$3 }, _brrp_varint$2 = varint$2;
const encodeTo$2 = (o, n, c = 0) => (_brrp_varint$2.encode(o, n, c), n), encodingLength$2 = (o) => _brrp_varint$2.encodingLength(o), create$4 = (o, n) => {
  const c = n.byteLength, u = encodingLength$2(o), h = u + encodingLength$2(c), g = new Uint8Array(h + c);
  return encodeTo$2(o, g, 0), encodeTo$2(c, g, u), g.set(n, h), new Digest$2(o, c, n, g);
};
class Digest$2 {
  constructor(n, c, u, h) {
    this.code = n, this.size = c, this.digest = u, this.bytes = h;
  }
}
const from$5 = ({ name: o, code: n, encode: c }) => new Hasher$1(o, n, c);
class Hasher$1 {
  constructor(n, c, u) {
    this.name = n, this.code = c, this.encode = u;
  }
  digest(n) {
    if (n instanceof Uint8Array) {
      const c = this.encode(n);
      return c instanceof Uint8Array ? create$4(this.code, c) : c.then((u) => create$4(this.code, u));
    }
    throw Error("Unknown type, must be binary type");
  }
}
const sha$2 = (o) => async (n) => new Uint8Array(await crypto.subtle.digest(o, n)), sha256$4 = from$5({ name: "sha2-256", code: 18, encode: sha$2("SHA-256") }), sha512$3 = from$5({ name: "sha2-512", code: 19, encode: sha$2("SHA-512") }), sha2$1 = Object.freeze(Object.defineProperty({ __proto__: null, sha256: sha256$4, sha512: sha512$3 }, Symbol.toStringTag, { value: "Module" })), code$8 = 0, name$6 = "identity", encode$i = coerce$3, digest$2 = (o) => create$4(code$8, encode$i(o)), identity$7 = { code: code$8, name: name$6, encode: encode$i, digest: digest$2 }, identity$8 = Object.freeze(Object.defineProperty({ __proto__: null, identity: identity$7 }, Symbol.toStringTag, { value: "Module" }));
new TextEncoder(), new TextDecoder();
const bases$2 = { ...identityBase$2, ...base2$5, ...base8$5, ...base10$5, ...base16$5, ...base32$5, ...base36$5, ...base58$1, ...base64$8, ...base256emoji$5 };
function asUint8Array$2(o) {
  return globalThis.Buffer != null ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength) : o;
}
function allocUnsafe$2(o = 0) {
  var n;
  return ((n = globalThis.Buffer) == null ? void 0 : n.allocUnsafe) != null ? asUint8Array$2(globalThis.Buffer.allocUnsafe(o)) : new Uint8Array(o);
}
function createCodec$2(o, n, c, u) {
  return { name: o, prefix: n, encoder: { name: o, prefix: n, encode: c }, decoder: { decode: u } };
}
const string$2 = createCodec$2("utf8", "u", (o) => "u" + new TextDecoder("utf8").decode(o), (o) => new TextEncoder().encode(o.substring(1))), ascii$2 = createCodec$2("ascii", "a", (o) => {
  let n = "a";
  for (let c = 0; c < o.length; c++)
    n += String.fromCharCode(o[c]);
  return n;
}, (o) => {
  const n = allocUnsafe$2((o = o.substring(1)).length);
  for (let c = 0; c < o.length; c++)
    n[c] = o.charCodeAt(c);
  return n;
}), BASES$2 = { utf8: string$2, "utf-8": string$2, hex: bases$2.base16, latin1: ascii$2, ascii: ascii$2, binary: ascii$2, ...bases$2 };
function toString$6(o, n = "utf8") {
  const c = BASES$2[n];
  if (c == null)
    throw new Error(`Unsupported encoding "${n}"`);
  return n !== "utf8" && n !== "utf-8" || globalThis.Buffer == null || globalThis.Buffer.from == null ? c.encoder.encode(o).substring(1) : globalThis.Buffer.from(o.buffer, o.byteOffset, o.byteLength).toString("utf8");
}
function fromString$4(o, n = "utf8") {
  const c = BASES$2[n];
  if (c == null)
    throw new Error(`Unsupported encoding "${n}"`);
  return n !== "utf8" && n !== "utf-8" || globalThis.Buffer == null || globalThis.Buffer.from == null ? c.decoder.decode(`${c.prefix}${o}`) : asUint8Array$2(globalThis.Buffer.from(o, "utf-8"));
}
const pathSepS = "/", pathSepB = new TextEncoder().encode(pathSepS), pathSep = pathSepB[0];
class Key {
  constructor(n, c) {
    if (typeof n == "string")
      this._buf = fromString$4(n);
    else {
      if (!(n instanceof Uint8Array))
        throw new Error("Invalid key, should be String of Uint8Array");
      this._buf = n;
    }
    if (c == null && (c = !0), c && this.clean(), this._buf.byteLength === 0 || this._buf[0] !== pathSep)
      throw new Error("Invalid key");
  }
  toString(n = "utf8") {
    return toString$6(this._buf, n);
  }
  uint8Array() {
    return this._buf;
  }
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  static withNamespaces(n) {
    return new Key(n.join(pathSepS));
  }
  static random() {
    return new Key(nanoid$1().replace(/-/g, ""));
  }
  static asKey(n) {
    return n instanceof Uint8Array || typeof n == "string" ? new Key(n) : typeof n.uint8Array == "function" ? new Key(n.uint8Array()) : null;
  }
  clean() {
    if (this._buf != null && this._buf.byteLength !== 0 || (this._buf = pathSepB), this._buf[0] !== pathSep) {
      const n = new Uint8Array(this._buf.byteLength + 1);
      n.fill(pathSep, 0, 1), n.set(this._buf, 1), this._buf = n;
    }
    for (; this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep; )
      this._buf = this._buf.subarray(0, -1);
  }
  less(n) {
    const c = this.list(), u = n.list();
    for (let h = 0; h < c.length; h++) {
      if (u.length < h + 1)
        return !1;
      const g = c[h], y = u[h];
      if (g < y)
        return !0;
      if (g > y)
        return !1;
    }
    return c.length < u.length;
  }
  reverse() {
    return Key.withNamespaces(this.list().slice().reverse());
  }
  namespaces() {
    return this.list();
  }
  baseNamespace() {
    const n = this.namespaces();
    return n[n.length - 1];
  }
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  type() {
    return namespaceType(this.baseNamespace());
  }
  name() {
    return namespaceValue(this.baseNamespace());
  }
  instance(n) {
    return new Key(this.toString() + ":" + n);
  }
  path() {
    let n = this.parent().toString();
    return n.endsWith(pathSepS) || (n += pathSepS), n += this.type(), new Key(n);
  }
  parent() {
    const n = this.list();
    return n.length === 1 ? new Key(pathSepS) : new Key(n.slice(0, -1).join(pathSepS));
  }
  child(n) {
    return this.toString() === pathSepS ? n : n.toString() === pathSepS ? this : new Key(this.toString() + n.toString(), !1);
  }
  isAncestorOf(n) {
    return n.toString() !== this.toString() && n.toString().startsWith(this.toString());
  }
  isDecendantOf(n) {
    return n.toString() !== this.toString() && this.toString().startsWith(n.toString());
  }
  isTopLevel() {
    return this.list().length === 1;
  }
  concat(...n) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(n.map((c) => c.namespaces()))]);
  }
}
function namespaceType(o) {
  const n = o.split(":");
  return n.length < 2 ? "" : n.slice(0, -1).join(":");
}
function namespaceValue(o) {
  const n = o.split(":");
  return n[n.length - 1];
}
function flatten(o) {
  return [].concat(...o);
}
const length$2 = async (o) => {
  let n = 0;
  for await (const c of o)
    n++;
  return n;
};
var itLength = length$2;
const log$7 = debug("ipfs:repo:migrator:migration-8");
function unwrap$1(o) {
  return o.child ? unwrap$1(o.child) : o;
}
function keyToMultihash$1(o) {
  try {
    const n = base32$6.decode(`b${o.toString().toLowerCase().slice(1)}`), c = CID$2.decode(n).multihash.bytes, u = base32$6.encode(c).slice(1).toUpperCase();
    return new Key(`/${u}`, !1);
  } catch {
    return o;
  }
}
function keyToCid$1(o) {
  try {
    const n = base32$6.decode(`b${o.toString().toLowerCase().slice(1)}`), c = decode$r(n), u = base32$6.encode(CID$2.createV1(code$9, c).bytes).slice(1);
    return new Key(`/${u.toUpperCase()}`, !1);
  } catch {
    return o;
  }
}
async function process$3(o, n, c) {
  const u = o.blocks;
  await u.open();
  const h = unwrap$1(u), g = await itLength(h.queryKeys({ filters: [(y) => c(y).toString() !== y.toString()] }));
  try {
    let y = 0;
    for await (const $ of h.query({})) {
      const I = c($.key);
      I.toString() !== $.key.toString() && (y += 1, log$7(`Migrating Block from ${$.key} to ${I}`, await h.has($.key)), await h.delete($.key), await h.put(I, $.value), n(y / g * 100, `Migrated Block from ${$.key} to ${I}`));
    }
  } finally {
    await u.close();
  }
}
const migration$4 = { version: 8, description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32", migrate: (o, n = () => {
}) => process$3(o, n, keyToMultihash$1), revert: (o, n = () => {
}) => process$3(o, n, keyToCid$1) }, textDecoder$2 = new TextDecoder();
function decodeVarint(o, n) {
  let c = 0;
  for (let u = 0; ; u += 7) {
    if (u >= 64)
      throw new Error("protobuf: varint overflow");
    if (n >= o.length)
      throw new Error("protobuf: unexpected end of data");
    const h = o[n++];
    if (c += u < 28 ? (127 & h) << u : (127 & h) * 2 ** u, h < 128)
      break;
  }
  return [c, n];
}
function decodeBytes(o, n) {
  let c;
  [c, n] = decodeVarint(o, n);
  const u = n + c;
  if (c < 0 || u < 0)
    throw new Error("protobuf: invalid length");
  if (u > o.length)
    throw new Error("protobuf: unexpected end of data");
  return [o.subarray(n, u), u];
}
function decodeKey(o, n) {
  let c;
  return [c, n] = decodeVarint(o, n), [7 & c, c >> 3, n];
}
function decodeLink(o) {
  const n = {}, c = o.length;
  let u = 0;
  for (; u < c; ) {
    let h, g;
    if ([h, g, u] = decodeKey(o, u), g === 1) {
      if (n.Hash)
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      if (h !== 2)
        throw new Error(`protobuf: (PBLink) wrong wireType (${h}) for Hash`);
      if (n.Name !== void 0)
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      if (n.Tsize !== void 0)
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      [n.Hash, u] = decodeBytes(o, u);
    } else if (g === 2) {
      if (n.Name !== void 0)
        throw new Error("protobuf: (PBLink) duplicate Name section");
      if (h !== 2)
        throw new Error(`protobuf: (PBLink) wrong wireType (${h}) for Name`);
      if (n.Tsize !== void 0)
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      let y;
      [y, u] = decodeBytes(o, u), n.Name = textDecoder$2.decode(y);
    } else {
      if (g !== 3)
        throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${g}`);
      if (n.Tsize !== void 0)
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      if (h !== 0)
        throw new Error(`protobuf: (PBLink) wrong wireType (${h}) for Tsize`);
      [n.Tsize, u] = decodeVarint(o, u);
    }
  }
  if (u > c)
    throw new Error("protobuf: (PBLink) unexpected end of data");
  return n;
}
function decodeNode(o) {
  const n = o.length;
  let c, u, h = 0, g = !1;
  for (; h < n; ) {
    let $, I;
    if ([$, I, h] = decodeKey(o, h), $ !== 2)
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${$}`);
    if (I === 1) {
      if (u)
        throw new Error("protobuf: (PBNode) duplicate Data section");
      [u, h] = decodeBytes(o, h), c && (g = !0);
    } else {
      if (I !== 2)
        throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${I}`);
      {
        if (g)
          throw new Error("protobuf: (PBNode) duplicate Links section");
        let P;
        c || (c = []), [P, h] = decodeBytes(o, h), c.push(decodeLink(P));
      }
    }
  }
  if (h > n)
    throw new Error("protobuf: (PBNode) unexpected end of data");
  const y = {};
  return u && (y.Data = u), y.Links = c || [], y;
}
const textEncoder$4 = new TextEncoder(), maxInt32 = 2 ** 32, maxUInt32 = 2 ** 31;
function encodeLink(o, n) {
  let c = n.length;
  if (typeof o.Tsize == "number") {
    if (o.Tsize < 0)
      throw new Error("Tsize cannot be negative");
    if (!Number.isSafeInteger(o.Tsize))
      throw new Error("Tsize too large for encoding");
    c = encodeVarint(n, c, o.Tsize) - 1, n[c] = 24;
  }
  if (typeof o.Name == "string") {
    const u = textEncoder$4.encode(o.Name);
    c -= u.length, n.set(u, c), c = encodeVarint(n, c, u.length) - 1, n[c] = 18;
  }
  return o.Hash && (c -= o.Hash.length, n.set(o.Hash, c), c = encodeVarint(n, c, o.Hash.length) - 1, n[c] = 10), n.length - c;
}
function encodeNode(o) {
  const n = sizeNode(o), c = new Uint8Array(n);
  let u = n;
  if (o.Data && (u -= o.Data.length, c.set(o.Data, u), u = encodeVarint(c, u, o.Data.length) - 1, c[u] = 10), o.Links)
    for (let h = o.Links.length - 1; h >= 0; h--) {
      const g = encodeLink(o.Links[h], c.subarray(0, u));
      u -= g, u = encodeVarint(c, u, g) - 1, c[u] = 18;
    }
  return c;
}
function sizeLink(o) {
  let n = 0;
  if (o.Hash) {
    const c = o.Hash.length;
    n += 1 + c + sov(c);
  }
  if (typeof o.Name == "string") {
    const c = textEncoder$4.encode(o.Name).length;
    n += 1 + c + sov(c);
  }
  return typeof o.Tsize == "number" && (n += 1 + sov(o.Tsize)), n;
}
function sizeNode(o) {
  let n = 0;
  if (o.Data) {
    const c = o.Data.length;
    n += 1 + c + sov(c);
  }
  if (o.Links)
    for (const c of o.Links) {
      const u = sizeLink(c);
      n += 1 + u + sov(u);
    }
  return n;
}
function encodeVarint(o, n, c) {
  const u = n -= sov(c);
  for (; c >= maxUInt32; )
    o[n++] = 127 & c | 128, c /= 128;
  for (; c >= 128; )
    o[n++] = 127 & c | 128, c >>>= 7;
  return o[n] = c, u;
}
function sov(o) {
  return o % 2 == 0 && o++, Math.floor((len64(o) + 6) / 7);
}
function len64(o) {
  let n = 0;
  return o >= maxInt32 && (o = Math.floor(o / maxInt32), n = 32), o >= 65536 && (o >>>= 16, n += 16), o >= 256 && (o >>>= 8, n += 8), n + len8tab[o];
}
const len8tab = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], pbNodeProperties = ["Data", "Links"], pbLinkProperties = ["Hash", "Name", "Tsize"], textEncoder$3 = new TextEncoder();
function linkComparator(o, n) {
  if (o === n)
    return 0;
  const c = o.Name ? textEncoder$3.encode(o.Name) : [], u = n.Name ? textEncoder$3.encode(n.Name) : [];
  let h = c.length, g = u.length;
  for (let y = 0, $ = Math.min(h, g); y < $; ++y)
    if (c[y] !== u[y]) {
      h = c[y], g = u[y];
      break;
    }
  return h < g ? -1 : g < h ? 1 : 0;
}
function hasOnlyProperties(o, n) {
  return !Object.keys(o).some((c) => !n.includes(c));
}
function validate(o) {
  if (!o || typeof o != "object" || Array.isArray(o))
    throw new TypeError("Invalid DAG-PB form");
  if (!hasOnlyProperties(o, pbNodeProperties))
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  if (o.Data !== void 0 && !(o.Data instanceof Uint8Array))
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  if (!Array.isArray(o.Links))
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  for (let n = 0; n < o.Links.length; n++) {
    const c = o.Links[n];
    if (!c || typeof c != "object" || Array.isArray(c))
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    if (!hasOnlyProperties(c, pbLinkProperties))
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    if (!c.Hash)
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    if (c.Hash.asCID !== c.Hash)
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    if (c.Name !== void 0 && typeof c.Name != "string")
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    if (c.Tsize !== void 0 && (typeof c.Tsize != "number" || c.Tsize % 1 != 0))
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    if (n > 0 && linkComparator(c, o.Links[n - 1]) === -1)
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
  }
}
const code$7 = 112;
function encode$h(o) {
  validate(o);
  const n = {};
  return o.Links && (n.Links = o.Links.map((c) => {
    const u = {};
    return c.Hash && (u.Hash = c.Hash.bytes), c.Name !== void 0 && (u.Name = c.Name), c.Tsize !== void 0 && (u.Tsize = c.Tsize), u;
  })), o.Data && (n.Data = o.Data), encodeNode(n);
}
function decode$j(o) {
  const n = decodeNode(o), c = {};
  return n.Data && (c.Data = n.Data), n.Links && (c.Links = n.Links.map((u) => {
    const h = {};
    try {
      h.Hash = CID$2.decode(u.Hash);
    } catch {
    }
    if (!h.Hash)
      throw new Error("Invalid Hash field found in link, expected CID");
    return u.Name !== void 0 && (h.Name = u.Name), u.Tsize !== void 0 && (h.Tsize = u.Tsize), h;
  })), c;
}
var minimal$1 = { exports: {} }, indexMinimal = {}, minimal = {}, aspromise = asPromise;
function asPromise(o, n) {
  for (var c = new Array(arguments.length - 1), u = 0, h = 2, g = !0; h < arguments.length; )
    c[u++] = arguments[h++];
  return new Promise(function(y, $) {
    c[u] = function(I) {
      if (g)
        if (g = !1, I)
          $(I);
        else {
          for (var P = new Array(arguments.length - 1), L = 0; L < P.length; )
            P[L++] = arguments[L];
          y.apply(null, P);
        }
    };
    try {
      o.apply(n || null, c);
    } catch (I) {
      g && (g = !1, $(I));
    }
  });
}
var base64$6 = {};
(function(o) {
  var n = base64$6;
  n.length = function(y) {
    var $ = y.length;
    if (!$)
      return 0;
    for (var I = 0; --$ % 4 > 1 && y.charAt($) === "="; )
      ++I;
    return Math.ceil(3 * y.length) / 4 - I;
  };
  for (var c = new Array(64), u = new Array(123), h = 0; h < 64; )
    u[c[h] = h < 26 ? h + 65 : h < 52 ? h + 71 : h < 62 ? h - 4 : h - 59 | 43] = h++;
  n.encode = function(y, $, I) {
    for (var P, L = null, q = [], N = 0, X = 0; $ < I; ) {
      var rt = y[$++];
      switch (X) {
        case 0:
          q[N++] = c[rt >> 2], P = (3 & rt) << 4, X = 1;
          break;
        case 1:
          q[N++] = c[P | rt >> 4], P = (15 & rt) << 2, X = 2;
          break;
        case 2:
          q[N++] = c[P | rt >> 6], q[N++] = c[63 & rt], X = 0;
      }
      N > 8191 && ((L || (L = [])).push(String.fromCharCode.apply(String, q)), N = 0);
    }
    return X && (q[N++] = c[P], q[N++] = 61, X === 1 && (q[N++] = 61)), L ? (N && L.push(String.fromCharCode.apply(String, q.slice(0, N))), L.join("")) : String.fromCharCode.apply(String, q.slice(0, N));
  };
  var g = "invalid encoding";
  n.decode = function(y, $, I) {
    for (var P, L = I, q = 0, N = 0; N < y.length; ) {
      var X = y.charCodeAt(N++);
      if (X === 61 && q > 1)
        break;
      if ((X = u[X]) === void 0)
        throw Error(g);
      switch (q) {
        case 0:
          P = X, q = 1;
          break;
        case 1:
          $[I++] = P << 2 | (48 & X) >> 4, P = X, q = 2;
          break;
        case 2:
          $[I++] = (15 & P) << 4 | (60 & X) >> 2, P = X, q = 3;
          break;
        case 3:
          $[I++] = (3 & P) << 6 | X, q = 0;
      }
    }
    if (q === 1)
      throw Error(g);
    return I - L;
  }, n.test = function(y) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(y);
  };
})();
var eventemitter = EventEmitter$3;
function EventEmitter$3() {
  this._listeners = {};
}
EventEmitter$3.prototype.on = function(o, n, c) {
  return (this._listeners[o] || (this._listeners[o] = [])).push({ fn: n, ctx: c || this }), this;
}, EventEmitter$3.prototype.off = function(o, n) {
  if (o === void 0)
    this._listeners = {};
  else if (n === void 0)
    this._listeners[o] = [];
  else
    for (var c = this._listeners[o], u = 0; u < c.length; )
      c[u].fn === n ? c.splice(u, 1) : ++u;
  return this;
}, EventEmitter$3.prototype.emit = function(o) {
  var n = this._listeners[o];
  if (n) {
    for (var c = [], u = 1; u < arguments.length; )
      c.push(arguments[u++]);
    for (u = 0; u < n.length; )
      n[u].fn.apply(n[u++].ctx, c);
  }
  return this;
};
var float = factory(factory);
function factory(o) {
  return typeof Float32Array < "u" ? function() {
    var n = new Float32Array([-0]), c = new Uint8Array(n.buffer), u = c[3] === 128;
    function h(I, P, L) {
      n[0] = I, P[L] = c[0], P[L + 1] = c[1], P[L + 2] = c[2], P[L + 3] = c[3];
    }
    function g(I, P, L) {
      n[0] = I, P[L] = c[3], P[L + 1] = c[2], P[L + 2] = c[1], P[L + 3] = c[0];
    }
    function y(I, P) {
      return c[0] = I[P], c[1] = I[P + 1], c[2] = I[P + 2], c[3] = I[P + 3], n[0];
    }
    function $(I, P) {
      return c[3] = I[P], c[2] = I[P + 1], c[1] = I[P + 2], c[0] = I[P + 3], n[0];
    }
    o.writeFloatLE = u ? h : g, o.writeFloatBE = u ? g : h, o.readFloatLE = u ? y : $, o.readFloatBE = u ? $ : y;
  }() : function() {
    function n(u, h, g, y) {
      var $ = h < 0 ? 1 : 0;
      if ($ && (h = -h), h === 0)
        u(1 / h > 0 ? 0 : 2147483648, g, y);
      else if (isNaN(h))
        u(2143289344, g, y);
      else if (h > 34028234663852886e22)
        u(($ << 31 | 2139095040) >>> 0, g, y);
      else if (h < 11754943508222875e-54)
        u(($ << 31 | Math.round(h / 1401298464324817e-60)) >>> 0, g, y);
      else {
        var I = Math.floor(Math.log(h) / Math.LN2);
        u(($ << 31 | I + 127 << 23 | 8388607 & Math.round(h * Math.pow(2, -I) * 8388608)) >>> 0, g, y);
      }
    }
    function c(u, h, g) {
      var y = u(h, g), $ = 2 * (y >> 31) + 1, I = y >>> 23 & 255, P = 8388607 & y;
      return I === 255 ? P ? NaN : $ * (1 / 0) : I === 0 ? 1401298464324817e-60 * $ * P : $ * Math.pow(2, I - 150) * (P + 8388608);
    }
    o.writeFloatLE = n.bind(null, writeUintLE$1), o.writeFloatBE = n.bind(null, writeUintBE$1), o.readFloatLE = c.bind(null, readUintLE$1), o.readFloatBE = c.bind(null, readUintBE$1);
  }(), typeof Float64Array < "u" ? function() {
    var n = new Float64Array([-0]), c = new Uint8Array(n.buffer), u = c[7] === 128;
    function h(I, P, L) {
      n[0] = I, P[L] = c[0], P[L + 1] = c[1], P[L + 2] = c[2], P[L + 3] = c[3], P[L + 4] = c[4], P[L + 5] = c[5], P[L + 6] = c[6], P[L + 7] = c[7];
    }
    function g(I, P, L) {
      n[0] = I, P[L] = c[7], P[L + 1] = c[6], P[L + 2] = c[5], P[L + 3] = c[4], P[L + 4] = c[3], P[L + 5] = c[2], P[L + 6] = c[1], P[L + 7] = c[0];
    }
    function y(I, P) {
      return c[0] = I[P], c[1] = I[P + 1], c[2] = I[P + 2], c[3] = I[P + 3], c[4] = I[P + 4], c[5] = I[P + 5], c[6] = I[P + 6], c[7] = I[P + 7], n[0];
    }
    function $(I, P) {
      return c[7] = I[P], c[6] = I[P + 1], c[5] = I[P + 2], c[4] = I[P + 3], c[3] = I[P + 4], c[2] = I[P + 5], c[1] = I[P + 6], c[0] = I[P + 7], n[0];
    }
    o.writeDoubleLE = u ? h : g, o.writeDoubleBE = u ? g : h, o.readDoubleLE = u ? y : $, o.readDoubleBE = u ? $ : y;
  }() : function() {
    function n(u, h, g, y, $, I) {
      var P = y < 0 ? 1 : 0;
      if (P && (y = -y), y === 0)
        u(0, $, I + h), u(1 / y > 0 ? 0 : 2147483648, $, I + g);
      else if (isNaN(y))
        u(0, $, I + h), u(2146959360, $, I + g);
      else if (y > 17976931348623157e292)
        u(0, $, I + h), u((P << 31 | 2146435072) >>> 0, $, I + g);
      else {
        var L;
        if (y < 22250738585072014e-324)
          u((L = y / 5e-324) >>> 0, $, I + h), u((P << 31 | L / 4294967296) >>> 0, $, I + g);
        else {
          var q = Math.floor(Math.log(y) / Math.LN2);
          q === 1024 && (q = 1023), u(4503599627370496 * (L = y * Math.pow(2, -q)) >>> 0, $, I + h), u((P << 31 | q + 1023 << 20 | 1048576 * L & 1048575) >>> 0, $, I + g);
        }
      }
    }
    function c(u, h, g, y, $) {
      var I = u(y, $ + h), P = u(y, $ + g), L = 2 * (P >> 31) + 1, q = P >>> 20 & 2047, N = 4294967296 * (1048575 & P) + I;
      return q === 2047 ? N ? NaN : L * (1 / 0) : q === 0 ? 5e-324 * L * N : L * Math.pow(2, q - 1075) * (N + 4503599627370496);
    }
    o.writeDoubleLE = n.bind(null, writeUintLE$1, 0, 4), o.writeDoubleBE = n.bind(null, writeUintBE$1, 4, 0), o.readDoubleLE = c.bind(null, readUintLE$1, 0, 4), o.readDoubleBE = c.bind(null, readUintBE$1, 4, 0);
  }(), o;
}
function writeUintLE$1(o, n, c) {
  n[c] = 255 & o, n[c + 1] = o >>> 8 & 255, n[c + 2] = o >>> 16 & 255, n[c + 3] = o >>> 24;
}
function writeUintBE$1(o, n, c) {
  n[c] = o >>> 24, n[c + 1] = o >>> 16 & 255, n[c + 2] = o >>> 8 & 255, n[c + 3] = 255 & o;
}
function readUintLE$1(o, n) {
  return (o[n] | o[n + 1] << 8 | o[n + 2] << 16 | o[n + 3] << 24) >>> 0;
}
function readUintBE$1(o, n) {
  return (o[n] << 24 | o[n + 1] << 16 | o[n + 2] << 8 | o[n + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (o) {
  }
  return null;
}
var utf8$2 = {}, t;
t = utf8$2, t.length = function(o) {
  for (var n = 0, c = 0, u = 0; u < o.length; ++u)
    (c = o.charCodeAt(u)) < 128 ? n += 1 : c < 2048 ? n += 2 : (64512 & c) == 55296 && (64512 & o.charCodeAt(u + 1)) == 56320 ? (++u, n += 4) : n += 3;
  return n;
}, t.read = function(o, n, c) {
  if (c - n < 1)
    return "";
  for (var u, h = null, g = [], y = 0; n < c; )
    (u = o[n++]) < 128 ? g[y++] = u : u > 191 && u < 224 ? g[y++] = (31 & u) << 6 | 63 & o[n++] : u > 239 && u < 365 ? (u = ((7 & u) << 18 | (63 & o[n++]) << 12 | (63 & o[n++]) << 6 | 63 & o[n++]) - 65536, g[y++] = 55296 + (u >> 10), g[y++] = 56320 + (1023 & u)) : g[y++] = (15 & u) << 12 | (63 & o[n++]) << 6 | 63 & o[n++], y > 8191 && ((h || (h = [])).push(String.fromCharCode.apply(String, g)), y = 0);
  return h ? (y && h.push(String.fromCharCode.apply(String, g.slice(0, y))), h.join("")) : String.fromCharCode.apply(String, g.slice(0, y));
}, t.write = function(o, n, c) {
  for (var u, h, g = c, y = 0; y < o.length; ++y)
    (u = o.charCodeAt(y)) < 128 ? n[c++] = u : u < 2048 ? (n[c++] = u >> 6 | 192, n[c++] = 63 & u | 128) : (64512 & u) == 55296 && (64512 & (h = o.charCodeAt(y + 1))) == 56320 ? (u = 65536 + ((1023 & u) << 10) + (1023 & h), ++y, n[c++] = u >> 18 | 240, n[c++] = u >> 12 & 63 | 128, n[c++] = u >> 6 & 63 | 128, n[c++] = 63 & u | 128) : (n[c++] = u >> 12 | 224, n[c++] = u >> 6 & 63 | 128, n[c++] = 63 & u | 128);
  return c - g;
};
var pool_1 = pool, longbits, hasRequiredLongbits, hasRequiredMinimal;
function pool(o, n, c) {
  var u = c || 8192, h = u >>> 1, g = null, y = u;
  return function($) {
    if ($ < 1 || $ > h)
      return o($);
    y + $ > u && (g = o(u), y = 0);
    var I = n.call(g, y, y += $);
    return 7 & y && (y = 1 + (7 | y)), I;
  };
}
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = n;
  var o = requireMinimal();
  function n(g, y) {
    this.lo = g >>> 0, this.hi = y >>> 0;
  }
  var c = n.zero = new n(0, 0);
  c.toNumber = function() {
    return 0;
  }, c.zzEncode = c.zzDecode = function() {
    return this;
  }, c.length = function() {
    return 1;
  };
  var u = n.zeroHash = "\0\0\0\0\0\0\0\0";
  n.fromNumber = function(g) {
    if (g === 0)
      return c;
    var y = g < 0;
    y && (g = -g);
    var $ = g >>> 0, I = (g - $) / 4294967296 >>> 0;
    return y && (I = ~I >>> 0, $ = ~$ >>> 0, ++$ > 4294967295 && ($ = 0, ++I > 4294967295 && (I = 0))), new n($, I);
  }, n.from = function(g) {
    if (typeof g == "number")
      return n.fromNumber(g);
    if (o.isString(g)) {
      if (!o.Long)
        return n.fromNumber(parseInt(g, 10));
      g = o.Long.fromString(g);
    }
    return g.low || g.high ? new n(g.low >>> 0, g.high >>> 0) : c;
  }, n.prototype.toNumber = function(g) {
    if (!g && this.hi >>> 31) {
      var y = 1 + ~this.lo >>> 0, $ = ~this.hi >>> 0;
      return y || ($ = $ + 1 >>> 0), -(y + 4294967296 * $);
    }
    return this.lo + 4294967296 * this.hi;
  }, n.prototype.toLong = function(g) {
    return o.Long ? new o.Long(0 | this.lo, 0 | this.hi, Boolean(g)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(g) };
  };
  var h = String.prototype.charCodeAt;
  return n.fromHash = function(g) {
    return g === u ? c : new n((h.call(g, 0) | h.call(g, 1) << 8 | h.call(g, 2) << 16 | h.call(g, 3) << 24) >>> 0, (h.call(g, 4) | h.call(g, 5) << 8 | h.call(g, 6) << 16 | h.call(g, 7) << 24) >>> 0);
  }, n.prototype.toHash = function() {
    return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
  }, n.prototype.zzEncode = function() {
    var g = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ g) >>> 0, this.lo = (this.lo << 1 ^ g) >>> 0, this;
  }, n.prototype.zzDecode = function() {
    var g = -(1 & this.lo);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ g) >>> 0, this.hi = (this.hi >>> 1 ^ g) >>> 0, this;
  }, n.prototype.length = function() {
    var g = this.lo, y = (this.lo >>> 28 | this.hi << 4) >>> 0, $ = this.hi >>> 24;
    return $ === 0 ? y === 0 ? g < 16384 ? g < 128 ? 1 : 2 : g < 2097152 ? 3 : 4 : y < 16384 ? y < 128 ? 5 : 6 : y < 2097152 ? 7 : 8 : $ < 128 ? 9 : 10;
  }, longbits;
}
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(o) {
    var n = minimal;
    function c(h, g, y) {
      for (var $ = Object.keys(g), I = 0; I < $.length; ++I)
        h[$[I]] !== void 0 && y || (h[$[I]] = g[$[I]]);
      return h;
    }
    function u(h) {
      function g(y, $) {
        if (!(this instanceof g))
          return new g(y, $);
        Object.defineProperty(this, "message", { get: function() {
          return y;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, g) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), $ && c(this, $);
      }
      return g.prototype = Object.create(Error.prototype, { constructor: { value: g, writable: !0, enumerable: !1, configurable: !0 }, name: { get: () => h, set: void 0, enumerable: !1, configurable: !0 }, toString: { value() {
        return this.name + ": " + this.message;
      }, writable: !0, enumerable: !1, configurable: !0 } }), g;
    }
    n.asPromise = aspromise, n.base64 = base64$6, n.EventEmitter = eventemitter, n.float = float, n.inquire = inquire_1, n.utf8 = utf8$2, n.pool = pool_1, n.LongBits = requireLongbits(), n.isNode = Boolean(commonjsGlobal !== void 0 && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), n.global = n.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal, n.emptyArray = Object.freeze ? Object.freeze([]) : [], n.emptyObject = Object.freeze ? Object.freeze({}) : {}, n.isInteger = Number.isInteger || function(h) {
      return typeof h == "number" && isFinite(h) && Math.floor(h) === h;
    }, n.isString = function(h) {
      return typeof h == "string" || h instanceof String;
    }, n.isObject = function(h) {
      return h && typeof h == "object";
    }, n.isset = n.isSet = function(h, g) {
      var y = h[g];
      return !(y == null || !h.hasOwnProperty(g)) && (typeof y != "object" || (Array.isArray(y) ? y.length : Object.keys(y).length) > 0);
    }, n.Buffer = function() {
      try {
        var h = n.inquire("buffer").Buffer;
        return h.prototype.utf8Write ? h : null;
      } catch {
        return null;
      }
    }(), n._Buffer_from = null, n._Buffer_allocUnsafe = null, n.newBuffer = function(h) {
      return typeof h == "number" ? n.Buffer ? n._Buffer_allocUnsafe(h) : new n.Array(h) : n.Buffer ? n._Buffer_from(h) : typeof Uint8Array > "u" ? h : new Uint8Array(h);
    }, n.Array = typeof Uint8Array < "u" ? Uint8Array : Array, n.Long = n.global.dcodeIO && n.global.dcodeIO.Long || n.global.Long || n.inquire("long"), n.key2Re = /^true|false|0|1$/, n.key32Re = /^-?(?:0|[1-9][0-9]*)$/, n.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, n.longToHash = function(h) {
      return h ? n.LongBits.from(h).toHash() : n.LongBits.zeroHash;
    }, n.longFromHash = function(h, g) {
      var y = n.LongBits.fromHash(h);
      return n.Long ? n.Long.fromBits(y.lo, y.hi, g) : y.toNumber(Boolean(g));
    }, n.merge = c, n.lcFirst = function(h) {
      return h.charAt(0).toLowerCase() + h.substring(1);
    }, n.newError = u, n.ProtocolError = u("ProtocolError"), n.oneOfGetter = function(h) {
      for (var g = {}, y = 0; y < h.length; ++y)
        g[h[y]] = 1;
      return function() {
        for (var $ = Object.keys(this), I = $.length - 1; I > -1; --I)
          if (g[$[I]] === 1 && this[$[I]] !== void 0 && this[$[I]] !== null)
            return $[I];
      };
    }, n.oneOfSetter = function(h) {
      return function(g) {
        for (var y = 0; y < h.length; ++y)
          h[y] !== g && delete this[h[y]];
      };
    }, n.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }, n._configure = function() {
      var h = n.Buffer;
      h ? (n._Buffer_from = h.from !== Uint8Array.from && h.from || function(g, y) {
        return new h(g, y);
      }, n._Buffer_allocUnsafe = h.allocUnsafe || function(g) {
        return new h(g);
      }) : n._Buffer_from = n._Buffer_allocUnsafe = null;
    };
  }()), minimal;
}
var writer = Writer$1, util$4 = requireMinimal(), BufferWriter$1, LongBits$1 = util$4.LongBits, base64$5 = util$4.base64, utf8$1 = util$4.utf8;
function Op(o, n, c) {
  this.fn = o, this.len = n, this.next = void 0, this.val = c;
}
function noop$2() {
}
function State(o) {
  this.head = o.head, this.tail = o.tail, this.len = o.len, this.next = o.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop$2, 0, 0), this.tail = this.head, this.states = null;
}
var create$3 = function() {
  return util$4.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
function writeByte(o, n, c) {
  n[c] = 255 & o;
}
function writeVarint32(o, n, c) {
  for (; o > 127; )
    n[c++] = 127 & o | 128, o >>>= 7;
  n[c] = o;
}
function VarintOp(o, n) {
  this.len = o, this.next = void 0, this.val = n;
}
function writeVarint64(o, n, c) {
  for (; o.hi; )
    n[c++] = 127 & o.lo | 128, o.lo = (o.lo >>> 7 | o.hi << 25) >>> 0, o.hi >>>= 7;
  for (; o.lo > 127; )
    n[c++] = 127 & o.lo | 128, o.lo = o.lo >>> 7;
  n[c++] = o.lo;
}
function writeFixed32(o, n, c) {
  n[c] = 255 & o, n[c + 1] = o >>> 8 & 255, n[c + 2] = o >>> 16 & 255, n[c + 3] = o >>> 24;
}
Writer$1.create = create$3(), Writer$1.alloc = function(o) {
  return new util$4.Array(o);
}, util$4.Array !== Array && (Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray)), Writer$1.prototype._push = function(o, n, c) {
  return this.tail = this.tail.next = new Op(o, n, c), this.len += n, this;
}, VarintOp.prototype = Object.create(Op.prototype), VarintOp.prototype.fn = writeVarint32, Writer$1.prototype.uint32 = function(o) {
  return this.len += (this.tail = this.tail.next = new VarintOp((o >>>= 0) < 128 ? 1 : o < 16384 ? 2 : o < 2097152 ? 3 : o < 268435456 ? 4 : 5, o)).len, this;
}, Writer$1.prototype.int32 = function(o) {
  return o < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(o)) : this.uint32(o);
}, Writer$1.prototype.sint32 = function(o) {
  return this.uint32((o << 1 ^ o >> 31) >>> 0);
}, Writer$1.prototype.uint64 = function(o) {
  var n = LongBits$1.from(o);
  return this._push(writeVarint64, n.length(), n);
}, Writer$1.prototype.int64 = Writer$1.prototype.uint64, Writer$1.prototype.sint64 = function(o) {
  var n = LongBits$1.from(o).zzEncode();
  return this._push(writeVarint64, n.length(), n);
}, Writer$1.prototype.bool = function(o) {
  return this._push(writeByte, 1, o ? 1 : 0);
}, Writer$1.prototype.fixed32 = function(o) {
  return this._push(writeFixed32, 4, o >>> 0);
}, Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32, Writer$1.prototype.fixed64 = function(o) {
  var n = LongBits$1.from(o);
  return this._push(writeFixed32, 4, n.lo)._push(writeFixed32, 4, n.hi);
}, Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64, Writer$1.prototype.float = function(o) {
  return this._push(util$4.float.writeFloatLE, 4, o);
}, Writer$1.prototype.double = function(o) {
  return this._push(util$4.float.writeDoubleLE, 8, o);
};
var writeBytes = util$4.Array.prototype.set ? function(o, n, c) {
  n.set(o, c);
} : function(o, n, c) {
  for (var u = 0; u < o.length; ++u)
    n[c + u] = o[u];
};
Writer$1.prototype.bytes = function(o) {
  var n = o.length >>> 0;
  if (!n)
    return this._push(writeByte, 1, 0);
  if (util$4.isString(o)) {
    var c = Writer$1.alloc(n = base64$5.length(o));
    base64$5.decode(o, c, 0), o = c;
  }
  return this.uint32(n)._push(writeBytes, n, o);
}, Writer$1.prototype.string = function(o) {
  var n = utf8$1.length(o);
  return n ? this.uint32(n)._push(utf8$1.write, n, o) : this._push(writeByte, 1, 0);
}, Writer$1.prototype.fork = function() {
  return this.states = new State(this), this.head = this.tail = new Op(noop$2, 0, 0), this.len = 0, this;
}, Writer$1.prototype.reset = function() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$2, 0, 0), this.len = 0), this;
}, Writer$1.prototype.ldelim = function() {
  var o = this.head, n = this.tail, c = this.len;
  return this.reset().uint32(c), c && (this.tail.next = o.next, this.tail = n, this.len += c), this;
}, Writer$1.prototype.finish = function() {
  for (var o = this.head.next, n = this.constructor.alloc(this.len), c = 0; o; )
    o.fn(o.val, n, c), c += o.len, o = o.next;
  return n;
}, Writer$1._configure = function(o) {
  BufferWriter$1 = o, Writer$1.create = create$3(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$3 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
function writeStringBuffer(o, n, c) {
  o.length < 40 ? util$3.utf8.write(o, n, c) : n.utf8Write ? n.utf8Write(o, c) : n.write(o, c);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$3._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function(o, n, c) {
    n.set(o, c);
  } : function(o, n, c) {
    if (o.copy)
      o.copy(n, c, 0, o.length);
    else
      for (var u = 0; u < o.length; )
        n[c++] = o[u++];
  };
}, BufferWriter.prototype.bytes = function(o) {
  util$3.isString(o) && (o = util$3._Buffer_from(o, "base64"));
  var n = o.length >>> 0;
  return this.uint32(n), n && this._push(BufferWriter.writeBytesBuffer, n, o), this;
}, BufferWriter.prototype.string = function(o) {
  var n = util$3.Buffer.byteLength(o);
  return this.uint32(n), n && this._push(writeStringBuffer, n, o), this;
}, BufferWriter._configure();
var reader = Reader$1, util$2 = requireMinimal(), BufferReader$1, LongBits = util$2.LongBits, utf8 = util$2.utf8;
function indexOutOfRange(o, n) {
  return RangeError("index out of range: " + o.pos + " + " + (n || 1) + " > " + o.len);
}
function Reader$1(o) {
  this.buf = o, this.pos = 0, this.len = o.length;
}
var create_array = typeof Uint8Array < "u" ? function(o) {
  if (o instanceof Uint8Array || Array.isArray(o))
    return new Reader$1(o);
  throw Error("illegal buffer");
} : function(o) {
  if (Array.isArray(o))
    return new Reader$1(o);
  throw Error("illegal buffer");
}, create$2 = function() {
  return util$2.Buffer ? function(o) {
    return (Reader$1.create = function(n) {
      return util$2.Buffer.isBuffer(n) ? new BufferReader$1(n) : create_array(n);
    })(o);
  } : create_array;
}, value;
function readLongVarint() {
  var o = new LongBits(0, 0), n = 0;
  if (!(this.len - this.pos > 4)) {
    for (; n < 3; ++n) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (o.lo = (o.lo | (127 & this.buf[this.pos]) << 7 * n) >>> 0, this.buf[this.pos++] < 128)
        return o;
    }
    return o.lo = (o.lo | (127 & this.buf[this.pos++]) << 7 * n) >>> 0, o;
  }
  for (; n < 4; ++n)
    if (o.lo = (o.lo | (127 & this.buf[this.pos]) << 7 * n) >>> 0, this.buf[this.pos++] < 128)
      return o;
  if (o.lo = (o.lo | (127 & this.buf[this.pos]) << 28) >>> 0, o.hi = (o.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128)
    return o;
  if (n = 0, this.len - this.pos > 4) {
    for (; n < 5; ++n)
      if (o.hi = (o.hi | (127 & this.buf[this.pos]) << 7 * n + 3) >>> 0, this.buf[this.pos++] < 128)
        return o;
  } else
    for (; n < 5; ++n) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (o.hi = (o.hi | (127 & this.buf[this.pos]) << 7 * n + 3) >>> 0, this.buf[this.pos++] < 128)
        return o;
    }
  throw Error("invalid varint encoding");
}
function readFixed32_end(o, n) {
  return (o[n - 4] | o[n - 3] << 8 | o[n - 2] << 16 | o[n - 1] << 24) >>> 0;
}
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.create = create$2(), Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice, Reader$1.prototype.uint32 = (value = 4294967295, function() {
  if (value = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128 || (value = (value | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) || (value = (value | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) || (value = (value | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) || (value = (value | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128))
    return value;
  if ((this.pos += 5) > this.len)
    throw this.pos = this.len, indexOutOfRange(this, 10);
  return value;
}), Reader$1.prototype.int32 = function() {
  return 0 | this.uint32();
}, Reader$1.prototype.sint32 = function() {
  var o = this.uint32();
  return o >>> 1 ^ -(1 & o) | 0;
}, Reader$1.prototype.bool = function() {
  return this.uint32() !== 0;
}, Reader$1.prototype.fixed32 = function() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
}, Reader$1.prototype.sfixed32 = function() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return 0 | readFixed32_end(this.buf, this.pos += 4);
}, Reader$1.prototype.float = function() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var o = util$2.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, o;
}, Reader$1.prototype.double = function() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var o = util$2.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, o;
}, Reader$1.prototype.bytes = function() {
  var o = this.uint32(), n = this.pos, c = this.pos + o;
  if (c > this.len)
    throw indexOutOfRange(this, o);
  return this.pos += o, Array.isArray(this.buf) ? this.buf.slice(n, c) : n === c ? new this.buf.constructor(0) : this._slice.call(this.buf, n, c);
}, Reader$1.prototype.string = function() {
  var o = this.bytes();
  return utf8.read(o, 0, o.length);
}, Reader$1.prototype.skip = function(o) {
  if (typeof o == "number") {
    if (this.pos + o > this.len)
      throw indexOutOfRange(this, o);
    this.pos += o;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (128 & this.buf[this.pos++]);
  return this;
}, Reader$1.prototype.skipType = function(o) {
  switch (o) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (o = 7 & this.uint32()) != 4; )
        this.skipType(o);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + o + " at offset " + this.pos);
  }
  return this;
}, Reader$1._configure = function(o) {
  BufferReader$1 = o, Reader$1.create = create$2(), BufferReader$1._configure();
  var n = util$2.Long ? "toLong" : "toNumber";
  util$2.merge(Reader$1.prototype, { int64: function() {
    return readLongVarint.call(this)[n](!1);
  }, uint64: function() {
    return readLongVarint.call(this)[n](!0);
  }, sint64: function() {
    return readLongVarint.call(this).zzDecode()[n](!1);
  }, fixed64: function() {
    return readFixed64.call(this)[n](!0);
  }, sfixed64: function() {
    return readFixed64.call(this)[n](!1);
  } });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$1 = requireMinimal();
function BufferReader(o) {
  Reader.call(this, o);
}
BufferReader._configure = function() {
  util$1.Buffer && (BufferReader.prototype._slice = util$1.Buffer.prototype.slice);
}, BufferReader.prototype.string = function() {
  var o = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + o, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + o, this.len));
}, BufferReader._configure();
var rpc = {}, service = Service, util = requireMinimal(), exports;
function Service(o, n, c) {
  if (typeof o != "function")
    throw TypeError("rpcImpl must be a function");
  util.EventEmitter.call(this), this.rpcImpl = o, this.requestDelimited = Boolean(n), this.responseDelimited = Boolean(c);
}
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service, Service.prototype.rpcCall = function o(n, c, u, h, g) {
  if (!h)
    throw TypeError("request must be specified");
  var y = this;
  if (!g)
    return util.asPromise(o, y, n, c, u, h);
  if (y.rpcImpl)
    try {
      return y.rpcImpl(n, c[y.requestDelimited ? "encodeDelimited" : "encode"](h).finish(), function($, I) {
        if ($)
          return y.emit("error", $, n), g($);
        if (I !== null) {
          if (!(I instanceof u))
            try {
              I = u[y.responseDelimited ? "decodeDelimited" : "decode"](I);
            } catch (P) {
              return y.emit("error", P, n), g(P);
            }
          return y.emit("data", I, n), g(null, I);
        }
        y.end(!0);
      });
    } catch ($) {
      return y.emit("error", $, n), void setTimeout(function() {
        g($);
      }, 0);
    }
  else
    setTimeout(function() {
      g(Error("already ended"));
    }, 0);
}, Service.prototype.end = function(o) {
  return this.rpcImpl && (o || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
}, exports = rpc, exports.Service = service;
var roots = {};
(function(o) {
  var n = indexMinimal;
  function c() {
    n.util._configure(), n.Writer._configure(n.BufferWriter), n.Reader._configure(n.BufferReader);
  }
  n.build = "minimal", n.Writer = writer, n.BufferWriter = writer_buffer, n.Reader = reader, n.BufferReader = reader_buffer, n.util = requireMinimal(), n.rpc = rpc, n.roots = roots, n.configure = c, c();
})(), minimal$1.exports = indexMinimal;
const $protobuf = getDefaultExportFromCjs(minimal$1.exports), $Reader$5 = $protobuf.Reader, $Writer$5 = $protobuf.Writer;
$protobuf.util;
const $root$5 = $protobuf.roots.default || ($protobuf.roots.default = {}), ipfs = $root$5.ipfs = (() => {
  const o = {};
  return o.pin = function() {
    const n = {};
    return n.Set = function() {
      function c(u) {
        if (u)
          for (var h = Object.keys(u), g = 0; g < h.length; ++g)
            u[h[g]] != null && (this[h[g]] = u[h[g]]);
      }
      return c.prototype.version = 0, c.prototype.fanout = 0, c.prototype.seed = 0, c.encode = function(u, h) {
        return h || (h = $Writer$5.create()), u.version != null && Object.hasOwnProperty.call(u, "version") && h.uint32(8).uint32(u.version), u.fanout != null && Object.hasOwnProperty.call(u, "fanout") && h.uint32(16).uint32(u.fanout), u.seed != null && Object.hasOwnProperty.call(u, "seed") && h.uint32(29).fixed32(u.seed), h;
      }, c.decode = function(u, h) {
        u instanceof $Reader$5 || (u = $Reader$5.create(u));
        for (var g = h === void 0 ? u.len : u.pos + h, y = new $root$5.ipfs.pin.Set(); u.pos < g; ) {
          var $ = u.uint32();
          switch ($ >>> 3) {
            case 1:
              y.version = u.uint32();
              break;
            case 2:
              y.fanout = u.uint32();
              break;
            case 3:
              y.seed = u.fixed32();
              break;
            default:
              u.skipType(7 & $);
          }
        }
        return y;
      }, c.fromObject = function(u) {
        if (u instanceof $root$5.ipfs.pin.Set)
          return u;
        var h = new $root$5.ipfs.pin.Set();
        return u.version != null && (h.version = u.version >>> 0), u.fanout != null && (h.fanout = u.fanout >>> 0), u.seed != null && (h.seed = u.seed >>> 0), h;
      }, c.toObject = function(u, h) {
        h || (h = {});
        var g = {};
        return h.defaults && (g.version = 0, g.fanout = 0, g.seed = 0), u.version != null && u.hasOwnProperty("version") && (g.version = u.version), u.fanout != null && u.hasOwnProperty("fanout") && (g.fanout = u.fanout), u.seed != null && u.hasOwnProperty("seed") && (g.seed = u.seed), g;
      }, c.prototype.toJSON = function() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      }, c;
    }(), n;
  }(), o;
})();
var fnv1a$1 = { exports: {} };
(function(o, n) {
  function c(u, h = c.BASE) {
    const g = u.length;
    for (let y = 0; y < g; y++)
      h ^= u.charCodeAt(y), h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
    return h >>> 0;
  }
  Object.defineProperty(n, "__esModule", { value: !0 }), c.BASE = 2166136261, n.default = c, o.exports = c;
})(fnv1a$1, fnv1a$1.exports);
const fnv1a = getDefaultExportFromCjs(fnv1a$1.exports), PIN_DS_KEY = new Key("/local/pins"), DEFAULT_FANOUT = 256, MAX_ITEMS = 8192, EMPTY_KEY = CID$2.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n"), PinTypes$1 = { direct: "direct", recursive: "recursive" };
function cidToKey$2(o) {
  return new Key(`/${base32$6.encode(o.multihash.bytes).toUpperCase().substring(1)}`);
}
function asUint8Array$1(o) {
  return globalThis.Buffer != null ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength) : o;
}
function allocUnsafe$1(o = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? asUint8Array$1(globalThis.Buffer.allocUnsafe(o)) : new Uint8Array(o);
}
function concat$1(o, n) {
  n || (n = o.reduce((h, g) => h + g.length, 0));
  const c = allocUnsafe$1(n);
  let u = 0;
  for (const h of o)
    c.set(h, u), u += h.length;
  return asUint8Array$1(c);
}
function compare$1(o, n) {
  for (let c = 0; c < o.byteLength; c++) {
    if (o[c] < n[c])
      return -1;
    if (o[c] > n[c])
      return 1;
  }
  return o.byteLength > n.byteLength ? 1 : o.byteLength < n.byteLength ? -1 : 0;
}
const identity$6 = from$8({ prefix: "\0", name: "identity", encode: (o) => toString$8(o), decode: (o) => fromString$6(o) }), identityBase$1 = Object.freeze(Object.defineProperty({ __proto__: null, identity: identity$6 }, Symbol.toStringTag, { value: "Module" })), base2$2 = rfc4648$4({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }), base2$3 = Object.freeze(Object.defineProperty({ __proto__: null, base2: base2$2 }, Symbol.toStringTag, { value: "Module" })), base8$2 = rfc4648$4({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 }), base8$3 = Object.freeze(Object.defineProperty({ __proto__: null, base8: base8$2 }, Symbol.toStringTag, { value: "Module" })), base10$2 = baseX$4({ prefix: "9", name: "base10", alphabet: "0123456789" }), base10$3 = Object.freeze(Object.defineProperty({ __proto__: null, base10: base10$2 }, Symbol.toStringTag, { value: "Module" })), base16$2 = rfc4648$4({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), base16upper$1 = rfc4648$4({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 }), base16$3 = Object.freeze(Object.defineProperty({ __proto__: null, base16: base16$2, base16upper: base16upper$1 }, Symbol.toStringTag, { value: "Module" })), base36$2 = baseX$4({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), base36upper$1 = baseX$4({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" }), base36$3 = Object.freeze(Object.defineProperty({ __proto__: null, base36: base36$2, base36upper: base36upper$1 }, Symbol.toStringTag, { value: "Module" })), base64$3 = rfc4648$4({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), base64pad$1 = rfc4648$4({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), base64url$1 = rfc4648$4({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), base64urlpad$1 = rfc4648$4({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 }), base64$4 = Object.freeze(Object.defineProperty({ __proto__: null, base64: base64$3, base64pad: base64pad$1, base64url: base64url$1, base64urlpad: base64urlpad$1 }, Symbol.toStringTag, { value: "Module" })), alphabet$1 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"), alphabetBytesToChars$1 = alphabet$1.reduce((o, n, c) => (o[c] = n, o), []), alphabetCharsToBytes$1 = alphabet$1.reduce((o, n, c) => (o[n.codePointAt(0)] = c, o), []);
function encode$g(o) {
  return o.reduce((n, c) => n + alphabetBytesToChars$1[c], "");
}
function decode$i(o) {
  const n = [];
  for (const c of o) {
    const u = alphabetCharsToBytes$1[c.codePointAt(0)];
    if (u === void 0)
      throw new Error(`Non-base256emoji character: ${c}`);
    n.push(u);
  }
  return new Uint8Array(n);
}
const base256emoji$2 = from$8({ prefix: "\u{1F680}", name: "base256emoji", encode: encode$g, decode: decode$i }), base256emoji$3 = Object.freeze(Object.defineProperty({ __proto__: null, base256emoji: base256emoji$2 }, Symbol.toStringTag, { value: "Module" })), code$6 = 0, name$5 = "identity", encode$f = coerce$4, digest$1 = (o) => create$6(code$6, encode$f(o)), identity$4 = { code: code$6, name: name$5, encode: encode$f, digest: digest$1 }, identity$5 = Object.freeze(Object.defineProperty({ __proto__: null, identity: identity$4 }, Symbol.toStringTag, { value: "Module" })), textEncoder$2 = new TextEncoder(), textDecoder$1 = new TextDecoder(), name$4 = "json", code$5 = 512, encode$e = (o) => textEncoder$2.encode(JSON.stringify(o)), decode$h = (o) => JSON.parse(textDecoder$1.decode(o)), json = Object.freeze(Object.defineProperty({ __proto__: null, name: name$4, code: code$5, encode: encode$e, decode: decode$h }, Symbol.toStringTag, { value: "Module" })), bases$1 = { ...identityBase$1, ...base2$3, ...base8$3, ...base10$3, ...base16$3, ...base32$7, ...base36$3, ...base58$2, ...base64$4, ...base256emoji$3 }, hashes = { ...sha2$2, ...identity$5 }, codecs = { raw, json };
function createCodec$1(o, n, c, u) {
  return { name: o, prefix: n, encoder: { name: o, prefix: n, encode: c }, decoder: { decode: u } };
}
const string$1 = createCodec$1("utf8", "u", (o) => "u" + new TextDecoder("utf8").decode(o), (o) => new TextEncoder().encode(o.substring(1))), ascii$1 = createCodec$1("ascii", "a", (o) => {
  let n = "a";
  for (let c = 0; c < o.length; c++)
    n += String.fromCharCode(o[c]);
  return n;
}, (o) => {
  const n = allocUnsafe$1((o = o.substring(1)).length);
  for (let c = 0; c < o.length; c++)
    n[c] = o.charCodeAt(c);
  return n;
}), BASES$1 = { utf8: string$1, "utf-8": string$1, hex: bases$1.base16, latin1: ascii$1, ascii: ascii$1, binary: ascii$1, ...bases$1 };
function toString$5(o, n = "utf8") {
  const c = BASES$1[n];
  if (!c)
    throw new Error(`Unsupported encoding "${n}"`);
  return n !== "utf8" && n !== "utf-8" || globalThis.Buffer == null || globalThis.Buffer.from == null ? c.encoder.encode(o).substring(1) : globalThis.Buffer.from(o.buffer, o.byteOffset, o.byteLength).toString("utf8");
}
function fromString$3(o, n = "utf8") {
  const c = BASES$1[n];
  if (!c)
    throw new Error(`Unsupported encoding "${n}"`);
  return n !== "utf8" && n !== "utf-8" || globalThis.Buffer == null || globalThis.Buffer.from == null ? c.decoder.decode(`${c.prefix}${o}`) : asUint8Array$1(globalThis.Buffer.from(o, "utf-8"));
}
const PinSet = ipfs.pin.Set;
function readHeader(o) {
  const n = o.Data;
  if (!n)
    throw new Error("No data present");
  const c = varint$4.decode(n), u = varint$4.decode.bytes;
  if (u <= 0)
    throw new Error("Invalid Set header length");
  if (u + c > n.length)
    throw new Error("Impossibly large set header length");
  const h = n.slice(u, c + u), g = PinSet.toObject(PinSet.decode(h), { defaults: !1, arrays: !0, longs: Number, objects: !1 });
  if (g.version !== 1)
    throw new Error(`Unsupported Set version: ${g.version}`);
  if (g.fanout > o.Links.length)
    throw new Error("Impossibly large fanout");
  return { header: g, data: n.slice(c + u) };
}
function hash$3(o, n) {
  const c = new Uint8Array(4);
  new DataView(c.buffer).setUint32(0, o, !0);
  const u = fromString$3(n.toString()), h = concat$1([c, u], c.byteLength + u.byteLength);
  return fnv1a(toString$5(h));
}
async function* walkItems(o, n) {
  const c = readHeader(n);
  let u = 0;
  for (const h of n.Links) {
    if (u < c.header.fanout) {
      const g = h.Hash;
      if (!EMPTY_KEY.equals(g)) {
        const y = decode$j(await o.get(g));
        yield* walkItems(o, y);
      }
    } else
      yield h.Hash;
    u++;
  }
}
async function* loadSet(o, n, c) {
  const u = n.Links.find((g) => g.Name === c);
  if (!u)
    throw new Error("No link found with name " + c);
  const h = decode$j(await o.get(u.Hash));
  yield* walkItems(o, h);
}
function storeItems(o, n) {
  return async function c(u, h) {
    const g = PinSet.encode({ version: 1, fanout: DEFAULT_FANOUT, seed: h }).finish(), y = concat$1([varint$4.encode(g.length), g]), $ = [];
    for (let P = 0; P < DEFAULT_FANOUT; P++)
      $.push({ Name: "", Tsize: 1, Hash: EMPTY_KEY });
    if (u.length <= MAX_ITEMS) {
      const P = u.map((q) => ({ link: { Name: "", Tsize: 1, Hash: q.key }, data: q.data || new Uint8Array() })).sort((q, N) => compare$1(q.link.Hash.bytes, N.link.Hash.bytes)), L = $.concat(P.map((q) => q.link));
      return { Data: concat$1([y, ...P.map((q) => q.data)]), Links: L };
    }
    {
      const P = u.reduce((q, N) => {
        const X = hash$3(h, N.key) % DEFAULT_FANOUT;
        return q[X] = X in q ? q[X].concat([N]) : [N], q;
      }, []);
      let L = 0;
      for (const q of P) {
        const N = await c(q, h + 1);
        await I(N, L), L++;
      }
      return { Data: y, Links: $ };
    }
    async function I(P, L) {
      const q = encode$h(P), N = await sha256$5.digest(q), X = CID$2.createV0(N);
      await o.put(X, q);
      const rt = P.Links.reduce((nt, st) => nt + (st.Tsize || 0), 0) + q.length;
      $[L] = { Name: "", Tsize: rt, Hash: X };
    }
  }(n, 0);
}
async function storeSet(o, n, c) {
  const u = await storeItems(o, c.map(($) => ({ key: $ }))), h = encode$h(u), g = await sha256$5.digest(h), y = CID$2.createV0(g);
  return await o.put(y, h), { Name: n, Tsize: u.Links.reduce(($, I) => $ + I.Tsize, 0) + h.length, Hash: y };
}
async function pinsToDatastore(o, n, c, u) {
  if (!await n.has(PIN_DS_KEY))
    return;
  const h = await n.get(PIN_DS_KEY), g = CID$2.decode(h), y = decode$j(await o.get(g));
  let $ = 0;
  const I = await itLength(loadSet(o, y, PinTypes$1.recursive)) + await itLength(loadSet(o, y, PinTypes$1.direct));
  for await (const P of loadSet(o, y, PinTypes$1.recursive)) {
    $++;
    const L = { depth: 1 / 0 };
    P.version !== 0 && (L.version = P.version), P.code !== code$7 && (L.codec = P.code), await c.put(cidToKey$2(P), encode$s(L)), u($ / I * 100, `Migrated recursive pin ${P}`);
  }
  for await (const P of loadSet(o, y, PinTypes$1.direct)) {
    $++;
    const L = { depth: 0 };
    P.version !== 0 && (L.version = P.version), P.code !== code$7 && (L.codec = P.code), await c.put(cidToKey$2(P), encode$s(L)), u($ / I * 100, `Migrated direct pin ${P}`);
  }
  await o.delete(g), await n.delete(PIN_DS_KEY);
}
async function pinsToDAG(o, n, c, u) {
  const h = [], g = [];
  let y = 0;
  const $ = await itLength(c.queryKeys({}));
  for await (const { key: q, value: N } of c.query({})) {
    y++;
    const X = decode$u(N), rt = CID$2.create(X.version || 0, X.codec || code$7, decode$r(base32$6.decode("b" + q.toString().toLowerCase().split("/").pop())));
    X.depth === 0 ? (u(y / $ * 100, `Reverted direct pin ${rt}`), g.push(rt)) : (u(y / $ * 100, `Reverted recursive pin ${rt}`), h.push(rt));
  }
  u(100, "Updating pin root");
  const I = encode$h({ Links: [await storeSet(o, PinTypes$1.direct, g), await storeSet(o, PinTypes$1.recursive, h)] }), P = await sha256$5.digest(I), L = CID$2.createV0(P);
  await o.put(L, I), await n.put(PIN_DS_KEY, L.bytes);
}
async function process$2(o, n, c) {
  const u = o.blocks, h = o.datastore, g = o.pins;
  await u.open(), await h.open(), await g.open();
  try {
    await c(u, h, g, n);
  } finally {
    await g.close(), await h.close(), await u.close();
  }
}
const migration$3 = { version: 9, description: "Migrates pins to datastore", migrate: (o, n = () => {
}) => process$2(o, n, pinsToDatastore), revert: (o, n = () => {
}) => process$2(o, n, pinsToDAG) };
function dbOpenFailedError(o) {
  return o = o || new Error("Cannot open database"), errCode(o, "ERR_DB_OPEN_FAILED");
}
function dbDeleteFailedError(o) {
  return o = o || new Error("Delete failed"), errCode(o, "ERR_DB_DELETE_FAILED");
}
function dbWriteFailedError(o) {
  return o = o || new Error("Write failed"), errCode(o, "ERR_DB_WRITE_FAILED");
}
function notFoundError$1(o) {
  return o = o || new Error("Not Found"), errCode(o, "ERR_NOT_FOUND");
}
const CONFIG_KEY = new Key("/config"), VERSION_KEY = new Key("/version");
function findLevelJs$1(o) {
  let n = o;
  for (; n.db || n.child; )
    if (n = n.db || n.child, n.type === "level-js" || n.constructor.name === "Level")
      return n;
}
async function hasWithFallback$1(o, n, c) {
  const u = await n(o);
  if (u)
    return u;
  const h = findLevelJs$1(c);
  return !!h && new Promise((g, y) => {
    const $ = h.store("readonly").get(o.toString());
    $.transaction.onabort = () => {
      y($.transaction.error);
    }, $.transaction.oncomplete = () => {
      g(Boolean($.result));
    };
  });
}
async function getWithFallback$1(o, n, c, u) {
  if (await c(o))
    return n(o);
  const h = findLevelJs$1(u);
  if (!h)
    throw notFoundError$1();
  return new Promise((g, y) => {
    const $ = h.store("readonly").get(o.toString());
    $.transaction.onabort = () => {
      y($.transaction.error);
    }, $.transaction.oncomplete = () => {
      if ($.result)
        return g($.result);
      y(notFoundError$1());
    };
  });
}
function wrapStore(o) {
  const n = o.get.bind(o), c = o.has.bind(o);
  return o.get = (u) => getWithFallback$1(u, n, c, o), o.has = (u) => hasWithFallback$1(u, c, o), o;
}
function wrapBackends(o) {
  return { ...o, root: wrapStore(o.root), datastore: wrapStore(o.datastore), pins: wrapStore(o.pins), keys: wrapStore(o.keys) };
}
async function keysToBinary(o, n, c = () => {
}) {
  const u = findLevelJs$1(n);
  u ? (c(`Upgrading ${o}`), await withEach(u, (h, g) => [{ type: "del", key: h }, { type: "put", key: fromString$3(h), value: g }])) : c(`${o} did not need an upgrade`);
}
async function keysToStrings(o, n, c = () => {
}) {
  const u = findLevelJs$1(n);
  u ? (c(`Downgrading ${o}`), await withEach(u, (h, g) => [{ type: "del", key: h }, { type: "put", key: toString$5(h), value: g }])) : c(`${o} did not need a downgrade`);
}
function unwrap(o) {
  return o.child ? unwrap(o.child) : o;
}
async function process$1(o, n, c) {
  const u = Object.entries(o).map(([y, $]) => ({ key: y, backend: unwrap($) })).filter(({ key: y, backend: $ }) => $.constructor.name === "LevelDatastore").map(({ key: y, backend: $ }) => ({ name: y, store: $ }));
  n(0, `Migrating ${u.length} dbs`);
  let h = 0;
  const g = (y) => {
    n(Math.round(h / u.length * 100), y);
  };
  for (const { name: y, store: $ } of u) {
    await $.open();
    try {
      await c(y, $, g);
    } finally {
      h++, await $.close();
    }
  }
  n(100, `Migrated ${u.length} dbs`);
}
const migration$2 = { version: 10, description: "Migrates datastore-level keys to binary", migrate: (o, n = () => {
}) => process$1(o, n, keysToBinary), revert: (o, n = () => {
}) => process$1(o, n, keysToStrings) };
function withEach(o, n) {
  return new Promise((c, u) => {
    const h = o.iterator();
    h._deserializeKey = h._deserializeValue = (g) => g, function g() {
      h.next((y, $, I) => {
        if (y || $ === void 0) {
          const P = (L) => {
            L ? u(L) : c();
          };
          h.end(P);
        } else
          (function(P, L) {
            const q = o.store("readwrite"), N = q.transaction;
            let X, rt = 0;
            N.onabort = () => L(X || N.error || new Error("aborted by user")), N.oncomplete = () => L(), function nt() {
              const st = P[rt++], ot = st.key;
              let St;
              try {
                St = st.type === "del" ? q.delete(ot) : q.put(st.value, ot);
              } catch (Ct) {
                return X = Ct, void N.abort();
              }
              rt < P.length && (St.onsuccess = nt);
            }();
          })(n($, I), g);
      });
    }();
  });
}
const MFS_ROOT_KEY$1 = new Key("/local/filesroot");
async function storeMfsRootInDatastore(o, n = () => {
}) {
  if (n(100, "Migrating MFS root to repo datastore"), await o.root.open(), await o.datastore.open(), await o.root.has(MFS_ROOT_KEY$1)) {
    const c = await o.root.get(MFS_ROOT_KEY$1);
    await o.datastore.put(MFS_ROOT_KEY$1, c), await o.root.delete(MFS_ROOT_KEY$1);
  }
  await o.datastore.close(), await o.root.close(), n(100, "Stored MFS root in repo datastore");
}
async function storeMfsRootInRoot(o, n = () => {
}) {
  if (n(100, "Migrating MFS root to repo root datastore"), await o.root.open(), await o.datastore.open(), await o.datastore.has(MFS_ROOT_KEY$1)) {
    const c = await o.datastore.get(MFS_ROOT_KEY$1);
    await o.root.put(MFS_ROOT_KEY$1, c), await o.datastore.delete(MFS_ROOT_KEY$1);
  }
  await o.datastore.close(), await o.root.close(), n(100, "Stored MFS root in repo root datastore");
}
const migration$1 = { version: 11, description: "Store mfs root in the datastore", migrate: storeMfsRootInDatastore, revert: storeMfsRootInRoot }, $Reader$4 = $protobuf.Reader, $Writer$4 = $protobuf.Writer, $util$4 = $protobuf.util, $root$4 = $protobuf.roots.default || ($protobuf.roots.default = {}), Protocols = $root$4.Protocols = (() => {
  function o(n) {
    if (this.protocols = [], n)
      for (var c = Object.keys(n), u = 0; u < c.length; ++u)
        n[c[u]] != null && (this[c[u]] = n[c[u]]);
  }
  return o.prototype.protocols = $util$4.emptyArray, o.encode = function(n, c) {
    if (c || (c = $Writer$4.create()), n.protocols != null && n.protocols.length)
      for (var u = 0; u < n.protocols.length; ++u)
        c.uint32(10).string(n.protocols[u]);
    return c;
  }, o.decode = function(n, c) {
    n instanceof $Reader$4 || (n = $Reader$4.create(n));
    for (var u = c === void 0 ? n.len : n.pos + c, h = new $root$4.Protocols(); n.pos < u; ) {
      var g = n.uint32();
      g >>> 3 == 1 ? (h.protocols && h.protocols.length || (h.protocols = []), h.protocols.push(n.string())) : n.skipType(7 & g);
    }
    return h;
  }, o.fromObject = function(n) {
    if (n instanceof $root$4.Protocols)
      return n;
    var c = new $root$4.Protocols();
    if (n.protocols) {
      if (!Array.isArray(n.protocols))
        throw TypeError(".Protocols.protocols: array expected");
      c.protocols = [];
      for (var u = 0; u < n.protocols.length; ++u)
        c.protocols[u] = String(n.protocols[u]);
    }
    return c;
  }, o.toObject = function(n, c) {
    c || (c = {});
    var u = {};
    if ((c.arrays || c.defaults) && (u.protocols = []), n.protocols && n.protocols.length) {
      u.protocols = [];
      for (var h = 0; h < n.protocols.length; ++h)
        u.protocols[h] = n.protocols[h];
    }
    return u;
  }, o.prototype.toJSON = function() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  }, o;
})(), $Reader$3 = $protobuf.Reader, $Writer$3 = $protobuf.Writer, $util$3 = $protobuf.util, $root$3 = $protobuf.roots.default || ($protobuf.roots.default = {}), Addresses = $root$3.Addresses = (() => {
  function o(n) {
    if (this.addrs = [], n)
      for (var c = Object.keys(n), u = 0; u < c.length; ++u)
        n[c[u]] != null && (this[c[u]] = n[c[u]]);
  }
  return o.prototype.addrs = $util$3.emptyArray, o.prototype.certifiedRecord = null, o.encode = function(n, c) {
    if (c || (c = $Writer$3.create()), n.addrs != null && n.addrs.length)
      for (var u = 0; u < n.addrs.length; ++u)
        $root$3.Addresses.Address.encode(n.addrs[u], c.uint32(10).fork()).ldelim();
    return n.certifiedRecord != null && Object.hasOwnProperty.call(n, "certifiedRecord") && $root$3.Addresses.CertifiedRecord.encode(n.certifiedRecord, c.uint32(18).fork()).ldelim(), c;
  }, o.decode = function(n, c) {
    n instanceof $Reader$3 || (n = $Reader$3.create(n));
    for (var u = c === void 0 ? n.len : n.pos + c, h = new $root$3.Addresses(); n.pos < u; ) {
      var g = n.uint32();
      switch (g >>> 3) {
        case 1:
          h.addrs && h.addrs.length || (h.addrs = []), h.addrs.push($root$3.Addresses.Address.decode(n, n.uint32()));
          break;
        case 2:
          h.certifiedRecord = $root$3.Addresses.CertifiedRecord.decode(n, n.uint32());
          break;
        default:
          n.skipType(7 & g);
      }
    }
    return h;
  }, o.fromObject = function(n) {
    if (n instanceof $root$3.Addresses)
      return n;
    var c = new $root$3.Addresses();
    if (n.addrs) {
      if (!Array.isArray(n.addrs))
        throw TypeError(".Addresses.addrs: array expected");
      c.addrs = [];
      for (var u = 0; u < n.addrs.length; ++u) {
        if (typeof n.addrs[u] != "object")
          throw TypeError(".Addresses.addrs: object expected");
        c.addrs[u] = $root$3.Addresses.Address.fromObject(n.addrs[u]);
      }
    }
    if (n.certifiedRecord != null) {
      if (typeof n.certifiedRecord != "object")
        throw TypeError(".Addresses.certifiedRecord: object expected");
      c.certifiedRecord = $root$3.Addresses.CertifiedRecord.fromObject(n.certifiedRecord);
    }
    return c;
  }, o.toObject = function(n, c) {
    c || (c = {});
    var u = {};
    if ((c.arrays || c.defaults) && (u.addrs = []), c.defaults && (u.certifiedRecord = null), n.addrs && n.addrs.length) {
      u.addrs = [];
      for (var h = 0; h < n.addrs.length; ++h)
        u.addrs[h] = $root$3.Addresses.Address.toObject(n.addrs[h], c);
    }
    return n.certifiedRecord != null && n.hasOwnProperty("certifiedRecord") && (u.certifiedRecord = $root$3.Addresses.CertifiedRecord.toObject(n.certifiedRecord, c)), u;
  }, o.prototype.toJSON = function() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  }, o.Address = function() {
    function n(u) {
      if (u)
        for (var h = Object.keys(u), g = 0; g < h.length; ++g)
          u[h[g]] != null && (this[h[g]] = u[h[g]]);
    }
    let c;
    return n.prototype.multiaddr = $util$3.newBuffer([]), n.prototype.isCertified = null, Object.defineProperty(n.prototype, "_isCertified", { get: $util$3.oneOfGetter(c = ["isCertified"]), set: $util$3.oneOfSetter(c) }), n.encode = function(u, h) {
      return h || (h = $Writer$3.create()), u.multiaddr != null && Object.hasOwnProperty.call(u, "multiaddr") && h.uint32(10).bytes(u.multiaddr), u.isCertified != null && Object.hasOwnProperty.call(u, "isCertified") && h.uint32(16).bool(u.isCertified), h;
    }, n.decode = function(u, h) {
      u instanceof $Reader$3 || (u = $Reader$3.create(u));
      for (var g = h === void 0 ? u.len : u.pos + h, y = new $root$3.Addresses.Address(); u.pos < g; ) {
        var $ = u.uint32();
        switch ($ >>> 3) {
          case 1:
            y.multiaddr = u.bytes();
            break;
          case 2:
            y.isCertified = u.bool();
            break;
          default:
            u.skipType(7 & $);
        }
      }
      return y;
    }, n.fromObject = function(u) {
      if (u instanceof $root$3.Addresses.Address)
        return u;
      var h = new $root$3.Addresses.Address();
      return u.multiaddr != null && (typeof u.multiaddr == "string" ? $util$3.base64.decode(u.multiaddr, h.multiaddr = $util$3.newBuffer($util$3.base64.length(u.multiaddr)), 0) : u.multiaddr.length && (h.multiaddr = u.multiaddr)), u.isCertified != null && (h.isCertified = Boolean(u.isCertified)), h;
    }, n.toObject = function(u, h) {
      h || (h = {});
      var g = {};
      return h.defaults && (h.bytes === String ? g.multiaddr = "" : (g.multiaddr = [], h.bytes !== Array && (g.multiaddr = $util$3.newBuffer(g.multiaddr)))), u.multiaddr != null && u.hasOwnProperty("multiaddr") && (g.multiaddr = h.bytes === String ? $util$3.base64.encode(u.multiaddr, 0, u.multiaddr.length) : h.bytes === Array ? Array.prototype.slice.call(u.multiaddr) : u.multiaddr), u.isCertified != null && u.hasOwnProperty("isCertified") && (g.isCertified = u.isCertified, h.oneofs && (g._isCertified = "isCertified")), g;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    }, n;
  }(), o.CertifiedRecord = function() {
    function n(c) {
      if (c)
        for (var u = Object.keys(c), h = 0; h < u.length; ++h)
          c[u[h]] != null && (this[u[h]] = c[u[h]]);
    }
    return n.prototype.seq = $util$3.Long ? $util$3.Long.fromBits(0, 0, !0) : 0, n.prototype.raw = $util$3.newBuffer([]), n.encode = function(c, u) {
      return u || (u = $Writer$3.create()), c.seq != null && Object.hasOwnProperty.call(c, "seq") && u.uint32(8).uint64(c.seq), c.raw != null && Object.hasOwnProperty.call(c, "raw") && u.uint32(18).bytes(c.raw), u;
    }, n.decode = function(c, u) {
      c instanceof $Reader$3 || (c = $Reader$3.create(c));
      for (var h = u === void 0 ? c.len : c.pos + u, g = new $root$3.Addresses.CertifiedRecord(); c.pos < h; ) {
        var y = c.uint32();
        switch (y >>> 3) {
          case 1:
            g.seq = c.uint64();
            break;
          case 2:
            g.raw = c.bytes();
            break;
          default:
            c.skipType(7 & y);
        }
      }
      return g;
    }, n.fromObject = function(c) {
      if (c instanceof $root$3.Addresses.CertifiedRecord)
        return c;
      var u = new $root$3.Addresses.CertifiedRecord();
      return c.seq != null && ($util$3.Long ? (u.seq = $util$3.Long.fromValue(c.seq)).unsigned = !0 : typeof c.seq == "string" ? u.seq = parseInt(c.seq, 10) : typeof c.seq == "number" ? u.seq = c.seq : typeof c.seq == "object" && (u.seq = new $util$3.LongBits(c.seq.low >>> 0, c.seq.high >>> 0).toNumber(!0))), c.raw != null && (typeof c.raw == "string" ? $util$3.base64.decode(c.raw, u.raw = $util$3.newBuffer($util$3.base64.length(c.raw)), 0) : c.raw.length && (u.raw = c.raw)), u;
    }, n.toObject = function(c, u) {
      u || (u = {});
      var h = {};
      if (u.defaults) {
        if ($util$3.Long) {
          var g = new $util$3.Long(0, 0, !0);
          h.seq = u.longs === String ? g.toString() : u.longs === Number ? g.toNumber() : g;
        } else
          h.seq = u.longs === String ? "0" : 0;
        u.bytes === String ? h.raw = "" : (h.raw = [], u.bytes !== Array && (h.raw = $util$3.newBuffer(h.raw)));
      }
      return c.seq != null && c.hasOwnProperty("seq") && (typeof c.seq == "number" ? h.seq = u.longs === String ? String(c.seq) : c.seq : h.seq = u.longs === String ? $util$3.Long.prototype.toString.call(c.seq) : u.longs === Number ? new $util$3.LongBits(c.seq.low >>> 0, c.seq.high >>> 0).toNumber(!0) : c.seq), c.raw != null && c.hasOwnProperty("raw") && (h.raw = u.bytes === String ? $util$3.base64.encode(c.raw, 0, c.raw.length) : u.bytes === Array ? Array.prototype.slice.call(c.raw) : c.raw), h;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    }, n;
  }(), o;
})(), $Reader$2 = $protobuf.Reader, $Writer$2 = $protobuf.Writer, $util$2 = $protobuf.util, $root$2 = $protobuf.roots.default || ($protobuf.roots.default = {}), Peer = $root$2.Peer = (() => {
  function o(c) {
    if (this.addresses = [], this.protocols = [], this.metadata = [], c)
      for (var u = Object.keys(c), h = 0; h < u.length; ++h)
        c[u[h]] != null && (this[u[h]] = c[u[h]]);
  }
  let n;
  return o.prototype.addresses = $util$2.emptyArray, o.prototype.protocols = $util$2.emptyArray, o.prototype.metadata = $util$2.emptyArray, o.prototype.pubKey = null, o.prototype.peerRecordEnvelope = null, Object.defineProperty(o.prototype, "_pubKey", { get: $util$2.oneOfGetter(n = ["pubKey"]), set: $util$2.oneOfSetter(n) }), Object.defineProperty(o.prototype, "_peerRecordEnvelope", { get: $util$2.oneOfGetter(n = ["peerRecordEnvelope"]), set: $util$2.oneOfSetter(n) }), o.encode = function(c, u) {
    if (u || (u = $Writer$2.create()), c.addresses != null && c.addresses.length)
      for (var h = 0; h < c.addresses.length; ++h)
        $root$2.Address.encode(c.addresses[h], u.uint32(10).fork()).ldelim();
    if (c.protocols != null && c.protocols.length)
      for (h = 0; h < c.protocols.length; ++h)
        u.uint32(18).string(c.protocols[h]);
    if (c.metadata != null && c.metadata.length)
      for (h = 0; h < c.metadata.length; ++h)
        $root$2.Metadata.encode(c.metadata[h], u.uint32(26).fork()).ldelim();
    return c.pubKey != null && Object.hasOwnProperty.call(c, "pubKey") && u.uint32(34).bytes(c.pubKey), c.peerRecordEnvelope != null && Object.hasOwnProperty.call(c, "peerRecordEnvelope") && u.uint32(42).bytes(c.peerRecordEnvelope), u;
  }, o.decode = function(c, u) {
    c instanceof $Reader$2 || (c = $Reader$2.create(c));
    for (var h = u === void 0 ? c.len : c.pos + u, g = new $root$2.Peer(); c.pos < h; ) {
      var y = c.uint32();
      switch (y >>> 3) {
        case 1:
          g.addresses && g.addresses.length || (g.addresses = []), g.addresses.push($root$2.Address.decode(c, c.uint32()));
          break;
        case 2:
          g.protocols && g.protocols.length || (g.protocols = []), g.protocols.push(c.string());
          break;
        case 3:
          g.metadata && g.metadata.length || (g.metadata = []), g.metadata.push($root$2.Metadata.decode(c, c.uint32()));
          break;
        case 4:
          g.pubKey = c.bytes();
          break;
        case 5:
          g.peerRecordEnvelope = c.bytes();
          break;
        default:
          c.skipType(7 & y);
      }
    }
    return g;
  }, o.fromObject = function(c) {
    if (c instanceof $root$2.Peer)
      return c;
    var u = new $root$2.Peer();
    if (c.addresses) {
      if (!Array.isArray(c.addresses))
        throw TypeError(".Peer.addresses: array expected");
      u.addresses = [];
      for (var h = 0; h < c.addresses.length; ++h) {
        if (typeof c.addresses[h] != "object")
          throw TypeError(".Peer.addresses: object expected");
        u.addresses[h] = $root$2.Address.fromObject(c.addresses[h]);
      }
    }
    if (c.protocols) {
      if (!Array.isArray(c.protocols))
        throw TypeError(".Peer.protocols: array expected");
      for (u.protocols = [], h = 0; h < c.protocols.length; ++h)
        u.protocols[h] = String(c.protocols[h]);
    }
    if (c.metadata) {
      if (!Array.isArray(c.metadata))
        throw TypeError(".Peer.metadata: array expected");
      for (u.metadata = [], h = 0; h < c.metadata.length; ++h) {
        if (typeof c.metadata[h] != "object")
          throw TypeError(".Peer.metadata: object expected");
        u.metadata[h] = $root$2.Metadata.fromObject(c.metadata[h]);
      }
    }
    return c.pubKey != null && (typeof c.pubKey == "string" ? $util$2.base64.decode(c.pubKey, u.pubKey = $util$2.newBuffer($util$2.base64.length(c.pubKey)), 0) : c.pubKey.length && (u.pubKey = c.pubKey)), c.peerRecordEnvelope != null && (typeof c.peerRecordEnvelope == "string" ? $util$2.base64.decode(c.peerRecordEnvelope, u.peerRecordEnvelope = $util$2.newBuffer($util$2.base64.length(c.peerRecordEnvelope)), 0) : c.peerRecordEnvelope.length && (u.peerRecordEnvelope = c.peerRecordEnvelope)), u;
  }, o.toObject = function(c, u) {
    u || (u = {});
    var h = {};
    if ((u.arrays || u.defaults) && (h.addresses = [], h.protocols = [], h.metadata = []), c.addresses && c.addresses.length) {
      h.addresses = [];
      for (var g = 0; g < c.addresses.length; ++g)
        h.addresses[g] = $root$2.Address.toObject(c.addresses[g], u);
    }
    if (c.protocols && c.protocols.length)
      for (h.protocols = [], g = 0; g < c.protocols.length; ++g)
        h.protocols[g] = c.protocols[g];
    if (c.metadata && c.metadata.length)
      for (h.metadata = [], g = 0; g < c.metadata.length; ++g)
        h.metadata[g] = $root$2.Metadata.toObject(c.metadata[g], u);
    return c.pubKey != null && c.hasOwnProperty("pubKey") && (h.pubKey = u.bytes === String ? $util$2.base64.encode(c.pubKey, 0, c.pubKey.length) : u.bytes === Array ? Array.prototype.slice.call(c.pubKey) : c.pubKey, u.oneofs && (h._pubKey = "pubKey")), c.peerRecordEnvelope != null && c.hasOwnProperty("peerRecordEnvelope") && (h.peerRecordEnvelope = u.bytes === String ? $util$2.base64.encode(c.peerRecordEnvelope, 0, c.peerRecordEnvelope.length) : u.bytes === Array ? Array.prototype.slice.call(c.peerRecordEnvelope) : c.peerRecordEnvelope, u.oneofs && (h._peerRecordEnvelope = "peerRecordEnvelope")), h;
  }, o.prototype.toJSON = function() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  }, o;
})();
$root$2.Address = (() => {
  function o(c) {
    if (c)
      for (var u = Object.keys(c), h = 0; h < u.length; ++h)
        c[u[h]] != null && (this[u[h]] = c[u[h]]);
  }
  let n;
  return o.prototype.multiaddr = $util$2.newBuffer([]), o.prototype.isCertified = null, Object.defineProperty(o.prototype, "_isCertified", { get: $util$2.oneOfGetter(n = ["isCertified"]), set: $util$2.oneOfSetter(n) }), o.encode = function(c, u) {
    return u || (u = $Writer$2.create()), c.multiaddr != null && Object.hasOwnProperty.call(c, "multiaddr") && u.uint32(10).bytes(c.multiaddr), c.isCertified != null && Object.hasOwnProperty.call(c, "isCertified") && u.uint32(16).bool(c.isCertified), u;
  }, o.decode = function(c, u) {
    c instanceof $Reader$2 || (c = $Reader$2.create(c));
    for (var h = u === void 0 ? c.len : c.pos + u, g = new $root$2.Address(); c.pos < h; ) {
      var y = c.uint32();
      switch (y >>> 3) {
        case 1:
          g.multiaddr = c.bytes();
          break;
        case 2:
          g.isCertified = c.bool();
          break;
        default:
          c.skipType(7 & y);
      }
    }
    return g;
  }, o.fromObject = function(c) {
    if (c instanceof $root$2.Address)
      return c;
    var u = new $root$2.Address();
    return c.multiaddr != null && (typeof c.multiaddr == "string" ? $util$2.base64.decode(c.multiaddr, u.multiaddr = $util$2.newBuffer($util$2.base64.length(c.multiaddr)), 0) : c.multiaddr.length && (u.multiaddr = c.multiaddr)), c.isCertified != null && (u.isCertified = Boolean(c.isCertified)), u;
  }, o.toObject = function(c, u) {
    u || (u = {});
    var h = {};
    return u.defaults && (u.bytes === String ? h.multiaddr = "" : (h.multiaddr = [], u.bytes !== Array && (h.multiaddr = $util$2.newBuffer(h.multiaddr)))), c.multiaddr != null && c.hasOwnProperty("multiaddr") && (h.multiaddr = u.bytes === String ? $util$2.base64.encode(c.multiaddr, 0, c.multiaddr.length) : u.bytes === Array ? Array.prototype.slice.call(c.multiaddr) : c.multiaddr), c.isCertified != null && c.hasOwnProperty("isCertified") && (h.isCertified = c.isCertified, u.oneofs && (h._isCertified = "isCertified")), h;
  }, o.prototype.toJSON = function() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  }, o;
})(), $root$2.Metadata = (() => {
  function o(n) {
    if (n)
      for (var c = Object.keys(n), u = 0; u < c.length; ++u)
        n[c[u]] != null && (this[c[u]] = n[c[u]]);
  }
  return o.prototype.key = "", o.prototype.value = $util$2.newBuffer([]), o.encode = function(n, c) {
    return c || (c = $Writer$2.create()), n.key != null && Object.hasOwnProperty.call(n, "key") && c.uint32(10).string(n.key), n.value != null && Object.hasOwnProperty.call(n, "value") && c.uint32(18).bytes(n.value), c;
  }, o.decode = function(n, c) {
    n instanceof $Reader$2 || (n = $Reader$2.create(n));
    for (var u = c === void 0 ? n.len : n.pos + c, h = new $root$2.Metadata(); n.pos < u; ) {
      var g = n.uint32();
      switch (g >>> 3) {
        case 1:
          h.key = n.string();
          break;
        case 2:
          h.value = n.bytes();
          break;
        default:
          n.skipType(7 & g);
      }
    }
    return h;
  }, o.fromObject = function(n) {
    if (n instanceof $root$2.Metadata)
      return n;
    var c = new $root$2.Metadata();
    return n.key != null && (c.key = String(n.key)), n.value != null && (typeof n.value == "string" ? $util$2.base64.decode(n.value, c.value = $util$2.newBuffer($util$2.base64.length(n.value)), 0) : n.value.length && (c.value = n.value)), c;
  }, o.toObject = function(n, c) {
    c || (c = {});
    var u = {};
    return c.defaults && (u.key = "", c.bytes === String ? u.value = "" : (u.value = [], c.bytes !== Array && (u.value = $util$2.newBuffer(u.value)))), n.key != null && n.hasOwnProperty("key") && (u.key = n.key), n.value != null && n.hasOwnProperty("value") && (u.value = c.bytes === String ? $util$2.base64.encode(n.value, 0, n.value.length) : c.bytes === Array ? Array.prototype.slice.call(n.value) : n.value), u;
  }, o.prototype.toJSON = function() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  }, o;
})();
const $Reader$1 = $protobuf.Reader, $Writer$1 = $protobuf.Writer, $util$1 = $protobuf.util, $root$1 = $protobuf.roots.default || ($protobuf.roots.default = {}), Envelope = $root$1.Envelope = (() => {
  function o(n) {
    if (n)
      for (var c = Object.keys(n), u = 0; u < c.length; ++u)
        n[c[u]] != null && (this[c[u]] = n[c[u]]);
  }
  return o.prototype.publicKey = $util$1.newBuffer([]), o.prototype.payloadType = $util$1.newBuffer([]), o.prototype.payload = $util$1.newBuffer([]), o.prototype.signature = $util$1.newBuffer([]), o.encode = function(n, c) {
    return c || (c = $Writer$1.create()), n.publicKey != null && Object.hasOwnProperty.call(n, "publicKey") && c.uint32(10).bytes(n.publicKey), n.payloadType != null && Object.hasOwnProperty.call(n, "payloadType") && c.uint32(18).bytes(n.payloadType), n.payload != null && Object.hasOwnProperty.call(n, "payload") && c.uint32(26).bytes(n.payload), n.signature != null && Object.hasOwnProperty.call(n, "signature") && c.uint32(42).bytes(n.signature), c;
  }, o.decode = function(n, c) {
    n instanceof $Reader$1 || (n = $Reader$1.create(n));
    for (var u = c === void 0 ? n.len : n.pos + c, h = new $root$1.Envelope(); n.pos < u; ) {
      var g = n.uint32();
      switch (g >>> 3) {
        case 1:
          h.publicKey = n.bytes();
          break;
        case 2:
          h.payloadType = n.bytes();
          break;
        case 3:
          h.payload = n.bytes();
          break;
        case 5:
          h.signature = n.bytes();
          break;
        default:
          n.skipType(7 & g);
      }
    }
    return h;
  }, o.fromObject = function(n) {
    if (n instanceof $root$1.Envelope)
      return n;
    var c = new $root$1.Envelope();
    return n.publicKey != null && (typeof n.publicKey == "string" ? $util$1.base64.decode(n.publicKey, c.publicKey = $util$1.newBuffer($util$1.base64.length(n.publicKey)), 0) : n.publicKey.length && (c.publicKey = n.publicKey)), n.payloadType != null && (typeof n.payloadType == "string" ? $util$1.base64.decode(n.payloadType, c.payloadType = $util$1.newBuffer($util$1.base64.length(n.payloadType)), 0) : n.payloadType.length && (c.payloadType = n.payloadType)), n.payload != null && (typeof n.payload == "string" ? $util$1.base64.decode(n.payload, c.payload = $util$1.newBuffer($util$1.base64.length(n.payload)), 0) : n.payload.length && (c.payload = n.payload)), n.signature != null && (typeof n.signature == "string" ? $util$1.base64.decode(n.signature, c.signature = $util$1.newBuffer($util$1.base64.length(n.signature)), 0) : n.signature.length && (c.signature = n.signature)), c;
  }, o.toObject = function(n, c) {
    c || (c = {});
    var u = {};
    return c.defaults && (c.bytes === String ? u.publicKey = "" : (u.publicKey = [], c.bytes !== Array && (u.publicKey = $util$1.newBuffer(u.publicKey))), c.bytes === String ? u.payloadType = "" : (u.payloadType = [], c.bytes !== Array && (u.payloadType = $util$1.newBuffer(u.payloadType))), c.bytes === String ? u.payload = "" : (u.payload = [], c.bytes !== Array && (u.payload = $util$1.newBuffer(u.payload))), c.bytes === String ? u.signature = "" : (u.signature = [], c.bytes !== Array && (u.signature = $util$1.newBuffer(u.signature)))), n.publicKey != null && n.hasOwnProperty("publicKey") && (u.publicKey = c.bytes === String ? $util$1.base64.encode(n.publicKey, 0, n.publicKey.length) : c.bytes === Array ? Array.prototype.slice.call(n.publicKey) : n.publicKey), n.payloadType != null && n.hasOwnProperty("payloadType") && (u.payloadType = c.bytes === String ? $util$1.base64.encode(n.payloadType, 0, n.payloadType.length) : c.bytes === Array ? Array.prototype.slice.call(n.payloadType) : n.payloadType), n.payload != null && n.hasOwnProperty("payload") && (u.payload = c.bytes === String ? $util$1.base64.encode(n.payload, 0, n.payload.length) : c.bytes === Array ? Array.prototype.slice.call(n.payload) : n.payload), n.signature != null && n.hasOwnProperty("signature") && (u.signature = c.bytes === String ? $util$1.base64.encode(n.signature, 0, n.signature.length) : c.bytes === Array ? Array.prototype.slice.call(n.signature) : n.signature), u;
  }, o.prototype.toJSON = function() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  }, o;
})(), $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util, $root = $protobuf.roots.default || ($protobuf.roots.default = {}), PeerRecord = $root.PeerRecord = (() => {
  function o(n) {
    if (this.addresses = [], n)
      for (var c = Object.keys(n), u = 0; u < c.length; ++u)
        n[c[u]] != null && (this[c[u]] = n[c[u]]);
  }
  return o.prototype.peerId = $util.newBuffer([]), o.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, !0) : 0, o.prototype.addresses = $util.emptyArray, o.encode = function(n, c) {
    if (c || (c = $Writer.create()), n.peerId != null && Object.hasOwnProperty.call(n, "peerId") && c.uint32(10).bytes(n.peerId), n.seq != null && Object.hasOwnProperty.call(n, "seq") && c.uint32(16).uint64(n.seq), n.addresses != null && n.addresses.length)
      for (var u = 0; u < n.addresses.length; ++u)
        $root.PeerRecord.AddressInfo.encode(n.addresses[u], c.uint32(26).fork()).ldelim();
    return c;
  }, o.decode = function(n, c) {
    n instanceof $Reader || (n = $Reader.create(n));
    for (var u = c === void 0 ? n.len : n.pos + c, h = new $root.PeerRecord(); n.pos < u; ) {
      var g = n.uint32();
      switch (g >>> 3) {
        case 1:
          h.peerId = n.bytes();
          break;
        case 2:
          h.seq = n.uint64();
          break;
        case 3:
          h.addresses && h.addresses.length || (h.addresses = []), h.addresses.push($root.PeerRecord.AddressInfo.decode(n, n.uint32()));
          break;
        default:
          n.skipType(7 & g);
      }
    }
    return h;
  }, o.fromObject = function(n) {
    if (n instanceof $root.PeerRecord)
      return n;
    var c = new $root.PeerRecord();
    if (n.peerId != null && (typeof n.peerId == "string" ? $util.base64.decode(n.peerId, c.peerId = $util.newBuffer($util.base64.length(n.peerId)), 0) : n.peerId.length && (c.peerId = n.peerId)), n.seq != null && ($util.Long ? (c.seq = $util.Long.fromValue(n.seq)).unsigned = !0 : typeof n.seq == "string" ? c.seq = parseInt(n.seq, 10) : typeof n.seq == "number" ? c.seq = n.seq : typeof n.seq == "object" && (c.seq = new $util.LongBits(n.seq.low >>> 0, n.seq.high >>> 0).toNumber(!0))), n.addresses) {
      if (!Array.isArray(n.addresses))
        throw TypeError(".PeerRecord.addresses: array expected");
      c.addresses = [];
      for (var u = 0; u < n.addresses.length; ++u) {
        if (typeof n.addresses[u] != "object")
          throw TypeError(".PeerRecord.addresses: object expected");
        c.addresses[u] = $root.PeerRecord.AddressInfo.fromObject(n.addresses[u]);
      }
    }
    return c;
  }, o.toObject = function(n, c) {
    c || (c = {});
    var u = {};
    if ((c.arrays || c.defaults) && (u.addresses = []), c.defaults)
      if (c.bytes === String ? u.peerId = "" : (u.peerId = [], c.bytes !== Array && (u.peerId = $util.newBuffer(u.peerId))), $util.Long) {
        var h = new $util.Long(0, 0, !0);
        u.seq = c.longs === String ? h.toString() : c.longs === Number ? h.toNumber() : h;
      } else
        u.seq = c.longs === String ? "0" : 0;
    if (n.peerId != null && n.hasOwnProperty("peerId") && (u.peerId = c.bytes === String ? $util.base64.encode(n.peerId, 0, n.peerId.length) : c.bytes === Array ? Array.prototype.slice.call(n.peerId) : n.peerId), n.seq != null && n.hasOwnProperty("seq") && (typeof n.seq == "number" ? u.seq = c.longs === String ? String(n.seq) : n.seq : u.seq = c.longs === String ? $util.Long.prototype.toString.call(n.seq) : c.longs === Number ? new $util.LongBits(n.seq.low >>> 0, n.seq.high >>> 0).toNumber(!0) : n.seq), n.addresses && n.addresses.length) {
      u.addresses = [];
      for (var g = 0; g < n.addresses.length; ++g)
        u.addresses[g] = $root.PeerRecord.AddressInfo.toObject(n.addresses[g], c);
    }
    return u;
  }, o.prototype.toJSON = function() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  }, o.AddressInfo = function() {
    function n(c) {
      if (c)
        for (var u = Object.keys(c), h = 0; h < u.length; ++h)
          c[u[h]] != null && (this[u[h]] = c[u[h]]);
    }
    return n.prototype.multiaddr = $util.newBuffer([]), n.encode = function(c, u) {
      return u || (u = $Writer.create()), c.multiaddr != null && Object.hasOwnProperty.call(c, "multiaddr") && u.uint32(10).bytes(c.multiaddr), u;
    }, n.decode = function(c, u) {
      c instanceof $Reader || (c = $Reader.create(c));
      for (var h = u === void 0 ? c.len : c.pos + u, g = new $root.PeerRecord.AddressInfo(); c.pos < h; ) {
        var y = c.uint32();
        y >>> 3 == 1 ? g.multiaddr = c.bytes() : c.skipType(7 & y);
      }
      return g;
    }, n.fromObject = function(c) {
      if (c instanceof $root.PeerRecord.AddressInfo)
        return c;
      var u = new $root.PeerRecord.AddressInfo();
      return c.multiaddr != null && (typeof c.multiaddr == "string" ? $util.base64.decode(c.multiaddr, u.multiaddr = $util.newBuffer($util.base64.length(c.multiaddr)), 0) : c.multiaddr.length && (u.multiaddr = c.multiaddr)), u;
    }, n.toObject = function(c, u) {
      u || (u = {});
      var h = {};
      return u.defaults && (u.bytes === String ? h.multiaddr = "" : (h.multiaddr = [], u.bytes !== Array && (h.multiaddr = $util.newBuffer(h.multiaddr)))), c.multiaddr != null && c.hasOwnProperty("multiaddr") && (h.multiaddr = u.bytes === String ? $util.base64.encode(c.multiaddr, 0, c.multiaddr.length) : u.bytes === Array ? Array.prototype.slice.call(c.multiaddr) : c.multiaddr), h;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    }, n;
  }(), o;
})(), word = "[a-fA-F\\d:]", boundry = (o) => o && o.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "", v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", v6segment = "[a-fA-F\\d]{1,4}", v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`), v4exact = new RegExp(`^${v4}$`), v6exact = new RegExp(`^${v6}$`), ipRegex = (o) => o && o.exact ? v46Exact : new RegExp(`(?:${boundry(o)}${v4}${boundry(o)})|(?:${boundry(o)}${v6}${boundry(o)})`, "g");
function functionTimeout(o) {
  const n = (...c) => o(...c);
  return Object.defineProperty(n, "name", { value: `functionTimeout(${o.name || "<anonymous>"})`, configurable: !0 }), n;
}
ipRegex.v4 = (o) => o && o.exact ? v4exact : new RegExp(`${boundry(o)}${v4}${boundry(o)}`, "g"), ipRegex.v6 = (o) => o && o.exact ? v6exact : new RegExp(`${boundry(o)}${v6}${boundry(o)}`, "g");
const { toString: toString$4 } = Object.prototype;
function isRegexp(o) {
  return toString$4.call(o) === "[object RegExp]";
}
const flagMap = { global: "g", ignoreCase: "i", multiline: "m", dotAll: "s", sticky: "y", unicode: "u" };
function clonedRegexp(o, n = {}) {
  if (!isRegexp(o))
    throw new TypeError("Expected a RegExp instance");
  const c = Object.keys(flagMap).map((h) => (typeof n[h] == "boolean" ? n[h] : o[h]) ? flagMap[h] : "").join(""), u = new RegExp(n.source || o.source, c);
  return u.lastIndex = typeof n.lastIndex == "number" ? n.lastIndex : o.lastIndex, u;
}
function isMatch(o, n, { timeout: c } = {}) {
  try {
    return functionTimeout(() => clonedRegexp(o).test(n), { timeout: c })();
  } catch (u) {
    throw u;
  }
}
const maxIPv4Length = 15, maxIPv6Length = 45, options = { timeout: 400 };
function isIP(o) {
  return isMatch(ipRegex({ exact: !0 }), o.slice(0, maxIPv6Length), options);
}
function isIPv6(o) {
  return isMatch(ipRegex.v6({ exact: !0 }), o.slice(0, maxIPv6Length), options);
}
function isIPv4(o) {
  return isMatch(ipRegex.v4({ exact: !0 }), o.slice(0, maxIPv4Length), options);
}
const isV4 = isIPv4, isV6 = isIPv6, toBytes = function(o) {
  let n = 0;
  if (o = o.toString().trim(), isV4(o)) {
    const c = new Uint8Array(n + 4);
    return o.split(/\./g).forEach((u) => {
      c[n++] = 255 & parseInt(u, 10);
    }), c;
  }
  if (isV6(o)) {
    const c = o.split(":", 8);
    let u;
    for (u = 0; u < c.length; u++) {
      let g;
      isV4(c[u]) && (g = toBytes(c[u]), c[u] = toString$6(g.slice(0, 2), "base16")), g != null && ++u < 8 && c.splice(u, 0, toString$6(g.slice(2, 4), "base16"));
    }
    if (c[0] === "")
      for (; c.length < 8; )
        c.unshift("0");
    else if (c[c.length - 1] === "")
      for (; c.length < 8; )
        c.push("0");
    else if (c.length < 8) {
      for (u = 0; u < c.length && c[u] !== ""; u++)
        ;
      const g = [u, 1];
      for (u = 9 - c.length; u > 0; u--)
        g.push("0");
      c.splice.apply(c, g);
    }
    const h = new Uint8Array(n + 16);
    for (u = 0; u < c.length; u++) {
      const g = parseInt(c[u], 16);
      h[n++] = g >> 8 & 255, h[n++] = 255 & g;
    }
    return h;
  }
  throw new Error("invalid ip address");
}, toString$3 = function(o, n = 0, c) {
  n = ~~n, c = c != null ? c : o.length - n;
  const u = new DataView(o.buffer);
  if (c === 4) {
    const h = [];
    for (let g = 0; g < c; g++)
      h.push(o[n + g]);
    return h.join(".");
  }
  if (c === 16) {
    const h = [];
    for (let g = 0; g < c; g += 2)
      h.push(u.getUint16(n + g).toString(16));
    return h.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
}, V = -1, names = {}, codes = {}, table = [[4, 32, "ip4"], [6, 16, "tcp"], [33, 16, "dccp"], [41, 128, "ip6"], [42, V, "ip6zone"], [53, V, "dns", !0], [54, V, "dns4", !0], [55, V, "dns6", !0], [56, V, "dnsaddr", !0], [132, 16, "sctp"], [273, 16, "udp"], [275, 0, "p2p-webrtc-star"], [276, 0, "p2p-webrtc-direct"], [277, 0, "p2p-stardust"], [280, 0, "webrtc"], [290, 0, "p2p-circuit"], [301, 0, "udt"], [302, 0, "utp"], [400, V, "unix", !1, !0], [421, V, "ipfs"], [421, V, "p2p"], [443, 0, "https"], [444, 96, "onion"], [445, 296, "onion3"], [446, V, "garlic64"], [460, 0, "quic"], [465, 0, "webtransport"], [466, V, "certhash"], [477, 0, "ws"], [478, 0, "wss"], [479, 0, "p2p-websocket-star"], [480, 0, "http"], [777, V, "memory"]];
function createProtocol(o, n, c, u, h) {
  return { code: o, size: n, name: c, resolvable: Boolean(u), path: Boolean(h) };
}
function getProtocol(o) {
  if (typeof o == "number") {
    if (codes[o] != null)
      return codes[o];
    throw new Error(`no protocol with code: ${o}`);
  }
  if (typeof o == "string") {
    if (names[o] != null)
      return names[o];
    throw new Error(`no protocol with name: ${o}`);
  }
  throw new Error("invalid protocol id type: " + typeof o);
}
table.forEach((o) => {
  const n = createProtocol(...o);
  codes[n.code] = n, names[n.name] = n;
});
var encode_1$1 = encode$d, MSB$2 = 128, REST$2 = 127, MSBALL$1 = ~REST$2, INT$1 = Math.pow(2, 31);
function encode$d(o, n, c) {
  n = n || [];
  for (var u = c = c || 0; o >= INT$1; )
    n[c++] = 255 & o | MSB$2, o /= 128;
  for (; o & MSBALL$1; )
    n[c++] = 255 & o | MSB$2, o >>>= 7;
  return n[c] = 0 | o, encode$d.bytes = c - u + 1, n;
}
var decode$g = read$3, MSB$1$1 = 128, REST$1$1 = 127;
function read$3(o, n) {
  var c, u = 0, h = 0, g = n = n || 0, y = o.length;
  do {
    if (g >= y)
      throw read$3.bytes = 0, new RangeError("Could not decode varint");
    c = o[g++], u += h < 28 ? (c & REST$1$1) << h : (c & REST$1$1) * Math.pow(2, h), h += 7;
  } while (c >= MSB$1$1);
  return read$3.bytes = g - n, u;
}
var N1$1 = Math.pow(2, 7), N2$1 = Math.pow(2, 14), N3$1 = Math.pow(2, 21), N4$1 = Math.pow(2, 28), N5$1 = Math.pow(2, 35), N6$1 = Math.pow(2, 42), N7$1 = Math.pow(2, 49), N8$1 = Math.pow(2, 56), N9$1 = Math.pow(2, 63), length$1 = function(o) {
  return o < N1$1 ? 1 : o < N2$1 ? 2 : o < N3$1 ? 3 : o < N4$1 ? 4 : o < N5$1 ? 5 : o < N6$1 ? 6 : o < N7$1 ? 7 : o < N8$1 ? 8 : o < N9$1 ? 9 : 10;
}, varint$1 = { encode: encode_1$1, decode: decode$g, encodingLength: length$1 }, _brrp_varint$1 = varint$1;
const decode$f = (o, n = 0) => [_brrp_varint$1.decode(o, n), _brrp_varint$1.decode.bytes], encodeTo$1 = (o, n, c = 0) => (_brrp_varint$1.encode(o, n, c), n), encodingLength$1 = (o) => _brrp_varint$1.encodingLength(o), equals$4 = (o, n) => {
  if (o === n)
    return !0;
  if (o.byteLength !== n.byteLength)
    return !1;
  for (let c = 0; c < o.byteLength; c++)
    if (o[c] !== n[c])
      return !1;
  return !0;
}, coerce$2 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o))
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  throw new Error("Unknown type, must be binary type");
}, fromString$2 = (o) => new TextEncoder().encode(o), toString$2 = (o) => new TextDecoder().decode(o), create$1 = (o, n) => {
  const c = n.byteLength, u = encodingLength$1(o), h = u + encodingLength$1(c), g = new Uint8Array(h + c);
  return encodeTo$1(o, g, 0), encodeTo$1(c, g, u), g.set(n, h), new Digest$1(o, c, n, g);
}, decode$e = (o) => {
  const n = coerce$2(o), [c, u] = decode$f(n), [h, g] = decode$f(n.subarray(u)), y = n.subarray(u + g);
  if (y.byteLength !== h)
    throw new Error("Incorrect length");
  return new Digest$1(c, h, y, n);
}, equals$3 = (o, n) => {
  if (o === n)
    return !0;
  {
    const c = n;
    return o.code === c.code && o.size === c.size && c.bytes instanceof Uint8Array && equals$4(o.bytes, c.bytes);
  }
};
class Digest$1 {
  constructor(n, c, u, h) {
    this.code = n, this.size = c, this.digest = u, this.bytes = h;
  }
}
function base$4(o, n) {
  if (o.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var c = new Uint8Array(256), u = 0; u < c.length; u++)
    c[u] = 255;
  for (var h = 0; h < o.length; h++) {
    var g = o.charAt(h), y = g.charCodeAt(0);
    if (c[y] !== 255)
      throw new TypeError(g + " is ambiguous");
    c[y] = h;
  }
  var $ = o.length, I = o.charAt(0), P = Math.log($) / Math.log(256), L = Math.log(256) / Math.log($);
  function q(N) {
    if (typeof N != "string")
      throw new TypeError("Expected String");
    if (N.length === 0)
      return new Uint8Array();
    var X = 0;
    if (N[X] !== " ") {
      for (var rt = 0, nt = 0; N[X] === I; )
        rt++, X++;
      for (var st = (N.length - X) * P + 1 >>> 0, ot = new Uint8Array(st); N[X]; ) {
        var St = c[N.charCodeAt(X)];
        if (St === 255)
          return;
        for (var Ct = 0, et = st - 1; (St !== 0 || Ct < nt) && et !== -1; et--, Ct++)
          St += $ * ot[et] >>> 0, ot[et] = St % 256 >>> 0, St = St / 256 >>> 0;
        if (St !== 0)
          throw new Error("Non-zero carry");
        nt = Ct, X++;
      }
      if (N[X] !== " ") {
        for (var at = st - nt; at !== st && ot[at] === 0; )
          at++;
        for (var _t = new Uint8Array(rt + (st - at)), Nt = rt; at !== st; )
          _t[Nt++] = ot[at++];
        return _t;
      }
    }
  }
  return { encode: function(N) {
    if (N instanceof Uint8Array || (ArrayBuffer.isView(N) ? N = new Uint8Array(N.buffer, N.byteOffset, N.byteLength) : Array.isArray(N) && (N = Uint8Array.from(N))), !(N instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (N.length === 0)
      return "";
    for (var X = 0, rt = 0, nt = 0, st = N.length; nt !== st && N[nt] === 0; )
      nt++, X++;
    for (var ot = (st - nt) * L + 1 >>> 0, St = new Uint8Array(ot); nt !== st; ) {
      for (var Ct = N[nt], et = 0, at = ot - 1; (Ct !== 0 || et < rt) && at !== -1; at--, et++)
        Ct += 256 * St[at] >>> 0, St[at] = Ct % $ >>> 0, Ct = Ct / $ >>> 0;
      if (Ct !== 0)
        throw new Error("Non-zero carry");
      rt = et, nt++;
    }
    for (var _t = ot - rt; _t !== ot && St[_t] === 0; )
      _t++;
    for (var Nt = I.repeat(X); _t < ot; ++_t)
      Nt += o.charAt(St[_t]);
    return Nt;
  }, decodeUnsafe: q, decode: function(N) {
    var X = q(N);
    if (X)
      return X;
    throw new Error(`Non-${n} character`);
  } };
}
var src$2 = base$4, _brrp__multiformats_scope_baseX$2 = src$2;
class Encoder$2 {
  constructor(n, c, u) {
    this.name = n, this.prefix = c, this.baseEncode = u;
  }
  encode(n) {
    if (n instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(n)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Decoder$2 {
  constructor(n, c, u) {
    if (this.name = n, this.prefix = c, c.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = c.codePointAt(0), this.baseDecode = u;
  }
  decode(n) {
    if (typeof n == "string") {
      if (n.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(n)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(n.slice(this.prefix.length));
    }
    throw Error("Can only multibase decode strings");
  }
  or(n) {
    return or$2(this, n);
  }
}
class ComposedDecoder$2 {
  constructor(n) {
    this.decoders = n;
  }
  or(n) {
    return or$2(this, n);
  }
  decode(n) {
    const c = n[0], u = this.decoders[c];
    if (u)
      return u.decode(n);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(n)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or$2 = (o, n) => new ComposedDecoder$2({ ...o.decoders || { [o.prefix]: o }, ...n.decoders || { [n.prefix]: n } });
class Codec$2 {
  constructor(n, c, u, h) {
    this.name = n, this.prefix = c, this.baseEncode = u, this.baseDecode = h, this.encoder = new Encoder$2(n, c, u), this.decoder = new Decoder$2(n, c, h);
  }
  encode(n) {
    return this.encoder.encode(n);
  }
  decode(n) {
    return this.decoder.decode(n);
  }
}
const from$4 = ({ name: o, prefix: n, encode: c, decode: u }) => new Codec$2(o, n, c, u), baseX$2 = ({ prefix: o, name: n, alphabet: c }) => {
  const { encode: u, decode: h } = _brrp__multiformats_scope_baseX$2(c, n);
  return from$4({ prefix: o, name: n, encode: u, decode: (g) => coerce$2(h(g)) });
}, decode$d = (o, n, c, u) => {
  const h = {};
  for (let L = 0; L < n.length; ++L)
    h[n[L]] = L;
  let g = o.length;
  for (; o[g - 1] === "="; )
    --g;
  const y = new Uint8Array(g * c / 8 | 0);
  let $ = 0, I = 0, P = 0;
  for (let L = 0; L < g; ++L) {
    const q = h[o[L]];
    if (q === void 0)
      throw new SyntaxError(`Non-${u} character`);
    I = I << c | q, $ += c, $ >= 8 && ($ -= 8, y[P++] = 255 & I >> $);
  }
  if ($ >= c || 255 & I << 8 - $)
    throw new SyntaxError("Unexpected end of data");
  return y;
}, encode$c = (o, n, c) => {
  const u = n[n.length - 1] === "=", h = (1 << c) - 1;
  let g = "", y = 0, $ = 0;
  for (let I = 0; I < o.length; ++I)
    for ($ = $ << 8 | o[I], y += 8; y > c; )
      y -= c, g += n[h & $ >> y];
  if (y && (g += n[h & $ << c - y]), u)
    for (; g.length * c & 7; )
      g += "=";
  return g;
}, rfc4648$2 = ({ name: o, prefix: n, bitsPerChar: c, alphabet: u }) => from$4({ prefix: n, name: o, encode: (h) => encode$c(h, u, c), decode: (h) => decode$d(h, u, c, o) }), base58btc$2 = baseX$2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), base58flickr = baseX$2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" }), base58 = Object.freeze(Object.defineProperty({ __proto__: null, base58btc: base58btc$2, base58flickr }, Symbol.toStringTag, { value: "Module" })), base32$2 = rfc4648$2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), base32upper = rfc4648$2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), base32pad = rfc4648$2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), base32padupper = rfc4648$2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), base32hex = rfc4648$2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), base32hexupper = rfc4648$2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), base32hexpad = rfc4648$2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), base32hexpadupper = rfc4648$2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), base32z = rfc4648$2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 }), base32$3 = Object.freeze(Object.defineProperty({ __proto__: null, base32: base32$2, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z }, Symbol.toStringTag, { value: "Module" })), format$2 = (o, n) => {
  const { bytes: c, version: u } = o;
  return u === 0 ? toStringV0$1(c, baseCache$1(o), n || base58btc$2.encoder) : toStringV1$1(c, baseCache$1(o), n || base32$2.encoder);
}, cache$1 = /* @__PURE__ */ new WeakMap(), baseCache$1 = (o) => {
  const n = cache$1.get(o);
  if (n == null) {
    const c = /* @__PURE__ */ new Map();
    return cache$1.set(o, c), c;
  }
  return n;
};
class CID$1 {
  constructor(n, c, u, h) {
    this.code = c, this.version = n, this.multihash = u, this.bytes = h, this["/"] = h;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      case 1: {
        const { code: n, multihash: c } = this;
        if (n !== DAG_PB_CODE$1)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (c.code !== SHA_256_CODE$1)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return CID$1.createV0(c);
      }
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: n, digest: c } = this.multihash, u = create$1(n, c);
        return CID$1.createV1(this.code, u);
      }
      case 1:
        return this;
      default:
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
    }
  }
  equals(n) {
    return CID$1.equals(this, n);
  }
  static equals(n, c) {
    const u = c;
    return u && n.code === u.code && n.version === u.version && equals$3(n.multihash, u.multihash);
  }
  toString(n) {
    return format$2(this, n);
  }
  toJSON() {
    return { code: this.code, version: this.version, hash: this.multihash.bytes };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(n) {
    if (n == null)
      return null;
    const c = n;
    if (c instanceof CID$1)
      return c;
    if (c["/"] != null && c["/"] === c.bytes || c.asCID === c) {
      const { version: u, code: h, multihash: g, bytes: y } = c;
      return new CID$1(u, h, g, y || encodeCID$1(u, h, g.bytes));
    }
    if (c[cidSymbol$1] === !0) {
      const { version: u, multihash: h, code: g } = c, y = decode$e(h);
      return CID$1.create(u, g, y);
    }
    return null;
  }
  static create(n, c, u) {
    if (typeof c != "number")
      throw new Error("String codecs are no longer supported");
    if (!(u.bytes instanceof Uint8Array))
      throw new Error("Invalid digest");
    switch (n) {
      case 0:
        if (c !== DAG_PB_CODE$1)
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$1}) block encoding`);
        return new CID$1(n, c, u, u.bytes);
      case 1: {
        const h = encodeCID$1(n, c, u.bytes);
        return new CID$1(n, c, u, h);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(n) {
    return CID$1.create(0, DAG_PB_CODE$1, n);
  }
  static createV1(n, c) {
    return CID$1.create(1, n, c);
  }
  static decode(n) {
    const [c, u] = CID$1.decodeFirst(n);
    if (u.length)
      throw new Error("Incorrect length");
    return c;
  }
  static decodeFirst(n) {
    const c = CID$1.inspectBytes(n), u = c.size - c.multihashSize, h = coerce$2(n.subarray(u, u + c.multihashSize));
    if (h.byteLength !== c.multihashSize)
      throw new Error("Incorrect length");
    const g = h.subarray(c.multihashSize - c.digestSize), y = new Digest$1(c.multihashCode, c.digestSize, g, h);
    return [c.version === 0 ? CID$1.createV0(y) : CID$1.createV1(c.codec, y), n.subarray(c.size)];
  }
  static inspectBytes(n) {
    let c = 0;
    const u = () => {
      const [L, q] = decode$f(n.subarray(c));
      return c += q, L;
    };
    let h = u(), g = DAG_PB_CODE$1;
    if (h === 18 ? (h = 0, c = 0) : g = u(), h !== 0 && h !== 1)
      throw new RangeError(`Invalid CID version ${h}`);
    const y = c, $ = u(), I = u(), P = c + I;
    return { version: h, codec: g, multihashCode: $, digestSize: I, multihashSize: P - y, size: P };
  }
  static parse(n, c) {
    const [u, h] = parseCIDtoBytes$1(n, c), g = CID$1.decode(h);
    return baseCache$1(g).set(u, n), g;
  }
}
const parseCIDtoBytes$1 = (o, n) => {
  switch (o[0]) {
    case "Q": {
      const c = n || base58btc$2;
      return [base58btc$2.prefix, c.decode(`${base58btc$2.prefix}${o}`)];
    }
    case base58btc$2.prefix: {
      const c = n || base58btc$2;
      return [base58btc$2.prefix, c.decode(o)];
    }
    case base32$2.prefix: {
      const c = n || base32$2;
      return [base32$2.prefix, c.decode(o)];
    }
    default:
      if (n == null)
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      return [o[0], n.decode(o)];
  }
}, toStringV0$1 = (o, n, c) => {
  const { prefix: u } = c;
  if (u !== base58btc$2.prefix)
    throw Error(`Cannot string encode V0 in ${c.name} encoding`);
  const h = n.get(u);
  if (h == null) {
    const g = c.encode(o).slice(1);
    return n.set(u, g), g;
  }
  return h;
}, toStringV1$1 = (o, n, c) => {
  const { prefix: u } = c, h = n.get(u);
  if (h == null) {
    const g = c.encode(o);
    return n.set(u, g), g;
  }
  return h;
}, DAG_PB_CODE$1 = 112, SHA_256_CODE$1 = 18, encodeCID$1 = (o, n, c) => {
  const u = encodingLength$1(o), h = u + encodingLength$1(n), g = new Uint8Array(h + c.byteLength);
  return encodeTo$1(o, g, 0), encodeTo$1(n, g, u), g.set(c, h), g;
}, cidSymbol$1 = Symbol.for("@ipld/js-cid/CID"), identity$3 = from$4({ prefix: "\0", name: "identity", encode: (o) => toString$2(o), decode: (o) => fromString$2(o) }), identityBase = Object.freeze(Object.defineProperty({ __proto__: null, identity: identity$3 }, Symbol.toStringTag, { value: "Module" })), base2 = rfc4648$2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }), base2$1 = Object.freeze(Object.defineProperty({ __proto__: null, base2 }, Symbol.toStringTag, { value: "Module" })), base8 = rfc4648$2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 }), base8$1 = Object.freeze(Object.defineProperty({ __proto__: null, base8 }, Symbol.toStringTag, { value: "Module" })), base10 = baseX$2({ prefix: "9", name: "base10", alphabet: "0123456789" }), base10$1 = Object.freeze(Object.defineProperty({ __proto__: null, base10 }, Symbol.toStringTag, { value: "Module" })), base16 = rfc4648$2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), base16upper = rfc4648$2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 }), base16$1 = Object.freeze(Object.defineProperty({ __proto__: null, base16, base16upper }, Symbol.toStringTag, { value: "Module" })), base36 = baseX$2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), base36upper = baseX$2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" }), base36$1 = Object.freeze(Object.defineProperty({ __proto__: null, base36, base36upper }, Symbol.toStringTag, { value: "Module" })), base64$1 = rfc4648$2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), base64pad = rfc4648$2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), base64url = rfc4648$2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), base64urlpad = rfc4648$2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 }), base64$2 = Object.freeze(Object.defineProperty({ __proto__: null, base64: base64$1, base64pad, base64url, base64urlpad }, Symbol.toStringTag, { value: "Module" })), alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"), alphabetBytesToChars = alphabet.reduce((o, n, c) => (o[c] = n, o), []), alphabetCharsToBytes = alphabet.reduce((o, n, c) => (o[n.codePointAt(0)] = c, o), []);
function encode$b(o) {
  return o.reduce((n, c) => n + alphabetBytesToChars[c], "");
}
function decode$c(o) {
  const n = [];
  for (const c of o) {
    const u = alphabetCharsToBytes[c.codePointAt(0)];
    if (u === void 0)
      throw new Error(`Non-base256emoji character: ${c}`);
    n.push(u);
  }
  return new Uint8Array(n);
}
const base256emoji = from$4({ prefix: "\u{1F680}", name: "base256emoji", encode: encode$b, decode: decode$c }), base256emoji$1 = Object.freeze(Object.defineProperty({ __proto__: null, base256emoji }, Symbol.toStringTag, { value: "Module" })), from$3 = ({ name: o, code: n, encode: c }) => new Hasher(o, n, c);
class Hasher {
  constructor(n, c, u) {
    this.name = n, this.code = c, this.encode = u;
  }
  digest(n) {
    if (n instanceof Uint8Array) {
      const c = this.encode(n);
      return c instanceof Uint8Array ? create$1(this.code, c) : c.then((u) => create$1(this.code, u));
    }
    throw Error("Unknown type, must be binary type");
  }
}
const sha$1 = (o) => async (n) => new Uint8Array(await crypto.subtle.digest(o, n)), sha256$3 = from$3({ name: "sha2-256", code: 18, encode: sha$1("SHA-256") }), sha512$2 = from$3({ name: "sha2-512", code: 19, encode: sha$1("SHA-512") }), sha2 = Object.freeze(Object.defineProperty({ __proto__: null, sha256: sha256$3, sha512: sha512$2 }, Symbol.toStringTag, { value: "Module" })), code$4 = 0, name$3 = "identity", encode$a = coerce$2, digest = (o) => create$1(code$4, encode$a(o)), identity$1 = { code: code$4, name: name$3, encode: encode$a, digest }, identity$2 = Object.freeze(Object.defineProperty({ __proto__: null, identity: identity$1 }, Symbol.toStringTag, { value: "Module" }));
new TextEncoder(), new TextDecoder();
const bases = { ...identityBase, ...base2$1, ...base8$1, ...base10$1, ...base16$1, ...base32$3, ...base36$1, ...base58, ...base64$2, ...base256emoji$1 };
function concat(o, n) {
  n == null && (n = o.reduce((h, g) => h + g.length, 0));
  const c = allocUnsafe$2(n);
  let u = 0;
  for (const h of o)
    c.set(h, u), u += h.length;
  return asUint8Array$2(c);
}
function convertToString(o, n) {
  switch (getProtocol(o).code) {
    case 4:
    case 41:
      return bytes2ip(n);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(n).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return bytes2str(n);
    case 421:
      return bytes2mh(n);
    case 444:
    case 445:
      return bytes2onion(n);
    case 466:
      return bytes2mb(n);
    default:
      return toString$6(n, "base16");
  }
}
function convertToBytes(o, n) {
  switch (getProtocol(o).code) {
    case 4:
    case 41:
      return ip2bytes(n);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(n, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return str2bytes(n);
    case 421:
      return mh2bytes(n);
    case 444:
      return onion2bytes(n);
    case 445:
      return onion32bytes(n);
    case 466:
      return mb2bytes(n);
    default:
      return fromString$4(n, "base16");
  }
}
const decoders$1 = Object.values(bases).map((o) => o.decoder), anybaseDecoder = function() {
  let o = decoders$1[0].or(decoders$1[1]);
  return decoders$1.slice(2).forEach((n) => o = o.or(n)), o;
}();
function ip2bytes(o) {
  if (!isIP(o))
    throw new Error("invalid ip address");
  return toBytes(o);
}
function bytes2ip(o) {
  const n = toString$3(o, 0, o.length);
  if (n == null)
    throw new Error("ipBuff is required");
  if (!isIP(n))
    throw new Error("invalid ip address");
  return n;
}
function port2bytes(o) {
  const n = new ArrayBuffer(2);
  return new DataView(n).setUint16(0, o), new Uint8Array(n);
}
function bytes2port(o) {
  return new DataView(o.buffer).getUint16(o.byteOffset);
}
function str2bytes(o) {
  const n = fromString$4(o), c = Uint8Array.from(varint$4.encode(n.length));
  return concat([c, n], c.length + n.length);
}
function bytes2str(o) {
  const n = varint$4.decode(o);
  if ((o = o.slice(varint$4.decode.bytes)).length !== n)
    throw new Error("inconsistent lengths");
  return toString$6(o);
}
function mh2bytes(o) {
  let n;
  n = o[0] === "Q" || o[0] === "1" ? decode$e(base58btc$2.decode(`z${o}`)).bytes : CID$1.parse(o).multihash.bytes;
  const c = Uint8Array.from(varint$4.encode(n.length));
  return concat([c, n], c.length + n.length);
}
function mb2bytes(o) {
  const n = anybaseDecoder.decode(o), c = Uint8Array.from(varint$4.encode(n.length));
  return concat([c, n], c.length + n.length);
}
function bytes2mb(o) {
  const n = varint$4.decode(o), c = o.slice(varint$4.decode.bytes);
  if (c.length !== n)
    throw new Error("inconsistent lengths");
  return "u" + toString$6(c, "base64url");
}
function bytes2mh(o) {
  const n = varint$4.decode(o), c = o.slice(varint$4.decode.bytes);
  if (c.length !== n)
    throw new Error("inconsistent lengths");
  return toString$6(c, "base58btc");
}
function onion2bytes(o) {
  const n = o.split(":");
  if (n.length !== 2)
    throw new Error(`failed to parse onion addr: ["'${n.join('", "')}'"]' does not contain a port number`);
  if (n[0].length !== 16)
    throw new Error(`failed to parse onion addr: ${n[0]} not a Tor onion address.`);
  const c = base32$2.decode("b" + n[0]), u = parseInt(n[1], 10);
  if (u < 1 || u > 65536)
    throw new Error("Port number is not in range(1, 65536)");
  const h = port2bytes(u);
  return concat([c, h], c.length + h.length);
}
function onion32bytes(o) {
  const n = o.split(":");
  if (n.length !== 2)
    throw new Error(`failed to parse onion addr: ["'${n.join('", "')}'"]' does not contain a port number`);
  if (n[0].length !== 56)
    throw new Error(`failed to parse onion addr: ${n[0]} not a Tor onion3 address.`);
  const c = base32$2.decode(`b${n[0]}`), u = parseInt(n[1], 10);
  if (u < 1 || u > 65536)
    throw new Error("Port number is not in range(1, 65536)");
  const h = port2bytes(u);
  return concat([c, h], c.length + h.length);
}
function bytes2onion(o) {
  const n = o.slice(0, o.length - 2), c = o.slice(o.length - 2);
  return `${toString$6(n, "base32")}:${bytes2port(c)}`;
}
function stringToStringTuples(o) {
  const n = [], c = o.split("/").slice(1);
  if (c.length === 1 && c[0] === "")
    return [];
  for (let u = 0; u < c.length; u++) {
    const h = c[u], g = getProtocol(h);
    if (g.size !== 0) {
      if (u++, u >= c.length)
        throw ParseError("invalid address: " + o);
      if (g.path === !0) {
        n.push([h, cleanPath(c.slice(u).join("/"))]);
        break;
      }
      n.push([h, c[u]]);
    } else
      n.push([h]);
  }
  return n;
}
function stringTuplesToString(o) {
  const n = [];
  return o.map((c) => {
    const u = protoFromTuple(c);
    return n.push(u.name), c.length > 1 && c[1] != null && n.push(c[1]), null;
  }), cleanPath(n.join("/"));
}
function stringTuplesToTuples(o) {
  return o.map((n) => {
    Array.isArray(n) || (n = [n]);
    const c = protoFromTuple(n);
    return n.length > 1 ? [c.code, convertToBytes(c.code, n[1])] : [c.code];
  });
}
function tuplesToStringTuples(o) {
  return o.map((n) => {
    const c = protoFromTuple(n);
    return n[1] != null ? [c.code, convertToString(c.code, n[1])] : [c.code];
  });
}
function tuplesToBytes(o) {
  return fromBytes(concat(o.map((n) => {
    const c = protoFromTuple(n);
    let u = Uint8Array.from(varint$4.encode(c.code));
    return n.length > 1 && n[1] != null && (u = concat([u, n[1]])), u;
  })));
}
function sizeForAddr(o, n) {
  return o.size > 0 ? o.size / 8 : o.size === 0 ? 0 : varint$4.decode(n) + varint$4.decode.bytes;
}
function bytesToTuples(o) {
  const n = [];
  let c = 0;
  for (; c < o.length; ) {
    const u = varint$4.decode(o, c), h = varint$4.decode.bytes, g = sizeForAddr(getProtocol(u), o.slice(c + h));
    if (g === 0) {
      n.push([u]), c += h;
      continue;
    }
    const y = o.slice(c + h, c + h + g);
    if (c += g + h, c > o.length)
      throw ParseError("Invalid address Uint8Array: " + toString$6(o, "base16"));
    n.push([u, y]);
  }
  return n;
}
function bytesToString(o) {
  return stringTuplesToString(tuplesToStringTuples(bytesToTuples(o)));
}
function stringToBytes(o) {
  return tuplesToBytes(stringTuplesToTuples(stringToStringTuples(o = cleanPath(o))));
}
function fromString$1(o) {
  return stringToBytes(o);
}
function fromBytes(o) {
  const n = validateBytes(o);
  if (n != null)
    throw n;
  return Uint8Array.from(o);
}
function validateBytes(o) {
  try {
    bytesToTuples(o);
  } catch (n) {
    return n;
  }
}
function cleanPath(o) {
  return "/" + o.trim().split("/").filter((n) => n).join("/");
}
function ParseError(o) {
  return new Error("Error parsing address: " + o);
}
function protoFromTuple(o) {
  return getProtocol(o[0]);
}
function equals$2(o, n) {
  if (o === n)
    return !0;
  if (o.byteLength !== n.byteLength)
    return !1;
  for (let c = 0; c < o.byteLength; c++)
    if (o[c] !== n[c])
      return !1;
  return !0;
}
var __classPrivateFieldGet$2 = globalThis && globalThis.__classPrivateFieldGet || function(o, n, c, u) {
  if (c === "a" && !u)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof n == "function" ? o !== n || !u : !n.has(o))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return c === "m" ? u : c === "a" ? u.call(o) : u ? u.value : n.get(o);
}, __classPrivateFieldSet$1 = globalThis && globalThis.__classPrivateFieldSet || function(o, n, c, u, h) {
  if (u === "m")
    throw new TypeError("Private method is not writable");
  if (u === "a" && !h)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof n == "function" ? o !== n || !h : !n.has(o))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return u === "a" ? h.call(o, c) : h ? h.value = c : n.set(o, c), c;
}, _DefaultMultiaddr_string, _DefaultMultiaddr_tuples, _DefaultMultiaddr_stringTuples, _a$1;
const inspect = Symbol.for("nodejs.util.inspect.custom"), DNS_CODES = [getProtocol("dns").code, getProtocol("dns4").code, getProtocol("dns6").code, getProtocol("dnsaddr").code], P2P_CODES = [getProtocol("p2p").code, getProtocol("ipfs").code], resolvers = /* @__PURE__ */ new Map(), symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
function isMultiaddr(o) {
  return Boolean(o == null ? void 0 : o[symbol]);
}
class DefaultMultiaddr {
  constructor(n) {
    if (_DefaultMultiaddr_string.set(this, void 0), _DefaultMultiaddr_tuples.set(this, void 0), _DefaultMultiaddr_stringTuples.set(this, void 0), this[_a$1] = !0, n == null && (n = ""), n instanceof Uint8Array)
      this.bytes = fromBytes(n);
    else if (typeof n == "string") {
      if (n.length > 0 && n.charAt(0) !== "/")
        throw new Error(`multiaddr "${n}" must start with a "/"`);
      this.bytes = fromString$1(n);
    } else {
      if (!isMultiaddr(n))
        throw new Error("addr must be a string, Buffer, or another Multiaddr");
      this.bytes = fromBytes(n.bytes);
    }
  }
  toString() {
    return __classPrivateFieldGet$2(this, _DefaultMultiaddr_string, "f") == null && __classPrivateFieldSet$1(this, _DefaultMultiaddr_string, bytesToString(this.bytes), "f"), __classPrivateFieldGet$2(this, _DefaultMultiaddr_string, "f");
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    const n = this.protoCodes(), c = this.toString().split("/").slice(1);
    let u, h;
    if (c.length > 2)
      DNS_CODES.includes(n[0]) && P2P_CODES.includes(n[1]) ? (u = getProtocol("tcp").name, h = 443) : (u = getProtocol(c[2]).name, h = parseInt(c[3]));
    else {
      if (!DNS_CODES.includes(n[0]))
        throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
      u = getProtocol("tcp").name, h = 443;
    }
    return { family: n[0] === 41 || n[0] === 55 ? 6 : 4, host: c[1], transport: u, port: h };
  }
  protos() {
    return this.protoCodes().map((n) => Object.assign({}, getProtocol(n)));
  }
  protoCodes() {
    const n = [], c = this.bytes;
    let u = 0;
    for (; u < c.length; ) {
      const h = varint$4.decode(c, u), g = varint$4.decode.bytes;
      u += sizeForAddr(getProtocol(h), c.slice(u + g)) + g, n.push(h);
    }
    return n;
  }
  protoNames() {
    return this.protos().map((n) => n.name);
  }
  tuples() {
    return __classPrivateFieldGet$2(this, _DefaultMultiaddr_tuples, "f") == null && __classPrivateFieldSet$1(this, _DefaultMultiaddr_tuples, bytesToTuples(this.bytes), "f"), __classPrivateFieldGet$2(this, _DefaultMultiaddr_tuples, "f");
  }
  stringTuples() {
    return __classPrivateFieldGet$2(this, _DefaultMultiaddr_stringTuples, "f") == null && __classPrivateFieldSet$1(this, _DefaultMultiaddr_stringTuples, tuplesToStringTuples(this.tuples()), "f"), __classPrivateFieldGet$2(this, _DefaultMultiaddr_stringTuples, "f");
  }
  encapsulate(n) {
    return n = new DefaultMultiaddr(n), new DefaultMultiaddr(this.toString() + n.toString());
  }
  decapsulate(n) {
    const c = n.toString(), u = this.toString(), h = u.lastIndexOf(c);
    if (h < 0)
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${n.toString()}`);
    return new DefaultMultiaddr(u.slice(0, h));
  }
  decapsulateCode(n) {
    const c = this.tuples();
    for (let u = c.length - 1; u >= 0; u--)
      if (c[u][0] === n)
        return new DefaultMultiaddr(tuplesToBytes(c.slice(0, u)));
    return this;
  }
  getPeerId() {
    try {
      const n = this.stringTuples().filter((c) => c[0] === names.ipfs.code).pop();
      if ((n == null ? void 0 : n[1]) != null) {
        const c = n[1];
        return c[0] === "Q" || c[0] === "1" ? toString$6(base58btc$2.decode(`z${c}`), "base58btc") : toString$6(CID$1.parse(c).multihash.bytes, "base58btc");
      }
      return null;
    } catch {
      return null;
    }
  }
  getPath() {
    let n = null;
    try {
      n = this.stringTuples().filter((c) => getProtocol(c[0]).path === !0)[0][1], n == null && (n = null);
    } catch {
      n = null;
    }
    return n;
  }
  equals(n) {
    return equals$2(this.bytes, n.bytes);
  }
  async resolve(n) {
    const c = this.protos().find((h) => h.resolvable);
    if (c == null)
      return [this];
    const u = resolvers.get(c.name);
    if (u == null)
      throw errCode(new Error(`no available resolver for ${c.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    return (await u(this, n)).map((h) => new DefaultMultiaddr(h));
  }
  nodeAddress() {
    const n = this.toOptions();
    if (n.transport !== "tcp" && n.transport !== "udp")
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${n.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    return { family: n.family, address: n.host, port: n.port };
  }
  isThinWaistAddress(n) {
    const c = (n != null ? n : this).protos();
    return !(c.length !== 2 || c[0].code !== 4 && c[0].code !== 41 || c[1].code !== 6 && c[1].code !== 273);
  }
  [(_DefaultMultiaddr_string = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_tuples = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_stringTuples = /* @__PURE__ */ new WeakMap(), _a$1 = symbol, inspect)]() {
    return this.inspect();
  }
  inspect() {
    return "<Multiaddr " + toString$6(this.bytes, "base16") + " - " + bytesToString(this.bytes) + ">";
  }
}
function multiaddr(o) {
  return new DefaultMultiaddr(o);
}
async function storePeerUnderSingleDatastoreKey(o, n = () => {
}) {
  n(0, "Storing each peerstore key under a single datastore key"), await o.datastore.open();
  const c = {}, u = [];
  for await (const { key: h, value: g } of o.datastore.query({ prefix: "/peers" })) {
    u.push(h);
    const y = h.toString(), [$, I, P, L, q] = y.split("/");
    if (I === "peers" && ["protos", "addrs", "metadata", "keys"].includes(P) && L)
      if (c[L] = c[L] || { addresses: [], protocols: [], metadata: [] }, P === "protos") {
        const N = Protocols.decode(g);
        c[L].protocols = N.protocols.sort();
      } else if (P === "addrs") {
        const N = Addresses.decode(g);
        c[L].addresses = N.addrs.sort((X, rt) => multiaddr(X.multiaddr).toString().localeCompare(multiaddr(rt.multiaddr).toString())), N.certifiedRecord && N.certifiedRecord.raw && (c[L].peerRecordEnvelope = N.certifiedRecord.raw);
      } else
        P === "metadata" ? c[L].metadata.push({ key: q, value: g }) : P === "keys" && (c[L].pubKey = g);
  }
  n(33, "Read peer data from store");
  for (const h of u)
    await o.datastore.delete(h);
  n(66, "Removed existing peer data from store");
  for (const h of Object.keys(c)) {
    const g = c[h];
    g.metadata = g.metadata.sort(($, I) => $.key.localeCompare(I.key));
    const y = Peer.encode(g).finish();
    await o.datastore.put(new Key(`/peers/${h}`), y);
  }
  await o.datastore.close(), n(100, "Stored each peerstore key under a single datastore key");
}
async function storePeerUnderMultipleDatastoreKeys(o, n = () => {
}) {
  n(0, "Storing each peerstore key under a multiple datastore keys"), await o.datastore.open();
  const c = {}, u = [];
  for await (const { key: h, value: g } of o.datastore.query({ prefix: "/peers" })) {
    u.push(h);
    const y = h.toString(), [$, I, P] = y.split("/");
    c[P] = Peer.decode(g);
  }
  n(33, "Read peer data from store");
  for (const h of u)
    await o.datastore.delete(h);
  n(66, "Removed existing peer data from store");
  for (const [h, g] of Object.entries(c)) {
    if (g.protocols && g.protocols.length > 0 && await o.datastore.put(new Key(`/peers/protos/${h}`), Protocols.encode({ protocols: g.protocols }).finish()), g.addresses && g.addresses.length > 0) {
      const y = g.peerRecordEnvelope;
      let $;
      if (y) {
        const I = Envelope.decode(y);
        $ = { raw: y, seq: PeerRecord.decode(I.payload).seq };
      }
      await o.datastore.put(new Key(`/peers/addrs/${h}`), Addresses.encode({ addrs: g.addresses, certifiedRecord: $ }).finish());
    }
    if (g.metadata && g.metadata.length > 0)
      for (const { key: y, value: $ } of g.metadata)
        await o.datastore.put(new Key(`/peers/metadata/${h}/${y}`), $);
    g.pubKey && await o.datastore.put(new Key(`/peers/keys/${h}`), g.pubKey);
  }
  await o.datastore.close(), n(100, "Stored each peerstore key under multiple datastore keys");
}
$protobuf.util.Long = void 0, $protobuf.configure();
const migration = { version: 12, description: "Store each peerstore peer under a single datastore key", migrate: storePeerUnderSingleDatastoreKey, revert: storePeerUnderMultipleDatastoreKeys }, emptyMigration = { description: "Empty migration.", migrate: () => {
}, revert: () => {
}, empty: !0 }, defaultMigrations = [Object.assign({ version: 1 }, emptyMigration), Object.assign({ version: 2 }, emptyMigration), Object.assign({ version: 3 }, emptyMigration), Object.assign({ version: 4 }, emptyMigration), Object.assign({ version: 5 }, emptyMigration), Object.assign({ version: 6 }, emptyMigration), Object.assign({ version: 7 }, emptyMigration), migration$4, migration$3, migration$2, migration$1, migration];
class NonReversibleMigrationError extends Error {
  constructor(n) {
    super(n), this.name = "NonReversibleMigrationError", this.code = NonReversibleMigrationError.code, this.message = n;
  }
}
NonReversibleMigrationError.code = "ERR_NON_REVERSIBLE_MIGRATION";
class NotInitializedRepoError extends Error {
  constructor(n) {
    super(n), this.name = "NotInitializedRepoError", this.code = NotInitializedRepoError.code, this.message = n;
  }
}
NotInitializedRepoError.code = "ERR_NOT_INITIALIZED_REPO";
class RequiredParameterError extends Error {
  constructor(n) {
    super(n), this.name = "RequiredParameterError", this.code = RequiredParameterError.code, this.message = n;
  }
}
RequiredParameterError.code = "ERR_REQUIRED_PARAMETER";
class InvalidValueError extends Error {
  constructor(n) {
    super(n), this.name = "InvalidValueError", this.code = InvalidValueError.code, this.message = n;
  }
}
InvalidValueError.code = "ERR_INVALID_VALUE";
class MissingRepoOptionsError extends Error {
  constructor(n) {
    super(n), this.name = "MissingRepoOptionsError", this.code = MissingRepoOptionsError.code, this.message = n;
  }
}
MissingRepoOptionsError.code = "ERR_MISSING_REPO_OPTIONS";
const Errors = Object.freeze(Object.defineProperty({ __proto__: null, NonReversibleMigrationError, NotInitializedRepoError, RequiredParameterError, InvalidValueError, MissingRepoOptionsError }, Symbol.toStringTag, { value: "Module" })), log$6 = debug("ipfs:repo:migrator:repo:init");
async function isRepoInitialized(o) {
  if (!o)
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  const n = o.root;
  try {
    await n.open();
    const c = await n.has(VERSION_KEY), u = await n.has(CONFIG_KEY);
    return !(!c || !u) || (log$6(`Version entry present: ${c}`), log$6(`Config entry present: ${u}`), !1);
  } catch (c) {
    return log$6("While checking if repo is initialized error was thrown: " + c.message), !1;
  } finally {
    if (n !== void 0)
      try {
        await n.close();
      } catch {
      }
  }
}
async function getVersion(o) {
  if (!await isRepoInitialized(o))
    throw new NotInitializedRepoError("Repo is not initialized!");
  const n = o.root;
  await n.open();
  try {
    return parseInt(toString$5(await n.get(VERSION_KEY)));
  } finally {
    await n.close();
  }
}
async function setVersion(o, n) {
  if (!n)
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  const c = n.root;
  await c.open(), await c.put(VERSION_KEY, fromString$3(String(o))), await c.close();
}
const log$5 = debug("ipfs:repo:migrator");
function getLatestMigrationVersion(o) {
  return o = o || defaultMigrations, Array.isArray(o) && o.length !== 0 ? o[o.length - 1].version : 0;
}
async function migrate(o, n, c, u, h = {}) {
  var q, N, X;
  const g = (q = h.ignoreLock) != null ? q : !1, y = h.onProgress, $ = (N = h.isDryRun) != null ? N : !1, I = (X = h.migrations) != null ? X : defaultMigrations;
  if (!o)
    throw new errors$1.RequiredParameterError("Path argument is required!");
  if (!c)
    throw new errors$1.RequiredParameterError("repoOptions argument is required!");
  if (!u)
    throw new errors$1.RequiredParameterError("toVersion argument is required!");
  if (!Number.isInteger(u) || u <= 0)
    throw new errors$1.InvalidValueError("Version has to be positive integer!");
  n = wrapBackends(n);
  const P = await getVersion(n);
  if (P === u)
    return void log$5("Nothing to migrate.");
  if (P > u)
    throw new errors$1.InvalidValueError(`Current repo's version (${P}) is higher then toVersion (${u}), you probably wanted to revert it?`);
  let L;
  verifyAvailableMigrations(I, P, u), $ || g || (L = await c.repoLock.lock(o));
  try {
    for (const rt of I) {
      if (u !== void 0 && rt.version > u)
        break;
      if (!(rt.version <= P)) {
        log$5(`Migrating version ${rt.version}`);
        try {
          if (!$) {
            let nt = () => {
            };
            y && (nt = (st, ot) => y(rt.version, st.toFixed(2), ot)), await rt.migrate(n, nt);
          }
        } catch (nt) {
          const st = rt.version - 1;
          throw log$5(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${st}`), await setVersion(st, n), new Error(`During migration to version ${rt.version} exception was raised: ${nt.stack || nt.message || nt}`);
        }
        log$5(`Migrating to version ${rt.version} finished`);
      }
    }
    $ || await setVersion(u || getLatestMigrationVersion(I), n), log$5("Repo successfully migrated", u !== void 0 ? `to version ${u}!` : "to latest version!");
  } finally {
    $ || g || !L || await L.close();
  }
}
async function revert(o, n, c, u, h = {}) {
  var q, N, X;
  const g = (q = h.ignoreLock) != null ? q : !1, y = h.onProgress, $ = (N = h.isDryRun) != null ? N : !1, I = (X = h.migrations) != null ? X : defaultMigrations;
  if (!o)
    throw new errors$1.RequiredParameterError("Path argument is required!");
  if (!c)
    throw new errors$1.RequiredParameterError("repoOptions argument is required!");
  if (!u)
    throw new errors$1.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
  if (!Number.isInteger(u) || u <= 0)
    throw new errors$1.InvalidValueError("Version has to be positive integer!");
  n = wrapBackends(n);
  const P = await getVersion(n);
  if (P === u)
    return void log$5("Nothing to revert.");
  if (P < u)
    throw new errors$1.InvalidValueError(`Current repo's version (${P}) is lower then toVersion (${u}), you probably wanted to migrate it?`);
  let L;
  verifyAvailableMigrations(I, u, P, !0), $ || g || (L = await c.repoLock.lock(o)), log$5(`Reverting from version ${P} to ${u}`);
  try {
    const rt = I.slice().reverse();
    for (const nt of rt) {
      if (nt.version <= u)
        break;
      if (!(nt.version > P)) {
        log$5(`Reverting migration version ${nt.version}`);
        try {
          if (!$) {
            let st = () => {
            };
            y && (st = (ot, St) => y(nt.version, ot.toFixed(2), St)), await nt.revert(n, st);
          }
        } catch (st) {
          const ot = nt.version;
          throw log$5(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${ot}`), await setVersion(ot, n), st.message = `During reversion to version ${nt.version} exception was raised: ${st.message}`, st;
        }
        log$5(`Reverting to version ${nt.version} finished`);
      }
    }
    $ || await setVersion(u, n), log$5(`All migrations successfully reverted to version ${u}!`);
  } finally {
    $ || g || !L || await L.close();
  }
}
function verifyAvailableMigrations(o, n, c, u = !1) {
  let h = 0;
  for (const g of o) {
    if (g.version > c)
      break;
    if (g.version > n) {
      if (u && !g.revert)
        throw new errors$1.NonReversibleMigrationError(`It is not possible to revert to version ${n} because migration version ${g.version} is not reversible. Cancelling reversion.`);
      h++;
    }
  }
  if (h !== c - n)
    throw new errors$1.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${n} to ${c}`);
}
const errors$1 = Errors;
var bytes$1 = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
bytes$1.exports = bytes, bytes$1.exports.format = format$1, bytes$1.exports.parse = parse$1;
var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g, formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/, map$1 = { b: 1, kb: 1024, mb: 1 << 20, gb: 1 << 30, tb: Math.pow(1024, 4), pb: Math.pow(1024, 5) }, parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
function bytes(o, n) {
  return typeof o == "string" ? parse$1(o) : typeof o == "number" ? format$1(o, n) : null;
}
function format$1(o, n) {
  if (!Number.isFinite(o))
    return null;
  var c = Math.abs(o), u = n && n.thousandsSeparator || "", h = n && n.unitSeparator || "", g = n && n.decimalPlaces !== void 0 ? n.decimalPlaces : 2, y = Boolean(n && n.fixedDecimals), $ = n && n.unit || "";
  $ && map$1[$.toLowerCase()] || ($ = c >= map$1.pb ? "PB" : c >= map$1.tb ? "TB" : c >= map$1.gb ? "GB" : c >= map$1.mb ? "MB" : c >= map$1.kb ? "KB" : "B");
  var I = (o / map$1[$.toLowerCase()]).toFixed(g);
  return y || (I = I.replace(formatDecimalsRegExp, "$1")), u && (I = I.split(".").map(function(P, L) {
    return L === 0 ? P.replace(formatThousandsRegExp, u) : P;
  }).join(".")), I + h + $;
}
function parse$1(o) {
  if (typeof o == "number" && !isNaN(o))
    return o;
  if (typeof o != "string")
    return null;
  var n, c = parseRegExp.exec(o), u = "b";
  return c ? (n = parseFloat(c[1]), u = c[4].toLowerCase()) : (n = parseInt(o, 10), u = "b"), isNaN(n) ? null : Math.floor(map$1[u] * n);
}
var isPlainObj = (o) => {
  if (Object.prototype.toString.call(o) !== "[object Object]")
    return !1;
  const n = Object.getPrototypeOf(o);
  return n === null || n === Object.prototype;
};
const isOptionObject = isPlainObj, { hasOwnProperty: hasOwnProperty$b } = Object.prototype, { propertyIsEnumerable: propertyIsEnumerable$2 } = Object, defineProperty$2 = (o, n, c) => Object.defineProperty(o, n, { value: c, writable: !0, enumerable: !0, configurable: !0 }), globalThis$1 = commonjsGlobal, defaultMergeOptions = { concatArrays: !1, ignoreUndefined: !1 }, getEnumerableOwnPropertyKeys = (o) => {
  const n = [];
  for (const c in o)
    hasOwnProperty$b.call(o, c) && n.push(c);
  if (Object.getOwnPropertySymbols) {
    const c = Object.getOwnPropertySymbols(o);
    for (const u of c)
      propertyIsEnumerable$2.call(o, u) && n.push(u);
  }
  return n;
};
function clone(o) {
  return Array.isArray(o) ? cloneArray(o) : isOptionObject(o) ? cloneOptionObject(o) : o;
}
function cloneArray(o) {
  const n = o.slice(0, 0);
  return getEnumerableOwnPropertyKeys(o).forEach((c) => {
    defineProperty$2(n, c, clone(o[c]));
  }), n;
}
function cloneOptionObject(o) {
  const n = Object.getPrototypeOf(o) === null ? /* @__PURE__ */ Object.create(null) : {};
  return getEnumerableOwnPropertyKeys(o).forEach((c) => {
    defineProperty$2(n, c, clone(o[c]));
  }), n;
}
const mergeKeys = (o, n, c, u) => (c.forEach((h) => {
  n[h] === void 0 && u.ignoreUndefined || (h in o && o[h] !== Object.getPrototypeOf(o) ? defineProperty$2(o, h, merge$1(o[h], n[h], u)) : defineProperty$2(o, h, clone(n[h])));
}), o), concatArrays = (o, n, c) => {
  let u = o.slice(0, 0), h = 0;
  return [o, n].forEach((g) => {
    const y = [];
    for (let $ = 0; $ < g.length; $++)
      hasOwnProperty$b.call(g, $) && (y.push(String($)), defineProperty$2(u, h++, g === o ? g[$] : clone(g[$])));
    u = mergeKeys(u, g, getEnumerableOwnPropertyKeys(g).filter(($) => !y.includes($)), c);
  }), u;
};
function merge$1(o, n, c) {
  return c.concatArrays && Array.isArray(o) && Array.isArray(n) ? concatArrays(o, n, c) : isOptionObject(n) && isOptionObject(o) ? mergeKeys(o, n, getEnumerableOwnPropertyKeys(n), c) : clone(n);
}
var mergeOptions = function(...o) {
  const n = merge$1(clone(defaultMergeOptions), this !== globalThis$1 && this || {}, defaultMergeOptions);
  let c = { _: {} };
  for (const u of o)
    if (u !== void 0) {
      if (!isOptionObject(u))
        throw new TypeError("`" + u + "` is not an Option Object");
      c = merge$1(c, { _: u }, n);
    }
  return c._;
};
const repoVersion = 12;
function asUint8Array(o) {
  return globalThis.Buffer != null ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength) : o;
}
function allocUnsafe(o = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? asUint8Array(globalThis.Buffer.allocUnsafe(o)) : new Uint8Array(o);
}
function createCodec(o, n, c, u) {
  return { name: o, prefix: n, encoder: { name: o, prefix: n, encode: c }, decoder: { decode: u } };
}
const string = createCodec("utf8", "u", (o) => "u" + new TextDecoder("utf8").decode(o), (o) => new TextEncoder().encode(o.substring(1))), ascii = createCodec("ascii", "a", (o) => {
  let n = "a";
  for (let c = 0; c < o.length; c++)
    n += String.fromCharCode(o[c]);
  return n;
}, (o) => {
  const n = allocUnsafe((o = o.substring(1)).length);
  for (let c = 0; c < o.length; c++)
    n[c] = o.charCodeAt(c);
  return n;
}), BASES = { utf8: string, "utf-8": string, hex: bases$1.base16, latin1: ascii, ascii, binary: ascii, ...bases$1 };
function toString$1(o, n = "utf8") {
  const c = BASES[n];
  if (!c)
    throw new Error(`Unsupported encoding "${n}"`);
  return n !== "utf8" && n !== "utf-8" || globalThis.Buffer == null || globalThis.Buffer.from == null ? c.encoder.encode(o).substring(1) : globalThis.Buffer.from(o.buffer, o.byteOffset, o.byteLength).toString("utf8");
}
function fromString(o, n = "utf8") {
  const c = BASES[n];
  if (!c)
    throw new Error(`Unsupported encoding "${n}"`);
  return n !== "utf8" && n !== "utf-8" || globalThis.Buffer == null || globalThis.Buffer.from == null ? c.decoder.decode(`${c.prefix}${o}`) : asUint8Array(globalThis.Buffer.from(o, "utf-8"));
}
class LockExistsError extends Error {
  constructor(n) {
    super(n), this.name = "LockExistsError", this.code = LockExistsError.code;
  }
}
LockExistsError.code = "ERR_LOCK_EXISTS";
class NotFoundError extends Error {
  constructor(n) {
    super(n), this.name = "NotFoundError", this.code = NotFoundError.code;
  }
}
NotFoundError.code = "ERR_NOT_FOUND";
class InvalidRepoVersionError extends Error {
  constructor(n) {
    super(n), this.name = "InvalidRepoVersionError", this.code = InvalidRepoVersionError.code;
  }
}
InvalidRepoVersionError.code = "ERR_INVALID_REPO_VERSION";
const ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED", ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN", ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";
async function hasWithFallback(o, n, c) {
  const u = await n(o);
  if (u)
    return u;
  const h = findLevelJs(c);
  return !!h && new Promise((g, y) => {
    const $ = h.store("readonly").get(o.toString());
    $.transaction.onabort = () => {
      y($.transaction.error);
    }, $.transaction.oncomplete = () => {
      g(Boolean($.result));
    };
  });
}
async function getWithFallback(o, n, c, u) {
  if (await c(o))
    return n(o);
  const h = findLevelJs(u);
  if (!h)
    throw new NotFoundError();
  return new Promise((g, y) => {
    const $ = h.store("readonly").get(o.toString());
    $.transaction.onabort = () => {
      y($.transaction.error);
    }, $.transaction.oncomplete = () => {
      if ($.result)
        return g($.result);
      y(new NotFoundError());
    };
  });
}
function findLevelJs(o) {
  let n = o;
  for (; n.db || n.child; )
    if (n = n.db || n.child, n.type === "level-js" || n.constructor.name === "Level")
      return n;
}
const log$4 = debug("ipfs:repo:version"), versionKey = new Key("version");
function version$1(o) {
  return { exists: async () => hasWithFallback(versionKey, o.has.bind(o), o), async get() {
    const n = await getWithFallback(versionKey, o.get.bind(o), o.has.bind(o), o);
    return parseInt(toString$1(n), 10);
  }, set: (n) => o.put(versionKey, fromString(String(n))), async check(n) {
    const c = await this.get();
    return log$4("comparing version: %s and %s", c, n), c === n || c === 6 && n === 7 || n === 6 && c === 7;
  } };
}
var eventemitter3 = { exports: {} };
(function(o) {
  var n = Object.prototype.hasOwnProperty, c = "~";
  function u() {
  }
  function h(I, P, L) {
    this.fn = I, this.context = P, this.once = L || !1;
  }
  function g(I, P, L, q, N) {
    if (typeof L != "function")
      throw new TypeError("The listener must be a function");
    var X = new h(L, q || I, N), rt = c ? c + P : P;
    return I._events[rt] ? I._events[rt].fn ? I._events[rt] = [I._events[rt], X] : I._events[rt].push(X) : (I._events[rt] = X, I._eventsCount++), I;
  }
  function y(I, P) {
    --I._eventsCount == 0 ? I._events = new u() : delete I._events[P];
  }
  function $() {
    this._events = new u(), this._eventsCount = 0;
  }
  Object.create && (u.prototype = /* @__PURE__ */ Object.create(null), new u().__proto__ || (c = !1)), $.prototype.eventNames = function() {
    var I, P, L = [];
    if (this._eventsCount === 0)
      return L;
    for (P in I = this._events)
      n.call(I, P) && L.push(c ? P.slice(1) : P);
    return Object.getOwnPropertySymbols ? L.concat(Object.getOwnPropertySymbols(I)) : L;
  }, $.prototype.listeners = function(I) {
    var P = c ? c + I : I, L = this._events[P];
    if (!L)
      return [];
    if (L.fn)
      return [L.fn];
    for (var q = 0, N = L.length, X = new Array(N); q < N; q++)
      X[q] = L[q].fn;
    return X;
  }, $.prototype.listenerCount = function(I) {
    var P = c ? c + I : I, L = this._events[P];
    return L ? L.fn ? 1 : L.length : 0;
  }, $.prototype.emit = function(I, P, L, q, N, X) {
    var rt = c ? c + I : I;
    if (!this._events[rt])
      return !1;
    var nt, st, ot = this._events[rt], St = arguments.length;
    if (ot.fn) {
      switch (ot.once && this.removeListener(I, ot.fn, void 0, !0), St) {
        case 1:
          return ot.fn.call(ot.context), !0;
        case 2:
          return ot.fn.call(ot.context, P), !0;
        case 3:
          return ot.fn.call(ot.context, P, L), !0;
        case 4:
          return ot.fn.call(ot.context, P, L, q), !0;
        case 5:
          return ot.fn.call(ot.context, P, L, q, N), !0;
        case 6:
          return ot.fn.call(ot.context, P, L, q, N, X), !0;
      }
      for (st = 1, nt = new Array(St - 1); st < St; st++)
        nt[st - 1] = arguments[st];
      ot.fn.apply(ot.context, nt);
    } else {
      var Ct, et = ot.length;
      for (st = 0; st < et; st++)
        switch (ot[st].once && this.removeListener(I, ot[st].fn, void 0, !0), St) {
          case 1:
            ot[st].fn.call(ot[st].context);
            break;
          case 2:
            ot[st].fn.call(ot[st].context, P);
            break;
          case 3:
            ot[st].fn.call(ot[st].context, P, L);
            break;
          case 4:
            ot[st].fn.call(ot[st].context, P, L, q);
            break;
          default:
            if (!nt)
              for (Ct = 1, nt = new Array(St - 1); Ct < St; Ct++)
                nt[Ct - 1] = arguments[Ct];
            ot[st].fn.apply(ot[st].context, nt);
        }
    }
    return !0;
  }, $.prototype.on = function(I, P, L) {
    return g(this, I, P, L, !1);
  }, $.prototype.once = function(I, P, L) {
    return g(this, I, P, L, !0);
  }, $.prototype.removeListener = function(I, P, L, q) {
    var N = c ? c + I : I;
    if (!this._events[N])
      return this;
    if (!P)
      return y(this, N), this;
    var X = this._events[N];
    if (X.fn)
      X.fn !== P || q && !X.once || L && X.context !== L || y(this, N);
    else {
      for (var rt = 0, nt = [], st = X.length; rt < st; rt++)
        (X[rt].fn !== P || q && !X[rt].once || L && X[rt].context !== L) && nt.push(X[rt]);
      nt.length ? this._events[N] = nt.length === 1 ? nt[0] : nt : y(this, N);
    }
    return this;
  }, $.prototype.removeAllListeners = function(I) {
    var P;
    return I ? (P = c ? c + I : I, this._events[P] && y(this, P)) : (this._events = new u(), this._eventsCount = 0), this;
  }, $.prototype.off = $.prototype.removeListener, $.prototype.addListener = $.prototype.on, $.prefixed = c, $.EventEmitter = $, o.exports = $;
})(eventemitter3);
const EventEmitter$2 = eventemitter3.exports;
class TimeoutError$1 extends Error {
  constructor(n) {
    super(n), this.name = "TimeoutError";
  }
}
class AbortError$2 extends Error {
  constructor(n) {
    super(), this.name = "AbortError", this.message = n;
  }
}
const getDOMException$1 = (o) => globalThis.DOMException === void 0 ? new AbortError$2(o) : new DOMException(o), getAbortedReason$1 = (o) => {
  const n = o.reason === void 0 ? getDOMException$1("This operation was aborted.") : o.reason;
  return n instanceof Error ? n : getDOMException$1(n);
};
function pTimeout$1(o, n, c, u) {
  let h;
  const g = new Promise((y, $) => {
    if (typeof n != "number" || Math.sign(n) !== 1)
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${n}\``);
    if (n !== Number.POSITIVE_INFINITY) {
      if ((u = { customTimers: { setTimeout, clearTimeout }, ...u }).signal) {
        const { signal: I } = u;
        I.aborted && $(getAbortedReason$1(I)), I.addEventListener("abort", () => {
          $(getAbortedReason$1(I));
        });
      }
      h = u.customTimers.setTimeout.call(void 0, () => {
        if (typeof c == "function") {
          try {
            y(c());
          } catch (P) {
            $(P);
          }
          return;
        }
        const I = c instanceof Error ? c : new TimeoutError$1(typeof c == "string" ? c : `Promise timed out after ${n} milliseconds`);
        typeof o.cancel == "function" && o.cancel(), $(I);
      }, n), (async () => {
        try {
          y(await o);
        } catch (I) {
          $(I);
        } finally {
          u.customTimers.clearTimeout.call(void 0, h);
        }
      })();
    } else
      y(o);
  });
  return g.clear = () => {
    clearTimeout(h), h = void 0;
  }, g;
}
function lowerBound(o, n, c) {
  let u = 0, h = o.length;
  for (; h > 0; ) {
    const g = Math.trunc(h / 2);
    let y = u + g;
    c(o[y], n) <= 0 ? (u = ++y, h -= g + 1) : h = g;
  }
  return u;
}
var __classPrivateFieldGet$1 = globalThis && globalThis.__classPrivateFieldGet || function(o, n, c, u) {
  if (c === "a" && !u)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof n == "function" ? o !== n || !u : !n.has(o))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return c === "m" ? u : c === "a" ? u.call(o) : u ? u.value : n.get(o);
}, _PriorityQueue_queue;
class PriorityQueue {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(n, c) {
    const u = { priority: (c = { priority: 0, ...c }).priority, run: n };
    if (this.size && __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= c.priority)
      return void __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").push(u);
    const h = lowerBound(__classPrivateFieldGet$1(this, _PriorityQueue_queue, "f"), u, (g, y) => y.priority - g.priority);
    __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").splice(h, 0, u);
  }
  dequeue() {
    const n = __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").shift();
    return n == null ? void 0 : n.run;
  }
  filter(n) {
    return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").filter((c) => c.priority === n.priority).map((c) => c.run);
  }
  get size() {
    return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").length;
  }
}
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = globalThis && globalThis.__classPrivateFieldSet || function(o, n, c, u, h) {
  if (u === "m")
    throw new TypeError("Private method is not writable");
  if (u === "a" && !h)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof n == "function" ? o !== n || !h : !n.has(o))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return u === "a" ? h.call(o, c) : h ? h.value = c : n.set(o, c), c;
}, __classPrivateFieldGet = globalThis && globalThis.__classPrivateFieldGet || function(o, n, c, u) {
  if (c === "a" && !u)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof n == "function" ? o !== n || !u : !n.has(o))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return c === "m" ? u : c === "a" ? u.call(o) : u ? u.value : n.get(o);
}, _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pendingCount, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_emitEvents, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_onEvent;
const timeoutError = new TimeoutError$1();
class AbortError$1 extends Error {
}
class PQueue extends EventEmitter$2 {
  constructor(n) {
    var c, u, h, g;
    if (super(), _PQueue_instances.add(this), _PQueue_carryoverConcurrencyCount.set(this, void 0), _PQueue_isIntervalIgnored.set(this, void 0), _PQueue_intervalCount.set(this, 0), _PQueue_intervalCap.set(this, void 0), _PQueue_interval.set(this, void 0), _PQueue_intervalEnd.set(this, 0), _PQueue_intervalId.set(this, void 0), _PQueue_timeoutId.set(this, void 0), _PQueue_queue.set(this, void 0), _PQueue_queueClass.set(this, void 0), _PQueue_pendingCount.set(this, 0), _PQueue_concurrency.set(this, void 0), _PQueue_isPaused.set(this, void 0), _PQueue_throwOnTimeout.set(this, void 0), Object.defineProperty(this, "timeout", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), !(typeof (n = { carryoverConcurrencyCount: !1, intervalCap: Number.POSITIVE_INFINITY, interval: 0, concurrency: Number.POSITIVE_INFINITY, autoStart: !0, queueClass: PriorityQueue, ...n }).intervalCap == "number" && n.intervalCap >= 1))
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(u = (c = n.intervalCap) === null || c === void 0 ? void 0 : c.toString()) !== null && u !== void 0 ? u : ""}\` (${typeof n.intervalCap})`);
    if (n.interval === void 0 || !(Number.isFinite(n.interval) && n.interval >= 0))
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(g = (h = n.interval) === null || h === void 0 ? void 0 : h.toString()) !== null && g !== void 0 ? g : ""}\` (${typeof n.interval})`);
    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, n.carryoverConcurrencyCount, "f"), __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, n.intervalCap === Number.POSITIVE_INFINITY || n.interval === 0, "f"), __classPrivateFieldSet(this, _PQueue_intervalCap, n.intervalCap, "f"), __classPrivateFieldSet(this, _PQueue_interval, n.interval, "f"), __classPrivateFieldSet(this, _PQueue_queue, new n.queueClass(), "f"), __classPrivateFieldSet(this, _PQueue_queueClass, n.queueClass, "f"), this.concurrency = n.concurrency, this.timeout = n.timeout, __classPrivateFieldSet(this, _PQueue_throwOnTimeout, n.throwOnTimeout === !0, "f"), __classPrivateFieldSet(this, _PQueue_isPaused, n.autoStart === !1, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet(this, _PQueue_concurrency, "f");
  }
  set concurrency(n) {
    if (!(typeof n == "number" && n >= 1))
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${n}\` (${typeof n})`);
    __classPrivateFieldSet(this, _PQueue_concurrency, n, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(n, c = {}) {
    return new Promise((u, h) => {
      __classPrivateFieldGet(this, _PQueue_queue, "f").enqueue(async () => {
        var g, y, $;
        __classPrivateFieldSet(this, _PQueue_pendingCount, (y = __classPrivateFieldGet(this, _PQueue_pendingCount, "f"), ++y), "f"), __classPrivateFieldSet(this, _PQueue_intervalCount, ($ = __classPrivateFieldGet(this, _PQueue_intervalCount, "f"), ++$), "f");
        try {
          if (!((g = c.signal) === null || g === void 0) && g.aborted)
            return void h(new AbortError$1("The task was aborted."));
          const I = this.timeout === void 0 && c.timeout === void 0 ? n({ signal: c.signal }) : pTimeout$1(Promise.resolve(n({ signal: c.signal })), c.timeout === void 0 ? this.timeout : c.timeout, () => {
            (c.throwOnTimeout === void 0 ? __classPrivateFieldGet(this, _PQueue_throwOnTimeout, "f") : c.throwOnTimeout) && h(timeoutError);
          }), P = await I;
          u(P), this.emit("completed", P);
        } catch (I) {
          h(I), this.emit("error", I);
        }
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_next).call(this);
      }, c), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this), this.emit("add");
    });
  }
  async addAll(n, c) {
    return Promise.all(n.map(async (u) => this.add(u, c)));
  }
  start() {
    return __classPrivateFieldGet(this, _PQueue_isPaused, "f") ? (__classPrivateFieldSet(this, _PQueue_isPaused, !1, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this), this) : this;
  }
  pause() {
    __classPrivateFieldSet(this, _PQueue_isPaused, !0, "f");
  }
  clear() {
    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, "f"))(), "f");
  }
  async onEmpty() {
    __classPrivateFieldGet(this, _PQueue_queue, "f").size !== 0 && await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  async onSizeLessThan(n) {
    __classPrivateFieldGet(this, _PQueue_queue, "f").size < n || await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet(this, _PQueue_queue, "f").size < n);
  }
  async onIdle() {
    __classPrivateFieldGet(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet(this, _PQueue_queue, "f").size === 0 || await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  get size() {
    return __classPrivateFieldGet(this, _PQueue_queue, "f").size;
  }
  sizeBy(n) {
    return __classPrivateFieldGet(this, _PQueue_queue, "f").filter(n).length;
  }
  get pending() {
    return __classPrivateFieldGet(this, _PQueue_pendingCount, "f");
  }
  get isPaused() {
    return __classPrivateFieldGet(this, _PQueue_isPaused, "f");
  }
}
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pendingCount = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function() {
  return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function() {
  return __classPrivateFieldGet(this, _PQueue_pendingCount, "f") < __classPrivateFieldGet(this, _PQueue_concurrency, "f");
}, _PQueue_next = function() {
  var o;
  __classPrivateFieldSet(this, _PQueue_pendingCount, (o = __classPrivateFieldGet(this, _PQueue_pendingCount, "f"), --o), "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this), this.emit("next");
}, _PQueue_emitEvents = function() {
  this.emit("empty"), __classPrivateFieldGet(this, _PQueue_pendingCount, "f") === 0 && this.emit("idle");
}, _PQueue_onResumeInterval = function() {
  __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this), __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function() {
  const o = Date.now();
  if (__classPrivateFieldGet(this, _PQueue_intervalId, "f") === void 0) {
    const n = __classPrivateFieldGet(this, _PQueue_intervalEnd, "f") - o;
    if (!(n < 0))
      return __classPrivateFieldGet(this, _PQueue_timeoutId, "f") === void 0 && __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
      }, n), "f"), !0;
    __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pendingCount, "f") : 0, "f");
  }
  return !1;
}, _PQueue_tryToStartAnother = function() {
  if (__classPrivateFieldGet(this, _PQueue_queue, "f").size === 0)
    return __classPrivateFieldGet(this, _PQueue_intervalId, "f") && clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f")), __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_emitEvents).call(this), !1;
  if (!__classPrivateFieldGet(this, _PQueue_isPaused, "f")) {
    const o = !__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const n = __classPrivateFieldGet(this, _PQueue_queue, "f").dequeue();
      return !!n && (this.emit("active"), n(), o && __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this), !0);
    }
  }
  return !1;
}, _PQueue_initializeIntervalIfNeeded = function() {
  __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalId, "f") !== void 0 || (__classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet(this, _PQueue_interval, "f")), "f"), __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, "f"), "f"));
}, _PQueue_onInterval = function() {
  __classPrivateFieldGet(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, "f") && (clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f")), __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f")), __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pendingCount, "f") : 0, "f"), __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function() {
  for (; __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this); )
    ;
}, _PQueue_onEvent = async function(o, n) {
  return new Promise((c) => {
    const u = () => {
      n && !n() || (this.off(o, u), c());
    };
    this.on(o, u);
  });
};
var objectSafeSet = set;
function set(o, n, c) {
  var u, h, g;
  if (Array.isArray(n) && (u = n.slice(0)), typeof n == "string" && (u = n.split(".")), typeof n == "symbol" && (u = [n]), !Array.isArray(u))
    throw new Error("props arg must be an array, a string or a symbol");
  if (!(h = u.pop()))
    return !1;
  for (prototypeCheck(h); g = u.shift(); )
    if (prototypeCheck(g), o[g] === void 0 && (o[g] = {}), !(o = o[g]) || typeof o != "object")
      return !1;
  return o[h] = c, !0;
}
function prototypeCheck(o) {
  if (o == "__proto__" || o == "constructor" || o == "prototype")
    throw new Error("setting of prototype values not supported");
}
const Queue = PQueue.default ? PQueue.default : PQueue, configKey = new Key("config");
function config$1(o) {
  const n = new Queue({ concurrency: 1 }), c = { async getAll(g = {}) {
    const y = await getWithFallback(configKey, o.get.bind(o), o.has.bind(o), o);
    return JSON.parse(toString$1(y));
  }, async get(g, y = {}) {
    if (g == null)
      throw new NotFoundError(`Key ${g} does not exist in config`);
    const $ = await this.getAll(y), I = objectSafeGet($, g);
    if (I === void 0)
      throw new NotFoundError(`Key ${g} does not exist in config`);
    return I;
  }, set(g, y, $ = {}) {
    if (typeof g != "string" && !(g instanceof String))
      throw errCode(new Error("Invalid key type: " + typeof g), "ERR_INVALID_KEY");
    if (y === void 0 || y instanceof Uint8Array)
      throw errCode(new Error("Invalid value type: " + typeof y), "ERR_INVALID_VALUE");
    return n.add(() => u({ key: g, value: y }, $.signal));
  }, replace(g, y = {}) {
    if (!g || g instanceof Uint8Array)
      throw errCode(new Error("Invalid value type: " + typeof g), "ERR_INVALID_VALUE");
    return n.add(() => u({ key: void 0, value: g }, y.signal));
  }, exists: async () => hasWithFallback(configKey, o.has.bind(o), o) };
  return c;
  async function u(g, y) {
    if (y && y.aborted)
      return;
    const $ = g.key, I = g.value;
    if ($) {
      const P = await c.getAll();
      return typeof P == "object" && P !== null && objectSafeSet(P, $, I), h(P);
    }
    return h(I);
  }
  function h(g) {
    const y = fromString(JSON.stringify(g, null, 2));
    return o.put(configKey, y);
  }
}
function isPlainObject(o) {
  if (typeof o != "object" || o === null)
    return !1;
  const n = Object.getPrototypeOf(o);
  return !(n !== null && n !== Object.prototype && Object.getPrototypeOf(n) !== null || Symbol.toStringTag in o || Symbol.iterator in o);
}
function sortKeys(o, n = {}) {
  if (!isPlainObject(o) && !Array.isArray(o))
    throw new TypeError("Expected a plain object or array");
  const { deep: c, compare: u } = n, h = [], g = [], y = (I) => {
    const P = h.indexOf(I);
    if (P !== -1)
      return g[P];
    const L = [];
    return h.push(I), g.push(L), L.push(...I.map((q) => Array.isArray(q) ? y(q) : isPlainObject(q) ? $(q) : q)), L;
  }, $ = (I) => {
    const P = h.indexOf(I);
    if (P !== -1)
      return g[P];
    const L = {}, q = Object.keys(I).sort(u);
    h.push(I), g.push(L);
    for (const N of q) {
      const X = I[N];
      let rt;
      rt = c && Array.isArray(X) ? y(X) : c && isPlainObject(X) ? $(X) : X, Object.defineProperty(L, N, { ...Object.getOwnPropertyDescriptor(I, N), value: rt });
    }
    return L;
  };
  return Array.isArray(o) ? c ? y(o) : o.slice() : $(o);
}
const specKey = new Key("datastore_spec");
function spec(o) {
  return { exists: () => o.has(specKey), async get() {
    const n = await o.get(specKey);
    return JSON.parse(toString$1(n));
  }, set: async (n) => o.put(specKey, fromString(JSON.stringify(sortKeys(n, { deep: !0 })))) };
}
const apiFile = new Key("api");
function apiAddr(o) {
  return { async get() {
    const n = await o.get(apiFile);
    return n && n.toString();
  }, set: (n) => o.put(apiFile, fromString(n.toString())), delete: () => o.delete(apiFile) };
}
const filter = async function* (o, n) {
  for await (const c of o)
    await n(c) && (yield c);
};
var itFilter = filter;
class FixedFIFO$1 {
  constructor(n) {
    if (!(n > 0) || (n - 1 & n) != 0)
      throw new Error("Max size for a FixedFIFO should be a power of two");
    this.buffer = new Array(n), this.mask = n - 1, this.top = 0, this.btm = 0, this.next = null;
  }
  push(n) {
    return this.buffer[this.top] === void 0 && (this.buffer[this.top] = n, this.top = this.top + 1 & this.mask, !0);
  }
  shift() {
    const n = this.buffer[this.btm];
    if (n !== void 0)
      return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, n;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
}
class FIFO$1 {
  constructor(n = {}) {
    var c;
    this.hwm = (c = n.splitLimit) != null ? c : 16, this.head = new FixedFIFO$1(this.hwm), this.tail = this.head, this.size = 0;
  }
  calculateSize(n) {
    return (n == null ? void 0 : n.byteLength) != null ? n.byteLength : 1;
  }
  push(n) {
    if ((n == null ? void 0 : n.value) != null && (this.size += this.calculateSize(n.value)), !this.head.push(n)) {
      const c = this.head;
      this.head = c.next = new FixedFIFO$1(2 * this.head.buffer.length), this.head.push(n);
    }
  }
  shift() {
    let n = this.tail.shift();
    if (n === void 0 && this.tail.next != null) {
      const c = this.tail.next;
      this.tail.next = null, this.tail = c, n = this.tail.shift();
    }
    return (n == null ? void 0 : n.value) != null && (this.size -= this.calculateSize(n.value)), n;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
}
function pushable$1(o = {}) {
  return _pushable((n) => {
    const c = n.shift();
    if (c == null)
      return { done: !0 };
    if (c.error != null)
      throw c.error;
    return { done: c.done === !0, value: c.value };
  }, o);
}
function _pushable(o, n) {
  let c, u, h, g = (n = n != null ? n : {}).onEnd, y = new FIFO$1();
  const $ = (q) => u != null ? u(q) : (y.push(q), c), I = (q) => {
    if (h)
      return c;
    if ((n == null ? void 0 : n.objectMode) !== !0 && (q == null ? void 0 : q.byteLength) == null)
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    return $({ done: !1, value: q });
  }, P = (q) => h ? c : (h = !0, q != null ? ((N) => (y = new FIFO$1(), u != null ? u({ error: N }) : (y.push({ error: N }), c)))(q) : $({ done: !0 }));
  if (c = { [Symbol.asyncIterator]() {
    return this;
  }, next: async () => y.isEmpty() ? h ? { done: !0 } : await new Promise((q, N) => {
    u = (X) => {
      u = null, y.push(X);
      try {
        q(o(y));
      } catch (rt) {
        N(rt);
      }
      return c;
    };
  }) : o(y), return: () => (y = new FIFO$1(), P(), { done: !0 }), throw: (q) => (P(q), { done: !0 }), push: I, end: P, get readableLength() {
    return y.size;
  } }, g == null)
    return c;
  const L = c;
  return c = { [Symbol.asyncIterator]() {
    return this;
  }, next: () => L.next(), throw: (q) => (L.throw(q), g != null && (g(q), g = void 0), { done: !0 }), return: () => (L.return(), g != null && (g(), g = void 0), { done: !0 }), push: I, end: (q) => (L.end(q), g != null && (g(q), g = void 0), c), get readableLength() {
    return L.readableLength;
  } }, c;
}
const drain = async (o) => {
  for await (const n of o)
    ;
};
var itDrain = drain;
function createIdStore(o) {
  return { open: () => o.open(), close: () => o.close(), query: (n, c) => o.query(n, c), queryKeys: (n, c) => o.queryKeys(n, c), async get(n, c) {
    const u = extractContents(n);
    return u.isIdentity ? Promise.resolve(u.digest) : o.get(n, c);
  }, async *getMany(n, c) {
    for await (const u of n)
      yield this.get(u, c);
  }, async put(n, c, u) {
    const { isIdentity: h } = extractContents(n);
    h || await o.put(n, c, u);
  }, async *putMany(n, c) {
    const u = pushable$1({ objectMode: !0 });
    (globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout)(async () => {
      try {
        await itDrain(o.putMany(async function* () {
          for await (const { key: h, value: g } of n)
            extractContents(h).isIdentity || (yield { key: h, value: g }), u.push({ key: h, value: g });
        }())), u.end();
      } catch (h) {
        u.end(h);
      }
    }), yield* u;
  }, has(n, c) {
    const { isIdentity: u } = extractContents(n);
    return u ? Promise.resolve(!0) : o.has(n, c);
  }, delete(n, c) {
    const { isIdentity: u } = extractContents(n);
    return u ? Promise.resolve() : o.delete(n, c);
  }, deleteMany: (n, c) => o.deleteMany(itFilter(n, (u) => !extractContents(u).isIdentity), c), batch() {
    const n = o.batch();
    return { put(c, u) {
      const { isIdentity: h } = extractContents(c);
      h || n.put(c, u);
    }, delete(c) {
      const { isIdentity: u } = extractContents(c);
      u || n.delete(c);
    }, commit: (c) => n.commit(c) };
  } };
}
function extractContents(o) {
  const n = CID$2.asCID(o);
  if (n == null)
    throw errCode(new Error("Not a valid cid"), "ERR_INVALID_CID");
  return n.multihash.code !== identity$4.code ? { isIdentity: !1 } : { isIdentity: !0, digest: n.multihash.digest };
}
const log$3 = debug("ipfs:repo:lock:memory"), lockFile = "repo.lock", LOCKS = {};
async function lock(o) {
  const n = o + "/" + lockFile;
  if (log$3("locking %s", n), LOCKS[n] === !0)
    throw new LockExistsError(`Lock already being held for file: ${n}`);
  return LOCKS[n] = !0, { async close() {
    LOCKS[n] && delete LOCKS[n];
  } };
}
async function locked(o) {
  const n = o + "/" + lockFile;
  return log$3(`checking lock: ${n}`), Boolean(LOCKS[n]);
}
const MemoryLock = { lock, locked }, defaultOptions$2 = { autoMigrate: !0, onMigrationProgress: () => {
}, repoOwner: !0, repoLock: MemoryLock }, defaultDatastore = { Spec: { type: "mount", mounts: [{ mountpoint: "/blocks", type: "measure", prefix: "flatfs.datastore", child: { type: "flatfs", path: "blocks", sync: !0, shardFunc: "/repo/flatfs/shard/v1/next-to-last/2" } }, { mountpoint: "/", type: "measure", prefix: "leveldb.datastore", child: { type: "levelds", path: "datastore", compression: "none" } }] } }, first = async (o) => {
  for await (const n of o)
    return n;
};
var itFirst = first;
function cidToKey$1(o) {
  const n = CID$2.asCID(o);
  if (n == null)
    throw errCode(new Error("Not a valid cid"), "ERR_INVALID_CID");
  const c = base32$6.encode(n.multihash.bytes);
  return new Key("/" + c.slice(1).toUpperCase(), !1);
}
function keyToMultihash(o) {
  return decode$r(base32$6.decode(`b${o.toString().toLowerCase().substring(1)}`));
}
const log$2 = debug("ipfs:repo:utils:walk-dag");
async function* walkDag(o, n, c, u) {
  try {
    const h = await n.get(o, u), g = await c(o.code), y = createUnsafe({ bytes: h, cid: o, codec: g });
    for (const [, $] of y.links())
      yield $, yield* walkDag($, n, c, u);
  } catch (h) {
    throw log$2("Could not walk DAG for CID", o.toString(), h), h;
  }
}
const PinTypes = { direct: "direct", recursive: "recursive", indirect: "indirect", all: "all" };
class QuickLRU extends Map {
  constructor(n = {}) {
    if (super(), !(n.maxSize && n.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    if (typeof n.maxAge == "number" && n.maxAge === 0)
      throw new TypeError("`maxAge` must be a number greater than 0");
    this.maxSize = n.maxSize, this.maxAge = n.maxAge || Number.POSITIVE_INFINITY, this.onEviction = n.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  _emitEvictions(n) {
    if (typeof this.onEviction == "function")
      for (const [c, u] of n)
        this.onEviction(c, u.value);
  }
  _deleteIfExpired(n, c) {
    return typeof c.expiry == "number" && c.expiry <= Date.now() && (typeof this.onEviction == "function" && this.onEviction(n, c.value), this.delete(n));
  }
  _getOrDeleteIfExpired(n, c) {
    if (this._deleteIfExpired(n, c) === !1)
      return c.value;
  }
  _getItemValue(n, c) {
    return c.expiry ? this._getOrDeleteIfExpired(n, c) : c.value;
  }
  _peek(n, c) {
    const u = c.get(n);
    return this._getItemValue(n, u);
  }
  _set(n, c) {
    this.cache.set(n, c), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
  _moveToRecent(n, c) {
    this.oldCache.delete(n), this._set(n, c);
  }
  *_entriesAscending() {
    for (const n of this.oldCache) {
      const [c, u] = n;
      this.cache.has(c) || this._deleteIfExpired(c, u) === !1 && (yield n);
    }
    for (const n of this.cache) {
      const [c, u] = n;
      this._deleteIfExpired(c, u) === !1 && (yield n);
    }
  }
  get(n) {
    if (this.cache.has(n)) {
      const c = this.cache.get(n);
      return this._getItemValue(n, c);
    }
    if (this.oldCache.has(n)) {
      const c = this.oldCache.get(n);
      if (this._deleteIfExpired(n, c) === !1)
        return this._moveToRecent(n, c), c.value;
    }
  }
  set(n, c, { maxAge: u = this.maxAge } = {}) {
    const h = typeof u == "number" && u !== Number.POSITIVE_INFINITY ? Date.now() + u : void 0;
    this.cache.has(n) ? this.cache.set(n, { value: c, expiry: h }) : this._set(n, { value: c, expiry: h });
  }
  has(n) {
    return this.cache.has(n) ? !this._deleteIfExpired(n, this.cache.get(n)) : !!this.oldCache.has(n) && !this._deleteIfExpired(n, this.oldCache.get(n));
  }
  peek(n) {
    return this.cache.has(n) ? this._peek(n, this.cache) : this.oldCache.has(n) ? this._peek(n, this.oldCache) : void 0;
  }
  delete(n) {
    const c = this.cache.delete(n);
    return c && this._size--, this.oldCache.delete(n) || c;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  resize(n) {
    if (!(n && n > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    const c = [...this._entriesAscending()], u = c.length - n;
    u < 0 ? (this.cache = new Map(c), this.oldCache = /* @__PURE__ */ new Map(), this._size = c.length) : (u > 0 && this._emitEvictions(c.slice(0, u)), this.oldCache = new Map(c.slice(u)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = n;
  }
  *keys() {
    for (const [n] of this)
      yield n;
  }
  *values() {
    for (const [, n] of this)
      yield n;
  }
  *[Symbol.iterator]() {
    for (const n of this.cache) {
      const [c, u] = n;
      this._deleteIfExpired(c, u) === !1 && (yield [c, u.value]);
    }
    for (const n of this.oldCache) {
      const [c, u] = n;
      this.cache.has(c) || this._deleteIfExpired(c, u) === !1 && (yield [c, u.value]);
    }
  }
  *entriesDescending() {
    let n = [...this.cache];
    for (let c = n.length - 1; c >= 0; --c) {
      const u = n[c], [h, g] = u;
      this._deleteIfExpired(h, g) === !1 && (yield [h, g.value]);
    }
    n = [...this.oldCache];
    for (let c = n.length - 1; c >= 0; --c) {
      const u = n[c], [h, g] = u;
      this.cache.has(h) || this._deleteIfExpired(h, g) === !1 && (yield [h, g.value]);
    }
  }
  *entriesAscending() {
    for (const [n, c] of this._entriesAscending())
      yield [n, c.value];
  }
  get size() {
    if (!this._size)
      return this.oldCache.size;
    let n = 0;
    for (const c of this.oldCache.keys())
      this.cache.has(c) || n++;
    return Math.min(this._size + n, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(n, c = this) {
    for (const [u, h] of this.entriesAscending())
      n.call(c, h, u, this);
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
}
const CID_CACHE_MAX_SIZE = 2048;
function invalidPinTypeErr(o) {
  return errCode(new Error(`Invalid type '${o}', must be one of {direct, indirect, recursive, all}`), "ERR_INVALID_PIN_TYPE");
}
class PinManager {
  constructor({ pinstore: n, blockstore: c, loadCodec: u }) {
    this.pinstore = n, this.blockstore = c, this.loadCodec = u, this.log = debug("ipfs:repo:pin"), this.directPins = /* @__PURE__ */ new Set(), this.recursivePins = /* @__PURE__ */ new Set();
  }
  async pinDirectly(n, c = {}) {
    await this.blockstore.get(n, c);
    const u = { depth: 0 };
    return n.version !== 0 && (u.version = n.version), n.code !== code$7 && (u.codec = n.code), c.metadata && (u.metadata = c.metadata), this.pinstore.put(cidToKey$1(n), encode$s(u));
  }
  unpin(n, c) {
    return this.pinstore.delete(cidToKey$1(n), c);
  }
  async pinRecursively(n, c = {}) {
    await this.fetchCompleteDag(n, c);
    const u = { depth: 1 / 0 };
    n.version !== 0 && (u.version = n.version), n.code !== code$7 && (u.codec = n.code), c.metadata && (u.metadata = c.metadata), await this.pinstore.put(cidToKey$1(n), encode$s(u));
  }
  async *directKeys(n) {
    for await (const c of this.pinstore.query({ filters: [(u) => decode$u(u.value).depth === 0] })) {
      const u = decode$u(c.value), h = u.version || 0, g = u.codec != null ? u.codec : code$7, y = keyToMultihash(c.key);
      yield { cid: CID$2.create(h, g, y), metadata: u.metadata };
    }
  }
  async *recursiveKeys(n) {
    for await (const c of this.pinstore.query({ filters: [(u) => decode$u(u.value).depth === 1 / 0] })) {
      const u = decode$u(c.value), h = u.version || 0, g = u.codec != null ? u.codec : code$7, y = keyToMultihash(c.key);
      yield { cid: CID$2.create(h, g, y), metadata: u.metadata };
    }
  }
  async *indirectKeys(n) {
    for await (const { cid: c } of this.recursiveKeys())
      for await (const u of walkDag(c, this.blockstore, this.loadCodec, n)) {
        const h = [PinTypes.recursive];
        (await this.isPinnedWithType(u, h)).pinned || (yield u);
      }
  }
  async isPinnedWithType(n, c, u) {
    Array.isArray(c) || (c = [c]);
    const h = c.includes(PinTypes.all), g = c.includes(PinTypes.direct), y = c.includes(PinTypes.recursive), $ = c.includes(PinTypes.indirect);
    if (y || g || h) {
      const P = await itFirst(this.pinstore.query({ prefix: cidToKey$1(n).toString(), filters: [(L) => {
        if (h)
          return !0;
        const q = decode$u(L.value);
        return c.includes(q.depth === 0 ? PinTypes.direct : PinTypes.recursive);
      }], limit: 1 }));
      if (P) {
        const L = decode$u(P.value);
        return { cid: n, pinned: !0, reason: L.depth === 0 ? PinTypes.direct : PinTypes.recursive, metadata: L.metadata };
      }
    }
    const I = this;
    if (h || $) {
      const P = await itFirst(async function* (L, q) {
        for await (const { cid: N } of q)
          for await (const X of walkDag(N, I.blockstore, I.loadCodec))
            if (X.equals(L))
              return void (yield N);
      }(n, this.recursiveKeys()));
      if (P)
        return { cid: n, pinned: !0, reason: PinTypes.indirect, parent: P };
    }
    return { cid: n, pinned: !1 };
  }
  async fetchCompleteDag(n, c = {}) {
    var g;
    const u = new QuickLRU({ maxSize: (g = c.cidCacheMaxSize) != null ? g : CID_CACHE_MAX_SIZE }), h = async (y, $) => {
      if (u.has(y.toString()))
        return;
      u.set(y.toString(), !0);
      const I = await this.blockstore.get(y, $), P = await this.loadCodec(y.code), L = createUnsafe({ bytes: I, cid: y, codec: P });
      await Promise.all([...L.links()].map(([, q]) => h(q, $)));
    };
    await h(n, c);
  }
  static checkPinType(n) {
    if (typeof n != "string" || !Object.keys(PinTypes).includes(n))
      throw invalidPinTypeErr(n);
    return !0;
  }
}
const map = async function* (o, n) {
  for await (const c of o)
    yield n(c);
};
var itMap = map;
function createPinnedBlockstore(o, n) {
  return { open: () => n.open(), close: () => n.close(), query: (c, u) => n.query(c, u), queryKeys: (c, u) => n.queryKeys(c, u), get: async (c, u) => n.get(c, u), async *getMany(c, u) {
    yield* n.getMany(c, u);
  }, async put(c, u, h) {
    await n.put(c, u, h);
  }, async *putMany(c, u) {
    yield* n.putMany(c, u);
  }, has: (c, u) => n.has(c, u), delete: async (c, u) => (await ensureNotPinned(c, o), n.delete(c, u)), deleteMany: (c, u) => n.deleteMany(itMap(c, async (h) => (await ensureNotPinned(h, o), h)), u), batch: () => n.batch() };
}
async function ensureNotPinned(o, n) {
  const { pinned: c, reason: u } = await n.isPinnedWithType(o, PinTypes.all);
  if (c)
    throw errCode(new Error(`pinned: ${u}`), "ERR_BLOCK_PINNED");
}
class TimeoutError extends Error {
  constructor(n) {
    super(n), this.name = "TimeoutError";
  }
}
class AbortError extends Error {
  constructor(n) {
    super(), this.name = "AbortError", this.message = n;
  }
}
const getDOMException = (o) => globalThis.DOMException === void 0 ? new AbortError(o) : new DOMException(o), getAbortedReason = (o) => {
  const n = o.reason === void 0 ? getDOMException("This operation was aborted.") : o.reason;
  return n instanceof Error ? n : getDOMException(n);
};
function pTimeout(o, n) {
  const { milliseconds: c, fallback: u, message: h, customTimers: g = { setTimeout, clearTimeout } } = n;
  let y;
  const $ = new Promise((I, P) => {
    if (typeof c != "number" || Math.sign(c) !== 1)
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${c}\``);
    if (c !== Number.POSITIVE_INFINITY) {
      if (n.signal) {
        const { signal: L } = n;
        L.aborted && P(getAbortedReason(L)), L.addEventListener("abort", () => {
          P(getAbortedReason(L));
        });
      }
      y = g.setTimeout.call(void 0, () => {
        if (u) {
          try {
            I(u());
          } catch (q) {
            P(q);
          }
          return;
        }
        const L = h instanceof Error ? h : new TimeoutError(typeof h == "string" ? h : `Promise timed out after ${c} milliseconds`);
        typeof o.cancel == "function" && o.cancel(), P(L);
      }, c), (async () => {
        try {
          I(await o);
        } catch (L) {
          P(L);
        } finally {
          g.clearTimeout.call(void 0, y);
        }
      })();
    } else
      I(o);
  });
  return $.clear = () => {
    g.clearTimeout.call(void 0, y), y = void 0;
  }, $;
}
let nanoid = (o = 21) => crypto.getRandomValues(new Uint8Array(o)).reduce((n, c) => n + ((c &= 63) < 36 ? c.toString(36) : c < 62 ? (c - 26).toString(36).toUpperCase() : c > 62 ? "-" : "_"), "");
const WORKER_REQUEST_READ_LOCK = "lock:worker:request-read", WORKER_RELEASE_READ_LOCK = "lock:worker:release-read", MASTER_GRANT_READ_LOCK = "lock:master:grant-read", WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write", WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write", MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write", events$1 = {}, observable = (o) => {
  o.addEventListener("message", (n) => {
    observable.dispatchEvent("message", o, n);
  }), o.port != null && o.port.addEventListener("message", (n) => {
    observable.dispatchEvent("message", o, n);
  });
};
observable.addEventListener = (o, n) => {
  events$1[o] == null && (events$1[o] = []), events$1[o].push(n);
}, observable.removeEventListener = (o, n) => {
  events$1[o] != null && (events$1[o] = events$1[o].filter((c) => c === n));
}, observable.dispatchEvent = function(o, n, c) {
  events$1[o] != null && events$1[o].forEach((u) => u(n, c));
};
const handleWorkerLockRequest = (o, n, c, u, h) => (g, y) => {
  if (y.data.type !== c)
    return;
  const $ = { type: y.data.type, name: y.data.name, identifier: y.data.identifier };
  o.dispatchEvent(new MessageEvent(n, { data: { name: $.name, handler: async () => (g.postMessage({ type: h, name: $.name, identifier: $.identifier }), await new Promise((I) => {
    const P = (L) => {
      if (L == null || L.data == null)
        return;
      const q = L.data.type, N = (L.data.name, L.data.identifier);
      q === u && N === $.identifier && (g.removeEventListener("message", P), I());
    };
    g.addEventListener("message", P);
  })) } }));
}, makeWorkerLockRequest = (o, n, c, u) => async () => {
  const h = nanoid();
  return globalThis.postMessage({ type: n, identifier: h, name: o }), await new Promise((g) => {
    const y = ($) => {
      if ($ == null || $.data == null)
        return;
      const I = $.data.type, P = $.data.identifier;
      I === c && P === h && (globalThis.removeEventListener("message", y), g(() => {
        globalThis.postMessage({ type: u, identifier: h, name: o });
      }));
    };
    globalThis.addEventListener("message", y);
  });
}, defaultOptions$1 = { singleProcess: !1 }, impl = (o) => {
  if (o = Object.assign({}, defaultOptions$1, o), Boolean(globalThis.document) || o.singleProcess) {
    const n = new EventTarget();
    return observable.addEventListener("message", handleWorkerLockRequest(n, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK)), observable.addEventListener("message", handleWorkerLockRequest(n, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK)), n;
  }
  return { isWorker: !0, readLock: (n) => makeWorkerLockRequest(n, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK), writeLock: (n) => makeWorkerLockRequest(n, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK) };
}, mutexes = {};
let implementation;
async function createReleaseable(o, n) {
  let c;
  const u = new Promise((h) => {
    c = h;
  });
  return o.add(async () => await pTimeout((async () => await new Promise((h) => {
    c(() => {
      h();
    });
  }))(), { milliseconds: n.timeout })), await u;
}
const createMutex = (o, n) => {
  if (implementation.isWorker === !0)
    return { readLock: implementation.readLock(o, n), writeLock: implementation.writeLock(o, n) };
  const c = new PQueue({ concurrency: 1 });
  let u;
  return { async readLock() {
    if (u != null)
      return await createReleaseable(u, n);
    u = new PQueue({ concurrency: n.concurrency, autoStart: !1 });
    const h = u, g = createReleaseable(u, n);
    return c.add(async () => (h.start(), await h.onIdle().then(() => {
      u === h && (u = null);
    }))), await g;
  }, writeLock: async () => (u = null, await createReleaseable(c, n)) };
}, defaultOptions = { name: "lock", concurrency: 1 / 0, timeout: 846e5, singleProcess: !1 };
function createMortice(o) {
  const n = Object.assign({}, defaultOptions, o);
  return implementation == null && (implementation = impl(n), implementation.isWorker !== !0 && (implementation.addEventListener("requestReadLock", (c) => {
    mutexes[c.data.name] != null && mutexes[c.data.name].readLock().then(async (u) => await c.data.handler().finally(() => u()));
  }), implementation.addEventListener("requestWriteLock", async (c) => {
    mutexes[c.data.name] != null && mutexes[c.data.name].writeLock().then(async (u) => await c.data.handler().finally(() => u()));
  }))), mutexes[n.name] == null && (mutexes[n.name] = createMutex(n.name, n)), mutexes[n.name];
}
async function* batch$1(o, n = 1) {
  let c = [];
  n < 1 && (n = 1);
  for await (const u of o)
    for (c.push(u); c.length >= n; )
      yield c.slice(0, n), c = c.slice(n);
  for (; c.length; )
    yield c.slice(0, n), c = c.slice(n);
}
var itBatch = batch$1;
const batch = itBatch;
async function* parallelBatch(o, n = 1) {
  for await (const c of batch(o, n)) {
    const u = c.map((h) => h().then((g) => ({ ok: !0, value: g }), (g) => ({ ok: !1, err: g })));
    for (let h = 0; h < u.length; h++) {
      const g = await u[h];
      if (!g.ok)
        throw g.err;
      yield g.value;
    }
  }
}
var itParallelBatch = parallelBatch, fixedSize = class {
  constructor(o) {
    if (!(o > 0) || (o - 1 & o) != 0)
      throw new Error("Max size for a FixedFIFO should be a power of two");
    this.buffer = new Array(o), this.mask = o - 1, this.top = 0, this.btm = 0, this.next = null;
  }
  push(o) {
    return this.buffer[this.top] === void 0 && (this.buffer[this.top] = o, this.top = this.top + 1 & this.mask, !0);
  }
  shift() {
    const o = this.buffer[this.btm];
    if (o !== void 0)
      return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, o;
  }
  peek() {
    return this.buffer[this.btm];
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
const FixedFIFO = fixedSize;
var fastFifo = class {
  constructor(o) {
    this.hwm = o || 16, this.head = new FixedFIFO(this.hwm), this.tail = this.head;
  }
  push(o) {
    if (!this.head.push(o)) {
      const n = this.head;
      this.head = n.next = new FixedFIFO(2 * this.head.buffer.length), this.head.push(o);
    }
  }
  shift() {
    const o = this.tail.shift();
    if (o === void 0 && this.tail.next) {
      const n = this.tail.next;
      return this.tail.next = null, this.tail = n, this.tail.shift();
    }
    return o;
  }
  peek() {
    return this.tail.peek();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};
const FIFO = fastFifo;
var itPushable = (o) => {
  let n;
  typeof (o = o || {}) == "function" ? (n = o, o = {}) : n = o.onEnd;
  let c, u, h, g = new FIFO();
  const y = (L) => u ? u(L) : (g.push(L), c), $ = (L) => h ? c : y({ done: !1, value: L }), I = (L) => h ? c : (h = !0, L ? ((q) => (g = new FIFO(), u ? u({ error: q }) : (g.push({ error: q }), c)))(L) : y({ done: !0 }));
  if (c = { [Symbol.asyncIterator]() {
    return this;
  }, next: () => {
    if (!g.isEmpty()) {
      if (o.writev) {
        let q;
        const N = [];
        for (; !g.isEmpty(); ) {
          if (q = g.shift(), q.error)
            throw q.error;
          N.push(q.value);
        }
        return { done: q.done, value: N };
      }
      const L = g.shift();
      if (L.error)
        throw L.error;
      return L;
    }
    return h ? { done: !0 } : new Promise((L, q) => {
      u = (N) => (u = null, N.error ? q(N.error) : o.writev && !N.done ? L({ done: N.done, value: [N.value] }) : L(N), c);
    });
  }, return: () => (g = new FIFO(), I(), { done: !0 }), throw: (L) => (I(L), { done: !0 }), push: $, end: I }, !n)
    return c;
  const P = c;
  return c = { [Symbol.asyncIterator]() {
    return this;
  }, next: () => P.next(), throw: (L) => (P.throw(L), n && (n(L), n = null), { done: !0 }), return: () => (P.return(), n && (n(), n = null), { done: !0 }), push: $, end: (L) => (P.end(L), n && (n(L), n = null), c) }, c;
};
const pushable = itPushable, merge = async function* (...o) {
  const n = pushable();
  setTimeout(async () => {
    try {
      await Promise.all(o.map(async (c) => {
        for await (const u of c)
          n.push(u);
      })), n.end();
    } catch (c) {
      n.end(c);
    }
  }, 0), yield* n;
};
var itMerge = merge;
const rawPipe = (...o) => {
  let n;
  for (; o.length > 0; )
    n = o.shift()(n);
  return n;
}, isIterable$1 = (o) => o != null && (typeof o[Symbol.asyncIterator] == "function" || typeof o[Symbol.iterator] == "function" || typeof o.next == "function"), isDuplex = (o) => o != null && typeof o.sink == "function" && isIterable$1(o.source), duplexPipelineFn = (o) => (n) => {
  const c = o.sink(n);
  if (c.then != null) {
    const u = pushable$1({ objectMode: !0 });
    return c.then(() => {
      u.end();
    }, (g) => {
      u.end(g);
    }), itMerge(u, async function* () {
      yield* o.source, u.end();
    }());
  }
  return o.source;
};
function pipe(o, ...n) {
  if (isDuplex(o)) {
    const u = o;
    o = () => u.source;
  } else if (isIterable$1(o)) {
    const u = o;
    o = () => u;
  }
  const c = [o, ...n];
  if (c.length > 1 && isDuplex(c[c.length - 1]) && (c[c.length - 1] = c[c.length - 1].sink), c.length > 2)
    for (let u = 1; u < c.length - 1; u++)
      isDuplex(c[u]) && (c[u] = duplexPipelineFn(c[u]));
  return rawPipe(...c);
}
const log$1 = debug("ipfs:repo:gc"), ERR_NOT_FOUND = notFoundError$1().code, BLOCK_RM_CONCURRENCY = 256, MFS_ROOT_KEY = new Key("/local/filesroot");
function gc$1({ gcLock: o, pins: n, blockstore: c, root: u, loadCodec: h }) {
  return async function* () {
    const g = Date.now();
    log$1("Creating set of marked blocks");
    const y = await o.writeLock();
    try {
      const $ = await createMarkedSet({ pins: n, blockstore: c, root: u, loadCodec: h }), I = c.queryKeys({});
      yield* deleteUnmarkedBlocks({ blockstore: c }, $, I), log$1(`Complete (${Date.now() - g}ms)`);
    } finally {
      y();
    }
  };
}
async function createMarkedSet({ pins: o, blockstore: n, loadCodec: c, root: u }) {
  const h = async function* () {
    let $;
    try {
      $ = await u.get(MFS_ROOT_KEY);
    } catch (P) {
      if (P.code === ERR_NOT_FOUND)
        return void log$1("No blocks in MFS");
      throw P;
    }
    const I = CID$2.decode($);
    yield I, yield* walkDag(I, n, c);
  }(), g = itMerge(itMap(o.recursiveKeys(), ({ cid: $ }) => $), o.indirectKeys(), itMap(o.directKeys(), ({ cid: $ }) => $), h), y = /* @__PURE__ */ new Set();
  for await (const $ of itMerge(g, h))
    y.add(base32$6.encode($.multihash.bytes));
  return y;
}
async function* deleteUnmarkedBlocks({ blockstore: o }, n, c) {
  let u = 0, h = 0;
  yield* pipe(itParallelBatch(itMap(c, async (g) => async function() {
    u++;
    try {
      const y = base32$6.encode(g.multihash.bytes);
      if (n.has(y))
        return null;
      try {
        await o.delete(g), h++;
      } catch ($) {
        return { err: new Error(`Could not delete block with CID ${g}: ${$.message}`) };
      }
      return { cid: g };
    } catch (y) {
      const $ = `Could delete block with CID ${g}`;
      return log$1($, y), { err: new Error($ + `: ${y.message}`) };
    }
  }), BLOCK_RM_CONCURRENCY), (g) => itFilter(g, Boolean)), log$1(`Marked set has ${n.size} unique blocks. Blockstore has ${u} blocks. Deleted ${h} blocks.`);
}
const log = debug("ipfs:repo"), noLimit = Number.MAX_SAFE_INTEGER, AUTO_MIGRATE_CONFIG_KEY = "repoAutoMigrate";
class Repo {
  constructor(n, c, u, h) {
    if (typeof n != "string")
      throw new Error("missing repo path");
    if (typeof c != "function")
      throw new Error("missing codec loader");
    this.options = mergeOptions(defaultOptions$2, h), this.closed = !0, this.path = n, this.root = u.root, this.datastore = u.datastore, this.keys = u.keys;
    const g = u.blocks, y = u.pins;
    this.pins = new PinManager({ pinstore: y, blockstore: g, loadCodec: c });
    const $ = createPinnedBlockstore(this.pins, g);
    this.blocks = createIdStore($), this.version = version$1(this.root), this.config = config$1(this.root), this.spec = spec(this.root), this.apiAddr = apiAddr(this.root), this.gcLock = createMortice({ name: n, singleProcess: this.options.repoOwner !== !1 }), this.gc = gc$1({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec: c });
  }
  async init(n) {
    log("initializing at: %s", this.path), await this._openRoot(), await this.config.replace(buildConfig(n)), await this.spec.set(buildDatastoreSpec(n)), await this.version.set(repoVersion);
  }
  async isInitialized() {
    if (!this.closed)
      return !0;
    try {
      return await this._openRoot(), await this._checkInitialized(), await this.root.close(), !0;
    } catch {
      return !1;
    }
  }
  async open() {
    if (!this.closed)
      throw errCode(new Error("repo is already open"), ERR_REPO_ALREADY_OPEN);
    log("opening at: %s", this.path);
    try {
      if (await this._openRoot(), await this._checkInitialized(), this._lockfile = await this._openLock(), log("acquired repo.lock"), !await this.version.check(repoVersion)) {
        if (!await this._isAutoMigrationEnabled())
          throw new InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
        await this._migrate(repoVersion, { root: this.root, datastore: this.datastore, pins: this.pins.pinstore, blocks: this.pins.blockstore, keys: this.keys });
      }
      log("creating datastore"), await this.datastore.open(), log("creating blocks"), await this.blocks.open(), log("creating keystore"), await this.keys.open(), log("creating pins"), await this.pins.pinstore.open(), this.closed = !1, log("all opened");
    } catch (n) {
      if (this._lockfile)
        try {
          await this._closeLock(), this._lockfile = null;
        } catch (c) {
          log("error removing lock", c);
        }
      throw n;
    }
  }
  async _openRoot() {
    try {
      await this.root.open();
    } catch (n) {
      if (n.message !== "Already open")
        throw n;
    }
  }
  async _openLock() {
    const n = await this.options.repoLock.lock(this.path);
    if (typeof n.close != "function")
      throw errCode(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
    return n;
  }
  _closeLock() {
    return this._lockfile && this._lockfile.close();
  }
  async _checkInitialized() {
    let n;
    log("init check");
    try {
      [n] = await Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);
    } catch (c) {
      throw c.code === "ERR_NOT_FOUND" ? errCode(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, { path: this.path }) : c;
    }
    if (!n)
      throw errCode(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, { path: this.path });
  }
  async close() {
    if (this.closed)
      throw errCode(new Error("repo is already closed"), ERR_REPO_ALREADY_CLOSED);
    log("closing at: %s", this.path);
    try {
      await this.apiAddr.delete();
    } catch (n) {
      if (n.code !== ERR_REPO_NOT_INITIALIZED && !n.message.startsWith("ENOENT"))
        throw n;
    }
    await Promise.all([this.root, this.blocks, this.keys, this.datastore, this.pins.pinstore].map((n) => n && n.close())), log("unlocking"), this.closed = !0, await this._closeLock();
  }
  exists() {
    return this.version.exists();
  }
  async stat() {
    if (this.datastore && this.keys) {
      const [n, c, u, h, g] = await Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), getSize(this.datastore), getSize(this.keys)]), y = c.size + h + g;
      return { repoPath: this.path, storageMax: n, version: u, numObjects: c.count, repoSize: y };
    }
    throw errCode(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, { path: this.path });
  }
  async _isAutoMigrationEnabled() {
    if (this.options.autoMigrate !== void 0)
      return this.options.autoMigrate;
    let n;
    try {
      n = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
    } catch (c) {
      if (c.code !== NotFoundError.code)
        throw c;
      n = !0;
    }
    return n;
  }
  async _migrate(n, c) {
    return await this.version.get() > n ? (log(`reverting to version ${n}`), revert(this.path, c, this.options, n, { ignoreLock: !0, onProgress: this.options.onMigrationProgress })) : (log(`migrating to version ${n}`), migrate(this.path, c, this.options, n, { ignoreLock: !0, onProgress: this.options.onMigrationProgress }));
  }
  async _storageMaxStat() {
    try {
      const n = await this.config.get("Datastore.StorageMax");
      return BigInt(bytes$1.exports(n));
    } catch {
      return BigInt(noLimit);
    }
  }
  async _blockStat() {
    let n = BigInt(0), c = BigInt(0);
    if (this.blocks)
      for await (const { key: u, value: h } of this.blocks.query({}))
        n += BigInt(1), c += BigInt(h.byteLength), c += BigInt(u.bytes.byteLength);
    return { count: n, size: c };
  }
}
async function getSize(o) {
  let n = BigInt(0);
  for await (const c of o.query({}))
    n += BigInt(c.value.byteLength), n += BigInt(c.key.uint8Array().byteLength);
  return n;
}
function createRepo$1(o, n, c, u) {
  return new Repo(o, n, c, u);
}
function buildConfig(o) {
  return o.Datastore = Object.assign({}, defaultDatastore, objectSafeGet(o, "datastore")), o;
}
function buildDatastoreSpec(o) {
  const n = { ...defaultDatastore.Spec, ...objectSafeGet(o, "Datastore.Spec") };
  return { type: n.type, mounts: n.mounts.map((c) => ({ mountpoint: c.mountpoint, type: c.child.type, path: c.child.path, shardFunc: c.child.shardFunc })) };
}
const SHARDING_FN = "SHARDING", README_FN = "_README", all$2 = async (o) => {
  const n = [];
  for await (const c of o)
    n.push(c);
  return n;
};
var itAll = all$2;
const sortAll$1 = (o, n) => async function* () {
  yield* (await itAll(o)).sort(n);
}(), take = async function* (o, n) {
  let c = 0;
  if (!(n < 1)) {
    for await (const u of o)
      if (yield u, c++, c === n)
        return;
  }
};
var itTake = take;
class BaseDatastore {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(n, c, u) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(n, c) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(n, c) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(n, c) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(n, c = {}) {
    for await (const { key: u, value: h } of n)
      await this.put(u, h, c), yield { key: u, value: h };
  }
  async *getMany(n, c = {}) {
    for await (const u of n)
      yield this.get(u, c);
  }
  async *deleteMany(n, c = {}) {
    for await (const u of n)
      await this.delete(u, c), yield u;
  }
  batch() {
    let n = [], c = [];
    return { put(u, h) {
      n.push({ key: u, value: h });
    }, delete(u) {
      c.push(u);
    }, commit: async (u) => {
      await itDrain(this.putMany(n, u)), n = [], await itDrain(this.deleteMany(c, u)), c = [];
    } };
  }
  async *_all(n, c) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(n, c) {
    throw new Error("._allKeys is not implemented");
  }
  query(n, c) {
    let u = this._all(n, c);
    if (n.prefix != null && (u = itFilter(u, (h) => h.key.toString().startsWith(n.prefix))), Array.isArray(n.filters) && (u = n.filters.reduce((h, g) => itFilter(h, g), u)), Array.isArray(n.orders) && (u = n.orders.reduce((h, g) => sortAll$1(h, g), u)), n.offset != null) {
      let h = 0;
      u = itFilter(u, () => h++ >= n.offset);
    }
    return n.limit != null && (u = itTake(u, n.limit)), u;
  }
  queryKeys(n, c) {
    let u = this._allKeys(n, c);
    if (n.prefix != null && (u = itFilter(u, (h) => h.toString().startsWith(n.prefix))), Array.isArray(n.filters) && (u = n.filters.reduce((h, g) => itFilter(h, g), u)), Array.isArray(n.orders) && (u = n.orders.reduce((h, g) => sortAll$1(h, g), u)), n.offset != null) {
      let h = 0;
      u = itFilter(u, () => h++ >= n.offset);
    }
    return n.limit != null && (u = itTake(u, n.limit)), u;
  }
}
class MemoryDatastore extends BaseDatastore {
  constructor() {
    super(), this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  async put(n, c) {
    this.data[n.toString()] = c;
  }
  async get(n) {
    if (!await this.has(n))
      throw notFoundError$1();
    return this.data[n.toString()];
  }
  async has(n) {
    return this.data[n.toString()] !== void 0;
  }
  async delete(n) {
    delete this.data[n.toString()];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([n, c]) => ({ key: new Key(n), value: c }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([n]) => new Key(n));
  }
}
function base$3(o, n) {
  if (o.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var c = new Uint8Array(256), u = 0; u < c.length; u++)
    c[u] = 255;
  for (var h = 0; h < o.length; h++) {
    var g = o.charAt(h), y = g.charCodeAt(0);
    if (c[y] !== 255)
      throw new TypeError(g + " is ambiguous");
    c[y] = h;
  }
  var $ = o.length, I = o.charAt(0), P = Math.log($) / Math.log(256), L = Math.log(256) / Math.log($);
  function q(N) {
    if (typeof N != "string")
      throw new TypeError("Expected String");
    if (N.length === 0)
      return new Uint8Array();
    var X = 0;
    if (N[X] !== " ") {
      for (var rt = 0, nt = 0; N[X] === I; )
        rt++, X++;
      for (var st = (N.length - X) * P + 1 >>> 0, ot = new Uint8Array(st); N[X]; ) {
        var St = c[N.charCodeAt(X)];
        if (St === 255)
          return;
        for (var Ct = 0, et = st - 1; (St !== 0 || Ct < nt) && et !== -1; et--, Ct++)
          St += $ * ot[et] >>> 0, ot[et] = St % 256 >>> 0, St = St / 256 >>> 0;
        if (St !== 0)
          throw new Error("Non-zero carry");
        nt = Ct, X++;
      }
      if (N[X] !== " ") {
        for (var at = st - nt; at !== st && ot[at] === 0; )
          at++;
        for (var _t = new Uint8Array(rt + (st - at)), Nt = rt; at !== st; )
          _t[Nt++] = ot[at++];
        return _t;
      }
    }
  }
  return { encode: function(N) {
    if (N instanceof Uint8Array || (ArrayBuffer.isView(N) ? N = new Uint8Array(N.buffer, N.byteOffset, N.byteLength) : Array.isArray(N) && (N = Uint8Array.from(N))), !(N instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (N.length === 0)
      return "";
    for (var X = 0, rt = 0, nt = 0, st = N.length; nt !== st && N[nt] === 0; )
      nt++, X++;
    for (var ot = (st - nt) * L + 1 >>> 0, St = new Uint8Array(ot); nt !== st; ) {
      for (var Ct = N[nt], et = 0, at = ot - 1; (Ct !== 0 || et < rt) && at !== -1; at--, et++)
        Ct += 256 * St[at] >>> 0, St[at] = Ct % $ >>> 0, Ct = Ct / $ >>> 0;
      if (Ct !== 0)
        throw new Error("Non-zero carry");
      rt = et, nt++;
    }
    for (var _t = ot - rt; _t !== ot && St[_t] === 0; )
      _t++;
    for (var Nt = I.repeat(X); _t < ot; ++_t)
      Nt += o.charAt(St[_t]);
    return Nt;
  }, decodeUnsafe: q, decode: function(N) {
    var X = q(N);
    if (X)
      return X;
    throw new Error(`Non-${n} character`);
  } };
}
new Key(SHARDING_FN), new Key(README_FN);
var src$1 = base$3, _brrp__multiformats_scope_baseX$1 = src$1;
const coerce$1 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o))
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  throw new Error("Unknown type, must be binary type");
};
class Encoder$1 {
  constructor(n, c, u) {
    this.name = n, this.prefix = c, this.baseEncode = u;
  }
  encode(n) {
    if (n instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(n)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Decoder$1 {
  constructor(n, c, u) {
    if (this.name = n, this.prefix = c, c.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = c.codePointAt(0), this.baseDecode = u;
  }
  decode(n) {
    if (typeof n == "string") {
      if (n.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(n)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(n.slice(this.prefix.length));
    }
    throw Error("Can only multibase decode strings");
  }
  or(n) {
    return or$1(this, n);
  }
}
class ComposedDecoder$1 {
  constructor(n) {
    this.decoders = n;
  }
  or(n) {
    return or$1(this, n);
  }
  decode(n) {
    const c = n[0], u = this.decoders[c];
    if (u)
      return u.decode(n);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(n)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or$1 = (o, n) => new ComposedDecoder$1({ ...o.decoders || { [o.prefix]: o }, ...n.decoders || { [n.prefix]: n } });
class Codec$1 {
  constructor(n, c, u, h) {
    this.name = n, this.prefix = c, this.baseEncode = u, this.baseDecode = h, this.encoder = new Encoder$1(n, c, u), this.decoder = new Decoder$1(n, c, h);
  }
  encode(n) {
    return this.encoder.encode(n);
  }
  decode(n) {
    return this.decoder.decode(n);
  }
}
const from$2 = ({ name: o, prefix: n, encode: c, decode: u }) => new Codec$1(o, n, c, u), baseX$1 = ({ prefix: o, name: n, alphabet: c }) => {
  const { encode: u, decode: h } = _brrp__multiformats_scope_baseX$1(c, n);
  return from$2({ prefix: o, name: n, encode: u, decode: (g) => coerce$1(h(g)) });
}, decode$b = (o, n, c, u) => {
  const h = {};
  for (let L = 0; L < n.length; ++L)
    h[n[L]] = L;
  let g = o.length;
  for (; o[g - 1] === "="; )
    --g;
  const y = new Uint8Array(g * c / 8 | 0);
  let $ = 0, I = 0, P = 0;
  for (let L = 0; L < g; ++L) {
    const q = h[o[L]];
    if (q === void 0)
      throw new SyntaxError(`Non-${u} character`);
    I = I << c | q, $ += c, $ >= 8 && ($ -= 8, y[P++] = 255 & I >> $);
  }
  if ($ >= c || 255 & I << 8 - $)
    throw new SyntaxError("Unexpected end of data");
  return y;
}, encode$9 = (o, n, c) => {
  const u = n[n.length - 1] === "=", h = (1 << c) - 1;
  let g = "", y = 0, $ = 0;
  for (let I = 0; I < o.length; ++I)
    for ($ = $ << 8 | o[I], y += 8; y > c; )
      y -= c, g += n[h & $ >> y];
  if (y && (g += n[h & $ << c - y]), u)
    for (; g.length * c & 7; )
      g += "=";
  return g;
}, rfc4648$1 = ({ name: o, prefix: n, bitsPerChar: c, alphabet: u }) => from$2({ prefix: n, name: o, encode: (h) => encode$9(h, u, c), decode: (h) => decode$b(h, u, c, o) }), base58btc$1 = baseX$1({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
baseX$1({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
const base32$1 = rfc4648$1({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
rfc4648$1({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), rfc4648$1({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), rfc4648$1({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), rfc4648$1({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), rfc4648$1({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), rfc4648$1({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), rfc4648$1({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), rfc4648$1({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
const base64 = rfc4648$1({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
function logger(o) {
  return Object.assign(debug(o), { error: debug(`${o}:error`), trace: debug(`${o}:trace`) });
}
rfc4648$1({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), rfc4648$1({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), rfc4648$1({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 }), debug.formatters.b = (o) => o == null ? "undefined" : base58btc$1.baseEncode(o), debug.formatters.t = (o) => o == null ? "undefined" : base32$1.baseEncode(o), debug.formatters.m = (o) => o == null ? "undefined" : base64.baseEncode(o), debug.formatters.p = (o) => o == null ? "undefined" : o.toString(), debug.formatters.c = (o) => o == null ? "undefined" : o.toString(), debug.formatters.k = (o) => o == null ? "undefined" : o.toString(), logger("datastore:core:tiered");
const all$1 = itAll, sort = async function* (o, n) {
  yield* (await all$1(o)).sort(n);
};
var itSort = sort, browser = {}, browserLevel = {}, abstractLevel$1 = {}, abstractLevel = {}, levelSupports = { supports: function(...o) {
  const n = o.reduce((c, u) => Object.assign(c, u), {});
  return Object.assign(n, { snapshots: n.snapshots || !1, permanence: n.permanence || !1, seek: n.seek || !1, clear: n.clear || !1, getMany: n.getMany || !1, keyIterator: n.keyIterator || !1, valueIterator: n.valueIterator || !1, iteratorNextv: n.iteratorNextv || !1, iteratorAll: n.iteratorAll || !1, status: n.status || !1, createIfMissing: n.createIfMissing || !1, errorIfExists: n.errorIfExists || !1, deferredOpen: n.deferredOpen || !1, promises: n.promises || !1, streams: n.streams || !1, encodings: Object.assign({}, n.encodings), events: Object.assign({}, n.events), additionalMethods: Object.assign({}, n.additionalMethods) });
} }, levelTranscoder = {}, moduleError = class extends Error {
  constructor(o, n) {
    super(o || ""), typeof n == "object" && n !== null && (n.code && (this.code = String(n.code)), n.expected && (this.expected = !0), n.transient && (this.transient = !0), n.cause && (this.cause = n.cause)), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
  }
}, encodings$1 = {}, buffer$2 = {}, ieee754 = {
  read: function(o, n, c, u, h) {
    var g, y, $ = 8 * h - u - 1, I = (1 << $) - 1, P = I >> 1, L = -7, q = c ? h - 1 : 0, N = c ? -1 : 1, X = o[n + q];
    for (q += N, g = X & (1 << -L) - 1, X >>= -L, L += $; L > 0; g = 256 * g + o[n + q], q += N, L -= 8)
      ;
    for (y = g & (1 << -L) - 1, g >>= -L, L += u; L > 0; y = 256 * y + o[n + q], q += N, L -= 8)
      ;
    if (g === 0)
      g = 1 - P;
    else {
      if (g === I)
        return y ? NaN : 1 / 0 * (X ? -1 : 1);
      y += Math.pow(2, u), g -= P;
    }
    return (X ? -1 : 1) * y * Math.pow(2, g - u);
  },
  write: function(o, n, c, u, h, g) {
    var y, $, I, P = 8 * g - h - 1, L = (1 << P) - 1, q = L >> 1, N = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, X = u ? 0 : g - 1, rt = u ? 1 : -1, nt = n < 0 || n === 0 && 1 / n < 0 ? 1 : 0;
    for (n = Math.abs(n), isNaN(n) || n === 1 / 0 ? ($ = isNaN(n) ? 1 : 0, y = L) : (y = Math.floor(Math.log(n) / Math.LN2), n * (I = Math.pow(2, -y)) < 1 && (y--, I *= 2), (n += y + q >= 1 ? N / I : N * Math.pow(2, 1 - q)) * I >= 2 && (y++, I /= 2), y + q >= L ? ($ = 0, y = L) : y + q >= 1 ? ($ = (n * I - 1) * Math.pow(2, h), y += q) : ($ = n * Math.pow(2, q - 1) * Math.pow(2, h), y = 0)); h >= 8; o[c + X] = 255 & $, X += rt, $ /= 256, h -= 8)
      ;
    for (y = y << h | $, P += h; P > 0; o[c + X] = 255 & y, X += rt, y /= 256, P -= 8)
      ;
    o[c + X - rt] |= 128 * nt;
  }
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(o) {
  const n = base64Js, c = ieee754, u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  o.Buffer = y, o.SlowBuffer = function(B) {
    return +B != B && (B = 0), y.alloc(+B);
  }, o.INSPECT_MAX_BYTES = 50;
  const h = 2147483647;
  function g(B) {
    if (B > h)
      throw new RangeError('The value "' + B + '" is invalid for option "size"');
    const j = new Uint8Array(B);
    return Object.setPrototypeOf(j, y.prototype), j;
  }
  function y(B, j, Z) {
    if (typeof B == "number") {
      if (typeof j == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return P(B);
    }
    return $(B, j, Z);
  }
  function $(B, j, Z) {
    if (typeof B == "string")
      return function(At, Bt) {
        if (typeof Bt == "string" && Bt !== "" || (Bt = "utf8"), !y.isEncoding(Bt))
          throw new TypeError("Unknown encoding: " + Bt);
        const Ft = 0 | X(At, Bt);
        let Kt = g(Ft);
        const Zt = Kt.write(At, Bt);
        return Zt !== Ft && (Kt = Kt.slice(0, Zt)), Kt;
      }(B, j);
    if (ArrayBuffer.isView(B))
      return function(At) {
        if (he(At, Uint8Array)) {
          const Bt = new Uint8Array(At);
          return q(Bt.buffer, Bt.byteOffset, Bt.byteLength);
        }
        return L(At);
      }(B);
    if (B == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof B);
    if (he(B, ArrayBuffer) || B && he(B.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (he(B, SharedArrayBuffer) || B && he(B.buffer, SharedArrayBuffer)))
      return q(B, j, Z);
    if (typeof B == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    const kt = B.valueOf && B.valueOf();
    if (kt != null && kt !== B)
      return y.from(kt, j, Z);
    const $t = function(At) {
      if (y.isBuffer(At)) {
        const Bt = 0 | N(At.length), Ft = g(Bt);
        return Ft.length === 0 || At.copy(Ft, 0, 0, Bt), Ft;
      }
      return At.length !== void 0 ? typeof At.length != "number" || je(At.length) ? g(0) : L(At) : At.type === "Buffer" && Array.isArray(At.data) ? L(At.data) : void 0;
    }(B);
    if ($t)
      return $t;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof B[Symbol.toPrimitive] == "function")
      return y.from(B[Symbol.toPrimitive]("string"), j, Z);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof B);
  }
  function I(B) {
    if (typeof B != "number")
      throw new TypeError('"size" argument must be of type number');
    if (B < 0)
      throw new RangeError('The value "' + B + '" is invalid for option "size"');
  }
  function P(B) {
    return I(B), g(B < 0 ? 0 : 0 | N(B));
  }
  function L(B) {
    const j = B.length < 0 ? 0 : 0 | N(B.length), Z = g(j);
    for (let kt = 0; kt < j; kt += 1)
      Z[kt] = 255 & B[kt];
    return Z;
  }
  function q(B, j, Z) {
    if (j < 0 || B.byteLength < j)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (B.byteLength < j + (Z || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let kt;
    return kt = j === void 0 && Z === void 0 ? new Uint8Array(B) : Z === void 0 ? new Uint8Array(B, j) : new Uint8Array(B, j, Z), Object.setPrototypeOf(kt, y.prototype), kt;
  }
  function N(B) {
    if (B >= h)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + h.toString(16) + " bytes");
    return 0 | B;
  }
  function X(B, j) {
    if (y.isBuffer(B))
      return B.length;
    if (ArrayBuffer.isView(B) || he(B, ArrayBuffer))
      return B.byteLength;
    if (typeof B != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof B);
    const Z = B.length, kt = arguments.length > 2 && arguments[2] === !0;
    if (!kt && Z === 0)
      return 0;
    let $t = !1;
    for (; ; )
      switch (j) {
        case "ascii":
        case "latin1":
        case "binary":
          return Z;
        case "utf8":
        case "utf-8":
          return ue(B).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * Z;
        case "hex":
          return Z >>> 1;
        case "base64":
          return xe(B).length;
        default:
          if ($t)
            return kt ? -1 : ue(B).length;
          j = ("" + j).toLowerCase(), $t = !0;
      }
  }
  function rt(B, j, Z) {
    let kt = !1;
    if ((j === void 0 || j < 0) && (j = 0), j > this.length || ((Z === void 0 || Z > this.length) && (Z = this.length), Z <= 0) || (Z >>>= 0) <= (j >>>= 0))
      return "";
    for (B || (B = "utf8"); ; )
      switch (B) {
        case "hex":
          return v(this, j, Z);
        case "utf8":
        case "utf-8":
          return m(this, j, Z);
        case "ascii":
          return E(this, j, Z);
        case "latin1":
        case "binary":
          return w(this, j, Z);
        case "base64":
          return Nt(this, j, Z);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return k(this, j, Z);
        default:
          if (kt)
            throw new TypeError("Unknown encoding: " + B);
          B = (B + "").toLowerCase(), kt = !0;
      }
  }
  function nt(B, j, Z) {
    const kt = B[j];
    B[j] = B[Z], B[Z] = kt;
  }
  function st(B, j, Z, kt, $t) {
    if (B.length === 0)
      return -1;
    if (typeof Z == "string" ? (kt = Z, Z = 0) : Z > 2147483647 ? Z = 2147483647 : Z < -2147483648 && (Z = -2147483648), je(Z = +Z) && (Z = $t ? 0 : B.length - 1), Z < 0 && (Z = B.length + Z), Z >= B.length) {
      if ($t)
        return -1;
      Z = B.length - 1;
    } else if (Z < 0) {
      if (!$t)
        return -1;
      Z = 0;
    }
    if (typeof j == "string" && (j = y.from(j, kt)), y.isBuffer(j))
      return j.length === 0 ? -1 : ot(B, j, Z, kt, $t);
    if (typeof j == "number")
      return j &= 255, typeof Uint8Array.prototype.indexOf == "function" ? $t ? Uint8Array.prototype.indexOf.call(B, j, Z) : Uint8Array.prototype.lastIndexOf.call(B, j, Z) : ot(B, [j], Z, kt, $t);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ot(B, j, Z, kt, $t) {
    let At, Bt = 1, Ft = B.length, Kt = j.length;
    if (kt !== void 0 && ((kt = String(kt).toLowerCase()) === "ucs2" || kt === "ucs-2" || kt === "utf16le" || kt === "utf-16le")) {
      if (B.length < 2 || j.length < 2)
        return -1;
      Bt = 2, Ft /= 2, Kt /= 2, Z /= 2;
    }
    function Zt(Gt, Qt) {
      return Bt === 1 ? Gt[Qt] : Gt.readUInt16BE(Qt * Bt);
    }
    if ($t) {
      let Gt = -1;
      for (At = Z; At < Ft; At++)
        if (Zt(B, At) === Zt(j, Gt === -1 ? 0 : At - Gt)) {
          if (Gt === -1 && (Gt = At), At - Gt + 1 === Kt)
            return Gt * Bt;
        } else
          Gt !== -1 && (At -= At - Gt), Gt = -1;
    } else
      for (Z + Kt > Ft && (Z = Ft - Kt), At = Z; At >= 0; At--) {
        let Gt = !0;
        for (let Qt = 0; Qt < Kt; Qt++)
          if (Zt(B, At + Qt) !== Zt(j, Qt)) {
            Gt = !1;
            break;
          }
        if (Gt)
          return At;
      }
    return -1;
  }
  function St(B, j, Z, kt) {
    Z = Number(Z) || 0;
    const $t = B.length - Z;
    kt ? (kt = Number(kt)) > $t && (kt = $t) : kt = $t;
    const At = j.length;
    let Bt;
    for (kt > At / 2 && (kt = At / 2), Bt = 0; Bt < kt; ++Bt) {
      const Ft = parseInt(j.substr(2 * Bt, 2), 16);
      if (je(Ft))
        return Bt;
      B[Z + Bt] = Ft;
    }
    return Bt;
  }
  function Ct(B, j, Z, kt) {
    return se(ue(j, B.length - Z), B, Z, kt);
  }
  function et(B, j, Z, kt) {
    return se(function($t) {
      const At = [];
      for (let Bt = 0; Bt < $t.length; ++Bt)
        At.push(255 & $t.charCodeAt(Bt));
      return At;
    }(j), B, Z, kt);
  }
  function at(B, j, Z, kt) {
    return se(xe(j), B, Z, kt);
  }
  function _t(B, j, Z, kt) {
    return se(function($t, At) {
      let Bt, Ft, Kt;
      const Zt = [];
      for (let Gt = 0; Gt < $t.length && !((At -= 2) < 0); ++Gt)
        Bt = $t.charCodeAt(Gt), Ft = Bt >> 8, Kt = Bt % 256, Zt.push(Kt), Zt.push(Ft);
      return Zt;
    }(j, B.length - Z), B, Z, kt);
  }
  function Nt(B, j, Z) {
    return j === 0 && Z === B.length ? n.fromByteArray(B) : n.fromByteArray(B.slice(j, Z));
  }
  function m(B, j, Z) {
    Z = Math.min(B.length, Z);
    const kt = [];
    let $t = j;
    for (; $t < Z; ) {
      const At = B[$t];
      let Bt = null, Ft = At > 239 ? 4 : At > 223 ? 3 : At > 191 ? 2 : 1;
      if ($t + Ft <= Z) {
        let Kt, Zt, Gt, Qt;
        switch (Ft) {
          case 1:
            At < 128 && (Bt = At);
            break;
          case 2:
            Kt = B[$t + 1], (192 & Kt) == 128 && (Qt = (31 & At) << 6 | 63 & Kt, Qt > 127 && (Bt = Qt));
            break;
          case 3:
            Kt = B[$t + 1], Zt = B[$t + 2], (192 & Kt) == 128 && (192 & Zt) == 128 && (Qt = (15 & At) << 12 | (63 & Kt) << 6 | 63 & Zt, Qt > 2047 && (Qt < 55296 || Qt > 57343) && (Bt = Qt));
            break;
          case 4:
            Kt = B[$t + 1], Zt = B[$t + 2], Gt = B[$t + 3], (192 & Kt) == 128 && (192 & Zt) == 128 && (192 & Gt) == 128 && (Qt = (15 & At) << 18 | (63 & Kt) << 12 | (63 & Zt) << 6 | 63 & Gt, Qt > 65535 && Qt < 1114112 && (Bt = Qt));
        }
      }
      Bt === null ? (Bt = 65533, Ft = 1) : Bt > 65535 && (Bt -= 65536, kt.push(Bt >>> 10 & 1023 | 55296), Bt = 56320 | 1023 & Bt), kt.push(Bt), $t += Ft;
    }
    return function(At) {
      const Bt = At.length;
      if (Bt <= A)
        return String.fromCharCode.apply(String, At);
      let Ft = "", Kt = 0;
      for (; Kt < Bt; )
        Ft += String.fromCharCode.apply(String, At.slice(Kt, Kt += A));
      return Ft;
    }(kt);
  }
  o.kMaxLength = h, y.TYPED_ARRAY_SUPPORT = function() {
    try {
      const B = new Uint8Array(1), j = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(j, Uint8Array.prototype), Object.setPrototypeOf(B, j), B.foo() === 42;
    } catch {
      return !1;
    }
  }(), y.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(y.prototype, "parent", { enumerable: !0, get: function() {
    if (y.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(y.prototype, "offset", { enumerable: !0, get: function() {
    if (y.isBuffer(this))
      return this.byteOffset;
  } }), y.poolSize = 8192, y.from = function(B, j, Z) {
    return $(B, j, Z);
  }, Object.setPrototypeOf(y.prototype, Uint8Array.prototype), Object.setPrototypeOf(y, Uint8Array), y.alloc = function(B, j, Z) {
    return function(kt, $t, At) {
      return I(kt), kt <= 0 ? g(kt) : $t !== void 0 ? typeof At == "string" ? g(kt).fill($t, At) : g(kt).fill($t) : g(kt);
    }(B, j, Z);
  }, y.allocUnsafe = function(B) {
    return P(B);
  }, y.allocUnsafeSlow = function(B) {
    return P(B);
  }, y.isBuffer = function(B) {
    return B != null && B._isBuffer === !0 && B !== y.prototype;
  }, y.compare = function(B, j) {
    if (he(B, Uint8Array) && (B = y.from(B, B.offset, B.byteLength)), he(j, Uint8Array) && (j = y.from(j, j.offset, j.byteLength)), !y.isBuffer(B) || !y.isBuffer(j))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (B === j)
      return 0;
    let Z = B.length, kt = j.length;
    for (let $t = 0, At = Math.min(Z, kt); $t < At; ++$t)
      if (B[$t] !== j[$t]) {
        Z = B[$t], kt = j[$t];
        break;
      }
    return Z < kt ? -1 : kt < Z ? 1 : 0;
  }, y.isEncoding = function(B) {
    switch (String(B).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, y.concat = function(B, j) {
    if (!Array.isArray(B))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (B.length === 0)
      return y.alloc(0);
    let Z;
    if (j === void 0)
      for (j = 0, Z = 0; Z < B.length; ++Z)
        j += B[Z].length;
    const kt = y.allocUnsafe(j);
    let $t = 0;
    for (Z = 0; Z < B.length; ++Z) {
      let At = B[Z];
      if (he(At, Uint8Array))
        $t + At.length > kt.length ? (y.isBuffer(At) || (At = y.from(At)), At.copy(kt, $t)) : Uint8Array.prototype.set.call(kt, At, $t);
      else {
        if (!y.isBuffer(At))
          throw new TypeError('"list" argument must be an Array of Buffers');
        At.copy(kt, $t);
      }
      $t += At.length;
    }
    return kt;
  }, y.byteLength = X, y.prototype._isBuffer = !0, y.prototype.swap16 = function() {
    const B = this.length;
    if (B % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let j = 0; j < B; j += 2)
      nt(this, j, j + 1);
    return this;
  }, y.prototype.swap32 = function() {
    const B = this.length;
    if (B % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let j = 0; j < B; j += 4)
      nt(this, j, j + 3), nt(this, j + 1, j + 2);
    return this;
  }, y.prototype.swap64 = function() {
    const B = this.length;
    if (B % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let j = 0; j < B; j += 8)
      nt(this, j, j + 7), nt(this, j + 1, j + 6), nt(this, j + 2, j + 5), nt(this, j + 3, j + 4);
    return this;
  }, y.prototype.toString = function() {
    const B = this.length;
    return B === 0 ? "" : arguments.length === 0 ? m(this, 0, B) : rt.apply(this, arguments);
  }, y.prototype.toLocaleString = y.prototype.toString, y.prototype.equals = function(B) {
    if (!y.isBuffer(B))
      throw new TypeError("Argument must be a Buffer");
    return this === B || y.compare(this, B) === 0;
  }, y.prototype.inspect = function() {
    let B = "";
    const j = o.INSPECT_MAX_BYTES;
    return B = this.toString("hex", 0, j).replace(/(.{2})/g, "$1 ").trim(), this.length > j && (B += " ... "), "<Buffer " + B + ">";
  }, u && (y.prototype[u] = y.prototype.inspect), y.prototype.compare = function(B, j, Z, kt, $t) {
    if (he(B, Uint8Array) && (B = y.from(B, B.offset, B.byteLength)), !y.isBuffer(B))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof B);
    if (j === void 0 && (j = 0), Z === void 0 && (Z = B ? B.length : 0), kt === void 0 && (kt = 0), $t === void 0 && ($t = this.length), j < 0 || Z > B.length || kt < 0 || $t > this.length)
      throw new RangeError("out of range index");
    if (kt >= $t && j >= Z)
      return 0;
    if (kt >= $t)
      return -1;
    if (j >= Z)
      return 1;
    if (this === B)
      return 0;
    let At = ($t >>>= 0) - (kt >>>= 0), Bt = (Z >>>= 0) - (j >>>= 0);
    const Ft = Math.min(At, Bt), Kt = this.slice(kt, $t), Zt = B.slice(j, Z);
    for (let Gt = 0; Gt < Ft; ++Gt)
      if (Kt[Gt] !== Zt[Gt]) {
        At = Kt[Gt], Bt = Zt[Gt];
        break;
      }
    return At < Bt ? -1 : Bt < At ? 1 : 0;
  }, y.prototype.includes = function(B, j, Z) {
    return this.indexOf(B, j, Z) !== -1;
  }, y.prototype.indexOf = function(B, j, Z) {
    return st(this, B, j, Z, !0);
  }, y.prototype.lastIndexOf = function(B, j, Z) {
    return st(this, B, j, Z, !1);
  }, y.prototype.write = function(B, j, Z, kt) {
    if (j === void 0)
      kt = "utf8", Z = this.length, j = 0;
    else if (Z === void 0 && typeof j == "string")
      kt = j, Z = this.length, j = 0;
    else {
      if (!isFinite(j))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      j >>>= 0, isFinite(Z) ? (Z >>>= 0, kt === void 0 && (kt = "utf8")) : (kt = Z, Z = void 0);
    }
    const $t = this.length - j;
    if ((Z === void 0 || Z > $t) && (Z = $t), B.length > 0 && (Z < 0 || j < 0) || j > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    kt || (kt = "utf8");
    let At = !1;
    for (; ; )
      switch (kt) {
        case "hex":
          return St(this, B, j, Z);
        case "utf8":
        case "utf-8":
          return Ct(this, B, j, Z);
        case "ascii":
        case "latin1":
        case "binary":
          return et(this, B, j, Z);
        case "base64":
          return at(this, B, j, Z);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _t(this, B, j, Z);
        default:
          if (At)
            throw new TypeError("Unknown encoding: " + kt);
          kt = ("" + kt).toLowerCase(), At = !0;
      }
  }, y.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const A = 4096;
  function E(B, j, Z) {
    let kt = "";
    Z = Math.min(B.length, Z);
    for (let $t = j; $t < Z; ++$t)
      kt += String.fromCharCode(127 & B[$t]);
    return kt;
  }
  function w(B, j, Z) {
    let kt = "";
    Z = Math.min(B.length, Z);
    for (let $t = j; $t < Z; ++$t)
      kt += String.fromCharCode(B[$t]);
    return kt;
  }
  function v(B, j, Z) {
    const kt = B.length;
    (!j || j < 0) && (j = 0), (!Z || Z < 0 || Z > kt) && (Z = kt);
    let $t = "";
    for (let At = j; At < Z; ++At)
      $t += jr[B[At]];
    return $t;
  }
  function k(B, j, Z) {
    const kt = B.slice(j, Z);
    let $t = "";
    for (let At = 0; At < kt.length - 1; At += 2)
      $t += String.fromCharCode(kt[At] + 256 * kt[At + 1]);
    return $t;
  }
  function O(B, j, Z) {
    if (B % 1 != 0 || B < 0)
      throw new RangeError("offset is not uint");
    if (B + j > Z)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function W(B, j, Z, kt, $t, At) {
    if (!y.isBuffer(B))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (j > $t || j < At)
      throw new RangeError('"value" argument is out of bounds');
    if (Z + kt > B.length)
      throw new RangeError("Index out of range");
  }
  function it(B, j, Z, kt, $t) {
    Xt(j, kt, $t, B, Z, 7);
    let At = Number(j & BigInt(4294967295));
    B[Z++] = At, At >>= 8, B[Z++] = At, At >>= 8, B[Z++] = At, At >>= 8, B[Z++] = At;
    let Bt = Number(j >> BigInt(32) & BigInt(4294967295));
    return B[Z++] = Bt, Bt >>= 8, B[Z++] = Bt, Bt >>= 8, B[Z++] = Bt, Bt >>= 8, B[Z++] = Bt, Z;
  }
  function vt(B, j, Z, kt, $t) {
    Xt(j, kt, $t, B, Z, 7);
    let At = Number(j & BigInt(4294967295));
    B[Z + 7] = At, At >>= 8, B[Z + 6] = At, At >>= 8, B[Z + 5] = At, At >>= 8, B[Z + 4] = At;
    let Bt = Number(j >> BigInt(32) & BigInt(4294967295));
    return B[Z + 3] = Bt, Bt >>= 8, B[Z + 2] = Bt, Bt >>= 8, B[Z + 1] = Bt, Bt >>= 8, B[Z] = Bt, Z + 8;
  }
  function xt(B, j, Z, kt, $t, At) {
    if (Z + kt > B.length)
      throw new RangeError("Index out of range");
    if (Z < 0)
      throw new RangeError("Index out of range");
  }
  function It(B, j, Z, kt, $t) {
    return j = +j, Z >>>= 0, $t || xt(B, 0, Z, 4), c.write(B, j, Z, kt, 23, 4), Z + 4;
  }
  function Wt(B, j, Z, kt, $t) {
    return j = +j, Z >>>= 0, $t || xt(B, 0, Z, 8), c.write(B, j, Z, kt, 52, 8), Z + 8;
  }
  y.prototype.slice = function(B, j) {
    const Z = this.length;
    (B = ~~B) < 0 ? (B += Z) < 0 && (B = 0) : B > Z && (B = Z), (j = j === void 0 ? Z : ~~j) < 0 ? (j += Z) < 0 && (j = 0) : j > Z && (j = Z), j < B && (j = B);
    const kt = this.subarray(B, j);
    return Object.setPrototypeOf(kt, y.prototype), kt;
  }, y.prototype.readUintLE = y.prototype.readUIntLE = function(B, j, Z) {
    B >>>= 0, j >>>= 0, Z || O(B, j, this.length);
    let kt = this[B], $t = 1, At = 0;
    for (; ++At < j && ($t *= 256); )
      kt += this[B + At] * $t;
    return kt;
  }, y.prototype.readUintBE = y.prototype.readUIntBE = function(B, j, Z) {
    B >>>= 0, j >>>= 0, Z || O(B, j, this.length);
    let kt = this[B + --j], $t = 1;
    for (; j > 0 && ($t *= 256); )
      kt += this[B + --j] * $t;
    return kt;
  }, y.prototype.readUint8 = y.prototype.readUInt8 = function(B, j) {
    return B >>>= 0, j || O(B, 1, this.length), this[B];
  }, y.prototype.readUint16LE = y.prototype.readUInt16LE = function(B, j) {
    return B >>>= 0, j || O(B, 2, this.length), this[B] | this[B + 1] << 8;
  }, y.prototype.readUint16BE = y.prototype.readUInt16BE = function(B, j) {
    return B >>>= 0, j || O(B, 2, this.length), this[B] << 8 | this[B + 1];
  }, y.prototype.readUint32LE = y.prototype.readUInt32LE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), (this[B] | this[B + 1] << 8 | this[B + 2] << 16) + 16777216 * this[B + 3];
  }, y.prototype.readUint32BE = y.prototype.readUInt32BE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), 16777216 * this[B] + (this[B + 1] << 16 | this[B + 2] << 8 | this[B + 3]);
  }, y.prototype.readBigUInt64LE = de(function(B) {
    ie(B >>>= 0, "offset");
    const j = this[B], Z = this[B + 7];
    j !== void 0 && Z !== void 0 || oe(B, this.length - 8);
    const kt = j + 256 * this[++B] + 65536 * this[++B] + this[++B] * 2 ** 24, $t = this[++B] + 256 * this[++B] + 65536 * this[++B] + Z * 2 ** 24;
    return BigInt(kt) + (BigInt($t) << BigInt(32));
  }), y.prototype.readBigUInt64BE = de(function(B) {
    ie(B >>>= 0, "offset");
    const j = this[B], Z = this[B + 7];
    j !== void 0 && Z !== void 0 || oe(B, this.length - 8);
    const kt = j * 2 ** 24 + 65536 * this[++B] + 256 * this[++B] + this[++B], $t = this[++B] * 2 ** 24 + 65536 * this[++B] + 256 * this[++B] + Z;
    return (BigInt(kt) << BigInt(32)) + BigInt($t);
  }), y.prototype.readIntLE = function(B, j, Z) {
    B >>>= 0, j >>>= 0, Z || O(B, j, this.length);
    let kt = this[B], $t = 1, At = 0;
    for (; ++At < j && ($t *= 256); )
      kt += this[B + At] * $t;
    return $t *= 128, kt >= $t && (kt -= Math.pow(2, 8 * j)), kt;
  }, y.prototype.readIntBE = function(B, j, Z) {
    B >>>= 0, j >>>= 0, Z || O(B, j, this.length);
    let kt = j, $t = 1, At = this[B + --kt];
    for (; kt > 0 && ($t *= 256); )
      At += this[B + --kt] * $t;
    return $t *= 128, At >= $t && (At -= Math.pow(2, 8 * j)), At;
  }, y.prototype.readInt8 = function(B, j) {
    return B >>>= 0, j || O(B, 1, this.length), 128 & this[B] ? -1 * (255 - this[B] + 1) : this[B];
  }, y.prototype.readInt16LE = function(B, j) {
    B >>>= 0, j || O(B, 2, this.length);
    const Z = this[B] | this[B + 1] << 8;
    return 32768 & Z ? 4294901760 | Z : Z;
  }, y.prototype.readInt16BE = function(B, j) {
    B >>>= 0, j || O(B, 2, this.length);
    const Z = this[B + 1] | this[B] << 8;
    return 32768 & Z ? 4294901760 | Z : Z;
  }, y.prototype.readInt32LE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), this[B] | this[B + 1] << 8 | this[B + 2] << 16 | this[B + 3] << 24;
  }, y.prototype.readInt32BE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), this[B] << 24 | this[B + 1] << 16 | this[B + 2] << 8 | this[B + 3];
  }, y.prototype.readBigInt64LE = de(function(B) {
    ie(B >>>= 0, "offset");
    const j = this[B], Z = this[B + 7];
    j !== void 0 && Z !== void 0 || oe(B, this.length - 8);
    const kt = this[B + 4] + 256 * this[B + 5] + 65536 * this[B + 6] + (Z << 24);
    return (BigInt(kt) << BigInt(32)) + BigInt(j + 256 * this[++B] + 65536 * this[++B] + this[++B] * 2 ** 24);
  }), y.prototype.readBigInt64BE = de(function(B) {
    ie(B >>>= 0, "offset");
    const j = this[B], Z = this[B + 7];
    j !== void 0 && Z !== void 0 || oe(B, this.length - 8);
    const kt = (j << 24) + 65536 * this[++B] + 256 * this[++B] + this[++B];
    return (BigInt(kt) << BigInt(32)) + BigInt(this[++B] * 2 ** 24 + 65536 * this[++B] + 256 * this[++B] + Z);
  }), y.prototype.readFloatLE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), c.read(this, B, !0, 23, 4);
  }, y.prototype.readFloatBE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), c.read(this, B, !1, 23, 4);
  }, y.prototype.readDoubleLE = function(B, j) {
    return B >>>= 0, j || O(B, 8, this.length), c.read(this, B, !0, 52, 8);
  }, y.prototype.readDoubleBE = function(B, j) {
    return B >>>= 0, j || O(B, 8, this.length), c.read(this, B, !1, 52, 8);
  }, y.prototype.writeUintLE = y.prototype.writeUIntLE = function(B, j, Z, kt) {
    B = +B, j >>>= 0, Z >>>= 0, kt || W(this, B, j, Z, Math.pow(2, 8 * Z) - 1, 0);
    let $t = 1, At = 0;
    for (this[j] = 255 & B; ++At < Z && ($t *= 256); )
      this[j + At] = B / $t & 255;
    return j + Z;
  }, y.prototype.writeUintBE = y.prototype.writeUIntBE = function(B, j, Z, kt) {
    B = +B, j >>>= 0, Z >>>= 0, kt || W(this, B, j, Z, Math.pow(2, 8 * Z) - 1, 0);
    let $t = Z - 1, At = 1;
    for (this[j + $t] = 255 & B; --$t >= 0 && (At *= 256); )
      this[j + $t] = B / At & 255;
    return j + Z;
  }, y.prototype.writeUint8 = y.prototype.writeUInt8 = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 1, 255, 0), this[j] = 255 & B, j + 1;
  }, y.prototype.writeUint16LE = y.prototype.writeUInt16LE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 2, 65535, 0), this[j] = 255 & B, this[j + 1] = B >>> 8, j + 2;
  }, y.prototype.writeUint16BE = y.prototype.writeUInt16BE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 2, 65535, 0), this[j] = B >>> 8, this[j + 1] = 255 & B, j + 2;
  }, y.prototype.writeUint32LE = y.prototype.writeUInt32LE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 4, 4294967295, 0), this[j + 3] = B >>> 24, this[j + 2] = B >>> 16, this[j + 1] = B >>> 8, this[j] = 255 & B, j + 4;
  }, y.prototype.writeUint32BE = y.prototype.writeUInt32BE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 4, 4294967295, 0), this[j] = B >>> 24, this[j + 1] = B >>> 16, this[j + 2] = B >>> 8, this[j + 3] = 255 & B, j + 4;
  }, y.prototype.writeBigUInt64LE = de(function(B, j = 0) {
    return it(this, B, j, BigInt(0), BigInt("0xffffffffffffffff"));
  }), y.prototype.writeBigUInt64BE = de(function(B, j = 0) {
    return vt(this, B, j, BigInt(0), BigInt("0xffffffffffffffff"));
  }), y.prototype.writeIntLE = function(B, j, Z, kt) {
    if (B = +B, j >>>= 0, !kt) {
      const Ft = Math.pow(2, 8 * Z - 1);
      W(this, B, j, Z, Ft - 1, -Ft);
    }
    let $t = 0, At = 1, Bt = 0;
    for (this[j] = 255 & B; ++$t < Z && (At *= 256); )
      B < 0 && Bt === 0 && this[j + $t - 1] !== 0 && (Bt = 1), this[j + $t] = (B / At >> 0) - Bt & 255;
    return j + Z;
  }, y.prototype.writeIntBE = function(B, j, Z, kt) {
    if (B = +B, j >>>= 0, !kt) {
      const Ft = Math.pow(2, 8 * Z - 1);
      W(this, B, j, Z, Ft - 1, -Ft);
    }
    let $t = Z - 1, At = 1, Bt = 0;
    for (this[j + $t] = 255 & B; --$t >= 0 && (At *= 256); )
      B < 0 && Bt === 0 && this[j + $t + 1] !== 0 && (Bt = 1), this[j + $t] = (B / At >> 0) - Bt & 255;
    return j + Z;
  }, y.prototype.writeInt8 = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 1, 127, -128), B < 0 && (B = 255 + B + 1), this[j] = 255 & B, j + 1;
  }, y.prototype.writeInt16LE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 2, 32767, -32768), this[j] = 255 & B, this[j + 1] = B >>> 8, j + 2;
  }, y.prototype.writeInt16BE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 2, 32767, -32768), this[j] = B >>> 8, this[j + 1] = 255 & B, j + 2;
  }, y.prototype.writeInt32LE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 4, 2147483647, -2147483648), this[j] = 255 & B, this[j + 1] = B >>> 8, this[j + 2] = B >>> 16, this[j + 3] = B >>> 24, j + 4;
  }, y.prototype.writeInt32BE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 4, 2147483647, -2147483648), B < 0 && (B = 4294967295 + B + 1), this[j] = B >>> 24, this[j + 1] = B >>> 16, this[j + 2] = B >>> 8, this[j + 3] = 255 & B, j + 4;
  }, y.prototype.writeBigInt64LE = de(function(B, j = 0) {
    return it(this, B, j, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), y.prototype.writeBigInt64BE = de(function(B, j = 0) {
    return vt(this, B, j, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), y.prototype.writeFloatLE = function(B, j, Z) {
    return It(this, B, j, !0, Z);
  }, y.prototype.writeFloatBE = function(B, j, Z) {
    return It(this, B, j, !1, Z);
  }, y.prototype.writeDoubleLE = function(B, j, Z) {
    return Wt(this, B, j, !0, Z);
  }, y.prototype.writeDoubleBE = function(B, j, Z) {
    return Wt(this, B, j, !1, Z);
  }, y.prototype.copy = function(B, j, Z, kt) {
    if (!y.isBuffer(B))
      throw new TypeError("argument should be a Buffer");
    if (Z || (Z = 0), kt || kt === 0 || (kt = this.length), j >= B.length && (j = B.length), j || (j = 0), kt > 0 && kt < Z && (kt = Z), kt === Z || B.length === 0 || this.length === 0)
      return 0;
    if (j < 0)
      throw new RangeError("targetStart out of bounds");
    if (Z < 0 || Z >= this.length)
      throw new RangeError("Index out of range");
    if (kt < 0)
      throw new RangeError("sourceEnd out of bounds");
    kt > this.length && (kt = this.length), B.length - j < kt - Z && (kt = B.length - j + Z);
    const $t = kt - Z;
    return this === B && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(j, Z, kt) : Uint8Array.prototype.set.call(B, this.subarray(Z, kt), j), $t;
  }, y.prototype.fill = function(B, j, Z, kt) {
    if (typeof B == "string") {
      if (typeof j == "string" ? (kt = j, j = 0, Z = this.length) : typeof Z == "string" && (kt = Z, Z = this.length), kt !== void 0 && typeof kt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof kt == "string" && !y.isEncoding(kt))
        throw new TypeError("Unknown encoding: " + kt);
      if (B.length === 1) {
        const At = B.charCodeAt(0);
        (kt === "utf8" && At < 128 || kt === "latin1") && (B = At);
      }
    } else
      typeof B == "number" ? B &= 255 : typeof B == "boolean" && (B = Number(B));
    if (j < 0 || this.length < j || this.length < Z)
      throw new RangeError("Out of range index");
    if (Z <= j)
      return this;
    let $t;
    if (j >>>= 0, Z = Z === void 0 ? this.length : Z >>> 0, B || (B = 0), typeof B == "number")
      for ($t = j; $t < Z; ++$t)
        this[$t] = B;
    else {
      const At = y.isBuffer(B) ? B : y.from(B, kt), Bt = At.length;
      if (Bt === 0)
        throw new TypeError('The value "' + B + '" is invalid for argument "value"');
      for ($t = 0; $t < Z - j; ++$t)
        this[$t + j] = At[$t % Bt];
    }
    return this;
  };
  const Ut = {};
  function zt(B, j, Z) {
    Ut[B] = class extends Z {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: j.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${B}]`, this.stack, delete this.name;
      }
      get code() {
        return B;
      }
      set code(kt) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: kt, writable: !0 });
      }
      toString() {
        return `${this.name} [${B}]: ${this.message}`;
      }
    };
  }
  function Jt(B) {
    let j = "", Z = B.length;
    const kt = B[0] === "-" ? 1 : 0;
    for (; Z >= kt + 4; Z -= 3)
      j = `_${B.slice(Z - 3, Z)}${j}`;
    return `${B.slice(0, Z)}${j}`;
  }
  function Xt(B, j, Z, kt, $t, At) {
    if (B > Z || B < j) {
      const Bt = typeof j == "bigint" ? "n" : "";
      let Ft;
      throw Ft = At > 3 ? j === 0 || j === BigInt(0) ? `>= 0${Bt} and < 2${Bt} ** ${8 * (At + 1)}${Bt}` : `>= -(2${Bt} ** ${8 * (At + 1) - 1}${Bt}) and < 2 ** ${8 * (At + 1) - 1}${Bt}` : `>= ${j}${Bt} and <= ${Z}${Bt}`, new Ut.ERR_OUT_OF_RANGE("value", Ft, B);
    }
    (function(Bt, Ft, Kt) {
      ie(Ft, "offset"), Bt[Ft] !== void 0 && Bt[Ft + Kt] !== void 0 || oe(Ft, Bt.length - (Kt + 1));
    })(kt, $t, At);
  }
  function ie(B, j) {
    if (typeof B != "number")
      throw new Ut.ERR_INVALID_ARG_TYPE(j, "number", B);
  }
  function oe(B, j, Z) {
    throw Math.floor(B) !== B ? (ie(B, Z), new Ut.ERR_OUT_OF_RANGE(Z || "offset", "an integer", B)) : j < 0 ? new Ut.ERR_BUFFER_OUT_OF_BOUNDS() : new Ut.ERR_OUT_OF_RANGE(Z || "offset", `>= ${Z ? 1 : 0} and <= ${j}`, B);
  }
  zt("ERR_BUFFER_OUT_OF_BOUNDS", function(B) {
    return B ? `${B} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), zt("ERR_INVALID_ARG_TYPE", function(B, j) {
    return `The "${B}" argument must be of type number. Received type ${typeof j}`;
  }, TypeError), zt("ERR_OUT_OF_RANGE", function(B, j, Z) {
    let kt = `The value of "${B}" is out of range.`, $t = Z;
    return Number.isInteger(Z) && Math.abs(Z) > 2 ** 32 ? $t = Jt(String(Z)) : typeof Z == "bigint" && ($t = String(Z), (Z > BigInt(2) ** BigInt(32) || Z < -(BigInt(2) ** BigInt(32))) && ($t = Jt($t)), $t += "n"), kt += ` It must be ${j}. Received ${$t}`, kt;
  }, RangeError);
  const De = /[^+/0-9A-Za-z-_]/g;
  function ue(B, j) {
    let Z;
    j = j || 1 / 0;
    const kt = B.length;
    let $t = null;
    const At = [];
    for (let Bt = 0; Bt < kt; ++Bt) {
      if (Z = B.charCodeAt(Bt), Z > 55295 && Z < 57344) {
        if (!$t) {
          if (Z > 56319) {
            (j -= 3) > -1 && At.push(239, 191, 189);
            continue;
          }
          if (Bt + 1 === kt) {
            (j -= 3) > -1 && At.push(239, 191, 189);
            continue;
          }
          $t = Z;
          continue;
        }
        if (Z < 56320) {
          (j -= 3) > -1 && At.push(239, 191, 189), $t = Z;
          continue;
        }
        Z = 65536 + ($t - 55296 << 10 | Z - 56320);
      } else
        $t && (j -= 3) > -1 && At.push(239, 191, 189);
      if ($t = null, Z < 128) {
        if ((j -= 1) < 0)
          break;
        At.push(Z);
      } else if (Z < 2048) {
        if ((j -= 2) < 0)
          break;
        At.push(Z >> 6 | 192, 63 & Z | 128);
      } else if (Z < 65536) {
        if ((j -= 3) < 0)
          break;
        At.push(Z >> 12 | 224, Z >> 6 & 63 | 128, 63 & Z | 128);
      } else {
        if (!(Z < 1114112))
          throw new Error("Invalid code point");
        if ((j -= 4) < 0)
          break;
        At.push(Z >> 18 | 240, Z >> 12 & 63 | 128, Z >> 6 & 63 | 128, 63 & Z | 128);
      }
    }
    return At;
  }
  function xe(B) {
    return n.toByteArray(function(j) {
      if ((j = (j = j.split("=")[0]).trim().replace(De, "")).length < 2)
        return "";
      for (; j.length % 4 != 0; )
        j += "=";
      return j;
    }(B));
  }
  function se(B, j, Z, kt) {
    let $t;
    for ($t = 0; $t < kt && !($t + Z >= j.length || $t >= B.length); ++$t)
      j[$t + Z] = B[$t];
    return $t;
  }
  function he(B, j) {
    return B instanceof j || B != null && B.constructor != null && B.constructor.name != null && B.constructor.name === j.name;
  }
  function je(B) {
    return B != B;
  }
  const jr = function() {
    const B = "0123456789abcdef", j = new Array(256);
    for (let Z = 0; Z < 16; ++Z) {
      const kt = 16 * Z;
      for (let $t = 0; $t < 16; ++$t)
        j[kt + $t] = B[Z] + B[$t];
    }
    return j;
  }();
  function de(B) {
    return typeof BigInt > "u" ? We : B;
  }
  function We() {
    throw new Error("BigInt not supported");
  }
})(buffer$2);
let lazy = null;
var textEndec$1 = function() {
  return lazy === null && (lazy = { textEncoder: new TextEncoder(), textDecoder: new TextDecoder() }), lazy;
}, formats$2 = {}, encoding = {};
const ModuleError$9 = moduleError, formats$1 = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
class Encoding$2 {
  constructor(n) {
    if (this.encode = n.encode || this.encode, this.decode = n.decode || this.decode, this.name = n.name || this.name, this.format = n.format || this.format, typeof this.encode != "function")
      throw new TypeError("The 'encode' property must be a function");
    if (typeof this.decode != "function")
      throw new TypeError("The 'decode' property must be a function");
    if (this.encode = this.encode.bind(this), this.decode = this.decode.bind(this), typeof this.name != "string" || this.name === "")
      throw new TypeError("The 'name' property must be a string");
    if (typeof this.format != "string" || !formats$1.has(this.format))
      throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
    n.createViewTranscoder && (this.createViewTranscoder = n.createViewTranscoder), n.createBufferTranscoder && (this.createBufferTranscoder = n.createBufferTranscoder), n.createUTF8Transcoder && (this.createUTF8Transcoder = n.createUTF8Transcoder);
  }
  get commonName() {
    return this.name.split("+")[0];
  }
  createBufferTranscoder() {
    throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
  }
  createViewTranscoder() {
    throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'view'`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
  }
  createUTF8Transcoder() {
    throw new ModuleError$9(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
  }
}
encoding.Encoding = Encoding$2;
const { Buffer: Buffer$a } = buffer$2 || {}, { Encoding: Encoding$1 } = encoding, textEndec = textEndec$1;
class BufferFormat$2 extends Encoding$1 {
  constructor(n) {
    super({ ...n, format: "buffer" });
  }
  createViewTranscoder() {
    return new ViewFormat$2({ encode: this.encode, decode: (n) => this.decode(Buffer$a.from(n.buffer, n.byteOffset, n.byteLength)), name: `${this.name}+view` });
  }
  createBufferTranscoder() {
    return this;
  }
}
class ViewFormat$2 extends Encoding$1 {
  constructor(n) {
    super({ ...n, format: "view" });
  }
  createBufferTranscoder() {
    return new BufferFormat$2({ encode: (n) => {
      const c = this.encode(n);
      return Buffer$a.from(c.buffer, c.byteOffset, c.byteLength);
    }, decode: this.decode, name: `${this.name}+buffer` });
  }
  createViewTranscoder() {
    return this;
  }
}
class UTF8Format$2 extends Encoding$1 {
  constructor(n) {
    super({ ...n, format: "utf8" });
  }
  createBufferTranscoder() {
    return new BufferFormat$2({ encode: (n) => Buffer$a.from(this.encode(n), "utf8"), decode: (n) => this.decode(n.toString("utf8")), name: `${this.name}+buffer` });
  }
  createViewTranscoder() {
    const { textEncoder: n, textDecoder: c } = textEndec();
    return new ViewFormat$2({ encode: (u) => n.encode(this.encode(u)), decode: (u) => this.decode(c.decode(u)), name: `${this.name}+view` });
  }
  createUTF8Transcoder() {
    return this;
  }
}
formats$2.BufferFormat = BufferFormat$2, formats$2.ViewFormat = ViewFormat$2, formats$2.UTF8Format = UTF8Format$2;
const { Buffer: Buffer$9 } = buffer$2 || { Buffer: { isBuffer: () => !1 } }, { textEncoder: textEncoder$1, textDecoder } = textEndec$1(), { BufferFormat: BufferFormat$1, ViewFormat: ViewFormat$1, UTF8Format: UTF8Format$1 } = formats$2, identity = (o) => o;
encodings$1.utf8 = new UTF8Format$1({ encode: function(o) {
  return Buffer$9.isBuffer(o) ? o.toString("utf8") : ArrayBuffer.isView(o) ? textDecoder.decode(o) : String(o);
}, decode: identity, name: "utf8", createViewTranscoder() {
  return new ViewFormat$1({ encode: function(o) {
    return ArrayBuffer.isView(o) ? o : textEncoder$1.encode(o);
  }, decode: function(o) {
    return textDecoder.decode(o);
  }, name: `${this.name}+view` });
}, createBufferTranscoder() {
  return new BufferFormat$1({ encode: function(o) {
    return Buffer$9.isBuffer(o) ? o : ArrayBuffer.isView(o) ? Buffer$9.from(o.buffer, o.byteOffset, o.byteLength) : Buffer$9.from(String(o), "utf8");
  }, decode: function(o) {
    return o.toString("utf8");
  }, name: `${this.name}+buffer` });
} }), encodings$1.json = new UTF8Format$1({ encode: JSON.stringify, decode: JSON.parse, name: "json" }), encodings$1.buffer = new BufferFormat$1({ encode: function(o) {
  return Buffer$9.isBuffer(o) ? o : ArrayBuffer.isView(o) ? Buffer$9.from(o.buffer, o.byteOffset, o.byteLength) : Buffer$9.from(String(o), "utf8");
}, decode: identity, name: "buffer", createViewTranscoder() {
  return new ViewFormat$1({ encode: function(o) {
    return ArrayBuffer.isView(o) ? o : Buffer$9.from(String(o), "utf8");
  }, decode: function(o) {
    return Buffer$9.from(o.buffer, o.byteOffset, o.byteLength);
  }, name: `${this.name}+view` });
} }), encodings$1.view = new ViewFormat$1({ encode: function(o) {
  return ArrayBuffer.isView(o) ? o : textEncoder$1.encode(o);
}, decode: identity, name: "view", createBufferTranscoder() {
  return new BufferFormat$1({ encode: function(o) {
    return Buffer$9.isBuffer(o) ? o : ArrayBuffer.isView(o) ? Buffer$9.from(o.buffer, o.byteOffset, o.byteLength) : Buffer$9.from(String(o), "utf8");
  }, decode: identity, name: `${this.name}+buffer` });
} }), encodings$1.hex = new BufferFormat$1({ encode: function(o) {
  return Buffer$9.isBuffer(o) ? o : Buffer$9.from(String(o), "hex");
}, decode: function(o) {
  return o.toString("hex");
}, name: "hex" }), encodings$1.base64 = new BufferFormat$1({ encode: function(o) {
  return Buffer$9.isBuffer(o) ? o : Buffer$9.from(String(o), "base64");
}, decode: function(o) {
  return o.toString("base64");
}, name: "base64" });
const ModuleError$8 = moduleError, encodings = encodings$1, { Encoding } = encoding, { BufferFormat, ViewFormat, UTF8Format } = formats$2, kFormats = Symbol("formats"), kEncodings = Symbol("encodings"), validFormats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
class Transcoder$1 {
  constructor(n) {
    if (!Array.isArray(n))
      throw new TypeError("The first argument 'formats' must be an array");
    if (!n.every((c) => validFormats.has(c)))
      throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
    this[kEncodings] = /* @__PURE__ */ new Map(), this[kFormats] = new Set(n);
    for (const c in encodings)
      try {
        this.encoding(c);
      } catch (u) {
        if (u.code !== "LEVEL_ENCODING_NOT_SUPPORTED")
          throw u;
      }
  }
  encodings() {
    return Array.from(new Set(this[kEncodings].values()));
  }
  encoding(n) {
    let c = this[kEncodings].get(n);
    if (c === void 0) {
      if (typeof n == "string" && n !== "") {
        if (c = lookup[n], !c)
          throw new ModuleError$8(`Encoding '${n}' is not found`, { code: "LEVEL_ENCODING_NOT_FOUND" });
      } else {
        if (typeof n != "object" || n === null)
          throw new TypeError("First argument 'encoding' must be a string or object");
        c = from$1(n);
      }
      const { name: u, format: h } = c;
      if (!this[kFormats].has(h))
        if (this[kFormats].has("view"))
          c = c.createViewTranscoder();
        else if (this[kFormats].has("buffer"))
          c = c.createBufferTranscoder();
        else {
          if (!this[kFormats].has("utf8"))
            throw new ModuleError$8(`Encoding '${u}' cannot be transcoded`, { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
          c = c.createUTF8Transcoder();
        }
      for (const g of [n, u, c.name, c.commonName])
        this[kEncodings].set(g, c);
    }
    return c;
  }
}
function from$1(o) {
  if (o instanceof Encoding)
    return o;
  const n = "type" in o && typeof o.type == "string" ? o.type : void 0, c = o.name || n || "anonymous-" + anonymousCount++;
  switch (detectFormat(o)) {
    case "view":
      return new ViewFormat({ ...o, name: c });
    case "utf8":
      return new UTF8Format({ ...o, name: c });
    case "buffer":
      return new BufferFormat({ ...o, name: c });
    default:
      throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
  }
}
function detectFormat(o) {
  return "format" in o && o.format !== void 0 ? o.format : "buffer" in o && typeof o.buffer == "boolean" ? o.buffer ? "buffer" : "utf8" : "code" in o && Number.isInteger(o.code) ? "view" : "buffer";
}
levelTranscoder.Transcoder = Transcoder$1;
const aliases = { binary: encodings.buffer, "utf-8": encodings.utf8 }, lookup = { ...encodings, ...aliases };
let anonymousCount = 0;
var events = { exports: {} }, R$1 = typeof Reflect == "object" ? Reflect : null, ReflectApply = R$1 && typeof R$1.apply == "function" ? R$1.apply : function(o, n, c) {
  return Function.prototype.apply.call(o, n, c);
}, ReflectOwnKeys;
function ProcessEmitWarning(o) {
  console && console.warn && console.warn(o);
}
ReflectOwnKeys = R$1 && typeof R$1.ownKeys == "function" ? R$1.ownKeys : Object.getOwnPropertySymbols ? function(o) {
  return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));
} : function(o) {
  return Object.getOwnPropertyNames(o);
};
var NumberIsNaN = Number.isNaN || function(o) {
  return o != o;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events.exports = EventEmitter$1, events.exports.once = once, EventEmitter$1.EventEmitter = EventEmitter$1, EventEmitter$1.prototype._events = void 0, EventEmitter$1.prototype._eventsCount = 0, EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(o) {
  if (typeof o != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof o);
}
function _getMaxListeners(o) {
  return o._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : o._maxListeners;
}
function _addListener(o, n, c, u) {
  var h, g, y;
  if (checkListener(c), (g = o._events) === void 0 ? (g = o._events = /* @__PURE__ */ Object.create(null), o._eventsCount = 0) : (g.newListener !== void 0 && (o.emit("newListener", n, c.listener ? c.listener : c), g = o._events), y = g[n]), y === void 0)
    y = g[n] = c, ++o._eventsCount;
  else if (typeof y == "function" ? y = g[n] = u ? [c, y] : [y, c] : u ? y.unshift(c) : y.push(c), (h = _getMaxListeners(o)) > 0 && y.length > h && !y.warned) {
    y.warned = !0;
    var $ = new Error("Possible EventEmitter memory leak detected. " + y.length + " " + String(n) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    $.name = "MaxListenersExceededWarning", $.emitter = o, $.type = n, $.count = y.length, ProcessEmitWarning($);
  }
  return o;
}
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(o, n, c) {
  var u = { fired: !1, wrapFn: void 0, target: o, type: n, listener: c }, h = onceWrapper.bind(u);
  return h.listener = c, u.wrapFn = h, h;
}
function _listeners(o, n, c) {
  var u = o._events;
  if (u === void 0)
    return [];
  var h = u[n];
  return h === void 0 ? [] : typeof h == "function" ? c ? [h.listener || h] : [h] : c ? unwrapListeners(h) : arrayClone(h, h.length);
}
function listenerCount(o) {
  var n = this._events;
  if (n !== void 0) {
    var c = n[o];
    if (typeof c == "function")
      return 1;
    if (c !== void 0)
      return c.length;
  }
  return 0;
}
function arrayClone(o, n) {
  for (var c = new Array(n), u = 0; u < n; ++u)
    c[u] = o[u];
  return c;
}
function spliceOne(o, n) {
  for (; n + 1 < o.length; n++)
    o[n] = o[n + 1];
  o.pop();
}
function unwrapListeners(o) {
  for (var n = new Array(o.length), c = 0; c < n.length; ++c)
    n[c] = o[c].listener || o[c];
  return n;
}
function once(o, n) {
  return new Promise(function(c, u) {
    function h(y) {
      o.removeListener(n, g), u(y);
    }
    function g() {
      typeof o.removeListener == "function" && o.removeListener("error", h), c([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(o, n, g, { once: !0 }), n !== "error" && addErrorHandlerIfEventEmitter(o, h, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(o, n, c) {
  typeof o.on == "function" && eventTargetAgnosticAddListener(o, "error", n, c);
}
function eventTargetAgnosticAddListener(o, n, c, u) {
  if (typeof o.on == "function")
    u.once ? o.once(n, c) : o.on(n, c);
  else {
    if (typeof o.addEventListener != "function")
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof o);
    o.addEventListener(n, function h(g) {
      u.once && o.removeEventListener(n, h), c(g);
    });
  }
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", { enumerable: !0, get: function() {
  return defaultMaxListeners;
}, set: function(o) {
  if (typeof o != "number" || o < 0 || NumberIsNaN(o))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + o + ".");
  defaultMaxListeners = o;
} }), EventEmitter$1.init = function() {
  this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, EventEmitter$1.prototype.setMaxListeners = function(o) {
  if (typeof o != "number" || o < 0 || NumberIsNaN(o))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + o + ".");
  return this._maxListeners = o, this;
}, EventEmitter$1.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
}, EventEmitter$1.prototype.emit = function(o) {
  for (var n = [], c = 1; c < arguments.length; c++)
    n.push(arguments[c]);
  var u = o === "error", h = this._events;
  if (h !== void 0)
    u = u && h.error === void 0;
  else if (!u)
    return !1;
  if (u) {
    var g;
    if (n.length > 0 && (g = n[0]), g instanceof Error)
      throw g;
    var y = new Error("Unhandled error." + (g ? " (" + g.message + ")" : ""));
    throw y.context = g, y;
  }
  var $ = h[o];
  if ($ === void 0)
    return !1;
  if (typeof $ == "function")
    ReflectApply($, this, n);
  else {
    var I = $.length, P = arrayClone($, I);
    for (c = 0; c < I; ++c)
      ReflectApply(P[c], this, n);
  }
  return !0;
}, EventEmitter$1.prototype.addListener = function(o, n) {
  return _addListener(this, o, n, !1);
}, EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener, EventEmitter$1.prototype.prependListener = function(o, n) {
  return _addListener(this, o, n, !0);
}, EventEmitter$1.prototype.once = function(o, n) {
  return checkListener(n), this.on(o, _onceWrap(this, o, n)), this;
}, EventEmitter$1.prototype.prependOnceListener = function(o, n) {
  return checkListener(n), this.prependListener(o, _onceWrap(this, o, n)), this;
}, EventEmitter$1.prototype.removeListener = function(o, n) {
  var c, u, h, g, y;
  if (checkListener(n), (u = this._events) === void 0)
    return this;
  if ((c = u[o]) === void 0)
    return this;
  if (c === n || c.listener === n)
    --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete u[o], u.removeListener && this.emit("removeListener", o, c.listener || n));
  else if (typeof c != "function") {
    for (h = -1, g = c.length - 1; g >= 0; g--)
      if (c[g] === n || c[g].listener === n) {
        y = c[g].listener, h = g;
        break;
      }
    if (h < 0)
      return this;
    h === 0 ? c.shift() : spliceOne(c, h), c.length === 1 && (u[o] = c[0]), u.removeListener !== void 0 && this.emit("removeListener", o, y || n);
  }
  return this;
}, EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener, EventEmitter$1.prototype.removeAllListeners = function(o) {
  var n, c, u;
  if ((c = this._events) === void 0)
    return this;
  if (c.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : c[o] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete c[o]), this;
  if (arguments.length === 0) {
    var h, g = Object.keys(c);
    for (u = 0; u < g.length; ++u)
      (h = g[u]) !== "removeListener" && this.removeAllListeners(h);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (typeof (n = c[o]) == "function")
    this.removeListener(o, n);
  else if (n !== void 0)
    for (u = n.length - 1; u >= 0; u--)
      this.removeListener(o, n[u]);
  return this;
}, EventEmitter$1.prototype.listeners = function(o) {
  return _listeners(this, o, !0);
}, EventEmitter$1.prototype.rawListeners = function(o) {
  return _listeners(this, o, !1);
}, EventEmitter$1.listenerCount = function(o, n) {
  return typeof o.listenerCount == "function" ? o.listenerCount(n) : listenerCount.call(o, n);
}, EventEmitter$1.prototype.listenerCount = listenerCount, EventEmitter$1.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
var catering = {}, nextTickBrowser$1 = typeof queueMicrotask == "function" ? queueMicrotask : (o) => Promise.resolve().then(o), nextTick = nextTickBrowser$1;
catering.fromCallback = function(o, n) {
  if (o === void 0) {
    var c = new Promise(function(u, h) {
      o = function(g, y) {
        g ? h(g) : u(y);
      };
    });
    o[n !== void 0 ? n : "promise"] = c;
  } else if (typeof o != "function")
    throw new TypeError("Callback must be a function");
  return o;
}, catering.fromPromise = function(o, n) {
  if (n === void 0)
    return o;
  o.then(function(c) {
    nextTick(() => n(null, c));
  }).catch(function(c) {
    nextTick(() => n(c));
  });
};
var abstractIterator = {}, common$7 = { getCallback: function(o, n) {
  return typeof o == "function" ? o : n;
}, getOptions: function(o, n) {
  return typeof o == "object" && o !== null ? o : n !== void 0 ? n : {};
} };
const { fromCallback: fromCallback$3 } = catering, ModuleError$7 = moduleError, { getOptions: getOptions$2, getCallback: getCallback$2 } = common$7, kPromise$3 = Symbol("promise"), kCallback$1 = Symbol("callback"), kWorking = Symbol("working"), kHandleOne$1 = Symbol("handleOne"), kHandleMany$1 = Symbol("handleMany"), kAutoClose = Symbol("autoClose"), kFinishWork = Symbol("finishWork"), kReturnMany = Symbol("returnMany"), kClosing = Symbol("closing"), kHandleClose = Symbol("handleClose"), kClosed = Symbol("closed"), kCloseCallbacks$1 = Symbol("closeCallbacks"), kKeyEncoding$1 = Symbol("keyEncoding"), kValueEncoding$1 = Symbol("valueEncoding"), kAbortOnClose = Symbol("abortOnClose"), kLegacy = Symbol("legacy"), kKeys = Symbol("keys"), kValues = Symbol("values"), kLimit = Symbol("limit"), kCount = Symbol("count"), emptyOptions$1 = Object.freeze({}), noop$1 = () => {
};
let warnedEnd = !1;
class CommonIterator {
  constructor(n, c, u) {
    if (typeof n != "object" || n === null)
      throw new TypeError("The first argument must be an abstract-level database, received " + (n === null ? "null" : typeof n));
    if (typeof c != "object" || c === null)
      throw new TypeError("The second argument must be an options object");
    this[kClosed] = !1, this[kCloseCallbacks$1] = [], this[kWorking] = !1, this[kClosing] = !1, this[kAutoClose] = !1, this[kCallback$1] = null, this[kHandleOne$1] = this[kHandleOne$1].bind(this), this[kHandleMany$1] = this[kHandleMany$1].bind(this), this[kHandleClose] = this[kHandleClose].bind(this), this[kKeyEncoding$1] = c[kKeyEncoding$1], this[kValueEncoding$1] = c[kValueEncoding$1], this[kLegacy] = u, this[kLimit] = Number.isInteger(c.limit) && c.limit >= 0 ? c.limit : 1 / 0, this[kCount] = 0, this[kAbortOnClose] = !!c.abortOnClose, this.db = n, this.db.attachResource(this), this.nextTick = n.nextTick;
  }
  get count() {
    return this[kCount];
  }
  get limit() {
    return this[kLimit];
  }
  next(n) {
    let c;
    if (n === void 0)
      c = new Promise((u, h) => {
        n = (g, y, $) => {
          g ? h(g) : this[kLegacy] ? y === void 0 && $ === void 0 ? u() : u([y, $]) : u(y);
        };
      });
    else if (typeof n != "function")
      throw new TypeError("Callback must be a function");
    return this[kClosing] ? this.nextTick(n, new ModuleError$7("Iterator is not open: cannot call next() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this[kWorking] ? this.nextTick(n, new ModuleError$7("Iterator is busy: cannot call next() until previous call has completed", { code: "LEVEL_ITERATOR_BUSY" })) : (this[kWorking] = !0, this[kCallback$1] = n, this[kCount] >= this[kLimit] ? this.nextTick(this[kHandleOne$1], null) : this._next(this[kHandleOne$1])), c;
  }
  _next(n) {
    this.nextTick(n);
  }
  nextv(n, c, u) {
    return u = getCallback$2(c, u), u = fromCallback$3(u, kPromise$3), c = getOptions$2(c, emptyOptions$1), Number.isInteger(n) ? (this[kClosing] ? this.nextTick(u, new ModuleError$7("Iterator is not open: cannot call nextv() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this[kWorking] ? this.nextTick(u, new ModuleError$7("Iterator is busy: cannot call nextv() until previous call has completed", { code: "LEVEL_ITERATOR_BUSY" })) : (n < 1 && (n = 1), this[kLimit] < 1 / 0 && (n = Math.min(n, this[kLimit] - this[kCount])), this[kWorking] = !0, this[kCallback$1] = u, n <= 0 ? this.nextTick(this[kHandleMany$1], null, []) : this._nextv(n, c, this[kHandleMany$1])), u[kPromise$3]) : (this.nextTick(u, new TypeError("The first argument 'size' must be an integer")), u[kPromise$3]);
  }
  _nextv(n, c, u) {
    const h = [], g = (y, $, I) => y ? u(y) : (this[kLegacy] ? $ === void 0 && I === void 0 : $ === void 0) ? u(null, h) : (h.push(this[kLegacy] ? [$, I] : $), void (h.length === n ? u(null, h) : this._next(g)));
    this._next(g);
  }
  all(n, c) {
    return c = getCallback$2(n, c), c = fromCallback$3(c, kPromise$3), n = getOptions$2(n, emptyOptions$1), this[kClosing] ? this.nextTick(c, new ModuleError$7("Iterator is not open: cannot call all() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this[kWorking] ? this.nextTick(c, new ModuleError$7("Iterator is busy: cannot call all() until previous call has completed", { code: "LEVEL_ITERATOR_BUSY" })) : (this[kWorking] = !0, this[kCallback$1] = c, this[kAutoClose] = !0, this[kCount] >= this[kLimit] ? this.nextTick(this[kHandleMany$1], null, []) : this._all(n, this[kHandleMany$1])), c[kPromise$3];
  }
  _all(n, c) {
    let u = this[kCount];
    const h = [], g = () => {
      const $ = this[kLimit] < 1 / 0 ? Math.min(1e3, this[kLimit] - u) : 1e3;
      $ <= 0 ? this.nextTick(c, null, h) : this._nextv($, emptyOptions$1, y);
    }, y = ($, I) => {
      $ ? c($) : I.length === 0 ? c(null, h) : (h.push.apply(h, I), u += I.length, g());
    };
    g();
  }
  [kFinishWork]() {
    const n = this[kCallback$1];
    return this[kAbortOnClose] && n === null ? noop$1 : (this[kWorking] = !1, this[kCallback$1] = null, this[kClosing] && this._close(this[kHandleClose]), n);
  }
  [kReturnMany](n, c, u) {
    this[kAutoClose] ? this.close(n.bind(null, c, u)) : n(c, u);
  }
  seek(n, c) {
    if (c = getOptions$2(c, emptyOptions$1), !this[kClosing]) {
      if (this[kWorking])
        throw new ModuleError$7("Iterator is busy: cannot call seek() until next() has completed", { code: "LEVEL_ITERATOR_BUSY" });
      {
        const u = this.db.keyEncoding(c.keyEncoding || this[kKeyEncoding$1]), h = u.format;
        c.keyEncoding !== h && (c = { ...c, keyEncoding: h });
        const g = this.db.prefixKey(u.encode(n), h);
        this._seek(g, c);
      }
    }
  }
  _seek(n, c) {
    throw new ModuleError$7("Iterator does not support seek()", { code: "LEVEL_NOT_SUPPORTED" });
  }
  close(n) {
    return n = fromCallback$3(n, kPromise$3), this[kClosed] ? this.nextTick(n) : this[kClosing] ? this[kCloseCallbacks$1].push(n) : (this[kClosing] = !0, this[kCloseCallbacks$1].push(n), this[kWorking] ? this[kAbortOnClose] && this[kFinishWork]()(new ModuleError$7("Aborted on iterator close()", { code: "LEVEL_ITERATOR_NOT_OPEN" })) : this._close(this[kHandleClose])), n[kPromise$3];
  }
  _close(n) {
    this.nextTick(n);
  }
  [kHandleClose]() {
    this[kClosed] = !0, this.db.detachResource(this);
    const n = this[kCloseCallbacks$1];
    this[kCloseCallbacks$1] = [];
    for (const c of n)
      c();
  }
  async *[Symbol.asyncIterator]() {
    try {
      let n;
      for (; (n = await this.next()) !== void 0; )
        yield n;
    } finally {
      this[kClosed] || await this.close();
    }
  }
}
class AbstractIterator$4 extends CommonIterator {
  constructor(n, c) {
    super(n, c, !0), this[kKeys] = c.keys !== !1, this[kValues] = c.values !== !1;
  }
  [kHandleOne$1](n, c, u) {
    const h = this[kFinishWork]();
    if (n)
      return h(n);
    try {
      c = this[kKeys] && c !== void 0 ? this[kKeyEncoding$1].decode(c) : void 0, u = this[kValues] && u !== void 0 ? this[kValueEncoding$1].decode(u) : void 0;
    } catch (g) {
      return h(new IteratorDecodeError("entry", g));
    }
    c === void 0 && u === void 0 || this[kCount]++, h(null, c, u);
  }
  [kHandleMany$1](n, c) {
    const u = this[kFinishWork]();
    if (n)
      return this[kReturnMany](u, n);
    try {
      for (const h of c) {
        const g = h[0], y = h[1];
        h[0] = this[kKeys] && g !== void 0 ? this[kKeyEncoding$1].decode(g) : void 0, h[1] = this[kValues] && y !== void 0 ? this[kValueEncoding$1].decode(y) : void 0;
      }
    } catch (h) {
      return this[kReturnMany](u, new IteratorDecodeError("entries", h));
    }
    this[kCount] += c.length, this[kReturnMany](u, null, c);
  }
  end(n) {
    return warnedEnd || typeof console > "u" || (warnedEnd = !0, console.warn(new ModuleError$7("The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version", { code: "LEVEL_LEGACY" }))), this.close(n);
  }
}
class AbstractKeyIterator$3 extends CommonIterator {
  constructor(n, c) {
    super(n, c, !1);
  }
  [kHandleOne$1](n, c) {
    const u = this[kFinishWork]();
    if (n)
      return u(n);
    try {
      c = c !== void 0 ? this[kKeyEncoding$1].decode(c) : void 0;
    } catch (h) {
      return u(new IteratorDecodeError("key", h));
    }
    c !== void 0 && this[kCount]++, u(null, c);
  }
  [kHandleMany$1](n, c) {
    const u = this[kFinishWork]();
    if (n)
      return this[kReturnMany](u, n);
    try {
      for (let h = 0; h < c.length; h++) {
        const g = c[h];
        c[h] = g !== void 0 ? this[kKeyEncoding$1].decode(g) : void 0;
      }
    } catch (h) {
      return this[kReturnMany](u, new IteratorDecodeError("keys", h));
    }
    this[kCount] += c.length, this[kReturnMany](u, null, c);
  }
}
class AbstractValueIterator$3 extends CommonIterator {
  constructor(n, c) {
    super(n, c, !1);
  }
  [kHandleOne$1](n, c) {
    const u = this[kFinishWork]();
    if (n)
      return u(n);
    try {
      c = c !== void 0 ? this[kValueEncoding$1].decode(c) : void 0;
    } catch (h) {
      return u(new IteratorDecodeError("value", h));
    }
    c !== void 0 && this[kCount]++, u(null, c);
  }
  [kHandleMany$1](n, c) {
    const u = this[kFinishWork]();
    if (n)
      return this[kReturnMany](u, n);
    try {
      for (let h = 0; h < c.length; h++) {
        const g = c[h];
        c[h] = g !== void 0 ? this[kValueEncoding$1].decode(g) : void 0;
      }
    } catch (h) {
      return this[kReturnMany](u, new IteratorDecodeError("values", h));
    }
    this[kCount] += c.length, this[kReturnMany](u, null, c);
  }
}
class IteratorDecodeError extends ModuleError$7 {
  constructor(n, c) {
    super(`Iterator could not decode ${n}`, { code: "LEVEL_DECODE_ERROR", cause: c });
  }
}
for (const o of ["_ended property", "_nexting property", "_end method"])
  Object.defineProperty(AbstractIterator$4.prototype, o.split(" ")[0], { get() {
    throw new ModuleError$7(`The ${o} has been removed`, { code: "LEVEL_LEGACY" });
  }, set() {
    throw new ModuleError$7(`The ${o} has been removed`, { code: "LEVEL_LEGACY" });
  } });
AbstractIterator$4.keyEncoding = kKeyEncoding$1, AbstractIterator$4.valueEncoding = kValueEncoding$1, abstractIterator.AbstractIterator = AbstractIterator$4, abstractIterator.AbstractKeyIterator = AbstractKeyIterator$3, abstractIterator.AbstractValueIterator = AbstractValueIterator$3;
var defaultKvIterator = {};
const { AbstractKeyIterator: AbstractKeyIterator$2, AbstractValueIterator: AbstractValueIterator$2 } = abstractIterator, kIterator$1 = Symbol("iterator"), kCallback = Symbol("callback"), kHandleOne = Symbol("handleOne"), kHandleMany = Symbol("handleMany");
class DefaultKeyIterator$1 extends AbstractKeyIterator$2 {
  constructor(n, c) {
    super(n, c), this[kIterator$1] = n.iterator({ ...c, keys: !0, values: !1 }), this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this);
  }
}
class DefaultValueIterator$1 extends AbstractValueIterator$2 {
  constructor(n, c) {
    super(n, c), this[kIterator$1] = n.iterator({ ...c, keys: !1, values: !0 }), this[kHandleOne] = this[kHandleOne].bind(this), this[kHandleMany] = this[kHandleMany].bind(this);
  }
}
for (const o of [DefaultKeyIterator$1, DefaultValueIterator$1]) {
  const n = o === DefaultKeyIterator$1, c = n ? (u) => u[0] : (u) => u[1];
  o.prototype._next = function(u) {
    this[kCallback] = u, this[kIterator$1].next(this[kHandleOne]);
  }, o.prototype[kHandleOne] = function(u, h, g) {
    const y = this[kCallback];
    u ? y(u) : y(null, n ? h : g);
  }, o.prototype._nextv = function(u, h, g) {
    this[kCallback] = g, this[kIterator$1].nextv(u, h, this[kHandleMany]);
  }, o.prototype._all = function(u, h) {
    this[kCallback] = h, this[kIterator$1].all(u, this[kHandleMany]);
  }, o.prototype[kHandleMany] = function(u, h) {
    const g = this[kCallback];
    u ? g(u) : g(null, h.map(c));
  }, o.prototype._seek = function(u, h) {
    this[kIterator$1].seek(u, h);
  }, o.prototype._close = function(u) {
    this[kIterator$1].close(u);
  };
}
defaultKvIterator.DefaultKeyIterator = DefaultKeyIterator$1, defaultKvIterator.DefaultValueIterator = DefaultValueIterator$1;
var deferredIterator = {};
const { AbstractIterator: AbstractIterator$3, AbstractKeyIterator: AbstractKeyIterator$1, AbstractValueIterator: AbstractValueIterator$1 } = abstractIterator, ModuleError$6 = moduleError, kNut = Symbol("nut"), kUndefer$1 = Symbol("undefer"), kFactory = Symbol("factory");
class DeferredIterator$1 extends AbstractIterator$3 {
  constructor(n, c) {
    super(n, c), this[kNut] = null, this[kFactory] = () => n.iterator(c), this.db.defer(() => this[kUndefer$1]());
  }
}
class DeferredKeyIterator$1 extends AbstractKeyIterator$1 {
  constructor(n, c) {
    super(n, c), this[kNut] = null, this[kFactory] = () => n.keys(c), this.db.defer(() => this[kUndefer$1]());
  }
}
class DeferredValueIterator$1 extends AbstractValueIterator$1 {
  constructor(n, c) {
    super(n, c), this[kNut] = null, this[kFactory] = () => n.values(c), this.db.defer(() => this[kUndefer$1]());
  }
}
for (const o of [DeferredIterator$1, DeferredKeyIterator$1, DeferredValueIterator$1])
  o.prototype[kUndefer$1] = function() {
    this.db.status === "open" && (this[kNut] = this[kFactory]());
  }, o.prototype._next = function(n) {
    this[kNut] !== null ? this[kNut].next(n) : this.db.status === "opening" ? this.db.defer(() => this._next(n)) : this.nextTick(n, new ModuleError$6("Iterator is not open: cannot call next() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" }));
  }, o.prototype._nextv = function(n, c, u) {
    this[kNut] !== null ? this[kNut].nextv(n, c, u) : this.db.status === "opening" ? this.db.defer(() => this._nextv(n, c, u)) : this.nextTick(u, new ModuleError$6("Iterator is not open: cannot call nextv() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" }));
  }, o.prototype._all = function(n, c) {
    this[kNut] !== null ? this[kNut].all(c) : this.db.status === "opening" ? this.db.defer(() => this._all(n, c)) : this.nextTick(c, new ModuleError$6("Iterator is not open: cannot call all() after close()", { code: "LEVEL_ITERATOR_NOT_OPEN" }));
  }, o.prototype._seek = function(n, c) {
    this[kNut] !== null ? this[kNut]._seek(n, c) : this.db.status === "opening" && this.db.defer(() => this._seek(n, c));
  }, o.prototype._close = function(n) {
    this[kNut] !== null ? this[kNut].close(n) : this.db.status === "opening" ? this.db.defer(() => this._close(n)) : this.nextTick(n);
  };
deferredIterator.DeferredIterator = DeferredIterator$1, deferredIterator.DeferredKeyIterator = DeferredKeyIterator$1, deferredIterator.DeferredValueIterator = DeferredValueIterator$1;
var defaultChainedBatch = {}, abstractChainedBatch = {};
const { fromCallback: fromCallback$2 } = catering, ModuleError$5 = moduleError, { getCallback: getCallback$1, getOptions: getOptions$1 } = common$7, kPromise$2 = Symbol("promise"), kStatus$1 = Symbol("status"), kOperations$1 = Symbol("operations"), kFinishClose = Symbol("finishClose"), kCloseCallbacks = Symbol("closeCallbacks");
class AbstractChainedBatch$1 {
  constructor(n) {
    if (typeof n != "object" || n === null)
      throw new TypeError("The first argument must be an abstract-level database, received " + (n === null ? "null" : typeof n));
    this[kOperations$1] = [], this[kCloseCallbacks] = [], this[kStatus$1] = "open", this[kFinishClose] = this[kFinishClose].bind(this), this.db = n, this.db.attachResource(this), this.nextTick = n.nextTick;
  }
  get length() {
    return this[kOperations$1].length;
  }
  put(n, c, u) {
    if (this[kStatus$1] !== "open")
      throw new ModuleError$5("Batch is not open: cannot call put() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" });
    const h = this.db._checkKey(n) || this.db._checkValue(c);
    if (h)
      throw h;
    const g = u && u.sublevel != null ? u.sublevel : this.db, y = u, $ = g.keyEncoding(u && u.keyEncoding), I = g.valueEncoding(u && u.valueEncoding), P = $.format;
    u = { ...u, keyEncoding: P, valueEncoding: I.format }, g !== this.db && (u.sublevel = null);
    const L = g.prefixKey($.encode(n), P), q = I.encode(c);
    return this._put(L, q, u), this[kOperations$1].push({ ...y, type: "put", key: n, value: c }), this;
  }
  _put(n, c, u) {
  }
  del(n, c) {
    if (this[kStatus$1] !== "open")
      throw new ModuleError$5("Batch is not open: cannot call del() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" });
    const u = this.db._checkKey(n);
    if (u)
      throw u;
    const h = c && c.sublevel != null ? c.sublevel : this.db, g = c, y = h.keyEncoding(c && c.keyEncoding), $ = y.format;
    return c = { ...c, keyEncoding: $ }, h !== this.db && (c.sublevel = null), this._del(h.prefixKey(y.encode(n), $), c), this[kOperations$1].push({ ...g, type: "del", key: n }), this;
  }
  _del(n, c) {
  }
  clear() {
    if (this[kStatus$1] !== "open")
      throw new ModuleError$5("Batch is not open: cannot call clear() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" });
    return this._clear(), this[kOperations$1] = [], this;
  }
  _clear() {
  }
  write(n, c) {
    return c = getCallback$1(n, c), c = fromCallback$2(c, kPromise$2), n = getOptions$1(n), this[kStatus$1] !== "open" ? this.nextTick(c, new ModuleError$5("Batch is not open: cannot call write() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" })) : this.length === 0 ? this.close(c) : (this[kStatus$1] = "writing", this._write(n, (u) => {
      this[kStatus$1] = "closing", this[kCloseCallbacks].push(() => c(u)), u || this.db.emit("batch", this[kOperations$1]), this._close(this[kFinishClose]);
    })), c[kPromise$2];
  }
  _write(n, c) {
  }
  close(n) {
    return n = fromCallback$2(n, kPromise$2), this[kStatus$1] === "closing" ? this[kCloseCallbacks].push(n) : this[kStatus$1] === "closed" ? this.nextTick(n) : (this[kCloseCallbacks].push(n), this[kStatus$1] !== "writing" && (this[kStatus$1] = "closing", this._close(this[kFinishClose]))), n[kPromise$2];
  }
  _close(n) {
    this.nextTick(n);
  }
  [kFinishClose]() {
    this[kStatus$1] = "closed", this.db.detachResource(this);
    const n = this[kCloseCallbacks];
    this[kCloseCallbacks] = [];
    for (const c of n)
      c();
  }
}
abstractChainedBatch.AbstractChainedBatch = AbstractChainedBatch$1;
const { AbstractChainedBatch } = abstractChainedBatch, ModuleError$4 = moduleError, kEncoded = Symbol("encoded");
class DefaultChainedBatch$1 extends AbstractChainedBatch {
  constructor(n) {
    super(n), this[kEncoded] = [];
  }
  _put(n, c, u) {
    this[kEncoded].push({ ...u, type: "put", key: n, value: c });
  }
  _del(n, c) {
    this[kEncoded].push({ ...c, type: "del", key: n });
  }
  _clear() {
    this[kEncoded] = [];
  }
  _write(n, c) {
    this.db.status === "opening" ? this.db.defer(() => this._write(n, c)) : this.db.status === "open" ? this[kEncoded].length === 0 ? this.nextTick(c) : this.db._batch(this[kEncoded], n, c) : this.nextTick(c, new ModuleError$4("Batch is not open: cannot call write() after write() or close()", { code: "LEVEL_BATCH_NOT_OPEN" }));
  }
}
defaultChainedBatch.DefaultChainedBatch = DefaultChainedBatch$1;
const ModuleError$3 = moduleError, hasOwnProperty$a = Object.prototype.hasOwnProperty, rangeOptions$2 = /* @__PURE__ */ new Set(["lt", "lte", "gt", "gte"]);
var rangeOptions_1 = function(o, n) {
  const c = {};
  for (const u in o)
    if (hasOwnProperty$a.call(o, u) && u !== "keyEncoding" && u !== "valueEncoding") {
      if (u === "start" || u === "end")
        throw new ModuleError$3(`The legacy range option '${u}' has been removed`, { code: "LEVEL_LEGACY" });
      if (u === "encoding")
        throw new ModuleError$3("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", { code: "LEVEL_LEGACY" });
      rangeOptions$2.has(u) ? c[u] = n.encode(o[u]) : c[u] = o[u];
    }
  return c.reverse = !!c.reverse, c.limit = Number.isInteger(c.limit) && c.limit >= 0 ? c.limit : -1, c;
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
};
let promise;
var queueMicrotask_1 = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : commonjsGlobal) : (o) => (promise || (promise = Promise.resolve())).then(o).catch((n) => setTimeout(() => {
  throw n;
}, 0)), nextTickBrowser, hasRequiredNextTickBrowser;
function requireNextTickBrowser() {
  if (hasRequiredNextTickBrowser)
    return nextTickBrowser;
  hasRequiredNextTickBrowser = 1;
  const o = queueMicrotask_1;
  return nextTickBrowser = function(n, ...c) {
    c.length === 0 ? o(n) : o(() => n(...c));
  }, nextTickBrowser;
}
var abstractSublevelIterator = {}, hasRequiredAbstractSublevelIterator, abstractSublevel, hasRequiredAbstractSublevel;
function requireAbstractSublevelIterator() {
  if (hasRequiredAbstractSublevelIterator)
    return abstractSublevelIterator;
  hasRequiredAbstractSublevelIterator = 1;
  const { AbstractIterator: o, AbstractKeyIterator: n, AbstractValueIterator: c } = abstractIterator, u = Symbol("unfix"), h = Symbol("iterator"), g = Symbol("handleOne"), y = Symbol("handleMany"), $ = Symbol("callback");
  class I extends o {
    constructor(N, X, rt, nt) {
      super(N, X), this[h] = rt, this[u] = nt, this[g] = this[g].bind(this), this[y] = this[y].bind(this), this[$] = null;
    }
    [g](N, X, rt) {
      const nt = this[$];
      if (N)
        return nt(N);
      X !== void 0 && (X = this[u](X)), nt(N, X, rt);
    }
    [y](N, X) {
      const rt = this[$];
      if (N)
        return rt(N);
      for (const nt of X) {
        const st = nt[0];
        st !== void 0 && (nt[0] = this[u](st));
      }
      rt(N, X);
    }
  }
  class P extends n {
    constructor(N, X, rt, nt) {
      super(N, X), this[h] = rt, this[u] = nt, this[g] = this[g].bind(this), this[y] = this[y].bind(this), this[$] = null;
    }
    [g](N, X) {
      const rt = this[$];
      if (N)
        return rt(N);
      X !== void 0 && (X = this[u](X)), rt(N, X);
    }
    [y](N, X) {
      const rt = this[$];
      if (N)
        return rt(N);
      for (let nt = 0; nt < X.length; nt++) {
        const st = X[nt];
        st !== void 0 && (X[nt] = this[u](st));
      }
      rt(N, X);
    }
  }
  class L extends c {
    constructor(N, X, rt) {
      super(N, X), this[h] = rt;
    }
  }
  for (const q of [I, P])
    q.prototype._next = function(N) {
      this[$] = N, this[h].next(this[g]);
    }, q.prototype._nextv = function(N, X, rt) {
      this[$] = rt, this[h].nextv(N, X, this[y]);
    }, q.prototype._all = function(N, X) {
      this[$] = X, this[h].all(N, this[y]);
    };
  for (const q of [L])
    q.prototype._next = function(N) {
      this[h].next(N);
    }, q.prototype._nextv = function(N, X, rt) {
      this[h].nextv(N, X, rt);
    }, q.prototype._all = function(N, X) {
      this[h].all(N, X);
    };
  for (const q of [I, P, L])
    q.prototype._seek = function(N, X) {
      this[h].seek(N, X);
    }, q.prototype._close = function(N) {
      this[h].close(N);
    };
  return abstractSublevelIterator.AbstractSublevelIterator = I, abstractSublevelIterator.AbstractSublevelKeyIterator = P, abstractSublevelIterator.AbstractSublevelValueIterator = L, abstractSublevelIterator;
}
function requireAbstractSublevel() {
  if (hasRequiredAbstractSublevel)
    return abstractSublevel;
  hasRequiredAbstractSublevel = 1;
  const o = moduleError, { Buffer: n } = buffer$2 || {}, { AbstractSublevelIterator: c, AbstractSublevelKeyIterator: u, AbstractSublevelValueIterator: h } = requireAbstractSublevelIterator(), g = Symbol("prefix"), y = Symbol("upperBound"), $ = Symbol("prefixRange"), I = Symbol("parent"), P = Symbol("unfix"), L = new TextEncoder(), q = { separator: "!" };
  abstractSublevel = function({ AbstractLevel: ot }) {
    class St extends ot {
      static defaults(et) {
        if (typeof et == "string")
          throw new o("The subleveldown string shorthand for { separator } has been removed", { code: "LEVEL_LEGACY" });
        if (et && et.open)
          throw new o("The subleveldown open option has been removed", { code: "LEVEL_LEGACY" });
        return et == null ? q : et.separator ? et : { ...et, separator: "!" };
      }
      constructor(et, at, _t) {
        const { separator: Nt, manifest: m, ...A } = St.defaults(_t);
        at = st(at, Nt);
        const E = Nt.charCodeAt(0) + 1, w = et[I] || et;
        if (!L.encode(at).every((O) => O > E && O < 127))
          throw new o(`Prefix must use bytes > ${E} < 127`, { code: "LEVEL_INVALID_PREFIX" });
        super(N(w, m), A);
        const v = (et.prefix || "") + Nt + at + Nt, k = v.slice(0, -1) + String.fromCharCode(E);
        this[I] = w, this[g] = new rt(v), this[y] = new rt(k), this[P] = new nt(), this.nextTick = w.nextTick;
      }
      prefixKey(et, at) {
        if (at === "utf8")
          return this[g].utf8 + et;
        if (et.byteLength === 0)
          return this[g][at];
        if (at === "view") {
          const _t = this[g].view, Nt = new Uint8Array(_t.byteLength + et.byteLength);
          return Nt.set(_t, 0), Nt.set(et, _t.byteLength), Nt;
        }
        {
          const _t = this[g].buffer;
          return n.concat([_t, et], _t.byteLength + et.byteLength);
        }
      }
      [$](et, at) {
        et.gte !== void 0 ? et.gte = this.prefixKey(et.gte, at) : et.gt !== void 0 ? et.gt = this.prefixKey(et.gt, at) : et.gte = this[g][at], et.lte !== void 0 ? et.lte = this.prefixKey(et.lte, at) : et.lt !== void 0 ? et.lt = this.prefixKey(et.lt, at) : et.lte = this[y][at];
      }
      get prefix() {
        return this[g].utf8;
      }
      get db() {
        return this[I];
      }
      _open(et, at) {
        this[I].open({ passive: !0 }, at);
      }
      _put(et, at, _t, Nt) {
        this[I].put(et, at, _t, Nt);
      }
      _get(et, at, _t) {
        this[I].get(et, at, _t);
      }
      _getMany(et, at, _t) {
        this[I].getMany(et, at, _t);
      }
      _del(et, at, _t) {
        this[I].del(et, at, _t);
      }
      _batch(et, at, _t) {
        this[I].batch(et, at, _t);
      }
      _clear(et, at) {
        this[$](et, et.keyEncoding), this[I].clear(et, at);
      }
      _iterator(et) {
        this[$](et, et.keyEncoding);
        const at = this[I].iterator(et), _t = this[P].get(this[g].utf8.length, et.keyEncoding);
        return new c(this, et, at, _t);
      }
      _keys(et) {
        this[$](et, et.keyEncoding);
        const at = this[I].keys(et), _t = this[P].get(this[g].utf8.length, et.keyEncoding);
        return new u(this, et, at, _t);
      }
      _values(et) {
        this[$](et, et.keyEncoding);
        const at = this[I].values(et);
        return new h(this, et, at);
      }
    }
    return { AbstractSublevel: St };
  };
  const N = function(ot, St) {
    return { ...ot.supports, createIfMissing: !1, errorIfExists: !1, events: {}, additionalMethods: {}, ...St, encodings: { utf8: X(ot, "utf8"), buffer: X(ot, "buffer"), view: X(ot, "view") } };
  }, X = function(ot, St) {
    return !!ot.supports.encodings[St] && ot.keyEncoding(St).name === St;
  };
  class rt {
    constructor(St) {
      this.utf8 = St, this.view = L.encode(St), this.buffer = n ? n.from(this.view.buffer, 0, this.view.byteLength) : {};
    }
  }
  class nt {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    get(St, Ct) {
      let et = this.cache.get(Ct);
      return et === void 0 && (et = Ct === "view" ? function(at, _t) {
        return _t.subarray(at);
      }.bind(null, St) : function(at, _t) {
        return _t.slice(at);
      }.bind(null, St), this.cache.set(Ct, et)), et;
    }
  }
  const st = function(ot, St) {
    let Ct = 0, et = ot.length;
    for (; Ct < et && ot[Ct] === St; )
      Ct++;
    for (; et > Ct && ot[et - 1] === St; )
      et--;
    return ot.slice(Ct, et);
  };
  return abstractSublevel;
}
const { supports } = levelSupports, { Transcoder } = levelTranscoder, { EventEmitter } = events.exports, { fromCallback: fromCallback$1 } = catering, ModuleError$2 = moduleError, { AbstractIterator: AbstractIterator$2 } = abstractIterator, { DefaultKeyIterator, DefaultValueIterator } = defaultKvIterator, { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = deferredIterator, { DefaultChainedBatch } = defaultChainedBatch, { getCallback, getOptions } = common$7, rangeOptions$1 = rangeOptions_1, kPromise$1 = Symbol("promise"), kLanded = Symbol("landed"), kResources = Symbol("resources"), kCloseResources = Symbol("closeResources"), kOperations = Symbol("operations"), kUndefer = Symbol("undefer"), kDeferOpen = Symbol("deferOpen"), kOptions$2 = Symbol("options"), kStatus = Symbol("status"), kDefaultOptions = Symbol("defaultOptions"), kTranscoder = Symbol("transcoder"), kKeyEncoding = Symbol("keyEncoding"), kValueEncoding = Symbol("valueEncoding"), noop = () => {
};
class AbstractLevel$2 extends EventEmitter {
  constructor(n, c) {
    if (super(), typeof n != "object" || n === null)
      throw new TypeError("The first argument 'manifest' must be an object");
    c = getOptions(c);
    const { keyEncoding: u, valueEncoding: h, passive: g, ...y } = c;
    this[kResources] = /* @__PURE__ */ new Set(), this[kOperations] = [], this[kDeferOpen] = !0, this[kOptions$2] = y, this[kStatus] = "opening", this.supports = supports(n, { status: !0, promises: !0, clear: !0, getMany: !0, deferredOpen: !0, snapshots: n.snapshots !== !1, permanence: n.permanence !== !1, keyIterator: !0, valueIterator: !0, iteratorNextv: !0, iteratorAll: !0, encodings: n.encodings || {}, events: Object.assign({}, n.events, { opening: !0, open: !0, closing: !0, closed: !0, put: !0, del: !0, batch: !0, clear: !0 }) }), this[kTranscoder] = new Transcoder(formats(this)), this[kKeyEncoding] = this[kTranscoder].encoding(u || "utf8"), this[kValueEncoding] = this[kTranscoder].encoding(h || "utf8");
    for (const $ of this[kTranscoder].encodings())
      this.supports.encodings[$.commonName] || (this.supports.encodings[$.commonName] = !0);
    this[kDefaultOptions] = { empty: Object.freeze({}), entry: Object.freeze({ keyEncoding: this[kKeyEncoding].commonName, valueEncoding: this[kValueEncoding].commonName }), key: Object.freeze({ keyEncoding: this[kKeyEncoding].commonName }) }, this.nextTick(() => {
      this[kDeferOpen] && this.open({ passive: !1 }, noop);
    });
  }
  get status() {
    return this[kStatus];
  }
  keyEncoding(n) {
    return this[kTranscoder].encoding(n != null ? n : this[kKeyEncoding]);
  }
  valueEncoding(n) {
    return this[kTranscoder].encoding(n != null ? n : this[kValueEncoding]);
  }
  open(n, c) {
    c = getCallback(n, c), c = fromCallback$1(c, kPromise$1), (n = { ...this[kOptions$2], ...getOptions(n) }).createIfMissing = n.createIfMissing !== !1, n.errorIfExists = !!n.errorIfExists;
    const u = (h) => {
      this[kStatus] === "closing" || this[kStatus] === "opening" ? this.once(kLanded, h ? () => u(h) : u) : this[kStatus] !== "open" ? c(new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN", cause: h })) : c();
    };
    return n.passive ? this[kStatus] === "opening" ? this.once(kLanded, u) : this.nextTick(u) : this[kStatus] === "closed" || this[kDeferOpen] ? (this[kDeferOpen] = !1, this[kStatus] = "opening", this.emit("opening"), this._open(n, (h) => {
      if (h)
        return this[kStatus] = "closed", this[kCloseResources](() => {
          this.emit(kLanded), u(h);
        }), void this[kUndefer]();
      this[kStatus] = "open", this[kUndefer](), this.emit(kLanded), this[kStatus] === "open" && this.emit("open"), this[kStatus] === "open" && this.emit("ready"), u();
    })) : this[kStatus] === "open" ? this.nextTick(u) : this.once(kLanded, () => this.open(n, c)), c[kPromise$1];
  }
  _open(n, c) {
    this.nextTick(c);
  }
  close(n) {
    n = fromCallback$1(n, kPromise$1);
    const c = (u) => {
      this[kStatus] === "opening" || this[kStatus] === "closing" ? this.once(kLanded, u ? c(u) : c) : this[kStatus] !== "closed" ? n(new ModuleError$2("Database is not closed", { code: "LEVEL_DATABASE_NOT_CLOSED", cause: u })) : n();
    };
    if (this[kStatus] === "open") {
      this[kStatus] = "closing", this.emit("closing");
      const u = (h) => {
        this[kStatus] = "open", this[kUndefer](), this.emit(kLanded), c(h);
      };
      this[kCloseResources](() => {
        this._close((h) => {
          if (h)
            return u(h);
          this[kStatus] = "closed", this[kUndefer](), this.emit(kLanded), this[kStatus] === "closed" && this.emit("closed"), c();
        });
      });
    } else
      this[kStatus] === "closed" ? this.nextTick(c) : this.once(kLanded, () => this.close(n));
    return n[kPromise$1];
  }
  [kCloseResources](n) {
    if (this[kResources].size === 0)
      return this.nextTick(n);
    let c = this[kResources].size, u = !0;
    const h = () => {
      --c == 0 && (u ? this.nextTick(n) : n());
    };
    for (const g of this[kResources])
      g.close(h);
    u = !1, this[kResources].clear();
  }
  _close(n) {
    this.nextTick(n);
  }
  get(n, c, u) {
    if (u = getCallback(c, u), u = fromCallback$1(u, kPromise$1), c = getOptions(c, this[kDefaultOptions].entry), this[kStatus] === "opening")
      return this.defer(() => this.get(n, c, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    const h = this._checkKey(n);
    if (h)
      return this.nextTick(u, h), u[kPromise$1];
    const g = this.keyEncoding(c.keyEncoding), y = this.valueEncoding(c.valueEncoding), $ = g.format, I = y.format;
    return c.keyEncoding === $ && c.valueEncoding === I || (c = Object.assign({}, c, { keyEncoding: $, valueEncoding: I })), this._get(this.prefixKey(g.encode(n), $), c, (P, L) => {
      if (P)
        return (P.code === "LEVEL_NOT_FOUND" || P.notFound || /NotFound/i.test(P)) && (P.code || (P.code = "LEVEL_NOT_FOUND"), P.notFound || (P.notFound = !0), P.status || (P.status = 404)), u(P);
      try {
        L = y.decode(L);
      } catch (q) {
        return u(new ModuleError$2("Could not decode value", { code: "LEVEL_DECODE_ERROR", cause: q }));
      }
      u(null, L);
    }), u[kPromise$1];
  }
  _get(n, c, u) {
    this.nextTick(u, new Error("NotFound"));
  }
  getMany(n, c, u) {
    if (u = getCallback(c, u), u = fromCallback$1(u, kPromise$1), c = getOptions(c, this[kDefaultOptions].entry), this[kStatus] === "opening")
      return this.defer(() => this.getMany(n, c, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    if (!Array.isArray(n))
      return this.nextTick(u, new TypeError("The first argument 'keys' must be an array")), u[kPromise$1];
    if (n.length === 0)
      return this.nextTick(u, null, []), u[kPromise$1];
    const h = this.keyEncoding(c.keyEncoding), g = this.valueEncoding(c.valueEncoding), y = h.format, $ = g.format;
    c.keyEncoding === y && c.valueEncoding === $ || (c = Object.assign({}, c, { keyEncoding: y, valueEncoding: $ }));
    const I = new Array(n.length);
    for (let P = 0; P < n.length; P++) {
      const L = n[P], q = this._checkKey(L);
      if (q)
        return this.nextTick(u, q), u[kPromise$1];
      I[P] = this.prefixKey(h.encode(L), y);
    }
    return this._getMany(I, c, (P, L) => {
      if (P)
        return u(P);
      try {
        for (let q = 0; q < L.length; q++)
          L[q] !== void 0 && (L[q] = g.decode(L[q]));
      } catch (q) {
        return u(new ModuleError$2(`Could not decode one or more of ${L.length} value(s)`, { code: "LEVEL_DECODE_ERROR", cause: q }));
      }
      u(null, L);
    }), u[kPromise$1];
  }
  _getMany(n, c, u) {
    this.nextTick(u, null, new Array(n.length).fill(void 0));
  }
  put(n, c, u, h) {
    if (h = getCallback(u, h), h = fromCallback$1(h, kPromise$1), u = getOptions(u, this[kDefaultOptions].entry), this[kStatus] === "opening")
      return this.defer(() => this.put(n, c, u, h)), h[kPromise$1];
    if (maybeError(this, h))
      return h[kPromise$1];
    const g = this._checkKey(n) || this._checkValue(c);
    if (g)
      return this.nextTick(h, g), h[kPromise$1];
    const y = this.keyEncoding(u.keyEncoding), $ = this.valueEncoding(u.valueEncoding), I = y.format, P = $.format;
    u.keyEncoding === I && u.valueEncoding === P || (u = Object.assign({}, u, { keyEncoding: I, valueEncoding: P }));
    const L = this.prefixKey(y.encode(n), I), q = $.encode(c);
    return this._put(L, q, u, (N) => {
      if (N)
        return h(N);
      this.emit("put", n, c), h();
    }), h[kPromise$1];
  }
  _put(n, c, u, h) {
    this.nextTick(h);
  }
  del(n, c, u) {
    if (u = getCallback(c, u), u = fromCallback$1(u, kPromise$1), c = getOptions(c, this[kDefaultOptions].key), this[kStatus] === "opening")
      return this.defer(() => this.del(n, c, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    const h = this._checkKey(n);
    if (h)
      return this.nextTick(u, h), u[kPromise$1];
    const g = this.keyEncoding(c.keyEncoding), y = g.format;
    return c.keyEncoding !== y && (c = Object.assign({}, c, { keyEncoding: y })), this._del(this.prefixKey(g.encode(n), y), c, ($) => {
      if ($)
        return u($);
      this.emit("del", n), u();
    }), u[kPromise$1];
  }
  _del(n, c, u) {
    this.nextTick(u);
  }
  batch(n, c, u) {
    if (!arguments.length) {
      if (this[kStatus] === "opening")
        return new DefaultChainedBatch(this);
      if (this[kStatus] !== "open")
        throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
      return this._chainedBatch();
    }
    if (u = typeof n == "function" ? n : getCallback(c, u), u = fromCallback$1(u, kPromise$1), c = getOptions(c, this[kDefaultOptions].empty), this[kStatus] === "opening")
      return this.defer(() => this.batch(n, c, u)), u[kPromise$1];
    if (maybeError(this, u))
      return u[kPromise$1];
    if (!Array.isArray(n))
      return this.nextTick(u, new TypeError("The first argument 'operations' must be an array")), u[kPromise$1];
    if (n.length === 0)
      return this.nextTick(u), u[kPromise$1];
    const h = new Array(n.length), { keyEncoding: g, valueEncoding: y, ...$ } = c;
    for (let I = 0; I < n.length; I++) {
      if (typeof n[I] != "object" || n[I] === null)
        return this.nextTick(u, new TypeError("A batch operation must be an object")), u[kPromise$1];
      const P = Object.assign({}, n[I]);
      if (P.type !== "put" && P.type !== "del")
        return this.nextTick(u, new TypeError("A batch operation must have a type property that is 'put' or 'del'")), u[kPromise$1];
      const L = this._checkKey(P.key);
      if (L)
        return this.nextTick(u, L), u[kPromise$1];
      const q = P.sublevel != null ? P.sublevel : this, N = q.keyEncoding(P.keyEncoding || g), X = N.format;
      if (P.key = q.prefixKey(N.encode(P.key), X), P.keyEncoding = X, P.type === "put") {
        const rt = this._checkValue(P.value);
        if (rt)
          return this.nextTick(u, rt), u[kPromise$1];
        const nt = q.valueEncoding(P.valueEncoding || y);
        P.value = nt.encode(P.value), P.valueEncoding = nt.format;
      }
      q !== this && (P.sublevel = null), h[I] = P;
    }
    return this._batch(h, $, (I) => {
      if (I)
        return u(I);
      this.emit("batch", n), u();
    }), u[kPromise$1];
  }
  _batch(n, c, u) {
    this.nextTick(u);
  }
  sublevel(n, c) {
    return this._sublevel(n, AbstractSublevel.defaults(c));
  }
  _sublevel(n, c) {
    return new AbstractSublevel(this, n, c);
  }
  prefixKey(n, c) {
    return n;
  }
  clear(n, c) {
    if (c = getCallback(n, c), c = fromCallback$1(c, kPromise$1), n = getOptions(n, this[kDefaultOptions].empty), this[kStatus] === "opening")
      return this.defer(() => this.clear(n, c)), c[kPromise$1];
    if (maybeError(this, c))
      return c[kPromise$1];
    const u = n, h = this.keyEncoding(n.keyEncoding);
    return (n = rangeOptions$1(n, h)).keyEncoding = h.format, n.limit === 0 ? this.nextTick(c) : this._clear(n, (g) => {
      if (g)
        return c(g);
      this.emit("clear", u), c();
    }), c[kPromise$1];
  }
  _clear(n, c) {
    this.nextTick(c);
  }
  iterator(n) {
    const c = this.keyEncoding(n && n.keyEncoding), u = this.valueEncoding(n && n.valueEncoding);
    if ((n = rangeOptions$1(n, c)).keys = n.keys !== !1, n.values = n.values !== !1, n[AbstractIterator$2.keyEncoding] = c, n[AbstractIterator$2.valueEncoding] = u, n.keyEncoding = c.format, n.valueEncoding = u.format, this[kStatus] === "opening")
      return new DeferredIterator(this, n);
    if (this[kStatus] !== "open")
      throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
    return this._iterator(n);
  }
  _iterator(n) {
    return new AbstractIterator$2(this, n);
  }
  keys(n) {
    const c = this.keyEncoding(n && n.keyEncoding), u = this.valueEncoding(n && n.valueEncoding);
    if ((n = rangeOptions$1(n, c))[AbstractIterator$2.keyEncoding] = c, n[AbstractIterator$2.valueEncoding] = u, n.keyEncoding = c.format, n.valueEncoding = u.format, this[kStatus] === "opening")
      return new DeferredKeyIterator(this, n);
    if (this[kStatus] !== "open")
      throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
    return this._keys(n);
  }
  _keys(n) {
    return new DefaultKeyIterator(this, n);
  }
  values(n) {
    const c = this.keyEncoding(n && n.keyEncoding), u = this.valueEncoding(n && n.valueEncoding);
    if ((n = rangeOptions$1(n, c))[AbstractIterator$2.keyEncoding] = c, n[AbstractIterator$2.valueEncoding] = u, n.keyEncoding = c.format, n.valueEncoding = u.format, this[kStatus] === "opening")
      return new DeferredValueIterator(this, n);
    if (this[kStatus] !== "open")
      throw new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" });
    return this._values(n);
  }
  _values(n) {
    return new DefaultValueIterator(this, n);
  }
  defer(n) {
    if (typeof n != "function")
      throw new TypeError("The first argument must be a function");
    this[kOperations].push(n);
  }
  [kUndefer]() {
    if (this[kOperations].length === 0)
      return;
    const n = this[kOperations];
    this[kOperations] = [];
    for (const c of n)
      c();
  }
  attachResource(n) {
    if (typeof n != "object" || n === null || typeof n.close != "function")
      throw new TypeError("The first argument must be a resource object");
    this[kResources].add(n);
  }
  detachResource(n) {
    this[kResources].delete(n);
  }
  _chainedBatch() {
    return new DefaultChainedBatch(this);
  }
  _checkKey(n) {
    if (n == null)
      return new ModuleError$2("Key cannot be null or undefined", { code: "LEVEL_INVALID_KEY" });
  }
  _checkValue(n) {
    if (n == null)
      return new ModuleError$2("Value cannot be null or undefined", { code: "LEVEL_INVALID_VALUE" });
  }
}
AbstractLevel$2.prototype.nextTick = requireNextTickBrowser();
const { AbstractSublevel } = requireAbstractSublevel()({ AbstractLevel: AbstractLevel$2 });
abstractLevel.AbstractLevel = AbstractLevel$2, abstractLevel.AbstractSublevel = AbstractSublevel;
const maybeError = function(o, n) {
  return o[kStatus] !== "open" && (o.nextTick(n, new ModuleError$2("Database is not open", { code: "LEVEL_DATABASE_NOT_OPEN" })), !0);
}, formats = function(o) {
  return Object.keys(o.supports.encodings).filter((n) => !!o.supports.encodings[n]);
};
abstractLevel$1.AbstractLevel = abstractLevel.AbstractLevel, abstractLevel$1.AbstractSublevel = abstractLevel.AbstractSublevel, abstractLevel$1.AbstractIterator = abstractIterator.AbstractIterator, abstractLevel$1.AbstractKeyIterator = abstractIterator.AbstractKeyIterator, abstractLevel$1.AbstractValueIterator = abstractIterator.AbstractValueIterator, abstractLevel$1.AbstractChainedBatch = abstractChainedBatch.AbstractChainedBatch;
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var runParallelLimit_1 = runParallelLimit;
const queueMicrotask$1 = queueMicrotask_1;
function runParallelLimit(o, n, c) {
  if (typeof n != "number")
    throw new Error("second argument must be a Number");
  let u, h, g, y, $, I, P = !0;
  function L(N) {
    function X() {
      c && c(N, u), c = null;
    }
    P ? queueMicrotask$1(X) : X();
  }
  function q(N, X, rt) {
    if (u[N] = rt, X && ($ = !0), --g == 0 || X)
      L(X);
    else if (!$ && I < h) {
      let nt;
      y ? (nt = y[I], I += 1, o[nt](function(st, ot) {
        q(nt, st, ot);
      })) : (nt = I, I += 1, o[nt](function(st, ot) {
        q(nt, st, ot);
      }));
    }
  }
  Array.isArray(o) ? (u = [], g = h = o.length) : (y = Object.keys(o), u = {}, g = h = y.length), I = n, g ? y ? y.some(function(N, X) {
    return o[N](function(rt, nt) {
      q(N, rt, nt);
    }), X === n - 1;
  }) : o.some(function(N, X) {
    return N(function(rt, nt) {
      q(X, rt, nt);
    }), X === n - 1;
  }) : L(null), P = !1;
}
var iterator$1 = {}, keyRange = function(o) {
  const n = o.gte !== void 0 ? o.gte : o.gt !== void 0 ? o.gt : void 0, c = o.lte !== void 0 ? o.lte : o.lt !== void 0 ? o.lt : void 0, u = o.gte === void 0, h = o.lte === void 0;
  return n !== void 0 && c !== void 0 ? IDBKeyRange.bound(n, c, u, h) : n !== void 0 ? IDBKeyRange.lowerBound(n, u) : c !== void 0 ? IDBKeyRange.upperBound(c, h) : null;
};
const textEncoder = new TextEncoder();
var deserialize$2 = function(o) {
  return o instanceof Uint8Array ? o : o instanceof ArrayBuffer ? new Uint8Array(o) : textEncoder.encode(o);
};
const { AbstractIterator: AbstractIterator$1 } = abstractLevel$1, createKeyRange$1 = keyRange, deserialize$1 = deserialize$2, kCache = Symbol("cache"), kFinished = Symbol("finished"), kOptions$1 = Symbol("options"), kCurrentOptions = Symbol("currentOptions"), kPosition = Symbol("position"), kLocation$1 = Symbol("location"), kFirst = Symbol("first"), emptyOptions = {};
class Iterator$1 extends AbstractIterator$1 {
  constructor(n, c, u) {
    super(n, u), this[kCache] = [], this[kFinished] = this.limit === 0, this[kOptions$1] = u, this[kCurrentOptions] = { ...u }, this[kPosition] = void 0, this[kLocation$1] = c, this[kFirst] = !0;
  }
  _nextv(n, c, u) {
    if (this[kFirst] = !1, this[kFinished])
      return this.nextTick(u, null, []);
    if (this[kCache].length > 0)
      return n = Math.min(n, this[kCache].length), this.nextTick(u, null, this[kCache].splice(0, n));
    let h;
    this[kPosition] !== void 0 && (this[kOptions$1].reverse ? (this[kCurrentOptions].lt = this[kPosition], this[kCurrentOptions].lte = void 0) : (this[kCurrentOptions].gt = this[kPosition], this[kCurrentOptions].gte = void 0));
    try {
      h = createKeyRange$1(this[kCurrentOptions]);
    } catch {
      return this[kFinished] = !0, this.nextTick(u, null, []);
    }
    const g = this.db.db.transaction([this[kLocation$1]], "readonly"), y = g.objectStore(this[kLocation$1]), $ = [];
    if (this[kOptions$1].reverse)
      y[!this[kOptions$1].values && y.openKeyCursor ? "openKeyCursor" : "openCursor"](h, "prev").onsuccess = (I) => {
        const P = I.target.result;
        if (P) {
          const { key: L, value: q } = P;
          this[kPosition] = L, $.push([this[kOptions$1].keys && L !== void 0 ? deserialize$1(L) : void 0, this[kOptions$1].values && q !== void 0 ? deserialize$1(q) : void 0]), $.length < n ? P.continue() : maybeCommit(g);
        } else
          this[kFinished] = !0;
      };
    else {
      let I, P;
      const L = () => {
        if (I === void 0 || P === void 0)
          return;
        const q = Math.max(I.length, P.length);
        q === 0 || n === 1 / 0 ? this[kFinished] = !0 : this[kPosition] = I[q - 1], $.length = q;
        for (let N = 0; N < q; N++) {
          const X = I[N], rt = P[N];
          $[N] = [this[kOptions$1].keys && X !== void 0 ? deserialize$1(X) : void 0, this[kOptions$1].values && rt !== void 0 ? deserialize$1(rt) : void 0];
        }
        maybeCommit(g);
      };
      this[kOptions$1].keys || n < 1 / 0 ? y.getAllKeys(h, n < 1 / 0 ? n : void 0).onsuccess = (q) => {
        I = q.target.result, L();
      } : (I = [], this.nextTick(L)), this[kOptions$1].values ? y.getAll(h, n < 1 / 0 ? n : void 0).onsuccess = (q) => {
        P = q.target.result, L();
      } : (P = [], this.nextTick(L));
    }
    g.onabort = () => {
      u(g.error || new Error("aborted by user")), u = null;
    }, g.oncomplete = () => {
      u(null, $), u = null;
    };
  }
  _next(n) {
    if (this[kCache].length > 0) {
      const [c, u] = this[kCache].shift();
      this.nextTick(n, null, c, u);
    } else if (this[kFinished])
      this.nextTick(n);
    else {
      let c = Math.min(100, this.limit - this.count);
      this[kFirst] && (this[kFirst] = !1, c = 1), this._nextv(c, emptyOptions, (u, h) => {
        if (u)
          return n(u);
        this[kCache] = h, this._next(n);
      });
    }
  }
  _all(n, c) {
    this[kFirst] = !1;
    const u = this[kCache].splice(0, this[kCache].length), h = this.limit - this.count - u.length;
    if (h <= 0)
      return this.nextTick(c, null, u);
    this._nextv(h, emptyOptions, (g, y) => {
      if (g)
        return c(g);
      u.length > 0 && (y = u.concat(y)), c(null, y);
    });
  }
  _seek(n, c) {
    let u;
    this[kFirst] = !0, this[kCache] = [], this[kFinished] = !1, this[kPosition] = void 0, this[kCurrentOptions] = { ...this[kOptions$1] };
    try {
      u = createKeyRange$1(this[kOptions$1]);
    } catch {
      return void (this[kFinished] = !0);
    }
    u === null || u.includes(n) ? this[kOptions$1].reverse ? this[kCurrentOptions].lte = n : this[kCurrentOptions].gte = n : this[kFinished] = !0;
  }
}
function maybeCommit(o) {
  typeof o.commit == "function" && o.commit();
}
iterator$1.Iterator = Iterator$1;
var clear$1 = function(o, n, c, u, h) {
  if (u.limit === 0)
    return o.nextTick(h);
  const g = o.db.transaction([n], "readwrite"), y = g.objectStore(n);
  let $ = 0;
  g.oncomplete = function() {
    h();
  }, g.onabort = function() {
    h(g.error || new Error("aborted by user"));
  };
  const I = y.openKeyCursor ? "openKeyCursor" : "openCursor", P = u.reverse ? "prev" : "next";
  y[I](c, P).onsuccess = function(L) {
    const q = L.target.result;
    q && (y.delete(q.key).onsuccess = function() {
      (u.limit <= 0 || ++$ < u.limit) && q.continue();
    });
  };
};
const { AbstractLevel: AbstractLevel$1 } = abstractLevel$1, ModuleError$1 = moduleError, parallel = runParallelLimit_1, { fromCallback } = catering, { Iterator } = iterator$1, deserialize = deserialize$2, clear = clear$1, createKeyRange = keyRange, DEFAULT_PREFIX = "level-js-", kIDB = Symbol("idb"), kNamePrefix = Symbol("namePrefix"), kLocation = Symbol("location"), kVersion = Symbol("version"), kStore = Symbol("store"), kOnComplete = Symbol("onComplete"), kPromise = Symbol("promise");
class BrowserLevel extends AbstractLevel$1 {
  constructor(n, c, u) {
    if (typeof c == "function" || typeof u == "function")
      throw new ModuleError$1("The levelup-style callback argument has been removed", { code: "LEVEL_LEGACY" });
    const { prefix: h, version: g, ...y } = c || {};
    if (super({ encodings: { view: !0 }, snapshots: !1, createIfMissing: !1, errorIfExists: !1, seek: !0 }, y), typeof n != "string")
      throw new Error("constructor requires a location string argument");
    this[kLocation] = n, this[kNamePrefix] = h == null ? DEFAULT_PREFIX : h, this[kVersion] = parseInt(g || 1, 10), this[kIDB] = null;
  }
  get location() {
    return this[kLocation];
  }
  get namePrefix() {
    return this[kNamePrefix];
  }
  get version() {
    return this[kVersion];
  }
  get db() {
    return this[kIDB];
  }
  get type() {
    return "browser-level";
  }
  _open(n, c) {
    const u = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
    u.onerror = function() {
      c(u.error || new Error("unknown error"));
    }, u.onsuccess = () => {
      this[kIDB] = u.result, c();
    }, u.onupgradeneeded = (h) => {
      const g = h.target.result;
      g.objectStoreNames.contains(this[kLocation]) || g.createObjectStore(this[kLocation]);
    };
  }
  [kStore](n) {
    return this[kIDB].transaction([this[kLocation]], n).objectStore(this[kLocation]);
  }
  [kOnComplete](n, c) {
    const u = n.transaction;
    u.onabort = function() {
      c(u.error || new Error("aborted by user"));
    }, u.oncomplete = function() {
      c(null, n.result);
    };
  }
  _get(n, c, u) {
    const h = this[kStore]("readonly");
    let g;
    try {
      g = h.get(n);
    } catch (y) {
      return this.nextTick(u, y);
    }
    this[kOnComplete](g, function(y, $) {
      return y ? u(y) : $ === void 0 ? u(new ModuleError$1("Entry not found", { code: "LEVEL_NOT_FOUND" })) : void u(null, deserialize($));
    });
  }
  _getMany(n, c, u) {
    const h = this[kStore]("readonly"), g = n.map((y) => ($) => {
      let I;
      try {
        I = h.get(y);
      } catch (P) {
        return $(P);
      }
      I.onsuccess = () => {
        const P = I.result;
        $(null, P === void 0 ? P : deserialize(P));
      }, I.onerror = (P) => {
        P.stopPropagation(), $(I.error);
      };
    });
    parallel(g, 16, u);
  }
  _del(n, c, u) {
    const h = this[kStore]("readwrite");
    let g;
    try {
      g = h.delete(n);
    } catch (y) {
      return this.nextTick(u, y);
    }
    this[kOnComplete](g, u);
  }
  _put(n, c, u, h) {
    const g = this[kStore]("readwrite");
    let y;
    try {
      y = g.put(c, n);
    } catch ($) {
      return this.nextTick(h, $);
    }
    this[kOnComplete](y, h);
  }
  _iterator(n) {
    return new Iterator(this, this[kLocation], n);
  }
  _batch(n, c, u) {
    const h = this[kStore]("readwrite"), g = h.transaction;
    let y, $ = 0;
    g.onabort = function() {
      u(y || g.error || new Error("aborted by user"));
    }, g.oncomplete = function() {
      u();
    }, function I() {
      const P = n[$++], L = P.key;
      let q;
      try {
        q = P.type === "del" ? h.delete(L) : h.put(P.value, L);
      } catch (N) {
        return y = N, void g.abort();
      }
      $ < n.length ? q.onsuccess = I : typeof g.commit == "function" && g.commit();
    }();
  }
  _clear(n, c) {
    let u, h;
    try {
      u = createKeyRange(n);
    } catch {
      return this.nextTick(c);
    }
    if (n.limit >= 0)
      return clear(this, this[kLocation], u, n, c);
    try {
      const g = this[kStore]("readwrite");
      h = u ? g.delete(u) : g.clear();
    } catch (g) {
      return this.nextTick(c, g);
    }
    this[kOnComplete](h, c);
  }
  _close(n) {
    this[kIDB].close(), this.nextTick(n);
  }
}
BrowserLevel.destroy = function(o, n, c) {
  typeof n == "function" && (c = n, n = DEFAULT_PREFIX), c = fromCallback(c, kPromise);
  const u = indexedDB.deleteDatabase(n + o);
  return u.onsuccess = function() {
    c();
  }, u.onerror = function(h) {
    c(h);
  }, c[kPromise];
}, browserLevel.BrowserLevel = BrowserLevel;
var Level = browser.Level = browserLevel.BrowserLevel;
class LevelDatastore extends BaseDatastore {
  constructor(n, c = {}) {
    super(), this.db = typeof n == "string" ? new Level(n, { ...c, keyEncoding: "utf8", valueEncoding: "view" }) : n, this.opts = { createIfMissing: !0, compression: !1, ...c };
  }
  async open() {
    try {
      await this.db.open(this.opts);
    } catch (n) {
      throw dbOpenFailedError(n);
    }
  }
  async put(n, c) {
    try {
      await this.db.put(n.toString(), c);
    } catch (u) {
      throw dbWriteFailedError(u);
    }
  }
  async get(n) {
    let c;
    try {
      c = await this.db.get(n.toString());
    } catch (u) {
      throw u.notFound ? notFoundError$1(u) : dbWriteFailedError(u);
    }
    return c;
  }
  async has(n) {
    try {
      await this.db.get(n.toString());
    } catch (c) {
      if (c.notFound)
        return !1;
      throw c;
    }
    return !0;
  }
  async delete(n) {
    try {
      await this.db.del(n.toString());
    } catch (c) {
      throw dbDeleteFailedError(c);
    }
  }
  close() {
    return this.db && this.db.close();
  }
  batch() {
    const n = [];
    return { put: (c, u) => {
      n.push({ type: "put", key: c.toString(), value: u });
    }, delete: (c) => {
      n.push({ type: "del", key: c.toString() });
    }, commit: () => this.db.batch(n) };
  }
  query(n) {
    let c = this._query({ values: !0, prefix: n.prefix });
    Array.isArray(n.filters) && (c = n.filters.reduce((g, y) => itFilter(g, y), c)), Array.isArray(n.orders) && (c = n.orders.reduce((g, y) => itSort(g, y), c));
    const { offset: u, limit: h } = n;
    if (u) {
      let g = 0;
      c = itFilter(c, () => g++ >= u);
    }
    return h && (c = itTake(c, h)), c;
  }
  queryKeys(n) {
    let c = itMap(this._query({ values: !1, prefix: n.prefix }), ({ key: g }) => g);
    Array.isArray(n.filters) && (c = n.filters.reduce((g, y) => itFilter(g, y), c)), Array.isArray(n.orders) && (c = n.orders.reduce((g, y) => itSort(g, y), c));
    const { offset: u, limit: h } = n;
    if (u) {
      let g = 0;
      c = itFilter(c, () => g++ >= u);
    }
    return h && (c = itTake(c, h)), c;
  }
  _query(n) {
    const c = { keys: !0, keyEncoding: "buffer", values: n.values };
    if (n.prefix != null) {
      const h = n.prefix.toString();
      c.gte = h, c.lt = h + "\xFF";
    }
    const u = this.db.iterator(c);
    if (u[Symbol.asyncIterator])
      return levelIteratorToIterator(u);
    if (u.next != null && u.end != null)
      return oldLevelIteratorToIterator(u);
    throw new Error("Level returned incompatible iterator");
  }
}
async function* levelIteratorToIterator(o) {
  for await (const [n, c] of o)
    yield { key: new Key(n, !1), value: c };
  await o.close();
}
function oldLevelIteratorToIterator(o) {
  return { [Symbol.asyncIterator]: () => ({ next: () => new Promise((n, c) => {
    o.next((u, h, g) => u ? c(u) : h == null ? o.end((y) => {
      if (y)
        return c(y);
      n({ done: !0, value: void 0 });
    }) : void n({ done: !1, value: { key: new Key(h, !1), value: g } }));
  }), return: () => new Promise((n, c) => {
    o.end((u) => {
      if (u)
        return c(u);
      n({ done: !0, value: void 0 });
    });
  }) }) };
}
const sortAll = (o, n) => async function* () {
  yield* (await itAll(o)).sort(n);
}();
class BaseBlockstore {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(n, c, u) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(n, c) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(n, c) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(n, c) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(n, c = {}) {
    for await (const { key: u, value: h } of n)
      await this.put(u, h, c), yield { key: u, value: h };
  }
  async *getMany(n, c = {}) {
    for await (const u of n)
      yield this.get(u, c);
  }
  async *deleteMany(n, c = {}) {
    for await (const u of n)
      await this.delete(u, c), yield u;
  }
  batch() {
    let n = [], c = [];
    return { put(u, h) {
      n.push({ key: u, value: h });
    }, delete(u) {
      c.push(u);
    }, commit: async (u) => {
      await itDrain(this.putMany(n, u)), n = [], await itDrain(this.deleteMany(c, u)), c = [];
    } };
  }
  async *_all(n, c) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(n, c) {
    throw new Error("._allKeys is not implemented");
  }
  query(n, c) {
    let u = this._all(n, c);
    if (n.prefix != null && (u = itFilter(u, (h) => h.key.toString().startsWith(n.prefix || ""))), Array.isArray(n.filters) && (u = n.filters.reduce((h, g) => itFilter(h, g), u)), Array.isArray(n.orders) && (u = n.orders.reduce((h, g) => sortAll(h, g), u)), n.offset != null) {
      let h = 0;
      u = itFilter(u, () => h++ >= (n.offset || 0));
    }
    return n.limit != null && (u = itTake(u, n.limit)), u;
  }
  queryKeys(n, c) {
    let u = this._allKeys(n, c);
    if (n.prefix != null && (u = itFilter(u, (h) => h.toString().startsWith(n.prefix || ""))), Array.isArray(n.filters) && (u = n.filters.reduce((h, g) => itFilter(h, g), u)), Array.isArray(n.orders) && (u = n.orders.reduce((h, g) => sortAll(h, g), u)), n.offset != null) {
      let h = 0;
      u = itFilter(u, () => h++ >= n.offset);
    }
    return n.limit != null && (u = itTake(u, n.limit)), u;
  }
}
function cidToKey(o) {
  const n = CID$2.asCID(o);
  if (!n)
    throw errCode(new Error("Not a valid cid"), "ERR_INVALID_CID");
  return new Key("/" + base32$6.encode(n.multihash.bytes).slice(1).toUpperCase(), !1);
}
function keyToCid(o) {
  return CID$2.createV1(code$9, decode$r(base32$6.decode("b" + o.toString().slice(1).toLowerCase())));
}
function convertPrefix(o) {
  const n = o.substring(0, 1);
  if (n === "/")
    return convertPrefix(o.substring(1));
  let c, u;
  c = n.toLowerCase() === "b" ? (g) => base32$6.decode(g.toLowerCase()).subarray(2) : n.toLowerCase() === "c" ? (g) => base32pad$2.decode(g.toLowerCase()).subarray(2) : n === "z" ? (g) => base58btc$4.decode(g).subarray(2) : n === "Q" ? (g) => base58btc$4.decode("z" + g) : (g) => base32$6.decode("b" + g.toLowerCase()).subarray(2);
  for (let g = 1; g < o.length; g++)
    try {
      u = c(o.substring(0, g));
    } catch (y) {
      if (y.message !== "Unexpected end of data")
        throw y;
    }
  let h = "/C";
  return u && (h = `/${base32$6.encode(u).slice(1, -1).toUpperCase() || "C"}`), h;
}
function convertQuery(o) {
  return { ...o, prefix: o.prefix ? convertPrefix(o.prefix) : void 0, filters: o.filters ? o.filters.map((n) => (c) => n({ key: keyToCid(c.key), value: c.value })) : void 0, orders: o.orders ? o.orders.map((n) => (c, u) => n({ key: keyToCid(c.key), value: c.value }, { key: keyToCid(u.key), value: u.value })) : void 0 };
}
function convertKeyQuery(o) {
  return { ...o, prefix: o.prefix ? convertPrefix(o.prefix) : void 0, filters: o.filters ? o.filters.map((n) => (c) => n(keyToCid(c))) : void 0, orders: o.orders ? o.orders.map((n) => (c, u) => n(keyToCid(c), keyToCid(u))) : void 0 };
}
class BlockstoreDatastoreAdapter extends BaseBlockstore {
  constructor(n) {
    super(), this.child = n;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  async *query(n, c) {
    for await (const { key: u, value: h } of this.child.query(convertQuery(n), c))
      yield { key: keyToCid(u), value: h };
  }
  async *queryKeys(n, c) {
    for await (const u of this.child.queryKeys(convertKeyQuery(n), c))
      yield keyToCid(u);
  }
  async get(n, c) {
    return this.child.get(cidToKey(n), c);
  }
  async *getMany(n, c) {
    for await (const u of n)
      yield this.get(u, c);
  }
  async put(n, c, u) {
    await this.child.put(cidToKey(n), c, u);
  }
  async *putMany(n, c) {
    const u = pushable$1({ objectMode: !0 });
    (globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout)(async () => {
      try {
        const h = this.child;
        await itDrain(this.child.putMany(async function* () {
          for await (const g of n) {
            const y = cidToKey(g.key);
            await h.has(y, c) || (yield { key: y, value: g.value }), u.push(g);
          }
        }())), u.end();
      } catch (h) {
        u.end(h);
      }
    }), yield* u;
  }
  has(n, c) {
    return this.child.has(cidToKey(n), c);
  }
  delete(n, c) {
    return this.child.delete(cidToKey(n), c);
  }
  deleteMany(n, c) {
    const u = pushable$1({ objectMode: !0 });
    return itDrain(this.child.deleteMany(async function* () {
      for await (const h of n)
        yield cidToKey(h), u.push(h);
      u.end();
    }(), c)).catch((h) => {
      u.end(h);
    }), u;
  }
}
function createRepo(o, n, c) {
  const u = c.path || "ipfs";
  return createRepo$1(u, (h) => n.getCodec(h), { root: new LevelDatastore(u, { prefix: "", version: 2 }), blocks: new BlockstoreDatastoreAdapter(new LevelDatastore(`${u}/blocks`, { prefix: "", version: 2 })), datastore: new LevelDatastore(`${u}/datastore`, { prefix: "", version: 2 }), keys: new LevelDatastore(`${u}/keys`, { prefix: "", version: 2 }), pins: new LevelDatastore(`${u}/pins`, { prefix: "", version: 2 }) }, { autoMigrate: c.autoMigrate, onMigrationProgress: c.onMigrationProgress || o, repoLock: MemoryLock });
}
var Tc = Object.create, nr = Object.defineProperty, Ic = Object.getOwnPropertyDescriptor, Sc = Object.getOwnPropertyNames, Uc = Object.getPrototypeOf, Fc = Object.prototype.hasOwnProperty, F = (o, n) => () => (o && (n = o(o = 0)), n), S = (o, n) => () => (n || o((n = { exports: {} }).exports, n), n.exports), M = (o, n) => {
  for (var c in n)
    nr(o, c, { get: n[c], enumerable: !0 });
}, No = (o, n, c, u) => {
  if (n && typeof n == "object" || typeof n == "function")
    for (let h of Sc(n))
      !Fc.call(o, h) && h !== c && nr(o, h, { get: () => n[h], enumerable: !(u = Ic(n, h)) || u.enumerable });
  return o;
}, J = (o, n, c) => (c = o != null ? Tc(Uc(o)) : {}, No(!n && o && o.__esModule ? c : nr(c, "default", { value: o, enumerable: !0 }), o)), R = (o) => No(nr({}, "__esModule", { value: !0 }), o), Po = S((o) => {
  a(), o.byteLength = function(L) {
    var q = $(L), N = q[0], X = q[1];
    return 3 * (N + X) / 4 - X;
  }, o.toByteArray = function(L) {
    var q, N, X = $(L), rt = X[0], nt = X[1], st = new g(function(Ct, et, at) {
      return 3 * (et + at) / 4 - at;
    }(0, rt, nt)), ot = 0, St = nt > 0 ? rt - 4 : rt;
    for (N = 0; N < St; N += 4)
      q = h[L.charCodeAt(N)] << 18 | h[L.charCodeAt(N + 1)] << 12 | h[L.charCodeAt(N + 2)] << 6 | h[L.charCodeAt(N + 3)], st[ot++] = q >> 16 & 255, st[ot++] = q >> 8 & 255, st[ot++] = 255 & q;
    return nt === 2 && (q = h[L.charCodeAt(N)] << 2 | h[L.charCodeAt(N + 1)] >> 4, st[ot++] = 255 & q), nt === 1 && (q = h[L.charCodeAt(N)] << 10 | h[L.charCodeAt(N + 1)] << 4 | h[L.charCodeAt(N + 2)] >> 2, st[ot++] = q >> 8 & 255, st[ot++] = 255 & q), st;
  }, o.fromByteArray = function(L) {
    for (var q, N = L.length, X = N % 3, rt = [], nt = 16383, st = 0, ot = N - X; st < ot; st += nt)
      rt.push(P(L, st, st + nt > ot ? ot : st + nt));
    return X === 1 ? (q = L[N - 1], rt.push(u[q >> 2] + u[q << 4 & 63] + "==")) : X === 2 && (q = (L[N - 2] << 8) + L[N - 1], rt.push(u[q >> 10] + u[q >> 4 & 63] + u[q << 2 & 63] + "=")), rt.join("");
  };
  var n, c, u = [], h = [], g = typeof Uint8Array < "u" ? Uint8Array : Array, y = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (n = 0, c = y.length; n < c; ++n)
    u[n] = y[n], h[y.charCodeAt(n)] = n;
  function $(L) {
    var q = L.length;
    if (q % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var N = L.indexOf("=");
    return N === -1 && (N = q), [N, N === q ? 0 : 4 - N % 4];
  }
  function I(L) {
    return u[L >> 18 & 63] + u[L >> 12 & 63] + u[L >> 6 & 63] + u[63 & L];
  }
  function P(L, q, N) {
    for (var X, rt = [], nt = q; nt < N; nt += 3)
      X = (L[nt] << 16 & 16711680) + (L[nt + 1] << 8 & 65280) + (255 & L[nt + 2]), rt.push(I(X));
    return rt.join("");
  }
  h["-".charCodeAt(0)] = 62, h["_".charCodeAt(0)] = 63;
}), Ro = S((o) => {
  a(), o.read = function(n, c, u, h, g) {
    var y, $, I = 8 * g - h - 1, P = (1 << I) - 1, L = P >> 1, q = -7, N = u ? g - 1 : 0, X = u ? -1 : 1, rt = n[c + N];
    for (N += X, y = rt & (1 << -q) - 1, rt >>= -q, q += I; q > 0; y = 256 * y + n[c + N], N += X, q -= 8)
      ;
    for ($ = y & (1 << -q) - 1, y >>= -q, q += h; q > 0; $ = 256 * $ + n[c + N], N += X, q -= 8)
      ;
    if (y === 0)
      y = 1 - L;
    else {
      if (y === P)
        return $ ? NaN : 1 / 0 * (rt ? -1 : 1);
      $ += Math.pow(2, h), y -= L;
    }
    return (rt ? -1 : 1) * $ * Math.pow(2, y - h);
  }, o.write = function(n, c, u, h, g, y) {
    var $, I, P, L = 8 * y - g - 1, q = (1 << L) - 1, N = q >> 1, X = g === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, rt = h ? 0 : y - 1, nt = h ? 1 : -1, st = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
    for (c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (I = isNaN(c) ? 1 : 0, $ = q) : ($ = Math.floor(Math.log(c) / Math.LN2), c * (P = Math.pow(2, -$)) < 1 && ($--, P *= 2), (c += $ + N >= 1 ? X / P : X * Math.pow(2, 1 - N)) * P >= 2 && ($++, P /= 2), $ + N >= q ? (I = 0, $ = q) : $ + N >= 1 ? (I = (c * P - 1) * Math.pow(2, g), $ += N) : (I = c * Math.pow(2, N - 1) * Math.pow(2, g), $ = 0)); g >= 8; n[u + rt] = 255 & I, rt += nt, I /= 256, g -= 8)
      ;
    for ($ = $ << g | I, L += g; L > 0; n[u + rt] = 255 & $, rt += nt, $ /= 256, L -= 8)
      ;
    n[u + rt - nt] |= 128 * st;
  };
}), ti = S((o) => {
  a();
  var n = Po(), c = Ro(), u = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  o.Buffer = y, o.SlowBuffer = function(B) {
    return +B != B && (B = 0), y.alloc(+B);
  }, o.INSPECT_MAX_BYTES = 50;
  var h = 2147483647;
  function g(B) {
    if (B > h)
      throw new RangeError('The value "' + B + '" is invalid for option "size"');
    let j = new Uint8Array(B);
    return Object.setPrototypeOf(j, y.prototype), j;
  }
  function y(B, j, Z) {
    if (typeof B == "number") {
      if (typeof j == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return P(B);
    }
    return $(B, j, Z);
  }
  function $(B, j, Z) {
    if (typeof B == "string")
      return function(At, Bt) {
        if ((typeof Bt != "string" || Bt === "") && (Bt = "utf8"), !y.isEncoding(Bt))
          throw new TypeError("Unknown encoding: " + Bt);
        let Ft = 0 | X(At, Bt), Kt = g(Ft), Zt = Kt.write(At, Bt);
        return Zt !== Ft && (Kt = Kt.slice(0, Zt)), Kt;
      }(B, j);
    if (ArrayBuffer.isView(B))
      return function(At) {
        if (he(At, Uint8Array)) {
          let Bt = new Uint8Array(At);
          return q(Bt.buffer, Bt.byteOffset, Bt.byteLength);
        }
        return L(At);
      }(B);
    if (B == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof B);
    if (he(B, ArrayBuffer) || B && he(B.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (he(B, SharedArrayBuffer) || B && he(B.buffer, SharedArrayBuffer)))
      return q(B, j, Z);
    if (typeof B == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let kt = B.valueOf && B.valueOf();
    if (kt != null && kt !== B)
      return y.from(kt, j, Z);
    let $t = function(At) {
      if (y.isBuffer(At)) {
        let Bt = 0 | N(At.length), Ft = g(Bt);
        return Ft.length === 0 || At.copy(Ft, 0, 0, Bt), Ft;
      }
      return At.length !== void 0 ? typeof At.length != "number" || je(At.length) ? g(0) : L(At) : At.type === "Buffer" && Array.isArray(At.data) ? L(At.data) : void 0;
    }(B);
    if ($t)
      return $t;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof B[Symbol.toPrimitive] == "function")
      return y.from(B[Symbol.toPrimitive]("string"), j, Z);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof B);
  }
  function I(B) {
    if (typeof B != "number")
      throw new TypeError('"size" argument must be of type number');
    if (B < 0)
      throw new RangeError('The value "' + B + '" is invalid for option "size"');
  }
  function P(B) {
    return I(B), g(B < 0 ? 0 : 0 | N(B));
  }
  function L(B) {
    let j = B.length < 0 ? 0 : 0 | N(B.length), Z = g(j);
    for (let kt = 0; kt < j; kt += 1)
      Z[kt] = 255 & B[kt];
    return Z;
  }
  function q(B, j, Z) {
    if (j < 0 || B.byteLength < j)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (B.byteLength < j + (Z || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let kt;
    return kt = j === void 0 && Z === void 0 ? new Uint8Array(B) : Z === void 0 ? new Uint8Array(B, j) : new Uint8Array(B, j, Z), Object.setPrototypeOf(kt, y.prototype), kt;
  }
  function N(B) {
    if (B >= h)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + h.toString(16) + " bytes");
    return 0 | B;
  }
  function X(B, j) {
    if (y.isBuffer(B))
      return B.length;
    if (ArrayBuffer.isView(B) || he(B, ArrayBuffer))
      return B.byteLength;
    if (typeof B != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof B);
    let Z = B.length, kt = arguments.length > 2 && arguments[2] === !0;
    if (!kt && Z === 0)
      return 0;
    let $t = !1;
    for (; ; )
      switch (j) {
        case "ascii":
        case "latin1":
        case "binary":
          return Z;
        case "utf8":
        case "utf-8":
          return ue(B).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * Z;
        case "hex":
          return Z >>> 1;
        case "base64":
          return xe(B).length;
        default:
          if ($t)
            return kt ? -1 : ue(B).length;
          j = ("" + j).toLowerCase(), $t = !0;
      }
  }
  function rt(B, j, Z) {
    let kt = !1;
    if ((j === void 0 || j < 0) && (j = 0), j > this.length || ((Z === void 0 || Z > this.length) && (Z = this.length), Z <= 0) || (Z >>>= 0) <= (j >>>= 0))
      return "";
    for (B || (B = "utf8"); ; )
      switch (B) {
        case "hex":
          return v(this, j, Z);
        case "utf8":
        case "utf-8":
          return m(this, j, Z);
        case "ascii":
          return E(this, j, Z);
        case "latin1":
        case "binary":
          return w(this, j, Z);
        case "base64":
          return Nt(this, j, Z);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return k(this, j, Z);
        default:
          if (kt)
            throw new TypeError("Unknown encoding: " + B);
          B = (B + "").toLowerCase(), kt = !0;
      }
  }
  function nt(B, j, Z) {
    let kt = B[j];
    B[j] = B[Z], B[Z] = kt;
  }
  function st(B, j, Z, kt, $t) {
    if (B.length === 0)
      return -1;
    if (typeof Z == "string" ? (kt = Z, Z = 0) : Z > 2147483647 ? Z = 2147483647 : Z < -2147483648 && (Z = -2147483648), je(Z = +Z) && (Z = $t ? 0 : B.length - 1), Z < 0 && (Z = B.length + Z), Z >= B.length) {
      if ($t)
        return -1;
      Z = B.length - 1;
    } else if (Z < 0) {
      if (!$t)
        return -1;
      Z = 0;
    }
    if (typeof j == "string" && (j = y.from(j, kt)), y.isBuffer(j))
      return j.length === 0 ? -1 : ot(B, j, Z, kt, $t);
    if (typeof j == "number")
      return j &= 255, typeof Uint8Array.prototype.indexOf == "function" ? $t ? Uint8Array.prototype.indexOf.call(B, j, Z) : Uint8Array.prototype.lastIndexOf.call(B, j, Z) : ot(B, [j], Z, kt, $t);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ot(B, j, Z, kt, $t) {
    let At, Bt = 1, Ft = B.length, Kt = j.length;
    if (kt !== void 0 && ((kt = String(kt).toLowerCase()) === "ucs2" || kt === "ucs-2" || kt === "utf16le" || kt === "utf-16le")) {
      if (B.length < 2 || j.length < 2)
        return -1;
      Bt = 2, Ft /= 2, Kt /= 2, Z /= 2;
    }
    function Zt(Gt, Qt) {
      return Bt === 1 ? Gt[Qt] : Gt.readUInt16BE(Qt * Bt);
    }
    if ($t) {
      let Gt = -1;
      for (At = Z; At < Ft; At++)
        if (Zt(B, At) === Zt(j, Gt === -1 ? 0 : At - Gt)) {
          if (Gt === -1 && (Gt = At), At - Gt + 1 === Kt)
            return Gt * Bt;
        } else
          Gt !== -1 && (At -= At - Gt), Gt = -1;
    } else
      for (Z + Kt > Ft && (Z = Ft - Kt), At = Z; At >= 0; At--) {
        let Gt = !0;
        for (let Qt = 0; Qt < Kt; Qt++)
          if (Zt(B, At + Qt) !== Zt(j, Qt)) {
            Gt = !1;
            break;
          }
        if (Gt)
          return At;
      }
    return -1;
  }
  function St(B, j, Z, kt) {
    Z = Number(Z) || 0;
    let $t = B.length - Z;
    kt ? (kt = Number(kt)) > $t && (kt = $t) : kt = $t;
    let At, Bt = j.length;
    for (kt > Bt / 2 && (kt = Bt / 2), At = 0; At < kt; ++At) {
      let Ft = parseInt(j.substr(2 * At, 2), 16);
      if (je(Ft))
        return At;
      B[Z + At] = Ft;
    }
    return At;
  }
  function Ct(B, j, Z, kt) {
    return se(ue(j, B.length - Z), B, Z, kt);
  }
  function et(B, j, Z, kt) {
    return se(function($t) {
      let At = [];
      for (let Bt = 0; Bt < $t.length; ++Bt)
        At.push(255 & $t.charCodeAt(Bt));
      return At;
    }(j), B, Z, kt);
  }
  function at(B, j, Z, kt) {
    return se(xe(j), B, Z, kt);
  }
  function _t(B, j, Z, kt) {
    return se(function($t, At) {
      let Bt, Ft, Kt, Zt = [];
      for (let Gt = 0; Gt < $t.length && !((At -= 2) < 0); ++Gt)
        Bt = $t.charCodeAt(Gt), Ft = Bt >> 8, Kt = Bt % 256, Zt.push(Kt), Zt.push(Ft);
      return Zt;
    }(j, B.length - Z), B, Z, kt);
  }
  function Nt(B, j, Z) {
    return j === 0 && Z === B.length ? n.fromByteArray(B) : n.fromByteArray(B.slice(j, Z));
  }
  function m(B, j, Z) {
    Z = Math.min(B.length, Z);
    let kt = [], $t = j;
    for (; $t < Z; ) {
      let At = B[$t], Bt = null, Ft = At > 239 ? 4 : At > 223 ? 3 : At > 191 ? 2 : 1;
      if ($t + Ft <= Z) {
        let Kt, Zt, Gt, Qt;
        switch (Ft) {
          case 1:
            At < 128 && (Bt = At);
            break;
          case 2:
            Kt = B[$t + 1], (192 & Kt) == 128 && (Qt = (31 & At) << 6 | 63 & Kt, Qt > 127 && (Bt = Qt));
            break;
          case 3:
            Kt = B[$t + 1], Zt = B[$t + 2], (192 & Kt) == 128 && (192 & Zt) == 128 && (Qt = (15 & At) << 12 | (63 & Kt) << 6 | 63 & Zt, Qt > 2047 && (Qt < 55296 || Qt > 57343) && (Bt = Qt));
            break;
          case 4:
            Kt = B[$t + 1], Zt = B[$t + 2], Gt = B[$t + 3], (192 & Kt) == 128 && (192 & Zt) == 128 && (192 & Gt) == 128 && (Qt = (15 & At) << 18 | (63 & Kt) << 12 | (63 & Zt) << 6 | 63 & Gt, Qt > 65535 && Qt < 1114112 && (Bt = Qt));
        }
      }
      Bt === null ? (Bt = 65533, Ft = 1) : Bt > 65535 && (Bt -= 65536, kt.push(Bt >>> 10 & 1023 | 55296), Bt = 56320 | 1023 & Bt), kt.push(Bt), $t += Ft;
    }
    return function(At) {
      let Bt = At.length;
      if (Bt <= A)
        return String.fromCharCode.apply(String, At);
      let Ft = "", Kt = 0;
      for (; Kt < Bt; )
        Ft += String.fromCharCode.apply(String, At.slice(Kt, Kt += A));
      return Ft;
    }(kt);
  }
  o.kMaxLength = h, y.TYPED_ARRAY_SUPPORT = function() {
    try {
      let B = new Uint8Array(1), j = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(j, Uint8Array.prototype), Object.setPrototypeOf(B, j), B.foo() === 42;
    } catch {
      return !1;
    }
  }(), !y.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(y.prototype, "parent", { enumerable: !0, get: function() {
    if (y.isBuffer(this))
      return this.buffer;
  } }), Object.defineProperty(y.prototype, "offset", { enumerable: !0, get: function() {
    if (y.isBuffer(this))
      return this.byteOffset;
  } }), y.poolSize = 8192, y.from = function(B, j, Z) {
    return $(B, j, Z);
  }, Object.setPrototypeOf(y.prototype, Uint8Array.prototype), Object.setPrototypeOf(y, Uint8Array), y.alloc = function(B, j, Z) {
    return function(kt, $t, At) {
      return I(kt), kt <= 0 ? g(kt) : $t !== void 0 ? typeof At == "string" ? g(kt).fill($t, At) : g(kt).fill($t) : g(kt);
    }(B, j, Z);
  }, y.allocUnsafe = function(B) {
    return P(B);
  }, y.allocUnsafeSlow = function(B) {
    return P(B);
  }, y.isBuffer = function(B) {
    return B != null && B._isBuffer === !0 && B !== y.prototype;
  }, y.compare = function(B, j) {
    if (he(B, Uint8Array) && (B = y.from(B, B.offset, B.byteLength)), he(j, Uint8Array) && (j = y.from(j, j.offset, j.byteLength)), !y.isBuffer(B) || !y.isBuffer(j))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (B === j)
      return 0;
    let Z = B.length, kt = j.length;
    for (let $t = 0, At = Math.min(Z, kt); $t < At; ++$t)
      if (B[$t] !== j[$t]) {
        Z = B[$t], kt = j[$t];
        break;
      }
    return Z < kt ? -1 : kt < Z ? 1 : 0;
  }, y.isEncoding = function(B) {
    switch (String(B).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, y.concat = function(B, j) {
    if (!Array.isArray(B))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (B.length === 0)
      return y.alloc(0);
    let Z;
    if (j === void 0)
      for (j = 0, Z = 0; Z < B.length; ++Z)
        j += B[Z].length;
    let kt = y.allocUnsafe(j), $t = 0;
    for (Z = 0; Z < B.length; ++Z) {
      let At = B[Z];
      if (he(At, Uint8Array))
        $t + At.length > kt.length ? (y.isBuffer(At) || (At = y.from(At)), At.copy(kt, $t)) : Uint8Array.prototype.set.call(kt, At, $t);
      else {
        if (!y.isBuffer(At))
          throw new TypeError('"list" argument must be an Array of Buffers');
        At.copy(kt, $t);
      }
      $t += At.length;
    }
    return kt;
  }, y.byteLength = X, y.prototype._isBuffer = !0, y.prototype.swap16 = function() {
    let B = this.length;
    if (B % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let j = 0; j < B; j += 2)
      nt(this, j, j + 1);
    return this;
  }, y.prototype.swap32 = function() {
    let B = this.length;
    if (B % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let j = 0; j < B; j += 4)
      nt(this, j, j + 3), nt(this, j + 1, j + 2);
    return this;
  }, y.prototype.swap64 = function() {
    let B = this.length;
    if (B % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let j = 0; j < B; j += 8)
      nt(this, j, j + 7), nt(this, j + 1, j + 6), nt(this, j + 2, j + 5), nt(this, j + 3, j + 4);
    return this;
  }, y.prototype.toString = function() {
    let B = this.length;
    return B === 0 ? "" : arguments.length === 0 ? m(this, 0, B) : rt.apply(this, arguments);
  }, y.prototype.toLocaleString = y.prototype.toString, y.prototype.equals = function(B) {
    if (!y.isBuffer(B))
      throw new TypeError("Argument must be a Buffer");
    return this === B || y.compare(this, B) === 0;
  }, y.prototype.inspect = function() {
    let B = "", j = o.INSPECT_MAX_BYTES;
    return B = this.toString("hex", 0, j).replace(/(.{2})/g, "$1 ").trim(), this.length > j && (B += " ... "), "<Buffer " + B + ">";
  }, u && (y.prototype[u] = y.prototype.inspect), y.prototype.compare = function(B, j, Z, kt, $t) {
    if (he(B, Uint8Array) && (B = y.from(B, B.offset, B.byteLength)), !y.isBuffer(B))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof B);
    if (j === void 0 && (j = 0), Z === void 0 && (Z = B ? B.length : 0), kt === void 0 && (kt = 0), $t === void 0 && ($t = this.length), j < 0 || Z > B.length || kt < 0 || $t > this.length)
      throw new RangeError("out of range index");
    if (kt >= $t && j >= Z)
      return 0;
    if (kt >= $t)
      return -1;
    if (j >= Z)
      return 1;
    if (this === B)
      return 0;
    let At = ($t >>>= 0) - (kt >>>= 0), Bt = (Z >>>= 0) - (j >>>= 0), Ft = Math.min(At, Bt), Kt = this.slice(kt, $t), Zt = B.slice(j, Z);
    for (let Gt = 0; Gt < Ft; ++Gt)
      if (Kt[Gt] !== Zt[Gt]) {
        At = Kt[Gt], Bt = Zt[Gt];
        break;
      }
    return At < Bt ? -1 : Bt < At ? 1 : 0;
  }, y.prototype.includes = function(B, j, Z) {
    return this.indexOf(B, j, Z) !== -1;
  }, y.prototype.indexOf = function(B, j, Z) {
    return st(this, B, j, Z, !0);
  }, y.prototype.lastIndexOf = function(B, j, Z) {
    return st(this, B, j, Z, !1);
  }, y.prototype.write = function(B, j, Z, kt) {
    if (j === void 0)
      kt = "utf8", Z = this.length, j = 0;
    else if (Z === void 0 && typeof j == "string")
      kt = j, Z = this.length, j = 0;
    else {
      if (!isFinite(j))
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      j >>>= 0, isFinite(Z) ? (Z >>>= 0, kt === void 0 && (kt = "utf8")) : (kt = Z, Z = void 0);
    }
    let $t = this.length - j;
    if ((Z === void 0 || Z > $t) && (Z = $t), B.length > 0 && (Z < 0 || j < 0) || j > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    kt || (kt = "utf8");
    let At = !1;
    for (; ; )
      switch (kt) {
        case "hex":
          return St(this, B, j, Z);
        case "utf8":
        case "utf-8":
          return Ct(this, B, j, Z);
        case "ascii":
        case "latin1":
        case "binary":
          return et(this, B, j, Z);
        case "base64":
          return at(this, B, j, Z);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _t(this, B, j, Z);
        default:
          if (At)
            throw new TypeError("Unknown encoding: " + kt);
          kt = ("" + kt).toLowerCase(), At = !0;
      }
  }, y.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  var A = 4096;
  function E(B, j, Z) {
    let kt = "";
    Z = Math.min(B.length, Z);
    for (let $t = j; $t < Z; ++$t)
      kt += String.fromCharCode(127 & B[$t]);
    return kt;
  }
  function w(B, j, Z) {
    let kt = "";
    Z = Math.min(B.length, Z);
    for (let $t = j; $t < Z; ++$t)
      kt += String.fromCharCode(B[$t]);
    return kt;
  }
  function v(B, j, Z) {
    let kt = B.length;
    (!j || j < 0) && (j = 0), (!Z || Z < 0 || Z > kt) && (Z = kt);
    let $t = "";
    for (let At = j; At < Z; ++At)
      $t += jr[B[At]];
    return $t;
  }
  function k(B, j, Z) {
    let kt = B.slice(j, Z), $t = "";
    for (let At = 0; At < kt.length - 1; At += 2)
      $t += String.fromCharCode(kt[At] + 256 * kt[At + 1]);
    return $t;
  }
  function O(B, j, Z) {
    if (B % 1 != 0 || B < 0)
      throw new RangeError("offset is not uint");
    if (B + j > Z)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function W(B, j, Z, kt, $t, At) {
    if (!y.isBuffer(B))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (j > $t || j < At)
      throw new RangeError('"value" argument is out of bounds');
    if (Z + kt > B.length)
      throw new RangeError("Index out of range");
  }
  function it(B, j, Z, kt, $t) {
    Xt(j, kt, $t, B, Z, 7);
    let At = Number(j & BigInt(4294967295));
    B[Z++] = At, At >>= 8, B[Z++] = At, At >>= 8, B[Z++] = At, At >>= 8, B[Z++] = At;
    let Bt = Number(j >> BigInt(32) & BigInt(4294967295));
    return B[Z++] = Bt, Bt >>= 8, B[Z++] = Bt, Bt >>= 8, B[Z++] = Bt, Bt >>= 8, B[Z++] = Bt, Z;
  }
  function vt(B, j, Z, kt, $t) {
    Xt(j, kt, $t, B, Z, 7);
    let At = Number(j & BigInt(4294967295));
    B[Z + 7] = At, At >>= 8, B[Z + 6] = At, At >>= 8, B[Z + 5] = At, At >>= 8, B[Z + 4] = At;
    let Bt = Number(j >> BigInt(32) & BigInt(4294967295));
    return B[Z + 3] = Bt, Bt >>= 8, B[Z + 2] = Bt, Bt >>= 8, B[Z + 1] = Bt, Bt >>= 8, B[Z] = Bt, Z + 8;
  }
  function xt(B, j, Z, kt, $t, At) {
    if (Z + kt > B.length)
      throw new RangeError("Index out of range");
    if (Z < 0)
      throw new RangeError("Index out of range");
  }
  function It(B, j, Z, kt, $t) {
    return j = +j, Z >>>= 0, $t || xt(B, 0, Z, 4), c.write(B, j, Z, kt, 23, 4), Z + 4;
  }
  function Wt(B, j, Z, kt, $t) {
    return j = +j, Z >>>= 0, $t || xt(B, 0, Z, 8), c.write(B, j, Z, kt, 52, 8), Z + 8;
  }
  y.prototype.slice = function(B, j) {
    let Z = this.length;
    (B = ~~B) < 0 ? (B += Z) < 0 && (B = 0) : B > Z && (B = Z), (j = j === void 0 ? Z : ~~j) < 0 ? (j += Z) < 0 && (j = 0) : j > Z && (j = Z), j < B && (j = B);
    let kt = this.subarray(B, j);
    return Object.setPrototypeOf(kt, y.prototype), kt;
  }, y.prototype.readUintLE = y.prototype.readUIntLE = function(B, j, Z) {
    B >>>= 0, j >>>= 0, Z || O(B, j, this.length);
    let kt = this[B], $t = 1, At = 0;
    for (; ++At < j && ($t *= 256); )
      kt += this[B + At] * $t;
    return kt;
  }, y.prototype.readUintBE = y.prototype.readUIntBE = function(B, j, Z) {
    B >>>= 0, j >>>= 0, Z || O(B, j, this.length);
    let kt = this[B + --j], $t = 1;
    for (; j > 0 && ($t *= 256); )
      kt += this[B + --j] * $t;
    return kt;
  }, y.prototype.readUint8 = y.prototype.readUInt8 = function(B, j) {
    return B >>>= 0, j || O(B, 1, this.length), this[B];
  }, y.prototype.readUint16LE = y.prototype.readUInt16LE = function(B, j) {
    return B >>>= 0, j || O(B, 2, this.length), this[B] | this[B + 1] << 8;
  }, y.prototype.readUint16BE = y.prototype.readUInt16BE = function(B, j) {
    return B >>>= 0, j || O(B, 2, this.length), this[B] << 8 | this[B + 1];
  }, y.prototype.readUint32LE = y.prototype.readUInt32LE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), (this[B] | this[B + 1] << 8 | this[B + 2] << 16) + 16777216 * this[B + 3];
  }, y.prototype.readUint32BE = y.prototype.readUInt32BE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), 16777216 * this[B] + (this[B + 1] << 16 | this[B + 2] << 8 | this[B + 3]);
  }, y.prototype.readBigUInt64LE = de(function(B) {
    ie(B >>>= 0, "offset");
    let j = this[B], Z = this[B + 7];
    (j === void 0 || Z === void 0) && oe(B, this.length - 8);
    let kt = j + 256 * this[++B] + 65536 * this[++B] + this[++B] * 2 ** 24, $t = this[++B] + 256 * this[++B] + 65536 * this[++B] + Z * 2 ** 24;
    return BigInt(kt) + (BigInt($t) << BigInt(32));
  }), y.prototype.readBigUInt64BE = de(function(B) {
    ie(B >>>= 0, "offset");
    let j = this[B], Z = this[B + 7];
    (j === void 0 || Z === void 0) && oe(B, this.length - 8);
    let kt = j * 2 ** 24 + 65536 * this[++B] + 256 * this[++B] + this[++B], $t = this[++B] * 2 ** 24 + 65536 * this[++B] + 256 * this[++B] + Z;
    return (BigInt(kt) << BigInt(32)) + BigInt($t);
  }), y.prototype.readIntLE = function(B, j, Z) {
    B >>>= 0, j >>>= 0, Z || O(B, j, this.length);
    let kt = this[B], $t = 1, At = 0;
    for (; ++At < j && ($t *= 256); )
      kt += this[B + At] * $t;
    return $t *= 128, kt >= $t && (kt -= Math.pow(2, 8 * j)), kt;
  }, y.prototype.readIntBE = function(B, j, Z) {
    B >>>= 0, j >>>= 0, Z || O(B, j, this.length);
    let kt = j, $t = 1, At = this[B + --kt];
    for (; kt > 0 && ($t *= 256); )
      At += this[B + --kt] * $t;
    return $t *= 128, At >= $t && (At -= Math.pow(2, 8 * j)), At;
  }, y.prototype.readInt8 = function(B, j) {
    return B >>>= 0, j || O(B, 1, this.length), 128 & this[B] ? -1 * (255 - this[B] + 1) : this[B];
  }, y.prototype.readInt16LE = function(B, j) {
    B >>>= 0, j || O(B, 2, this.length);
    let Z = this[B] | this[B + 1] << 8;
    return 32768 & Z ? 4294901760 | Z : Z;
  }, y.prototype.readInt16BE = function(B, j) {
    B >>>= 0, j || O(B, 2, this.length);
    let Z = this[B + 1] | this[B] << 8;
    return 32768 & Z ? 4294901760 | Z : Z;
  }, y.prototype.readInt32LE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), this[B] | this[B + 1] << 8 | this[B + 2] << 16 | this[B + 3] << 24;
  }, y.prototype.readInt32BE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), this[B] << 24 | this[B + 1] << 16 | this[B + 2] << 8 | this[B + 3];
  }, y.prototype.readBigInt64LE = de(function(B) {
    ie(B >>>= 0, "offset");
    let j = this[B], Z = this[B + 7];
    (j === void 0 || Z === void 0) && oe(B, this.length - 8);
    let kt = this[B + 4] + 256 * this[B + 5] + 65536 * this[B + 6] + (Z << 24);
    return (BigInt(kt) << BigInt(32)) + BigInt(j + 256 * this[++B] + 65536 * this[++B] + this[++B] * 2 ** 24);
  }), y.prototype.readBigInt64BE = de(function(B) {
    ie(B >>>= 0, "offset");
    let j = this[B], Z = this[B + 7];
    (j === void 0 || Z === void 0) && oe(B, this.length - 8);
    let kt = (j << 24) + 65536 * this[++B] + 256 * this[++B] + this[++B];
    return (BigInt(kt) << BigInt(32)) + BigInt(this[++B] * 2 ** 24 + 65536 * this[++B] + 256 * this[++B] + Z);
  }), y.prototype.readFloatLE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), c.read(this, B, !0, 23, 4);
  }, y.prototype.readFloatBE = function(B, j) {
    return B >>>= 0, j || O(B, 4, this.length), c.read(this, B, !1, 23, 4);
  }, y.prototype.readDoubleLE = function(B, j) {
    return B >>>= 0, j || O(B, 8, this.length), c.read(this, B, !0, 52, 8);
  }, y.prototype.readDoubleBE = function(B, j) {
    return B >>>= 0, j || O(B, 8, this.length), c.read(this, B, !1, 52, 8);
  }, y.prototype.writeUintLE = y.prototype.writeUIntLE = function(B, j, Z, kt) {
    B = +B, j >>>= 0, Z >>>= 0, kt || W(this, B, j, Z, Math.pow(2, 8 * Z) - 1, 0);
    let $t = 1, At = 0;
    for (this[j] = 255 & B; ++At < Z && ($t *= 256); )
      this[j + At] = B / $t & 255;
    return j + Z;
  }, y.prototype.writeUintBE = y.prototype.writeUIntBE = function(B, j, Z, kt) {
    B = +B, j >>>= 0, Z >>>= 0, kt || W(this, B, j, Z, Math.pow(2, 8 * Z) - 1, 0);
    let $t = Z - 1, At = 1;
    for (this[j + $t] = 255 & B; --$t >= 0 && (At *= 256); )
      this[j + $t] = B / At & 255;
    return j + Z;
  }, y.prototype.writeUint8 = y.prototype.writeUInt8 = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 1, 255, 0), this[j] = 255 & B, j + 1;
  }, y.prototype.writeUint16LE = y.prototype.writeUInt16LE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 2, 65535, 0), this[j] = 255 & B, this[j + 1] = B >>> 8, j + 2;
  }, y.prototype.writeUint16BE = y.prototype.writeUInt16BE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 2, 65535, 0), this[j] = B >>> 8, this[j + 1] = 255 & B, j + 2;
  }, y.prototype.writeUint32LE = y.prototype.writeUInt32LE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 4, 4294967295, 0), this[j + 3] = B >>> 24, this[j + 2] = B >>> 16, this[j + 1] = B >>> 8, this[j] = 255 & B, j + 4;
  }, y.prototype.writeUint32BE = y.prototype.writeUInt32BE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 4, 4294967295, 0), this[j] = B >>> 24, this[j + 1] = B >>> 16, this[j + 2] = B >>> 8, this[j + 3] = 255 & B, j + 4;
  }, y.prototype.writeBigUInt64LE = de(function(B, j = 0) {
    return it(this, B, j, BigInt(0), BigInt("0xffffffffffffffff"));
  }), y.prototype.writeBigUInt64BE = de(function(B, j = 0) {
    return vt(this, B, j, BigInt(0), BigInt("0xffffffffffffffff"));
  }), y.prototype.writeIntLE = function(B, j, Z, kt) {
    if (B = +B, j >>>= 0, !kt) {
      let Ft = Math.pow(2, 8 * Z - 1);
      W(this, B, j, Z, Ft - 1, -Ft);
    }
    let $t = 0, At = 1, Bt = 0;
    for (this[j] = 255 & B; ++$t < Z && (At *= 256); )
      B < 0 && Bt === 0 && this[j + $t - 1] !== 0 && (Bt = 1), this[j + $t] = (B / At >> 0) - Bt & 255;
    return j + Z;
  }, y.prototype.writeIntBE = function(B, j, Z, kt) {
    if (B = +B, j >>>= 0, !kt) {
      let Ft = Math.pow(2, 8 * Z - 1);
      W(this, B, j, Z, Ft - 1, -Ft);
    }
    let $t = Z - 1, At = 1, Bt = 0;
    for (this[j + $t] = 255 & B; --$t >= 0 && (At *= 256); )
      B < 0 && Bt === 0 && this[j + $t + 1] !== 0 && (Bt = 1), this[j + $t] = (B / At >> 0) - Bt & 255;
    return j + Z;
  }, y.prototype.writeInt8 = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 1, 127, -128), B < 0 && (B = 255 + B + 1), this[j] = 255 & B, j + 1;
  }, y.prototype.writeInt16LE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 2, 32767, -32768), this[j] = 255 & B, this[j + 1] = B >>> 8, j + 2;
  }, y.prototype.writeInt16BE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 2, 32767, -32768), this[j] = B >>> 8, this[j + 1] = 255 & B, j + 2;
  }, y.prototype.writeInt32LE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 4, 2147483647, -2147483648), this[j] = 255 & B, this[j + 1] = B >>> 8, this[j + 2] = B >>> 16, this[j + 3] = B >>> 24, j + 4;
  }, y.prototype.writeInt32BE = function(B, j, Z) {
    return B = +B, j >>>= 0, Z || W(this, B, j, 4, 2147483647, -2147483648), B < 0 && (B = 4294967295 + B + 1), this[j] = B >>> 24, this[j + 1] = B >>> 16, this[j + 2] = B >>> 8, this[j + 3] = 255 & B, j + 4;
  }, y.prototype.writeBigInt64LE = de(function(B, j = 0) {
    return it(this, B, j, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), y.prototype.writeBigInt64BE = de(function(B, j = 0) {
    return vt(this, B, j, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), y.prototype.writeFloatLE = function(B, j, Z) {
    return It(this, B, j, !0, Z);
  }, y.prototype.writeFloatBE = function(B, j, Z) {
    return It(this, B, j, !1, Z);
  }, y.prototype.writeDoubleLE = function(B, j, Z) {
    return Wt(this, B, j, !0, Z);
  }, y.prototype.writeDoubleBE = function(B, j, Z) {
    return Wt(this, B, j, !1, Z);
  }, y.prototype.copy = function(B, j, Z, kt) {
    if (!y.isBuffer(B))
      throw new TypeError("argument should be a Buffer");
    if (Z || (Z = 0), !kt && kt !== 0 && (kt = this.length), j >= B.length && (j = B.length), j || (j = 0), kt > 0 && kt < Z && (kt = Z), kt === Z || B.length === 0 || this.length === 0)
      return 0;
    if (j < 0)
      throw new RangeError("targetStart out of bounds");
    if (Z < 0 || Z >= this.length)
      throw new RangeError("Index out of range");
    if (kt < 0)
      throw new RangeError("sourceEnd out of bounds");
    kt > this.length && (kt = this.length), B.length - j < kt - Z && (kt = B.length - j + Z);
    let $t = kt - Z;
    return this === B && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(j, Z, kt) : Uint8Array.prototype.set.call(B, this.subarray(Z, kt), j), $t;
  }, y.prototype.fill = function(B, j, Z, kt) {
    if (typeof B == "string") {
      if (typeof j == "string" ? (kt = j, j = 0, Z = this.length) : typeof Z == "string" && (kt = Z, Z = this.length), kt !== void 0 && typeof kt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof kt == "string" && !y.isEncoding(kt))
        throw new TypeError("Unknown encoding: " + kt);
      if (B.length === 1) {
        let At = B.charCodeAt(0);
        (kt === "utf8" && At < 128 || kt === "latin1") && (B = At);
      }
    } else
      typeof B == "number" ? B &= 255 : typeof B == "boolean" && (B = Number(B));
    if (j < 0 || this.length < j || this.length < Z)
      throw new RangeError("Out of range index");
    if (Z <= j)
      return this;
    let $t;
    if (j >>>= 0, Z = Z === void 0 ? this.length : Z >>> 0, B || (B = 0), typeof B == "number")
      for ($t = j; $t < Z; ++$t)
        this[$t] = B;
    else {
      let At = y.isBuffer(B) ? B : y.from(B, kt), Bt = At.length;
      if (Bt === 0)
        throw new TypeError('The value "' + B + '" is invalid for argument "value"');
      for ($t = 0; $t < Z - j; ++$t)
        this[$t + j] = At[$t % Bt];
    }
    return this;
  };
  var Ut = {};
  function zt(B, j, Z) {
    Ut[B] = class extends Z {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: j.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${B}]`, this.stack, delete this.name;
      }
      get code() {
        return B;
      }
      set code(kt) {
        Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: kt, writable: !0 });
      }
      toString() {
        return `${this.name} [${B}]: ${this.message}`;
      }
    };
  }
  function Jt(B) {
    let j = "", Z = B.length, kt = B[0] === "-" ? 1 : 0;
    for (; Z >= kt + 4; Z -= 3)
      j = `_${B.slice(Z - 3, Z)}${j}`;
    return `${B.slice(0, Z)}${j}`;
  }
  function Xt(B, j, Z, kt, $t, At) {
    if (B > Z || B < j) {
      let Bt, Ft = typeof j == "bigint" ? "n" : "";
      throw Bt = At > 3 ? j === 0 || j === BigInt(0) ? `>= 0${Ft} and < 2${Ft} ** ${8 * (At + 1)}${Ft}` : `>= -(2${Ft} ** ${8 * (At + 1) - 1}${Ft}) and < 2 ** ${8 * (At + 1) - 1}${Ft}` : `>= ${j}${Ft} and <= ${Z}${Ft}`, new Ut.ERR_OUT_OF_RANGE("value", Bt, B);
    }
    (function(Bt, Ft, Kt) {
      ie(Ft, "offset"), (Bt[Ft] === void 0 || Bt[Ft + Kt] === void 0) && oe(Ft, Bt.length - (Kt + 1));
    })(kt, $t, At);
  }
  function ie(B, j) {
    if (typeof B != "number")
      throw new Ut.ERR_INVALID_ARG_TYPE(j, "number", B);
  }
  function oe(B, j, Z) {
    throw Math.floor(B) !== B ? (ie(B, Z), new Ut.ERR_OUT_OF_RANGE(Z || "offset", "an integer", B)) : j < 0 ? new Ut.ERR_BUFFER_OUT_OF_BOUNDS() : new Ut.ERR_OUT_OF_RANGE(Z || "offset", `>= ${Z ? 1 : 0} and <= ${j}`, B);
  }
  zt("ERR_BUFFER_OUT_OF_BOUNDS", function(B) {
    return B ? `${B} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), zt("ERR_INVALID_ARG_TYPE", function(B, j) {
    return `The "${B}" argument must be of type number. Received type ${typeof j}`;
  }, TypeError), zt("ERR_OUT_OF_RANGE", function(B, j, Z) {
    let kt = `The value of "${B}" is out of range.`, $t = Z;
    return Number.isInteger(Z) && Math.abs(Z) > 2 ** 32 ? $t = Jt(String(Z)) : typeof Z == "bigint" && ($t = String(Z), (Z > BigInt(2) ** BigInt(32) || Z < -(BigInt(2) ** BigInt(32))) && ($t = Jt($t)), $t += "n"), kt += ` It must be ${j}. Received ${$t}`, kt;
  }, RangeError);
  var De = /[^+/0-9A-Za-z-_]/g;
  function ue(B, j) {
    j = j || 1 / 0;
    let Z, kt = B.length, $t = null, At = [];
    for (let Bt = 0; Bt < kt; ++Bt) {
      if (Z = B.charCodeAt(Bt), Z > 55295 && Z < 57344) {
        if (!$t) {
          if (Z > 56319) {
            (j -= 3) > -1 && At.push(239, 191, 189);
            continue;
          }
          if (Bt + 1 === kt) {
            (j -= 3) > -1 && At.push(239, 191, 189);
            continue;
          }
          $t = Z;
          continue;
        }
        if (Z < 56320) {
          (j -= 3) > -1 && At.push(239, 191, 189), $t = Z;
          continue;
        }
        Z = 65536 + ($t - 55296 << 10 | Z - 56320);
      } else
        $t && (j -= 3) > -1 && At.push(239, 191, 189);
      if ($t = null, Z < 128) {
        if ((j -= 1) < 0)
          break;
        At.push(Z);
      } else if (Z < 2048) {
        if ((j -= 2) < 0)
          break;
        At.push(Z >> 6 | 192, 63 & Z | 128);
      } else if (Z < 65536) {
        if ((j -= 3) < 0)
          break;
        At.push(Z >> 12 | 224, Z >> 6 & 63 | 128, 63 & Z | 128);
      } else {
        if (!(Z < 1114112))
          throw new Error("Invalid code point");
        if ((j -= 4) < 0)
          break;
        At.push(Z >> 18 | 240, Z >> 12 & 63 | 128, Z >> 6 & 63 | 128, 63 & Z | 128);
      }
    }
    return At;
  }
  function xe(B) {
    return n.toByteArray(function(j) {
      if ((j = (j = j.split("=")[0]).trim().replace(De, "")).length < 2)
        return "";
      for (; j.length % 4 != 0; )
        j += "=";
      return j;
    }(B));
  }
  function se(B, j, Z, kt) {
    let $t;
    for ($t = 0; $t < kt && !($t + Z >= j.length || $t >= B.length); ++$t)
      j[$t + Z] = B[$t];
    return $t;
  }
  function he(B, j) {
    return B instanceof j || B != null && B.constructor != null && B.constructor.name != null && B.constructor.name === j.name;
  }
  function je(B) {
    return B != B;
  }
  var jr = function() {
    let B = "0123456789abcdef", j = new Array(256);
    for (let Z = 0; Z < 16; ++Z) {
      let kt = 16 * Z;
      for (let $t = 0; $t < 16; ++$t)
        j[kt + $t] = B[Z] + B[$t];
    }
    return j;
  }();
  function de(B) {
    return typeof BigInt > "u" ? We : B;
  }
  function We() {
    throw new Error("BigInt not supported");
  }
}), si = S((o, n) => {
  a();
  var c, u, h = n.exports = {};
  function g() {
    throw new Error("setTimeout has not been defined");
  }
  function y() {
    throw new Error("clearTimeout has not been defined");
  }
  function $(st) {
    if (c === setTimeout)
      return setTimeout(st, 0);
    if ((c === g || !c) && setTimeout)
      return c = setTimeout, setTimeout(st, 0);
    try {
      return c(st, 0);
    } catch {
      try {
        return c.call(null, st, 0);
      } catch {
        return c.call(this, st, 0);
      }
    }
  }
  (function() {
    try {
      c = typeof setTimeout == "function" ? setTimeout : g;
    } catch {
      c = g;
    }
    try {
      u = typeof clearTimeout == "function" ? clearTimeout : y;
    } catch {
      u = y;
    }
  })();
  var I, P = [], L = !1, q = -1;
  function N() {
    !L || !I || (L = !1, I.length ? P = I.concat(P) : q = -1, P.length && X());
  }
  function X() {
    if (!L) {
      var st = $(N);
      L = !0;
      for (var ot = P.length; ot; ) {
        for (I = P, P = []; ++q < ot; )
          I && I[q].run();
        q = -1, ot = P.length;
      }
      I = null, L = !1, function(St) {
        if (u === clearTimeout)
          return clearTimeout(St);
        if ((u === y || !u) && clearTimeout)
          return u = clearTimeout, clearTimeout(St);
        try {
          u(St);
        } catch {
          try {
            return u.call(null, St);
          } catch {
            return u.call(this, St);
          }
        }
      }(st);
    }
  }
  function rt(st, ot) {
    this.fun = st, this.array = ot;
  }
  function nt() {
  }
  h.nextTick = function(st) {
    var ot = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var St = 1; St < arguments.length; St++)
        ot[St - 1] = arguments[St];
    P.push(new rt(st, ot)), P.length === 1 && !L && $(X);
  }, rt.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, h.title = "browser", h.browser = !0, h.env = {}, h.argv = [], h.version = "", h.versions = {}, h.on = nt, h.addListener = nt, h.once = nt, h.off = nt, h.removeListener = nt, h.removeAllListeners = nt, h.emit = nt, h.prependListener = nt, h.prependOnceListener = nt, h.listeners = function(st) {
    return [];
  }, h.binding = function(st) {
    throw new Error("process.binding is not supported");
  }, h.cwd = function() {
    return "/";
  }, h.chdir = function(st) {
    throw new Error("process.chdir is not supported");
  }, h.umask = function() {
    return 0;
  };
}), p, d, a = F(() => {
  ti().Buffer, p = si(), d = globalThis, globalThis && globalThis.process && globalThis.process.env && (globalThis.process.env.LIBP2P_FORCE_PNET = !1);
});
function ci(o, n, c) {
  n = n || [];
  for (var u = c = c || 0; o >= mf; )
    n[c++] = 255 & o | ai, o /= 128;
  for (; o & pf; )
    n[c++] = 255 & o | ai, o >>>= 7;
  return n[c] = 0 | o, ci.bytes = c - u + 1, n;
}
function un(o, n) {
  var c, u = 0, h = 0, g = n = n || 0, y = o.length;
  do {
    if (g >= y)
      throw un.bytes = 0, new RangeError("Could not decode varint");
    c = o[g++], u += h < 28 ? (c & ui) << h : (c & ui) * Math.pow(2, h), h += 7;
  } while (c >= wf);
  return un.bytes = g - n, u;
}
var df, ai, hf, pf, mf, yf, wf, ui, gf, Df, bf, Ef, xf, Cf, Bf, Af, Tf, If, Sf, Uf, Lt, fi = F(() => {
  a(), df = ci, ai = 128, pf = ~(hf = 127), mf = Math.pow(2, 31), yf = un, wf = 128, ui = 127, gf = Math.pow(2, 7), Df = Math.pow(2, 14), bf = Math.pow(2, 21), Ef = Math.pow(2, 28), xf = Math.pow(2, 35), Cf = Math.pow(2, 42), Bf = Math.pow(2, 49), Af = Math.pow(2, 56), Tf = Math.pow(2, 63), Lt = Uf = Sf = { encode: df, decode: yf, encodingLength: If = function(o) {
    return o < gf ? 1 : o < Df ? 2 : o < bf ? 3 : o < Ef ? 4 : o < xf ? 5 : o < Cf ? 6 : o < Bf ? 7 : o < Af ? 8 : o < Tf ? 9 : 10;
  } };
}), Pt, ut, ct, cr = F(() => {
  a(), fi(), Pt = (o) => [Lt.decode(o), Lt.decode.bytes], ut = (o, n, c = 0) => (Lt.encode(o, n, c), n), ct = (o) => Lt.encodingLength(o);
}), li, Se, di, hi, Ne = F(() => {
  a(), li = (o, n) => {
    if (o === n)
      return !0;
    if (o.byteLength !== n.byteLength)
      return !1;
    for (let c = 0; c < o.byteLength; c++)
      if (o[c] !== n[c])
        return !1;
    return !0;
  }, Se = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o))
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    throw new Error("Unknown type, must be binary type");
  }, di = (o) => new TextEncoder().encode(o), hi = (o) => new TextDecoder().decode(o);
}), Ue = {};
M(Ue, { Digest: () => Xe, create: () => $e, decode: () => ft, equals: () => fn });
var $e, ft, fn, Xe, Le = F(() => {
  a(), Ne(), cr(), $e = (o, n) => {
    let c = n.byteLength, u = ct(o), h = u + ct(c), g = new Uint8Array(h + c);
    return ut(o, g, 0), ut(c, g, u), g.set(n, h), new Xe(o, c, n, g);
  }, ft = (o) => {
    let n = Se(o), [c, u] = Pt(n), [h, g] = Pt(n.subarray(u)), y = n.subarray(u + g);
    if (y.byteLength !== h)
      throw new Error("Incorrect length");
    return new Xe(c, h, y, n);
  }, fn = (o, n) => o === n || o.code === n.code && o.size === n.size && li(o.bytes, n.bytes), Xe = class {
    constructor(o, n, c, u) {
      this.code = o, this.size = n, this.digest = c, this.bytes = u;
    }
  };
});
function Ff(o, n) {
  if (o.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var c = new Uint8Array(256), u = 0; u < c.length; u++)
    c[u] = 255;
  for (var h = 0; h < o.length; h++) {
    var g = o.charAt(h), y = g.charCodeAt(0);
    if (c[y] !== 255)
      throw new TypeError(g + " is ambiguous");
    c[y] = h;
  }
  var $ = o.length, I = o.charAt(0), P = Math.log($) / Math.log(256), L = Math.log(256) / Math.log($);
  function q(N) {
    if (typeof N != "string")
      throw new TypeError("Expected String");
    if (N.length === 0)
      return new Uint8Array();
    var X = 0;
    if (N[X] !== " ") {
      for (var rt = 0, nt = 0; N[X] === I; )
        rt++, X++;
      for (var st = (N.length - X) * P + 1 >>> 0, ot = new Uint8Array(st); N[X]; ) {
        var St = c[N.charCodeAt(X)];
        if (St === 255)
          return;
        for (var Ct = 0, et = st - 1; (St !== 0 || Ct < nt) && et !== -1; et--, Ct++)
          St += $ * ot[et] >>> 0, ot[et] = St % 256 >>> 0, St = St / 256 >>> 0;
        if (St !== 0)
          throw new Error("Non-zero carry");
        nt = Ct, X++;
      }
      if (N[X] !== " ") {
        for (var at = st - nt; at !== st && ot[at] === 0; )
          at++;
        for (var _t = new Uint8Array(rt + (st - at)), Nt = rt; at !== st; )
          _t[Nt++] = ot[at++];
        return _t;
      }
    }
  }
  return { encode: function(N) {
    if (N instanceof Uint8Array || (ArrayBuffer.isView(N) ? N = new Uint8Array(N.buffer, N.byteOffset, N.byteLength) : Array.isArray(N) && (N = Uint8Array.from(N))), !(N instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (N.length === 0)
      return "";
    for (var X = 0, rt = 0, nt = 0, st = N.length; nt !== st && N[nt] === 0; )
      nt++, X++;
    for (var ot = (st - nt) * L + 1 >>> 0, St = new Uint8Array(ot); nt !== st; ) {
      for (var Ct = N[nt], et = 0, at = ot - 1; (Ct !== 0 || et < rt) && at !== -1; at--, et++)
        Ct += 256 * St[at] >>> 0, St[at] = Ct % $ >>> 0, Ct = Ct / $ >>> 0;
      if (Ct !== 0)
        throw new Error("Non-zero carry");
      rt = et, nt++;
    }
    for (var _t = ot - rt; _t !== ot && St[_t] === 0; )
      _t++;
    for (var Nt = I.repeat(X); _t < ot; ++_t)
      Nt += o.charAt(St[_t]);
    return Nt;
  }, decodeUnsafe: q, decode: function(N) {
    var X = q(N);
    if (X)
      return X;
    throw new Error(`Non-${n} character`);
  } };
}
var vf, kf, pi, mi = F(() => {
  a(), pi = kf = vf = Ff;
}), ln, dn, hn, yi, pn, lt$1, Pe, _f, Nf, _, pe = F(() => {
  a(), mi(), Ne(), ln = class {
    constructor(o, n, c) {
      this.name = o, this.prefix = n, this.baseEncode = c;
    }
    encode(o) {
      if (o instanceof Uint8Array)
        return `${this.prefix}${this.baseEncode(o)}`;
      throw Error("Unknown type, must be binary type");
    }
  }, dn = class {
    constructor(o, n, c) {
      if (this.name = o, this.prefix = n, n.codePointAt(0) === void 0)
        throw new Error("Invalid prefix character");
      this.prefixCodePoint = n.codePointAt(0), this.baseDecode = c;
    }
    decode(o) {
      if (typeof o == "string") {
        if (o.codePointAt(0) !== this.prefixCodePoint)
          throw Error(`Unable to decode multibase string ${JSON.stringify(o)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        return this.baseDecode(o.slice(this.prefix.length));
      }
      throw Error("Can only multibase decode strings");
    }
    or(o) {
      return yi(this, o);
    }
  }, hn = class {
    constructor(o) {
      this.decoders = o;
    }
    or(o) {
      return yi(this, o);
    }
    decode(o) {
      let n = o[0], c = this.decoders[n];
      if (c)
        return c.decode(o);
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(o)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }, yi = (o, n) => new hn({ ...o.decoders || { [o.prefix]: o }, ...n.decoders || { [n.prefix]: n } }), pn = class {
    constructor(o, n, c, u) {
      this.name = o, this.prefix = n, this.baseEncode = c, this.baseDecode = u, this.encoder = new ln(o, n, c), this.decoder = new dn(o, n, u);
    }
    encode(o) {
      return this.encoder.encode(o);
    }
    decode(o) {
      return this.decoder.decode(o);
    }
  }, lt$1 = ({ name: o, prefix: n, encode: c, decode: u }) => new pn(o, n, c, u), Pe = ({ prefix: o, name: n, alphabet: c }) => {
    let { encode: u, decode: h } = pi(c, n);
    return lt$1({ prefix: o, name: n, encode: u, decode: (g) => Se(h(g)) });
  }, _f = (o, n, c, u) => {
    let h = {};
    for (let L = 0; L < n.length; ++L)
      h[n[L]] = L;
    let g = o.length;
    for (; o[g - 1] === "="; )
      --g;
    let y = new Uint8Array(g * c / 8 | 0), $ = 0, I = 0, P = 0;
    for (let L = 0; L < g; ++L) {
      let q = h[o[L]];
      if (q === void 0)
        throw new SyntaxError(`Non-${u} character`);
      I = I << c | q, $ += c, $ >= 8 && ($ -= 8, y[P++] = 255 & I >> $);
    }
    if ($ >= c || 255 & I << 8 - $)
      throw new SyntaxError("Unexpected end of data");
    return y;
  }, Nf = (o, n, c) => {
    let u = n[n.length - 1] === "=", h = (1 << c) - 1, g = "", y = 0, $ = 0;
    for (let I = 0; I < o.length; ++I)
      for ($ = $ << 8 | o[I], y += 8; y > c; )
        y -= c, g += n[h & $ >> y];
    if (y && (g += n[h & $ << c - y]), u)
      for (; g.length * c & 7; )
        g += "=";
    return g;
  }, _ = ({ name: o, prefix: n, bitsPerChar: c, alphabet: u }) => lt$1({ prefix: n, name: o, encode: (h) => Nf(h, u, c), decode: (h) => _f(h, u, c, o) });
}), dt = {};
M(dt, { base58btc: () => Y, base58flickr: () => $f });
var Y, $f, Re = F(() => {
  a(), pe(), Y = Pe({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), $f = Pe({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
}), Rt = {};
M(Rt, { base32: () => Me, base32hex: () => Mf, base32hexpad: () => zf, base32hexpadupper: () => qf, base32hexupper: () => Of, base32pad: () => Pf, base32padupper: () => Rf, base32upper: () => Lf, base32z: () => Hf });
var Me, Lf, Pf, Rf, Mf, Of, zf, qf, Hf, ht = F(() => {
  a(), pe(), Me = _({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Lf = _({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Pf = _({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Rf = _({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Mf = _({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), Of = _({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), zf = _({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), qf = _({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Hf = _({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
}), dr = {};
M(dr, { CID: () => x });
var x, jf, Vf, Gf, Mt, Wf, wi, gi, fr, lr, Jf, Xf, Yf, Q = F(() => {
  a(), cr(), Le(), Re(), ht(), Ne(), x = class {
    constructor(o, n, c, u) {
      this.code = n, this.version = o, this.multihash = c, this.bytes = u, this.byteOffset = u.byteOffset, this.byteLength = u.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, { byteOffset: lr, byteLength: lr, code: fr, version: fr, multihash: fr, bytes: fr, _baseCache: lr, asCID: lr });
    }
    toV0() {
      if (this.version === 0)
        return this;
      {
        let { code: o, multihash: n } = this;
        if (o !== Mt)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (n.code !== Wf)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return x.createV0(n);
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          let { code: o, digest: n } = this.multihash, c = $e(o, n);
          return x.createV1(this.code, c);
        }
        case 1:
          return this;
        default:
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
    equals(o) {
      return o && this.code === o.code && this.version === o.version && fn(this.multihash, o.multihash);
    }
    toString(o) {
      let { bytes: n, version: c, _baseCache: u } = this;
      return c === 0 ? Vf(n, u, o || Y.encoder) : Gf(n, u, o || Me.encoder);
    }
    toJSON() {
      return { code: this.code, version: this.version, hash: this.multihash.bytes };
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    static isCID(o) {
      return Xf(/^0\.0/, Yf), !(!o || !o[gi] && o.asCID !== o);
    }
    get toBaseEncodedString() {
      throw new Error("Deprecated, use .toString()");
    }
    get codec() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
      throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
    }
    get multibaseName() {
      throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
      throw new Error('"prefix" property is deprecated');
    }
    static asCID(o) {
      if (o instanceof x)
        return o;
      if (o != null && o.asCID === o) {
        let { version: n, code: c, multihash: u, bytes: h } = o;
        return new x(n, c, u, h || wi(n, c, u.bytes));
      }
      if (o != null && o[gi] === !0) {
        let { version: n, multihash: c, code: u } = o, h = ft(c);
        return x.create(n, u, h);
      }
      return null;
    }
    static create(o, n, c) {
      if (typeof n != "number")
        throw new Error("String codecs are no longer supported");
      switch (o) {
        case 0:
          if (n !== Mt)
            throw new Error(`Version 0 CID must use dag-pb (code: ${Mt}) block encoding`);
          return new x(o, n, c, c.bytes);
        case 1: {
          let u = wi(o, n, c.bytes);
          return new x(o, n, c, u);
        }
        default:
          throw new Error("Invalid version");
      }
    }
    static createV0(o) {
      return x.create(0, Mt, o);
    }
    static createV1(o, n) {
      return x.create(1, o, n);
    }
    static decode(o) {
      let [n, c] = x.decodeFirst(o);
      if (c.length)
        throw new Error("Incorrect length");
      return n;
    }
    static decodeFirst(o) {
      let n = x.inspectBytes(o), c = n.size - n.multihashSize, u = Se(o.subarray(c, c + n.multihashSize));
      if (u.byteLength !== n.multihashSize)
        throw new Error("Incorrect length");
      let h = u.subarray(n.multihashSize - n.digestSize), g = new Xe(n.multihashCode, n.digestSize, h, u);
      return [n.version === 0 ? x.createV0(g) : x.createV1(n.codec, g), o.subarray(n.size)];
    }
    static inspectBytes(o) {
      let n = 0, c = () => {
        let [P, L] = Pt(o.subarray(n));
        return n += L, P;
      }, u = c(), h = Mt;
      if (u === 18 ? (u = 0, n = 0) : u === 1 && (h = c()), u !== 0 && u !== 1)
        throw new RangeError(`Invalid CID version ${u}`);
      let g = n, y = c(), $ = c(), I = n + $;
      return { version: u, codec: h, multihashCode: y, digestSize: $, multihashSize: I - g, size: I };
    }
    static parse(o, n) {
      let [c, u] = jf(o, n), h = x.decode(u);
      return h._baseCache.set(c, o), h;
    }
  }, jf = (o, n) => {
    switch (o[0]) {
      case "Q": {
        let c = n || Y;
        return [Y.prefix, c.decode(`${Y.prefix}${o}`)];
      }
      case Y.prefix: {
        let c = n || Y;
        return [Y.prefix, c.decode(o)];
      }
      case Me.prefix: {
        let c = n || Me;
        return [Me.prefix, c.decode(o)];
      }
      default:
        if (n == null)
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        return [o[0], n.decode(o)];
    }
  }, Vf = (o, n, c) => {
    let { prefix: u } = c;
    if (u !== Y.prefix)
      throw Error(`Cannot string encode V0 in ${c.name} encoding`);
    let h = n.get(u);
    if (h == null) {
      let g = c.encode(o).slice(1);
      return n.set(u, g), g;
    }
    return h;
  }, Gf = (o, n, c) => {
    let { prefix: u } = c, h = n.get(u);
    if (h == null) {
      let g = c.encode(o);
      return n.set(u, g), g;
    }
    return h;
  }, Mt = 112, Wf = 18, wi = (o, n, c) => {
    let u = ct(o), h = u + ct(n), g = new Uint8Array(h + c.byteLength);
    return ut(o, g, 0), ut(n, g, u), g.set(c, h), g;
  }, gi = Symbol.for("@ipld/js-cid/CID"), fr = { writable: !1, configurable: !1, enumerable: !0 }, lr = { writable: !1, enumerable: !1, configurable: !1 }, Jf = "0.0.0-dev", Xf = (o, n) => {
    if (!o.test(Jf))
      throw new Error(n);
    console.warn(n);
  }, Yf = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
}), yn, mn, wn = F(() => {
  a(), Le(), yn = ({ name: o, code: n, encode: c }) => new mn(o, n, c), mn = class {
    constructor(o, n, c) {
      this.name = o, this.code = n, this.encode = c;
    }
    digest(o) {
      if (o instanceof Uint8Array) {
        let n = this.encode(o);
        return n instanceof Uint8Array ? $e(this.code, n) : n.then((c) => $e(this.code, c));
      }
      throw Error("Unknown type, must be binary type");
    }
  };
}), gn = F(() => {
  a(), Q(), cr(), Ne(), wn(), Le();
}), Ci = S((o, n) => {
  a(), n.exports = function u(h, g, y) {
    if (Number.MAX_SAFE_INTEGER && h > Number.MAX_SAFE_INTEGER)
      throw u.bytes = 0, new RangeError("Could not encode varint");
    g = g || [];
    for (var $ = y = y || 0; h >= c; )
      g[y++] = 255 & h | 128, h /= 128;
    for (; -128 & h; )
      g[y++] = 255 & h | 128, h >>>= 7;
    return g[y] = 0 | h, u.bytes = y - $ + 1, g;
  };
  var c = Math.pow(2, 31);
}), Ti = S((o, n) => {
  a(), n.exports = function c(u, h) {
    var g, y = 0, $ = 0, I = h = h || 0, P = u.length;
    do {
      if (I >= P || $ > 49)
        throw c.bytes = 0, new RangeError("Could not decode varint");
      g = u[I++], y += $ < 28 ? (127 & g) << $ : (127 & g) * Math.pow(2, $), $ += 7;
    } while (g >= 128);
    return c.bytes = I - h, y;
  };
}), Si = S((o, n) => {
  a();
  var c = Math.pow(2, 7), u = Math.pow(2, 14), h = Math.pow(2, 21), g = Math.pow(2, 28), y = Math.pow(2, 35), $ = Math.pow(2, 42), I = Math.pow(2, 49), P = Math.pow(2, 56), L = Math.pow(2, 63);
  n.exports = function(q) {
    return q < c ? 1 : q < u ? 2 : q < h ? 3 : q < g ? 4 : q < y ? 5 : q < $ ? 6 : q < I ? 7 : q < P ? 8 : q < L ? 9 : 10;
  };
}), pt = S((o, n) => {
  a(), n.exports = { encode: Ci(), decode: Ti(), encodingLength: Si() };
}), Ws = S((o, n) => {
  a(), n.exports = function() {
    return Date.now();
  };
}), Xs = S((o, n) => {
  a();
  var c = Ws(), u = class {
    constructor(h, g, y) {
      let $ = this;
      this._started = c(), this._rescheduled = 0, this._scheduled = g, this._args = y, this._triggered = !1, this._timerWrapper = () => {
        $._rescheduled > 0 ? ($._scheduled = $._rescheduled - (c() - $._started), $._schedule($._scheduled)) : ($._triggered = !0, h.apply(null, $._args));
      }, this._timer = setTimeout(this._timerWrapper, g);
    }
    reschedule(h) {
      h || (h = this._scheduled);
      let g = c();
      g + h - (this._started + this._scheduled) < 0 ? (clearTimeout(this._timer), this._schedule(h)) : this._triggered ? this._schedule(h) : (this._started = g, this._rescheduled = h);
    }
    _schedule(h) {
      this._triggered = !1, this._started = c(), this._rescheduled = 0, this._scheduled = h, this._timer = setTimeout(this._timerWrapper, h);
    }
    clear() {
      clearTimeout(this._timer);
    }
  };
  n.exports = function() {
    if (typeof arguments[0] != "function")
      throw new Error("callback needed");
    if (typeof arguments[1] != "number")
      throw new Error("timeout needed");
    let h;
    if (arguments.length > 0) {
      h = new Array(arguments.length - 2);
      for (var g = 0; g < h.length; g++)
        h[g] = arguments[g + 2];
    }
    return new u(arguments[0], arguments[1], h);
  };
}), Zs = S((o, n) => {
  a();
  var { AbortController: c } = globalThis, u = Xs(), h = class extends c {
    constructor(g) {
      super(), this._ms = g, this._timer = u(() => this.abort(), g), Object.setPrototypeOf(this, h.prototype);
    }
    abort() {
      return this._timer.clear(), super.abort();
    }
    clear() {
      this._timer.clear();
    }
    reset() {
      this._timer.clear(), this._timer = u(() => this.abort(), this._ms);
    }
  };
  n.exports = { TimeoutController: h };
}), ea = S((o, n) => {
  function c(u) {
    let h = new globalThis.AbortController();
    function g() {
      h.abort();
      for (let y of u)
        !y || !y.removeEventListener || y.removeEventListener("abort", g);
    }
    for (let y of u)
      if (y && y.addEventListener) {
        if (y.aborted) {
          g();
          break;
        }
        y.addEventListener("abort", g);
      }
    return h.signal;
  }
  a(), n.exports = c, n.exports.anySignal = c;
}), sa = S((o, n) => {
  a();
  var c = 1e3, u = 6e4, h = 60 * u, g = 24 * h;
  function y($, I, P, L) {
    var q = I >= 1.5 * P;
    return Math.round($ / P) + " " + L + (q ? "s" : "");
  }
  n.exports = function($, I) {
    I = I || {};
    var P = typeof $;
    if (P === "string" && $.length > 0)
      return function(L) {
        if (!((L = String(L)).length > 100)) {
          var q = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(L);
          if (q) {
            var N = parseFloat(q[1]);
            switch ((q[2] || "ms").toLowerCase()) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return 315576e5 * N;
              case "weeks":
              case "week":
              case "w":
                return 6048e5 * N;
              case "days":
              case "day":
              case "d":
                return N * g;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return N * h;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return N * u;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return N * c;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return N;
              default:
                return;
            }
          }
        }
      }($);
    if (P === "number" && isFinite($))
      return I.long ? function(L) {
        var q = Math.abs(L);
        return q >= g ? y(L, q, g, "day") : q >= h ? y(L, q, h, "hour") : q >= u ? y(L, q, u, "minute") : q >= c ? y(L, q, c, "second") : L + " ms";
      }($) : function(L) {
        var q = Math.abs(L);
        return q >= g ? Math.round(L / g) + "d" : q >= h ? Math.round(L / h) + "h" : q >= u ? Math.round(L / u) + "m" : q >= c ? Math.round(L / c) + "s" : L + "ms";
      }($);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify($));
  };
}), ua = S((o, n) => {
  a(), n.exports = function(c) {
    function u(y) {
      let $, I, P, L = null;
      function q(...N) {
        if (!q.enabled)
          return;
        let X = q, rt = Number(new Date()), nt = rt - ($ || rt);
        X.diff = nt, X.prev = $, X.curr = rt, $ = rt, N[0] = u.coerce(N[0]), typeof N[0] != "string" && N.unshift("%O");
        let st = 0;
        N[0] = N[0].replace(/%([a-zA-Z%])/g, (ot, St) => {
          if (ot === "%%")
            return "%";
          st++;
          let Ct = u.formatters[St];
          if (typeof Ct == "function") {
            let et = N[st];
            ot = Ct.call(X, et), N.splice(st, 1), st--;
          }
          return ot;
        }), u.formatArgs.call(X, N), (X.log || u.log).apply(X, N);
      }
      return q.namespace = y, q.useColors = u.useColors(), q.color = u.selectColor(y), q.extend = h, q.destroy = u.destroy, Object.defineProperty(q, "enabled", { enumerable: !0, configurable: !1, get: () => L !== null ? L : (I !== u.namespaces && (I = u.namespaces, P = u.enabled(y)), P), set: (N) => {
        L = N;
      } }), typeof u.init == "function" && u.init(q), q;
    }
    function h(y, $) {
      let I = u(this.namespace + (typeof $ > "u" ? ":" : $) + y);
      return I.log = this.log, I;
    }
    function g(y) {
      return y.toString().substring(2, y.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    return u.debug = u, u.default = u, u.coerce = function(y) {
      return y instanceof Error ? y.stack || y.message : y;
    }, u.disable = function() {
      let y = [...u.names.map(g), ...u.skips.map(g).map(($) => "-" + $)].join(",");
      return u.enable(""), y;
    }, u.enable = function(y) {
      u.save(y), u.namespaces = y, u.names = [], u.skips = [];
      let $, I = (typeof y == "string" ? y : "").split(/[\s,]+/), P = I.length;
      for ($ = 0; $ < P; $++)
        !I[$] || ((y = I[$].replace(/\*/g, ".*?"))[0] === "-" ? u.skips.push(new RegExp("^" + y.slice(1) + "$")) : u.names.push(new RegExp("^" + y + "$")));
    }, u.enabled = function(y) {
      if (y[y.length - 1] === "*")
        return !0;
      let $, I;
      for ($ = 0, I = u.skips.length; $ < I; $++)
        if (u.skips[$].test(y))
          return !1;
      for ($ = 0, I = u.names.length; $ < I; $++)
        if (u.names[$].test(y))
          return !0;
      return !1;
    }, u.humanize = sa(), u.destroy = function() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }, Object.keys(c).forEach((y) => {
      u[y] = c[y];
    }), u.names = [], u.skips = [], u.formatters = {}, u.selectColor = function(y) {
      let $ = 0;
      for (let I = 0; I < y.length; I++)
        $ = ($ << 5) - $ + y.charCodeAt(I), $ |= 0;
      return u.colors[Math.abs($) % u.colors.length];
    }, u.enable(u.load()), u;
  };
}), ca = S((o, n) => {
  a(), o.formatArgs = function(u) {
    if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff), !this.useColors)
      return;
    let h = "color: " + this.color;
    u.splice(1, 0, h, "color: inherit");
    let g = 0, y = 0;
    u[0].replace(/%[a-zA-Z%]/g, ($) => {
      $ !== "%%" && (g++, $ === "%c" && (y = g));
    }), u.splice(y, 0, h);
  }, o.save = function(u) {
    try {
      u ? o.storage.setItem("debug", u) : o.storage.removeItem("debug");
    } catch {
    }
  }, o.load = function() {
    let u;
    try {
      u = o.storage.getItem("debug");
    } catch {
    }
    return !u && typeof p < "u" && "env" in p && (u = p.env.DEBUG), u;
  }, o.useColors = function() {
    return !(!(typeof window < "u" && window.process) || window.process.type !== "renderer" && !window.process.__nwjs) || !(typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && (typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }, o.storage = function() {
    try {
      return localStorage;
    } catch {
    }
  }(), o.destroy = (() => {
    let u = !1;
    return () => {
      u || (u = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), o.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], o.log = console.debug || console.log || (() => {
  }), n.exports = ua()(o);
  var { formatters: c } = n.exports;
  c.j = function(u) {
    try {
      return JSON.stringify(u);
    } catch (h) {
      return "[UnexpectedJSONParseError]: " + h.message;
    }
  };
}), On = {};
M(On, { base64: () => Mn, base64pad: () => md, base64url: () => yd, base64urlpad: () => wd });
var Mn, md, yd, wd, zn = F(() => {
  a(), pe(), Mn = _({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), md = _({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), yd = _({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), wd = _({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
}), fa, qn = F(() => {
  a(), Ne(), fa = 85;
}), da, Hn = F(() => {
  a(), new TextEncoder(), new TextDecoder(), da = 512;
}), wa = S((o, n) => {
  a(), n.exports = async (c) => {
    for await (let u of c)
      return u;
  };
}), Da = S((o, n) => {
  a(), n.exports = async (c) => {
    let u;
    for await (let h of c)
      u = h;
    return u;
  };
}), xa = S((o, n) => {
  a();
  var c = "[a-fA-F\\d:]", u = (q) => q && q.includeBoundaries ? `(?:(?<=\\s|^)(?=${c})|(?<=${c})(?=\\s|$))` : "", h = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", g = "[a-fA-F\\d]{1,4}", y = `
(?:
(?:${g}:){7}(?:${g}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${g}:){6}(?:${h}|:${g}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${g}:){5}(?::${h}|(?::${g}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${g}:){4}(?:(?::${g}){0,1}:${h}|(?::${g}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${g}:){3}(?:(?::${g}){0,2}:${h}|(?::${g}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${g}:){2}(?:(?::${g}){0,3}:${h}|(?::${g}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${g}:){1}(?:(?::${g}){0,4}:${h}|(?::${g}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${g}){0,5}:${h}|(?::${g}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), $ = new RegExp(`(?:^${h}$)|(?:^${y}$)`), I = new RegExp(`^${h}$`), P = new RegExp(`^${y}$`), L = (q) => q && q.exact ? $ : new RegExp(`(?:${u(q)}${h}${u(q)})|(?:${u(q)}${y}${u(q)})`, "g");
  L.v4 = (q) => q && q.exact ? I : new RegExp(`${u(q)}${h}${u(q)}`, "g"), L.v6 = (q) => q && q.exact ? P : new RegExp(`${u(q)}${y}${u(q)}`, "g"), n.exports = L;
}), Ba = S((o, n) => {
  a();
  var c = xa(), u = (h) => c({ exact: !0 }).test(h);
  u.v4 = (h) => c.v4({ exact: !0 }).test(h), u.v6 = (h) => c.v6({ exact: !0 }).test(h), u.version = (h) => u(h) ? u.v4(h) ? 4 : 6 : void 0, n.exports = u;
}), Wn = {};
M(Wn, { identity: () => Ad });
var Ad, Aa = F(() => {
  a(), pe(), Ne(), Ad = lt$1({ prefix: "\0", name: "identity", encode: (o) => hi(o), decode: (o) => di(o) });
}), Jn = {};
M(Jn, { base2: () => Td });
var Td, Ta = F(() => {
  a(), pe(), Td = _({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
}), Xn = {};
M(Xn, { base8: () => Id });
var Id, Ia = F(() => {
  a(), pe(), Id = _({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
}), Yn = {};
M(Yn, { base10: () => Sd });
var Sd, Sa = F(() => {
  a(), pe(), Sd = Pe({ prefix: "9", name: "base10", alphabet: "0123456789" });
}), Qn = {};
M(Qn, { base16: () => Ud, base16upper: () => Fd });
var Ud, Fd, Ua = F(() => {
  a(), pe(), Ud = _({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Fd = _({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
}), Zn = {};
M(Zn, { base36: () => vd, base36upper: () => kd });
var vd, kd, Fa = F(() => {
  a(), pe(), vd = Pe({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), kd = Pe({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
}), Kn = {};
function $d(o) {
  return o.reduce((n, c) => n + _d[c], "");
}
function Ld(o) {
  let n = [];
  for (let c of o) {
    let u = Nd[c.codePointAt(0)];
    if (u === void 0)
      throw new Error(`Non-base256emoji character: ${c}`);
    n.push(u);
  }
  return new Uint8Array(n);
}
M(Kn, { base256emoji: () => Pd });
var va, _d, Nd, Pd, ka = F(() => {
  a(), pe(), va = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"), _d = va.reduce((o, n, c) => (o[c] = n, o), []), Nd = va.reduce((o, n, c) => (o[n.codePointAt(0)] = c, o), []), Pd = lt$1({ prefix: "\u{1F680}", name: "base256emoji", encode: $d, decode: Ld });
}), eo = {};
M(eo, { sha256: () => Rd, sha512: () => Md });
var _a, Rd, Md, Na = F(() => {
  a(), wn(), Rd = yn({ name: "sha2-256", code: 18, encode: (_a = (o) => async (n) => new Uint8Array(await crypto.subtle.digest(o, n)))("SHA-256") }), Md = yn({ name: "sha2-512", code: 19, encode: _a("SHA-512") });
}), to = {};
M(to, { identity: () => qd });
var $a, Od, La, zd, qd, Pa = F(() => {
  a(), Ne(), Le(), zd = (o) => $e($a, La(o)), qd = { code: $a = 0, name: Od = "identity", encode: La = Se, digest: zd };
}), ro, Ra = F(() => {
  a(), Aa(), Ta(), Ia(), Sa(), Ua(), ht(), Fa(), Re(), zn(), ka(), Na(), Pa(), qn(), Hn(), gn(), ro = { ...Wn, ...Jn, ...Xn, ...Yn, ...Qn, ...Rt, ...Zn, ...dt, ...On, ...Kn };
});
function Nr(o = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o) : new Uint8Array(o);
}
var no = F(() => {
  a();
});
function Oa(o, n, c, u) {
  return { name: o, prefix: n, encoder: { name: o, prefix: n, encode: c }, decoder: { decode: u } };
}
var Ma, oo, Hd, $r, io = F(() => {
  a(), Ra(), no(), Ma = Oa("utf8", "u", (o) => "u" + new TextDecoder("utf8").decode(o), (o) => new TextEncoder().encode(o.substring(1))), oo = Oa("ascii", "a", (o) => {
    let n = "a";
    for (let c = 0; c < o.length; c++)
      n += String.fromCharCode(o[c]);
    return n;
  }, (o) => {
    let n = Nr((o = o.substring(1)).length);
    for (let c = 0; c < o.length; c++)
      n[c] = o.charCodeAt(c);
    return n;
  }), Hd = { utf8: Ma, "utf-8": Ma, hex: ro.base16, latin1: oo, ascii: oo, binary: oo, ...ro }, $r = Hd;
}), Tt = {};
function so(o, n = "utf8") {
  let c = $r[n];
  if (!c)
    throw new Error(`Unsupported encoding "${n}"`);
  return n !== "utf8" && n !== "utf-8" || globalThis.Buffer == null || globalThis.Buffer.from == null ? c.encoder.encode(o).substring(1) : globalThis.Buffer.from(o.buffer, o.byteOffset, o.byteLength).toString("utf8");
}
M(Tt, { toString: () => so });
var Ke = F(() => {
  a(), io();
}), Va = S((o, n) => {
  a();
  var c = Ba(), { toString: u } = (Ke(), R(Tt)), h = c, g = c.v4, y = c.v6, $ = function(I, P, L) {
    let q;
    if (L = ~~L, g(I))
      q = P || new Uint8Array(L + 4), I.split(/\./g).map(function(N) {
        q[L++] = 255 & parseInt(N, 10);
      });
    else if (y(I)) {
      let N, X = I.split(":", 8);
      for (N = 0; N < X.length; N++) {
        let rt;
        g(X[N]) && (rt = $(X[N]), X[N] = u(rt.slice(0, 2), "base16")), rt && ++N < 8 && X.splice(N, 0, u(rt.slice(2, 4), "base16"));
      }
      if (X[0] === "")
        for (; X.length < 8; )
          X.unshift("0");
      else if (X[X.length - 1] === "")
        for (; X.length < 8; )
          X.push("0");
      else if (X.length < 8) {
        for (N = 0; N < X.length && X[N] !== ""; N++)
          ;
        let rt = [N, "1"];
        for (N = 9 - X.length; N > 0; N--)
          rt.push("0");
        X.splice.apply(X, rt);
      }
      for (q = P || new Uint8Array(L + 16), N = 0; N < X.length; N++) {
        let rt = parseInt(X[N], 16);
        q[L++] = rt >> 8 & 255, q[L++] = 255 & rt;
      }
    }
    if (!q)
      throw Error("Invalid ip address: " + I);
    return q;
  };
  n.exports = { isIP: h, isV4: g, isV6: y, toBytes: $, toString: function(I, P, L) {
    P = ~~P, L = L || I.length - P;
    let q, N = [], X = new DataView(I.buffer);
    if (L === 4) {
      for (let rt = 0; rt < L; rt++)
        N.push(I[P + rt]);
      q = N.join(".");
    } else if (L === 16) {
      for (let rt = 0; rt < L; rt += 2)
        N.push(X.getUint16(P + rt).toString(16));
      q = N.join(":"), q = q.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3"), q = q.replace(/:{3,4}/, "::");
    }
    return q;
  } };
}), Lr = S((o, n) => {
  function c(g) {
    if (typeof g == "number") {
      if (c.codes[g])
        return c.codes[g];
      throw new Error("no protocol with code: " + g);
    }
    if (typeof g == "string") {
      if (c.names[g])
        return c.names[g];
      throw new Error("no protocol with name: " + g);
    }
    throw new Error("invalid protocol id type: " + g);
  }
  a();
  var u = -1;
  function h(g, y, $, I, P) {
    return { code: g, size: y, name: $, resolvable: Boolean(I), path: Boolean(P) };
  }
  c.lengthPrefixedVarSize = u, c.V = u, c.table = [[4, 32, "ip4"], [6, 16, "tcp"], [33, 16, "dccp"], [41, 128, "ip6"], [42, u, "ip6zone"], [53, u, "dns", "resolvable"], [54, u, "dns4", "resolvable"], [55, u, "dns6", "resolvable"], [56, u, "dnsaddr", "resolvable"], [132, 16, "sctp"], [273, 16, "udp"], [275, 0, "p2p-webrtc-star"], [276, 0, "p2p-webrtc-direct"], [277, 0, "p2p-stardust"], [290, 0, "p2p-circuit"], [301, 0, "udt"], [302, 0, "utp"], [400, u, "unix", !1, "path"], [421, u, "ipfs"], [421, u, "p2p"], [443, 0, "https"], [444, 96, "onion"], [445, 296, "onion3"], [446, u, "garlic64"], [460, 0, "quic"], [477, 0, "ws"], [478, 0, "wss"], [479, 0, "p2p-websocket-star"], [480, 0, "http"], [777, u, "memory"]], c.names = {}, c.codes = {}, c.table.map((g) => {
    let y = h.apply(null, g);
    return c.codes[y.code] = y, c.names[y.name] = y, null;
  }), c.object = h, n.exports = c;
}), Ja = {};
function co(o, n = "utf8") {
  let c = $r[n];
  if (!c)
    throw new Error(`Unsupported encoding "${n}"`);
  return n !== "utf8" && n !== "utf-8" || globalThis.Buffer == null || globalThis.Buffer.from == null ? c.decoder.decode(`${c.prefix}${o}`) : globalThis.Buffer.from(o, "utf8");
}
M(Ja, { fromString: () => co });
var fo = F(() => {
  a(), io();
}), lo = {};
function Gd(o, n) {
  n || (n = o.reduce((h, g) => h + g.length, 0));
  let c = Nr(n), u = 0;
  for (let h of o)
    c.set(h, u), u += h.length;
  return c;
}
M(lo, { concat: () => Gd });
var ho = F(() => {
  a(), no();
}), ru = S((o, n) => {
  a();
  var c = Va(), u = Lr(), { CID: h } = (Q(), R(dr)), { base32: g } = (ht(), R(Rt)), { base58btc: y } = (Re(), R(dt)), $ = (Le(), R(Ue)), I = pt(), { toString: P } = (Ke(), R(Tt)), { fromString: L } = (fo(), R(Ja)), { concat: q } = (ho(), R(lo));
  function N(nt, st) {
    return st instanceof Uint8Array ? N.toString(nt, st) : N.toBytes(nt, st);
  }
  function X(nt) {
    let st = new ArrayBuffer(2);
    return new DataView(st).setUint16(0, nt), new Uint8Array(st);
  }
  function rt(nt) {
    return new DataView(nt.buffer).getUint16(nt.byteOffset);
  }
  n.exports = N, N.toString = function(nt, st) {
    switch (u(nt).code) {
      case 4:
      case 41:
        return function(ot) {
          let St = c.toString(ot);
          if (!St || !c.isIP(St))
            throw new Error("invalid ip address");
          return St;
        }(st);
      case 6:
      case 273:
      case 33:
      case 132:
        return rt(st).toString();
      case 53:
      case 54:
      case 55:
      case 56:
      case 400:
      case 777:
        return function(ot) {
          let St = I.decode(ot);
          if ((ot = ot.slice(I.decode.bytes)).length !== St)
            throw new Error("inconsistent lengths");
          return P(ot);
        }(st);
      case 421:
        return function(ot) {
          let St = I.decode(ot), Ct = ot.slice(I.decode.bytes);
          if (Ct.length !== St)
            throw new Error("inconsistent lengths");
          return P(Ct, "base58btc");
        }(st);
      case 444:
      case 445:
        return function(ot) {
          let St = ot.slice(0, ot.length - 2), Ct = ot.slice(ot.length - 2);
          return P(St, "base32") + ":" + rt(Ct);
        }(st);
      default:
        return P(st, "base16");
    }
  }, N.toBytes = function(nt, st) {
    switch (u(nt).code) {
      case 4:
      case 41:
        return function(ot) {
          if (!c.isIP(ot))
            throw new Error("invalid ip address");
          return c.toBytes(ot);
        }(st);
      case 6:
      case 273:
      case 33:
      case 132:
        return X(parseInt(st, 10));
      case 53:
      case 54:
      case 55:
      case 56:
      case 400:
      case 777:
        return function(ot) {
          let St = L(ot), Ct = Uint8Array.from(I.encode(St.length));
          return q([Ct, St], Ct.length + St.length);
        }(st);
      case 421:
        return function(ot) {
          let St;
          St = ot[0] === "Q" || ot[0] === "1" ? $.decode(y.decode(`z${ot}`)).bytes : h.parse(ot).multihash.bytes;
          let Ct = Uint8Array.from(I.encode(St.length));
          return q([Ct, St], Ct.length + St.length);
        }(st);
      case 444:
        return function(ot) {
          let St = ot.split(":");
          if (St.length !== 2)
            throw new Error("failed to parse onion addr: " + St + " does not contain a port number");
          if (St[0].length !== 16)
            throw new Error("failed to parse onion addr: " + St[0] + " not a Tor onion address.");
          let Ct = g.decode("b" + St[0]), et = parseInt(St[1], 10);
          if (et < 1 || et > 65536)
            throw new Error("Port number is not in range(1, 65536)");
          let at = X(et);
          return q([Ct, at], Ct.length + at.length);
        }(st);
      case 445:
        return function(ot) {
          let St = ot.split(":");
          if (St.length !== 2)
            throw new Error("failed to parse onion addr: " + St + " does not contain a port number");
          if (St[0].length !== 56)
            throw new Error("failed to parse onion addr: " + St[0] + " not a Tor onion3 address.");
          let Ct = g.decode("b" + St[0]), et = parseInt(St[1], 10);
          if (et < 1 || et > 65536)
            throw new Error("Port number is not in range(1, 65536)");
          let at = X(et);
          return q([Ct, at], Ct.length + at.length);
        }(st);
      default:
        return L(st, "base16");
    }
  };
}), pu = S((o, n) => {
  a();
  var c = ru(), u = Lr(), h = pt(), { concat: g } = (ho(), R(lo)), { toString: y } = (Ke(), R(Tt));
  function $(et) {
    let at = [], _t = et.split("/").slice(1);
    if (_t.length === 1 && _t[0] === "")
      return [];
    for (let Nt = 0; Nt < _t.length; Nt++) {
      let m = _t[Nt], A = u(m);
      if (A.size !== 0) {
        if (Nt++, Nt >= _t.length)
          throw St("invalid address: " + et);
        if (A.path) {
          at.push([m, ot(_t.slice(Nt).join("/"))]);
          break;
        }
        at.push([m, _t[Nt]]);
      } else
        at.push([m]);
    }
    return at;
  }
  function I(et) {
    let at = [];
    return et.map((_t) => {
      let Nt = Ct(_t);
      return at.push(Nt.name), _t.length > 1 && at.push(_t[1]), null;
    }), ot(at.join("/"));
  }
  function P(et) {
    return et.map((at) => {
      Array.isArray(at) || (at = [at]);
      let _t = Ct(at);
      return at.length > 1 ? [_t.code, c.toBytes(_t.code, at[1])] : [_t.code];
    });
  }
  function L(et) {
    return et.map((at) => {
      let _t = Ct(at);
      return at[1] ? [_t.code, c.toString(_t.code, at[1])] : [_t.code];
    });
  }
  function q(et) {
    return nt(g(et.map((at) => {
      let _t = Ct(at), Nt = Uint8Array.from(h.encode(_t.code));
      return at.length > 1 && (Nt = g([Nt, at[1]])), Nt;
    })));
  }
  function N(et, at) {
    return et.size > 0 ? et.size / 8 : et.size === 0 ? 0 : h.decode(at) + h.decode.bytes;
  }
  function X(et) {
    let at = [], _t = 0;
    for (; _t < et.length; ) {
      let Nt = h.decode(et, _t), m = h.decode.bytes, A = N(u(Nt), et.slice(_t + m));
      if (A === 0) {
        at.push([Nt]), _t += m;
        continue;
      }
      let E = et.slice(_t + m, _t + m + A);
      if (_t += A + m, _t > et.length)
        throw St("Invalid address Uint8Array: " + y(et, "base16"));
      at.push([Nt, E]);
    }
    return at;
  }
  function rt(et) {
    return q(P($(et = ot(et))));
  }
  function nt(et) {
    let at = st(et);
    if (at)
      throw at;
    return Uint8Array.from(et);
  }
  function st(et) {
    try {
      X(et);
    } catch (at) {
      return at;
    }
  }
  function ot(et) {
    return "/" + et.trim().split("/").filter((at) => at).join("/");
  }
  function St(et) {
    return new Error("Error parsing address: " + et);
  }
  function Ct(et) {
    return u(et[0]);
  }
  n.exports = { stringToStringTuples: $, stringTuplesToString: I, tuplesToStringTuples: L, stringTuplesToTuples: P, bytesToTuples: X, tuplesToBytes: q, bytesToString: function(et) {
    return I(L(X(et)));
  }, stringToBytes: rt, fromString: function(et) {
    return rt(et);
  }, fromBytes: nt, validateBytes: st, isValidBytes: function(et) {
    return st(et) === void 0;
  }, cleanPath: ot, ParseError: St, protoFromTuple: Ct, sizeForAddr: N };
}), Yt = S((o, n) => {
  function c(u, h) {
    for (let g in h)
      Object.defineProperty(u, g, { value: h[g], enumerable: !0, configurable: !0 });
    return u;
  }
  a(), n.exports = function(u, h, g) {
    if (!u || typeof u == "string")
      throw new TypeError("Please pass an Error to err-code");
    g || (g = {}), typeof h == "object" && (g = h, h = ""), h && (g.code = h);
    try {
      return c(u, g);
    } catch {
      g.message = u.message, g.stack = u.stack;
      let y = function() {
      };
      return y.prototype = Object.create(Object.getPrototypeOf(u)), c(new y(), g);
    }
  };
}), wu = {};
function uh(o, n) {
  if (o === n)
    return !0;
  if (o.byteLength !== n.byteLength)
    return !1;
  for (let c = 0; c < o.byteLength; c++)
    if (o[c] !== n[c])
      return !1;
  return !0;
}
M(wu, { equals: () => uh });
var gu = F(() => {
  a();
}), bo = S((o, n) => {
  a();
  var c = pu(), u = Lr(), h = pt(), { CID: g } = (Q(), R(dr)), { base58btc: y } = (Re(), R(dt)), $ = Yt(), I = Symbol.for("nodejs.util.inspect.custom"), { toString: P } = (Ke(), R(Tt)), { equals: L } = (gu(), R(wu)), q = /* @__PURE__ */ new Map(), N = Symbol.for("@multiformats/js-multiaddr/multiaddr"), X = class {
    constructor(rt) {
      if (rt == null && (rt = ""), Object.defineProperty(this, N, { value: !0 }), rt instanceof Uint8Array)
        this.bytes = c.fromBytes(rt);
      else if (typeof rt == "string") {
        if (rt.length > 0 && rt.charAt(0) !== "/")
          throw new Error(`multiaddr "${rt}" must start with a "/"`);
        this.bytes = c.fromString(rt);
      } else {
        if (!X.isMultiaddr(rt))
          throw new Error("addr must be a string, Buffer, or another Multiaddr");
        this.bytes = c.fromBytes(rt.bytes);
      }
    }
    toString() {
      return c.bytesToString(this.bytes);
    }
    toJSON() {
      return this.toString();
    }
    toOptions() {
      let rt = {}, nt = this.toString().split("/");
      return rt.family = nt[1] === "ip4" ? 4 : 6, rt.host = nt[2], rt.transport = nt[3], rt.port = parseInt(nt[4]), rt;
    }
    protos() {
      return this.protoCodes().map((rt) => Object.assign({}, u(rt)));
    }
    protoCodes() {
      let rt = [], nt = this.bytes, st = 0;
      for (; st < nt.length; ) {
        let ot = h.decode(nt, st), St = h.decode.bytes, Ct = u(ot);
        st += c.sizeForAddr(Ct, nt.slice(st + St)) + St, rt.push(ot);
      }
      return rt;
    }
    protoNames() {
      return this.protos().map((rt) => rt.name);
    }
    tuples() {
      return c.bytesToTuples(this.bytes);
    }
    stringTuples() {
      let rt = c.bytesToTuples(this.bytes);
      return c.tuplesToStringTuples(rt);
    }
    encapsulate(rt) {
      return rt = new X(rt), new X(this.toString() + rt.toString());
    }
    decapsulate(rt) {
      let nt = rt.toString(), st = this.toString(), ot = st.lastIndexOf(nt);
      if (ot < 0)
        throw new Error("Address " + this + " does not contain subaddress: " + rt);
      return new X(st.slice(0, ot));
    }
    decapsulateCode(rt) {
      let nt = this.tuples();
      for (let st = nt.length - 1; st >= 0; st--)
        if (nt[st][0] === rt)
          return new X(c.tuplesToBytes(nt.slice(0, st)));
      return this;
    }
    getPeerId() {
      try {
        let rt = this.stringTuples().filter((nt) => nt[0] === u.names.ipfs.code).pop();
        if (rt && rt[1]) {
          let nt = rt[1];
          return nt[0] === "Q" || nt[0] === "1" ? P(y.decode(`z${nt}`), "base58btc") : P(g.parse(nt).multihash.bytes, "base58btc");
        }
        return null;
      } catch {
        return null;
      }
    }
    getPath() {
      let rt = null;
      try {
        rt = this.stringTuples().filter((nt) => !!u(nt[0]).path)[0][1], rt || (rt = null);
      } catch {
        rt = null;
      }
      return rt;
    }
    equals(rt) {
      return L(this.bytes, rt.bytes);
    }
    async resolve() {
      let rt = this.protos().find((st) => st.resolvable);
      if (!rt)
        return [this];
      let nt = q.get(rt.name);
      if (!nt)
        throw $(new Error(`no available resolver for ${rt.name}`), "ERR_NO_AVAILABLE_RESOLVER");
      return (await nt(this)).map((st) => new X(st));
    }
    nodeAddress() {
      let rt = this.protoCodes(), nt = this.protoNames(), st = this.toString().split("/").slice(1);
      if (st.length < 4)
        throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
      if (rt[0] !== 4 && rt[0] !== 41 && rt[0] !== 54 && rt[0] !== 55)
        throw new Error(`no protocol with name: "'${nt[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
      if (st[2] !== "tcp" && st[2] !== "udp")
        throw new Error(`no protocol with name: "'${nt[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
      return { family: rt[0] === 41 || rt[0] === 55 ? 6 : 4, address: st[1], port: parseInt(st[3]) };
    }
    isThinWaistAddress(rt) {
      let nt = (rt || this).protos();
      return !(nt.length !== 2 || nt[0].code !== 4 && nt[0].code !== 41 || nt[1].code !== 6 && nt[1].code !== 273);
    }
    static fromNodeAddress(rt, nt) {
      if (!rt)
        throw new Error("requires node address object");
      if (!nt)
        throw new Error("requires transport protocol");
      let st;
      switch (rt.family) {
        case 4:
          st = "ip4";
          break;
        case 6:
          st = "ip6";
          break;
        default:
          throw Error(`Invalid addr family. Got '${rt.family}' instead of 4 or 6`);
      }
      return new X("/" + [st, rt.address, nt, rt.port].join("/"));
    }
    static isName(rt) {
      return !!X.isMultiaddr(rt) && rt.protos().some((nt) => nt.resolvable);
    }
    static isMultiaddr(rt) {
      return rt instanceof X || Boolean(rt && rt[N]);
    }
    [I]() {
      return "<Multiaddr " + P(this.bytes, "base16") + " - " + c.bytesToString(this.bytes) + ">";
    }
    inspect() {
      return "<Multiaddr " + P(this.bytes, "base16") + " - " + c.bytesToString(this.bytes) + ">";
    }
  };
  X.protocols = u, X.resolvers = q, n.exports = { Multiaddr: X, multiaddr: function(rt) {
    return new X(rt);
  }, protocols: u, resolvers: q };
}), ku = S((o, n) => {
  a();
  var { Multiaddr: c } = bo(), u = k("dns4"), h = k("dns6"), g = k("dnsaddr"), y = v(k("dns"), g, u, h), $ = v(k("ip4"), k("ip6")), I = v(w($, k("tcp")), w(y, k("tcp"))), P = w($, k("udp")), L = w(P, k("utp")), q = w(P, k("quic")), N = v(w(I, k("ws")), w(y, k("ws"))), X = v(w(I, k("wss")), w(y, k("wss"))), rt = v(w(I, k("http")), w($, k("http")), w(y, k("http"))), nt = v(w(I, k("https")), w($, k("https")), w(y, k("https"))), st = v(w(N, k("p2p-webrtc-star"), k("p2p")), w(X, k("p2p-webrtc-star"), k("p2p")), w(N, k("p2p-webrtc-star")), w(X, k("p2p-webrtc-star"))), ot = v(w(N, k("p2p-websocket-star"), k("p2p")), w(X, k("p2p-websocket-star"), k("p2p")), w(N, k("p2p-websocket-star")), w(X, k("p2p-websocket-star"))), St = v(w(rt, k("p2p-webrtc-direct"), k("p2p")), w(nt, k("p2p-webrtc-direct"), k("p2p")), w(rt, k("p2p-webrtc-direct")), w(nt, k("p2p-webrtc-direct"))), Ct = v(N, X, rt, nt, st, St, I, L, q, y), et = v(w(Ct, k("p2p-stardust"), k("p2p")), w(Ct, k("p2p-stardust"))), at = v(w(Ct, k("p2p")), st, St, k("p2p")), _t = v(w(at, k("p2p-circuit"), at), w(at, k("p2p-circuit")), w(k("p2p-circuit"), at), w(Ct, k("p2p-circuit")), w(k("p2p-circuit"), Ct), k("p2p-circuit")), Nt = () => v(w(_t, Nt), _t), m = Nt(), A = v(w(m, at, m), w(at, m), w(m, at), m, at);
  function E(O) {
    return function(W) {
      if (!c.isMultiaddr(W))
        try {
          W = new c(W);
        } catch {
          return !1;
        }
      let it = O(W.protoNames());
      return it !== null && (it === !0 || it === !1 ? it : it.length === 0);
    };
  }
  function w(...O) {
    function W(it) {
      if (it.length < O.length)
        return null;
      let vt = it;
      return O.some((xt) => (vt = typeof xt == "function" ? xt().partialMatch(it) : xt.partialMatch(it), Array.isArray(vt) && (it = vt), vt === null)), vt;
    }
    return { toString: function() {
      return "{ " + O.join(" ") + " }";
    }, input: O, matches: E(W), partialMatch: W };
  }
  function v(...O) {
    function W(it) {
      let vt = null;
      return O.some((xt) => {
        let It = typeof xt == "function" ? xt().partialMatch(it) : xt.partialMatch(it);
        return !!It && (vt = It, !0);
      }), vt;
    }
    return { toString: function() {
      return "{ " + O.join(" ") + " }";
    }, input: O, matches: E(W), partialMatch: W };
  }
  function k(O) {
    let W = O;
    return { toString: function() {
      return W;
    }, matches: function(it) {
      let vt;
      if (typeof it == "string" || it instanceof Uint8Array)
        try {
          vt = new c(it);
        } catch {
          return !1;
        }
      else
        vt = it;
      let xt = vt.protoNames();
      return xt.length === 1 && xt[0] === W;
    }, partialMatch: function(it) {
      return it.length === 0 ? null : it[0] === W ? it.slice(1) : null;
    } };
  }
  n.exports = { DNS: y, DNS4: u, DNS6: h, DNSADDR: g, IP: $, TCP: I, UDP: P, QUIC: q, UTP: L, HTTP: rt, HTTPS: nt, WebSockets: N, WebSocketsSecure: X, WebSocketStar: ot, WebRTCStar: st, WebRTCDirect: St, Reliable: Ct, Stardust: et, Circuit: m, P2P: A, IPFS: A };
}), To = S((o, n) => {
  a();
  var c = typeof navigator < "u" && navigator.product === "ReactNative", u = d.URL, h = c ? "http://localhost" : d.location ? d.location.protocol + "//" + d.location.host : "";
  n.exports = { URLWithLegacySupport: class {
    constructor(g = "", y = h) {
      this.super = new u(g, y), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
    }
    get hash() {
      return this.super.hash;
    }
    get host() {
      return this.super.host;
    }
    get hostname() {
      return this.super.hostname;
    }
    get href() {
      return this.super.href;
    }
    get origin() {
      return this.super.origin;
    }
    get password() {
      return this.super.password;
    }
    get pathname() {
      return this.super.pathname;
    }
    get port() {
      return this.super.port;
    }
    get protocol() {
      return this.super.protocol;
    }
    get search() {
      return this.super.search;
    }
    get searchParams() {
      return this.super.searchParams;
    }
    get username() {
      return this.super.username;
    }
    set hash(g) {
      this.super.hash = g;
    }
    set host(g) {
      this.super.host = g;
    }
    set hostname(g) {
      this.super.hostname = g;
    }
    set href(g) {
      this.super.href = g;
    }
    set password(g) {
      this.super.password = g;
    }
    set pathname(g) {
      this.super.pathname = g;
    }
    set port(g) {
      this.super.port = g;
    }
    set protocol(g) {
      this.super.protocol = g;
    }
    set search(g) {
      this.super.search = g;
    }
    set username(g) {
      this.super.username = g;
    }
    static createObjectURL(g) {
      return u.createObjectURL(g);
    }
    static revokeObjectURL(g) {
      u.revokeObjectURL(g);
    }
    toJSON() {
      return this.super.toJSON();
    }
    toString() {
      return this.super.toString();
    }
    format() {
      return this.toString();
    }
  }, URLSearchParams: d.URLSearchParams, defaultBase: h, format: function(g) {
    if (typeof g == "string")
      return new u(g).toString();
    if (!(g instanceof u)) {
      let y = g.username && g.password ? `${g.username}:${g.password}@` : "", $ = g.auth ? g.auth + "@" : "", I = g.port ? ":" + g.port : "", P = g.protocol ? g.protocol + "//" : "", L = g.host || "", q = g.hostname || "", N = g.search || (g.query ? "?" + g.query : ""), X = g.hash || "", rt = g.pathname || "";
      return `${P}${y || $}${L || q + I}${g.path || rt + N}${X}`;
    }
  } };
}), Pu = S((o, n) => {
  a();
  var { URLWithLegacySupport: c, format: u } = To();
  n.exports = (h, g = {}, y = {}, $) => {
    let I, P = g.protocol ? g.protocol.replace(":", "") : "http";
    P = (y[P] || $ || P) + ":";
    try {
      I = new c(h);
    } catch {
      I = {};
    }
    let L = Object.assign({}, g, { protocol: P || I.protocol, host: g.host || I.host });
    return new c(h, u(L)).toString();
  };
}), Mu = S((o, n) => {
  a();
  var { URLWithLegacySupport: c, format: u, URLSearchParams: h, defaultBase: g } = To(), y = Pu();
  n.exports = { URL: c, URLSearchParams: h, format: u, relative: y, defaultBase: g };
}), Ku = S((o, n) => {
  a();
  var { base58btc: c } = (Re(), R(dt)), { base32: u } = (ht(), R(Rt)), h = (Le(), R(Ue)), { Multiaddr: g } = bo(), y = ku(), { CID: $ } = (Q(), R(dr)), { URL: I } = Mu(), { toString: P } = (Ke(), R(Tt)), L = /^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/, q = /^\/(ip[fn]s)\/([^/?#]+)/, N = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/, X = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
  function rt(w) {
    try {
      return typeof w == "string" ? Boolean($.parse(w)) : w instanceof Uint8Array ? Boolean($.decode(w)) : Boolean($.asCID(w));
    } catch {
      return !1;
    }
  }
  function nt(w) {
    if (!w)
      return !1;
    if (g.isMultiaddr(w))
      return !0;
    try {
      return new g(w), !0;
    } catch {
      return !1;
    }
  }
  function st(w, v, k = 1, O = 2) {
    let W = Ct(w);
    if (!W)
      return !1;
    let it = W.match(v);
    if (!it || it[k] !== "ipfs")
      return !1;
    let vt = it[O];
    return vt && v === N && (vt = vt.toLowerCase()), rt(vt);
  }
  function ot(w, v, k = 1, O = 2) {
    let W = Ct(w);
    if (!W)
      return !1;
    let it = W.match(v);
    if (!it || it[k] !== "ipns")
      return !1;
    let vt = it[O];
    if (vt && v === N) {
      if (vt = vt.toLowerCase(), rt(vt))
        return !0;
      try {
        !vt.includes(".") && vt.includes("-") && (vt = vt.replace(/--/g, "@").replace(/-/g, ".").replace(/@/g, "-"));
        let { hostname: xt } = new I(`http://${vt}`);
        return X.test(xt);
      } catch {
        return !1;
      }
    }
    return !0;
  }
  function St(w) {
    return typeof w == "string";
  }
  function Ct(w) {
    return w instanceof Uint8Array ? P(w, "base58btc") : !!St(w) && w;
  }
  var et = (w) => st(w, N, 2, 1), at = (w) => ot(w, N, 2, 1), _t = (w) => et(w) || at(w), Nt = (w) => st(w, L) || et(w), m = (w) => ot(w, L) || at(w), A = (w) => Nt(w) || m(w) || _t(w), E = (w) => st(w, q) || ot(w, q);
  n.exports = { multihash: function(w) {
    let v = Ct(w);
    try {
      h.decode(c.decode("z" + v));
    } catch {
      return !1;
    }
    return !0;
  }, multiaddr: nt, peerMultiaddr: function(w) {
    return nt(w) && y.P2P.matches(w);
  }, cid: rt, base32cid: (w) => function(v) {
    try {
      u.decode(v);
    } catch {
      return !1;
    }
    return !0;
  }(w) && rt(w), ipfsSubdomain: et, ipnsSubdomain: at, subdomain: _t, subdomainGatewayPattern: N, ipfsUrl: Nt, ipnsUrl: m, url: A, pathGatewayPattern: L, ipfsPath: (w) => st(w, q), ipnsPath: (w) => ot(w, q), path: E, pathPattern: q, urlOrPath: (w) => A(w) || E(w), cidPath: (w) => St(w) && !rt(w) && st(`/ipfs/${w}`, q) };
}), hc = S((o, n) => {
  a(), n.exports = function(c) {
    let [u, h] = c[Symbol.asyncIterator] ? [c[Symbol.asyncIterator](), Symbol.asyncIterator] : [c[Symbol.iterator](), Symbol.iterator], g = [];
    return { peek: () => u.next(), push: (y) => {
      g.push(y);
    }, next: () => g.length ? { done: !1, value: g.shift() } : u.next(), [h]() {
      return this;
    } };
  };
}), mc = S((o, n) => {
  a(), n.exports = async (c) => {
    for await (let u of c)
      ;
  };
}), wc = S((o, n) => {
  a(), n.exports = async function* (c, u) {
    for await (let h of c)
      yield u(h);
  };
});
a(), a(), Q(), a(), gn();
var hr = ({ enumerable: o = !0, configurable: n = !1 } = {}) => ({ enumerable: o, configurable: n, writable: !1 }), Dn = function* (o, n) {
  if (o != null && !(o instanceof Uint8Array))
    for (let [c, u] of Object.entries(o)) {
      let h = [...n, c];
      if (u != null && typeof u == "object")
        if (Array.isArray(u))
          for (let [g, y] of u.entries()) {
            let $ = [...h, g], I = x.asCID(y);
            I ? yield [$.join("/"), I] : typeof y == "object" && (yield* Dn(y, $));
          }
        else {
          let g = x.asCID(u);
          g ? yield [h.join("/"), g] : yield* Dn(u, h);
        }
    }
}, bn$4 = function* (o, n) {
  if (o != null)
    for (let [c, u] of Object.entries(o)) {
      let h = [...n, c];
      if (yield h.join("/"), !(u == null || u instanceof Uint8Array || typeof u != "object" || x.asCID(u)))
        if (Array.isArray(u))
          for (let [g, y] of u.entries()) {
            let $ = [...h, g];
            yield $.join("/"), typeof y == "object" && !x.asCID(y) && (yield* bn$4(y, $));
          }
        else
          yield* bn$4(u, h);
    }
}, Qf = (o, n) => {
  let c = o;
  for (let [u, h] of n.entries()) {
    if (c = c[h], c == null)
      throw new Error(`Object has no property at ${n.slice(0, u + 1).map((y) => `[${JSON.stringify(y)}]`).join("")}`);
    let g = x.asCID(c);
    if (g)
      return { value: g, remaining: n.slice(u + 1).join("/") };
  }
  return { value: c };
}, En = class {
  constructor({ cid: o, bytes: n, value: c }) {
    if (!o || !n || typeof c > "u")
      throw new Error("Missing required argument");
    this.cid = o, this.bytes = n, this.value = c, this.asBlock = this, Object.defineProperties(this, { cid: hr(), bytes: hr(), value: hr(), asBlock: hr() });
  }
  links() {
    return Dn(this.value, []);
  }
  tree() {
    return bn$4(this.value, []);
  }
  get(o = "/") {
    return Qf(this.value, o.split("/").filter(Boolean));
  }
}, bi = ({ bytes: o, cid: n, value: c, codec: u }) => {
  let h = c !== void 0 ? c : u && u.decode(o);
  if (h === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new En({ cid: n, bytes: o, value: h });
};
a(), Q(), a();
var Nn = J(pt(), 1);
a(), a(), a(), a();
var ll = ["string", "number", "bigint", "symbol"], dl = ["Function", "Generator", "AsyncGenerator", "GeneratorFunction", "AsyncGeneratorFunction", "AsyncFunction", "Observable", "Array", "Buffer", "Object", "RegExp", "Date", "Error", "Map", "Set", "WeakMap", "WeakSet", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Promise", "URL", "HTMLElement", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array"];
function Fi(o) {
  if (o === null)
    return "null";
  if (o === void 0)
    return "undefined";
  if (o === !0 || o === !1)
    return "boolean";
  let n = typeof o;
  return ll.includes(n) ? n : n === "function" ? "Function" : Array.isArray(o) ? "Array" : hl(o) ? "Buffer" : pl(o) || "Object";
}
function hl(o) {
  return o && o.constructor && o.constructor.isBuffer && o.constructor.isBuffer.call(null, o);
}
function pl(o) {
  let n = Object.prototype.toString.call(o).slice(8, -1);
  if (dl.includes(n))
    return n;
}
a();
var l = class {
  constructor(o, n, c) {
    this.major = o, this.majorEncoded = o << 5, this.name = n, this.terminal = c;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(o) {
    return this.major < o.major ? -1 : this.major > o.major ? 1 : 0;
  }
};
l.uint = new l(0, "uint", !0), l.negint = new l(1, "negint", !0), l.bytes = new l(2, "bytes", !0), l.string = new l(3, "string", !0), l.array = new l(4, "array", !1), l.map = new l(5, "map", !1), l.tag = new l(6, "tag", !1), l.float = new l(7, "float", !0), l.false = new l(7, "false", !0), l.true = new l(7, "true", !0), l.null = new l(7, "null", !0), l.undefined = new l(7, "undefined", !0), l.break = new l(7, "break", !0);
var b = class {
  constructor(o, n, c) {
    this.type = o, this.value = n, this.encodedLength = c, this.encodedBytes = void 0, this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};
a(), a();
var mt = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer == "function", ml = new TextDecoder(), yl = new TextEncoder();
function pr(o) {
  return mt && globalThis.Buffer.isBuffer(o);
}
function Bn$2(o) {
  return o instanceof Uint8Array ? pr(o) ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength) : o : Uint8Array.from(o);
}
var Ni = mt ? (o, n, c) => c - n > 64 ? globalThis.Buffer.from(o.subarray(n, c)).toString("utf8") : ki(o, n, c) : (o, n, c) => c - n > 64 ? ml.decode(o.subarray(n, c)) : ki(o, n, c), $i = mt ? (o) => o.length > 64 ? globalThis.Buffer.from(o) : vi(o) : (o) => o.length > 64 ? yl.encode(o) : vi(o), Ce = (o) => Uint8Array.from(o), yt = mt ? (o, n, c) => pr(o) ? new Uint8Array(o.subarray(n, c)) : o.slice(n, c) : (o, n, c) => o.slice(n, c), Li = mt ? (o, n) => (o = o.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c)), Bn$2(globalThis.Buffer.concat(o, n))) : (o, n) => {
  let c = new Uint8Array(n), u = 0;
  for (let h of o)
    u + h.length > c.length && (h = h.subarray(0, c.length - u)), c.set(h, u), u += h.length;
  return c;
}, Pi = mt ? (o) => globalThis.Buffer.allocUnsafe(o) : (o) => new Uint8Array(o);
function Ri(o, n) {
  if (pr(o) && pr(n))
    return o.compare(n);
  for (let c = 0; c < o.length; c++)
    if (o[c] !== n[c])
      return o[c] < n[c] ? -1 : 1;
  return 0;
}
function vi(o, n = 1 / 0) {
  let c, u = o.length, h = null, g = [];
  for (let y = 0; y < u; ++y) {
    if (c = o.charCodeAt(y), c > 55295 && c < 57344) {
      if (!h) {
        if (c > 56319) {
          (n -= 3) > -1 && g.push(239, 191, 189);
          continue;
        }
        if (y + 1 === u) {
          (n -= 3) > -1 && g.push(239, 191, 189);
          continue;
        }
        h = c;
        continue;
      }
      if (c < 56320) {
        (n -= 3) > -1 && g.push(239, 191, 189), h = c;
        continue;
      }
      c = 65536 + (h - 55296 << 10 | c - 56320);
    } else
      h && (n -= 3) > -1 && g.push(239, 191, 189);
    if (h = null, c < 128) {
      if ((n -= 1) < 0)
        break;
      g.push(c);
    } else if (c < 2048) {
      if ((n -= 2) < 0)
        break;
      g.push(c >> 6 | 192, 63 & c | 128);
    } else if (c < 65536) {
      if ((n -= 3) < 0)
        break;
      g.push(c >> 12 | 224, c >> 6 & 63 | 128, 63 & c | 128);
    } else {
      if (!(c < 1114112))
        throw new Error("Invalid code point");
      if ((n -= 4) < 0)
        break;
      g.push(c >> 18 | 240, c >> 12 & 63 | 128, c >> 6 & 63 | 128, 63 & c | 128);
    }
  }
  return g;
}
function ki(o, n, c) {
  let u = [];
  for (; n < c; ) {
    let h = o[n], g = null, y = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
    if (n + y <= c) {
      let $, I, P, L;
      switch (y) {
        case 1:
          h < 128 && (g = h);
          break;
        case 2:
          $ = o[n + 1], (192 & $) == 128 && (L = (31 & h) << 6 | 63 & $, L > 127 && (g = L));
          break;
        case 3:
          $ = o[n + 1], I = o[n + 2], (192 & $) == 128 && (192 & I) == 128 && (L = (15 & h) << 12 | (63 & $) << 6 | 63 & I, L > 2047 && (L < 55296 || L > 57343) && (g = L));
          break;
        case 4:
          $ = o[n + 1], I = o[n + 2], P = o[n + 3], (192 & $) == 128 && (192 & I) == 128 && (192 & P) == 128 && (L = (15 & h) << 18 | (63 & $) << 12 | (63 & I) << 6 | 63 & P, L > 65535 && L < 1114112 && (g = L));
      }
    }
    g === null ? (g = 65533, y = 1) : g > 65535 && (g -= 65536, u.push(g >>> 10 & 1023 | 55296), g = 56320 | 1023 & g), u.push(g), n += y;
  }
  return wl(u);
}
var _i = 4096;
function wl(o) {
  let n = o.length;
  if (n <= _i)
    return String.fromCharCode.apply(String, o);
  let c = "", u = 0;
  for (; u < n; )
    c += String.fromCharCode.apply(String, o.slice(u, u += _i));
  return c;
}
var gl = 256, Ot = class {
  constructor(o = gl) {
    this.chunkSize = o, this.cursor = 0, this.maxCursor = -1, this.chunks = [], this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0, this.maxCursor = -1, this.chunks.length && (this.chunks = []), this._initReuseChunk !== null && (this.chunks.push(this._initReuseChunk), this.maxCursor = this._initReuseChunk.length - 1);
  }
  push(o) {
    let n = this.chunks[this.chunks.length - 1];
    if (this.cursor + o.length <= this.maxCursor + 1) {
      let c = n.length - (this.maxCursor - this.cursor) - 1;
      n.set(o, c);
    } else {
      if (n) {
        let c = n.length - (this.maxCursor - this.cursor) - 1;
        c < n.length && (this.chunks[this.chunks.length - 1] = n.subarray(0, c), this.maxCursor = this.cursor - 1);
      }
      o.length < 64 && o.length < this.chunkSize ? (n = Pi(this.chunkSize), this.chunks.push(n), this.maxCursor += n.length, this._initReuseChunk === null && (this._initReuseChunk = n), n.set(o, 0)) : (this.chunks.push(o), this.maxCursor += o.length);
    }
    this.cursor += o.length;
  }
  toBytes(o = !1) {
    let n;
    if (this.chunks.length === 1) {
      let c = this.chunks[0];
      o && this.cursor > c.length / 2 ? (n = this.cursor === c.length ? c : c.subarray(0, this.cursor), this._initReuseChunk = null, this.chunks = []) : n = yt(c, 0, this.cursor);
    } else
      n = Li(this.chunks, this.cursor);
    return o && this.reset(), n;
  }
};
a();
var C = "CBOR decode error:", An = "CBOR encode error:";
function Fe(o, n, c) {
  if (o.length - n < c)
    throw new Error(`${C} not enough data for type`);
}
a(), a();
var z = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function ee(o, n, c) {
  Fe(o, n, 1);
  let u = o[n];
  if (c.strict === !0 && u < z[0])
    throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);
  return u;
}
function te(o, n, c) {
  Fe(o, n, 2);
  let u = o[n] << 8 | o[n + 1];
  if (c.strict === !0 && u < z[1])
    throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);
  return u;
}
function re(o, n, c) {
  Fe(o, n, 4);
  let u = 16777216 * o[n] + (o[n + 1] << 16) + (o[n + 2] << 8) + o[n + 3];
  if (c.strict === !0 && u < z[2])
    throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);
  return u;
}
function ne(o, n, c) {
  Fe(o, n, 8);
  let u = 16777216 * o[n] + (o[n + 1] << 16) + (o[n + 2] << 8) + o[n + 3], h = 16777216 * o[n + 4] + (o[n + 5] << 16) + (o[n + 6] << 8) + o[n + 7], g = (BigInt(u) << BigInt(32)) + BigInt(h);
  if (c.strict === !0 && g < z[3])
    throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);
  if (g <= Number.MAX_SAFE_INTEGER)
    return Number(g);
  if (c.allowBigInt === !0)
    return g;
  throw new Error(`${C} integers outside of the safe integer range are not supported`);
}
function Mi(o, n, c, u) {
  return new b(l.uint, ee(o, n + 1, u), 2);
}
function Oi(o, n, c, u) {
  return new b(l.uint, te(o, n + 1, u), 3);
}
function zi(o, n, c, u) {
  return new b(l.uint, re(o, n + 1, u), 5);
}
function qi(o, n, c, u) {
  return new b(l.uint, ne(o, n + 1, u), 9);
}
function ce(o, n) {
  return H(o, 0, n.value);
}
function H(o, n, c) {
  if (c < z[0]) {
    let u = Number(c);
    o.push([n | u]);
  } else if (c < z[1]) {
    let u = Number(c);
    o.push([24 | n, u]);
  } else if (c < z[2]) {
    let u = Number(c);
    o.push([25 | n, u >>> 8, 255 & u]);
  } else if (c < z[3]) {
    let u = Number(c);
    o.push([26 | n, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, 255 & u]);
  } else {
    let u = BigInt(c);
    if (!(u < z[4]))
      throw new Error(`${C} encountered BigInt larger than allowable range`);
    {
      let h = [27 | n, 0, 0, 0, 0, 0, 0, 0], g = Number(u & BigInt(4294967295)), y = Number(u >> BigInt(32) & BigInt(4294967295));
      h[8] = 255 & g, g >>= 8, h[7] = 255 & g, g >>= 8, h[6] = 255 & g, g >>= 8, h[5] = 255 & g, h[4] = 255 & y, y >>= 8, h[3] = 255 & y, y >>= 8, h[2] = 255 & y, y >>= 8, h[1] = 255 & y, o.push(h);
    }
  }
}
function Hi(o, n, c, u) {
  return new b(l.negint, -1 - ee(o, n + 1, u), 2);
}
function ji(o, n, c, u) {
  return new b(l.negint, -1 - te(o, n + 1, u), 3);
}
function Vi(o, n, c, u) {
  return new b(l.negint, -1 - re(o, n + 1, u), 5);
}
ce.encodedSize = function(o) {
  return H.encodedSize(o.value);
}, H.encodedSize = function(o) {
  return o < z[0] ? 1 : o < z[1] ? 2 : o < z[2] ? 3 : o < z[3] ? 5 : 9;
}, ce.compareTokens = function(o, n) {
  return o.value < n.value ? -1 : o.value > n.value ? 1 : 0;
}, a();
var Tn = BigInt(-1), Gi = BigInt(1);
function Wi(o, n, c, u) {
  let h = ne(o, n + 1, u);
  if (typeof h != "bigint") {
    let g = -1 - h;
    if (g >= Number.MIN_SAFE_INTEGER)
      return new b(l.negint, g, 9);
  }
  if (u.allowBigInt !== !0)
    throw new Error(`${C} integers outside of the safe integer range are not supported`);
  return new b(l.negint, Tn - BigInt(h), 9);
}
function mr(o, n) {
  let c = n.value, u = typeof c == "bigint" ? c * Tn - Gi : -1 * c - 1;
  H(o, n.type.majorEncoded, u);
}
function qt(o, n, c, u) {
  Fe(o, n, c + u);
  let h = yt(o, n + c, n + c + u);
  return new b(l.bytes, h, c + u);
}
function Ji(o, n, c, u) {
  return qt(o, n, 1, c);
}
function Xi(o, n, c, u) {
  return qt(o, n, 2, ee(o, n + 1, u));
}
function Yi(o, n, c, u) {
  return qt(o, n, 3, te(o, n + 1, u));
}
function Qi(o, n, c, u) {
  return qt(o, n, 5, re(o, n + 1, u));
}
function Zi(o, n, c, u) {
  let h = ne(o, n + 1, u);
  if (typeof h == "bigint")
    throw new Error(`${C} 64-bit integer bytes lengths not supported`);
  return qt(o, n, 9, h);
}
function yr(o) {
  return o.encodedBytes === void 0 && (o.encodedBytes = o.type === l.string ? $i(o.value) : o.value), o.encodedBytes;
}
function wt(o, n) {
  let c = yr(n);
  H(o, n.type.majorEncoded, c.length), o.push(c);
}
function bl(o, n) {
  return o.length < n.length ? -1 : o.length > n.length ? 1 : Ri(o, n);
}
function Ht(o, n, c, u, h) {
  let g = c + u;
  Fe(o, n, g);
  let y = new b(l.string, Ni(o, n + c, n + g), g);
  return h.retainStringBytes === !0 && (y.byteValue = yt(o, n + c, n + g)), y;
}
function Ki(o, n, c, u) {
  return Ht(o, n, 1, c, u);
}
function es(o, n, c, u) {
  return Ht(o, n, 2, ee(o, n + 1, u), u);
}
function ts(o, n, c, u) {
  return Ht(o, n, 3, te(o, n + 1, u), u);
}
function rs(o, n, c, u) {
  return Ht(o, n, 5, re(o, n + 1, u), u);
}
function ns(o, n, c, u) {
  let h = ne(o, n + 1, u);
  if (typeof h == "bigint")
    throw new Error(`${C} 64-bit integer string lengths not supported`);
  return Ht(o, n, 9, h, u);
}
mr.encodedSize = function(o) {
  let n = o.value, c = typeof n == "bigint" ? n * Tn - Gi : -1 * n - 1;
  return c < z[0] ? 1 : c < z[1] ? 2 : c < z[2] ? 3 : c < z[3] ? 5 : 9;
}, mr.compareTokens = function(o, n) {
  return o.value < n.value ? 1 : o.value > n.value ? -1 : 0;
}, a(), wt.encodedSize = function(o) {
  let n = yr(o);
  return H.encodedSize(n.length) + n.length;
}, wt.compareTokens = function(o, n) {
  return bl(yr(o), yr(n));
}, a();
var os = wt;
function gt$1(o, n, c, u) {
  return new b(l.array, u, c);
}
function is(o, n, c, u) {
  return gt$1(o, n, 1, c);
}
function ss(o, n, c, u) {
  return gt$1(o, n, 2, ee(o, n + 1, u));
}
function as(o, n, c, u) {
  return gt$1(o, n, 3, te(o, n + 1, u));
}
function us(o, n, c, u) {
  return gt$1(o, n, 5, re(o, n + 1, u));
}
function cs(o, n, c, u) {
  let h = ne(o, n + 1, u);
  if (typeof h == "bigint")
    throw new Error(`${C} 64-bit integer array lengths not supported`);
  return gt$1(o, n, 9, h);
}
function fs(o, n, c, u) {
  if (u.allowIndefinite === !1)
    throw new Error(`${C} indefinite length items not allowed`);
  return gt$1(o, n, 1, 1 / 0);
}
function wr(o, n) {
  H(o, l.array.majorEncoded, n.value);
}
function Dt(o, n, c, u) {
  return new b(l.map, u, c);
}
function ls(o, n, c, u) {
  return Dt(o, n, 1, c);
}
function ds(o, n, c, u) {
  return Dt(o, n, 2, ee(o, n + 1, u));
}
function hs(o, n, c, u) {
  return Dt(o, n, 3, te(o, n + 1, u));
}
function ps(o, n, c, u) {
  return Dt(o, n, 5, re(o, n + 1, u));
}
function ms(o, n, c, u) {
  let h = ne(o, n + 1, u);
  if (typeof h == "bigint")
    throw new Error(`${C} 64-bit integer map lengths not supported`);
  return Dt(o, n, 9, h);
}
function ys(o, n, c, u) {
  if (u.allowIndefinite === !1)
    throw new Error(`${C} indefinite length items not allowed`);
  return Dt(o, n, 1, 1 / 0);
}
function gr(o, n) {
  H(o, l.map.majorEncoded, n.value);
}
function ws(o, n, c, u) {
  return new b(l.tag, c, 1);
}
function gs(o, n, c, u) {
  return new b(l.tag, ee(o, n + 1, u), 2);
}
function Ds(o, n, c, u) {
  return new b(l.tag, te(o, n + 1, u), 3);
}
function bs(o, n, c, u) {
  return new b(l.tag, re(o, n + 1, u), 5);
}
function Es(o, n, c, u) {
  return new b(l.tag, ne(o, n + 1, u), 9);
}
function Dr(o, n) {
  H(o, l.tag.majorEncoded, n.value);
}
a(), wr.compareTokens = ce.compareTokens, wr.encodedSize = function(o) {
  return H.encodedSize(o.value);
}, a(), gr.compareTokens = ce.compareTokens, gr.encodedSize = function(o) {
  return H.encodedSize(o.value);
}, a(), Dr.compareTokens = ce.compareTokens, Dr.encodedSize = function(o) {
  return H.encodedSize(o.value);
}, a();
var Tl = 20, Il = 21, Sl = 22, Ul = 23;
function xs(o, n, c, u) {
  if (u.allowUndefined === !1)
    throw new Error(`${C} undefined values are not supported`);
  return u.coerceUndefinedToNull === !0 ? new b(l.null, null, 1) : new b(l.undefined, void 0, 1);
}
function Cs(o, n, c, u) {
  if (u.allowIndefinite === !1)
    throw new Error(`${C} indefinite length items not allowed`);
  return new b(l.break, void 0, 1);
}
function In(o, n, c) {
  if (c) {
    if (c.allowNaN === !1 && Number.isNaN(o))
      throw new Error(`${C} NaN values are not supported`);
    if (c.allowInfinity === !1 && (o === 1 / 0 || o === -1 / 0))
      throw new Error(`${C} Infinity values are not supported`);
  }
  return new b(l.float, o, n);
}
function Bs(o, n, c, u) {
  return In(Sn(o, n + 1), 3, u);
}
function As(o, n, c, u) {
  return In(Un(o, n + 1), 5, u);
}
function Ts(o, n, c, u) {
  return In(Fs(o, n + 1), 9, u);
}
function br$1(o, n, c) {
  let u = n.value;
  if (u === !1)
    o.push([l.float.majorEncoded | Tl]);
  else if (u === !0)
    o.push([l.float.majorEncoded | Il]);
  else if (u === null)
    o.push([l.float.majorEncoded | Sl]);
  else if (u === void 0)
    o.push([l.float.majorEncoded | Ul]);
  else {
    let h, g = !1;
    (!c || c.float64 !== !0) && (Ss(u), h = Sn(me, 1), u === h || Number.isNaN(u) ? (me[0] = 249, o.push(me.slice(0, 3)), g = !0) : (Us(u), h = Un(me, 1), u === h && (me[0] = 250, o.push(me.slice(0, 5)), g = !0))), g || (Fl(u), h = Fs(me, 1), me[0] = 251, o.push(me.slice(0, 9)));
  }
}
br$1.encodedSize = function(o, n) {
  let c = o.value;
  if (c === !1 || c === !0 || c == null)
    return 1;
  if (!n || n.float64 !== !0) {
    Ss(c);
    let u = Sn(me, 1);
    if (c === u || Number.isNaN(c))
      return 3;
    if (Us(c), u = Un(me, 1), c === u)
      return 5;
  }
  return 9;
};
var Is = new ArrayBuffer(9), fe = new DataView(Is, 1), me = new Uint8Array(Is, 0);
function Ss(o) {
  if (o === 1 / 0)
    fe.setUint16(0, 31744, !1);
  else if (o === -1 / 0)
    fe.setUint16(0, 64512, !1);
  else if (Number.isNaN(o))
    fe.setUint16(0, 32256, !1);
  else {
    fe.setFloat32(0, o);
    let n = fe.getUint32(0), c = (2139095040 & n) >> 23, u = 8388607 & n;
    if (c === 255)
      fe.setUint16(0, 31744, !1);
    else if (c === 0)
      fe.setUint16(0, (2147483648 & o) >> 16 | u >> 13, !1);
    else {
      let h = c - 127;
      h < -24 ? fe.setUint16(0, 0) : h < -14 ? fe.setUint16(0, (2147483648 & n) >> 16 | 1 << 24 + h, !1) : fe.setUint16(0, (2147483648 & n) >> 16 | h + 15 << 10 | u >> 13, !1);
    }
  }
}
function Sn(o, n) {
  if (o.length - n < 2)
    throw new Error(`${C} not enough data for float16`);
  let c = (o[n] << 8) + o[n + 1];
  if (c === 31744)
    return 1 / 0;
  if (c === 64512)
    return -1 / 0;
  if (c === 32256)
    return NaN;
  let u, h = c >> 10 & 31, g = 1023 & c;
  return u = h === 0 ? g * 2 ** -24 : h !== 31 ? (g + 1024) * 2 ** (h - 25) : g === 0 ? 1 / 0 : NaN, 32768 & c ? -u : u;
}
function Us(o) {
  fe.setFloat32(0, o, !1);
}
function Un(o, n) {
  if (o.length - n < 4)
    throw new Error(`${C} not enough data for float32`);
  let c = (o.byteOffset || 0) + n;
  return new DataView(o.buffer, c, 4).getFloat32(0, !1);
}
function Fl(o) {
  fe.setFloat64(0, o, !1);
}
function Fs(o, n) {
  if (o.length - n < 8)
    throw new Error(`${C} not enough data for float64`);
  let c = (o.byteOffset || 0) + n;
  return new DataView(o.buffer, c, 8).getFloat64(0, !1);
}
function U$1(o, n, c) {
  throw new Error(`${C} encountered invalid minor (${c}) for major ${o[n] >>> 5}`);
}
function Er(o) {
  return () => {
    throw new Error(`${C} ${o}`);
  };
}
br$1.compareTokens = ce.compareTokens;
var D = [];
for (let o = 0; o <= 23; o++)
  D[o] = U$1;
D[24] = Mi, D[25] = Oi, D[26] = zi, D[27] = qi, D[28] = U$1, D[29] = U$1, D[30] = U$1, D[31] = U$1;
for (let o = 32; o <= 55; o++)
  D[o] = U$1;
D[56] = Hi, D[57] = ji, D[58] = Vi, D[59] = Wi, D[60] = U$1, D[61] = U$1, D[62] = U$1, D[63] = U$1;
for (let o = 64; o <= 87; o++)
  D[o] = Ji;
D[88] = Xi, D[89] = Yi, D[90] = Qi, D[91] = Zi, D[92] = U$1, D[93] = U$1, D[94] = U$1, D[95] = Er("indefinite length bytes/strings are not supported");
for (let o = 96; o <= 119; o++)
  D[o] = Ki;
D[120] = es, D[121] = ts, D[122] = rs, D[123] = ns, D[124] = U$1, D[125] = U$1, D[126] = U$1, D[127] = Er("indefinite length bytes/strings are not supported");
for (let o = 128; o <= 151; o++)
  D[o] = is;
D[152] = ss, D[153] = as, D[154] = us, D[155] = cs, D[156] = U$1, D[157] = U$1, D[158] = U$1, D[159] = fs;
for (let o = 160; o <= 183; o++)
  D[o] = ls;
D[184] = ds, D[185] = hs, D[186] = ps, D[187] = ms, D[188] = U$1, D[189] = U$1, D[190] = U$1, D[191] = ys;
for (let o = 192; o <= 215; o++)
  D[o] = ws;
D[216] = gs, D[217] = Ds, D[218] = bs, D[219] = Es, D[220] = U$1, D[221] = U$1, D[222] = U$1, D[223] = U$1;
for (let o = 224; o <= 243; o++)
  D[o] = Er("simple values are not supported");
D[244] = U$1, D[245] = U$1, D[246] = U$1, D[247] = xs, D[248] = Er("simple values are not supported"), D[249] = Bs, D[250] = As, D[251] = Ts, D[252] = U$1, D[253] = U$1, D[254] = U$1, D[255] = Cs;
var ye = [];
for (let o = 0; o < 24; o++)
  ye[o] = new b(l.uint, o, 1);
for (let o = -1; o >= -24; o--)
  ye[31 - o] = new b(l.negint, o, 1);
function vs(o) {
  switch (o.type) {
    case l.false:
      return Ce([244]);
    case l.true:
      return Ce([245]);
    case l.null:
      return Ce([246]);
    case l.bytes:
      return o.value.length ? void 0 : Ce([64]);
    case l.string:
      return o.value === "" ? Ce([96]) : void 0;
    case l.array:
      return o.value === 0 ? Ce([128]) : void 0;
    case l.map:
      return o.value === 0 ? Ce([160]) : void 0;
    case l.uint:
      return o.value < 24 ? Ce([Number(o.value)]) : void 0;
    case l.negint:
      if (o.value >= -24)
        return Ce([31 - Number(o.value)]);
  }
}
ye[64] = new b(l.bytes, new Uint8Array(0), 1), ye[96] = new b(l.string, "", 1), ye[128] = new b(l.array, 0, 1), ye[160] = new b(l.map, 0, 1), ye[244] = new b(l.false, !1, 1), ye[245] = new b(l.true, !0, 1), ye[246] = new b(l.null, null, 1);
var kl = { float64: !1, mapSorter: $l, quickEncodeToken: vs };
function _l() {
  let o = [];
  return o[l.uint.major] = ce, o[l.negint.major] = mr, o[l.bytes.major] = wt, o[l.string.major] = os, o[l.array.major] = wr, o[l.map.major] = gr, o[l.tag.major] = Dr, o[l.float.major] = br$1, o;
}
var ks = _l(), Fn = new Ot(), bt = class {
  constructor(o, n) {
    this.obj = o, this.parent = n;
  }
  includes(o) {
    let n = this;
    do
      if (n.obj === o)
        return !0;
    while (n = n.parent);
    return !1;
  }
  static createCheck(o, n) {
    if (o && o.includes(n))
      throw new Error(`${An} object contains circular references`);
    return new bt(n, o);
  }
}, Oe = { null: new b(l.null, null), undefined: new b(l.undefined, void 0), true: new b(l.true, !0), false: new b(l.false, !1), emptyArray: new b(l.array, 0), emptyMap: new b(l.map, 0) }, ze = { number: (o, n, c, u) => Number.isInteger(o) && Number.isSafeInteger(o) ? new b(o >= 0 ? l.uint : l.negint, o) : new b(l.float, o), bigint: (o, n, c, u) => o >= BigInt(0) ? new b(l.uint, o) : new b(l.negint, o), Uint8Array: (o, n, c, u) => new b(l.bytes, o), string: (o, n, c, u) => new b(l.string, o), boolean: (o, n, c, u) => o ? Oe.true : Oe.false, null: (o, n, c, u) => Oe.null, undefined: (o, n, c, u) => Oe.undefined, ArrayBuffer: (o, n, c, u) => new b(l.bytes, new Uint8Array(o)), DataView: (o, n, c, u) => new b(l.bytes, new Uint8Array(o.buffer, o.byteOffset, o.byteLength)), Array(o, n, c, u) {
  if (!o.length)
    return c.addBreakTokens === !0 ? [Oe.emptyArray, new b(l.break)] : Oe.emptyArray;
  u = bt.createCheck(u, o);
  let h = [], g = 0;
  for (let y of o)
    h[g++] = xr(y, c, u);
  return c.addBreakTokens ? [new b(l.array, o.length), h, new b(l.break)] : [new b(l.array, o.length), h];
}, Object(o, n, c, u) {
  let h = n !== "Object", g = h ? o.keys() : Object.keys(o), y = h ? o.size : g.length;
  if (!y)
    return c.addBreakTokens === !0 ? [Oe.emptyMap, new b(l.break)] : Oe.emptyMap;
  u = bt.createCheck(u, o);
  let $ = [], I = 0;
  for (let P of g)
    $[I++] = [xr(P, c, u), xr(h ? o.get(P) : o[P], c, u)];
  return Nl($, c), c.addBreakTokens ? [new b(l.map, y), $, new b(l.break)] : [new b(l.map, y), $];
} };
ze.Map = ze.Object, ze.Buffer = ze.Uint8Array;
for (let o of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))
  ze[`${o}Array`] = ze.DataView;
function xr(o, n = {}, c) {
  let u = Fi(o), h = n && n.typeEncoders && n.typeEncoders[u] || ze[u];
  if (typeof h == "function") {
    let y = h(o, u, n, c);
    if (y != null)
      return y;
  }
  let g = ze[u];
  if (!g)
    throw new Error(`${An} unsupported type: ${u}`);
  return g(o, u, n, c);
}
function Nl(o, n) {
  n.mapSorter && o.sort(n.mapSorter);
}
function $l(o, n) {
  let c = Array.isArray(o[0]) ? o[0][0] : o[0], u = Array.isArray(n[0]) ? n[0][0] : n[0];
  if (c.type !== u.type)
    return c.type.compare(u.type);
  let h = c.type.major, g = ks[h].compareTokens(c, u);
  return g === 0 && console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"), g;
}
function _s(o, n, c, u) {
  if (Array.isArray(n))
    for (let h of n)
      _s(o, h, c, u);
  else
    c[n.type.major](o, n, u);
}
function Ll(o, n, c) {
  let u = xr(o, c);
  if (!Array.isArray(u) && c.quickEncodeToken) {
    let h = c.quickEncodeToken(u);
    if (h)
      return h;
    let g = n[u.type.major];
    if (g.encodedSize) {
      let y = g.encodedSize(u, c), $ = new Ot(y);
      if (g($, u, c), $.chunks.length !== 1)
        throw new Error(`Unexpected error: pre-calculated length for ${u} was wrong`);
      return Bn$2($.chunks[0]);
    }
  }
  return Fn.reset(), _s(Fn, u, n, c), Fn.toBytes(!0);
}
function vn(o, n) {
  return n = Object.assign({}, kl, n), Ll(o, ks, n);
}
a();
var Pl = { strict: !1, allowIndefinite: !0, allowUndefined: !0, allowBigInt: !0 }, kn = class {
  constructor(o, n = {}) {
    this.pos = 0, this.data = o, this.options = n;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    let o = this.data[this.pos], n = ye[o];
    if (n === void 0) {
      let c = D[o];
      if (!c)
        throw new Error(`${C} no decoder for major type ${o >>> 5} (byte 0x${o.toString(16).padStart(2, "0")})`);
      let u = 31 & o;
      n = c(this.data, this.pos, u, this.options);
    }
    return this.pos += n.encodedLength, n;
  }
}, jt = Symbol.for("DONE"), Cr = Symbol.for("BREAK");
function Rl(o, n, c) {
  let u = [];
  for (let h = 0; h < o.value; h++) {
    let g = Vt(n, c);
    if (g === Cr) {
      if (o.value === 1 / 0)
        break;
      throw new Error(`${C} got unexpected break to lengthed array`);
    }
    if (g === jt)
      throw new Error(`${C} found array but not enough entries (got ${h}, expected ${o.value})`);
    u[h] = g;
  }
  return u;
}
function Ml(o, n, c) {
  let u = c.useMaps === !0, h = u ? void 0 : {}, g = u ? /* @__PURE__ */ new Map() : void 0;
  for (let y = 0; y < o.value; y++) {
    let $ = Vt(n, c);
    if ($ === Cr) {
      if (o.value === 1 / 0)
        break;
      throw new Error(`${C} got unexpected break to lengthed map`);
    }
    if ($ === jt)
      throw new Error(`${C} found map but not enough entries (got ${y} [no key], expected ${o.value})`);
    if (u !== !0 && typeof $ != "string")
      throw new Error(`${C} non-string keys not supported (got ${typeof $})`);
    let I = Vt(n, c);
    if (I === jt)
      throw new Error(`${C} found map but not enough entries (got ${y} [no value], expected ${o.value})`);
    u ? g.set($, I) : h[$] = I;
  }
  return u ? g : h;
}
function Vt(o, n) {
  if (o.done())
    return jt;
  let c = o.next();
  if (c.type === l.break)
    return Cr;
  if (c.type.terminal)
    return c.value;
  if (c.type === l.array)
    return Rl(c, o, n);
  if (c.type === l.map)
    return Ml(c, o, n);
  if (c.type === l.tag) {
    if (n.tags && typeof n.tags[c.value] == "function") {
      let u = Vt(o, n);
      return n.tags[c.value](u);
    }
    throw new Error(`${C} tag not supported (${c.value})`);
  }
  throw new Error("unsupported");
}
function _n(o, n) {
  if (!(o instanceof Uint8Array))
    throw new Error(`${C} data to decode must be a Uint8Array`);
  let c = (n = Object.assign({}, Pl, n)).tokenizer || new kn(o, n), u = Vt(c, n);
  if (u === jt)
    throw new Error(`${C} did not find any content to decode`);
  if (u === Cr)
    throw new Error(`${C} got unexpected break`);
  if (!c.done())
    throw new Error(`${C} too many terminals, data makes no sense`);
  return u;
}
Q();
var Ns = 42;
function zl(o) {
  if (o.asCID !== o)
    return null;
  let n = x.asCID(o);
  if (!n)
    return null;
  let c = new Uint8Array(n.bytes.byteLength + 1);
  return c.set(n.bytes, 1), [new b(l.tag, Ns), new b(l.bytes, c)];
}
function ql() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function Hl(o) {
  if (Number.isNaN(o))
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  if (o === 1 / 0 || o === -1 / 0)
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  return null;
}
var jl = { float64: !0, typeEncoders: { Object: zl, undefined: ql, number: Hl } };
function Vl(o) {
  if (o[0] !== 0)
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  return x.decode(o.subarray(1));
}
var $s = { allowIndefinite: !1, coerceUndefinedToNull: !0, allowNaN: !1, allowInfinity: !1, allowBigInt: !0, strict: !0, useMaps: !1, tags: [] };
$s.tags[Ns] = Vl;
var Ls = (o) => vn(o, jl), Ps = (o) => _n(o, $s);
function $n(o) {
  let n = Ls({ version: 1, roots: o }), c = Nn.default.encode(n.length), u = new Uint8Array(c.length + n.length);
  return u.set(c, 0), u.set(n, c.length), u;
}
function Rs(o) {
  return { async setRoots(n) {
    let c = $n(n);
    await o.write(c);
  }, async writeBlock(n) {
    let { cid: c, bytes: u } = n;
    await o.write(new Uint8Array(Nn.default.encode(c.bytes.length + u.length))), await o.write(c.bytes), u.length && await o.write(u);
  }, async close() {
    await o.end();
  } };
}
function Br() {
}
function Ms() {
  let o = [], n = null, c = Br, u = !1, h = null, g = Br, y = () => (n || (n = new Promise((I) => {
    c = () => {
      n = null, c = Br, I();
    };
  })), n), $ = { async next() {
    let I = o.shift();
    return I ? (o.length === 0 && c(), { done: !1, value: I }) : u ? (c(), { done: !0, value: void 0 }) : (h || (h = new Promise((P) => {
      g = () => (h = null, g = Br, P($.next()));
    })), h);
  } };
  return { writer: { write(I) {
    o.push(I);
    let P = y();
    return g(), P;
  }, async end() {
    u = !0;
    let I = y();
    g(), await I;
  } }, iterator: $ };
}
a(), a();
var He = J(pt(), 1);
Q(), Le(), a();
var qe = { Null: (o) => o === null, Int: (o) => Number.isInteger(o), Float: (o) => typeof o == "number" && Number.isFinite(o), String: (o) => typeof o == "string", Bool: (o) => typeof o == "boolean", Bytes: (o) => o instanceof Uint8Array, Link: (o) => !qe.Null(o) && typeof o == "object" && o.asCID === o, List: (o) => Array.isArray(o), Map: (o) => !qe.Null(o) && typeof o == "object" && o.asCID !== o && !qe.List(o) && !qe.Bytes(o) }, Et = { Int: qe.Int, "CarHeader > version": (o) => Et.Int(o), "CarHeader > roots (anon) > valueType (anon)": qe.Link, "CarHeader > roots (anon)": (o) => qe.List(o) && Array.prototype.every.call(o, Et["CarHeader > roots (anon) > valueType (anon)"]), "CarHeader > roots": (o) => Et["CarHeader > roots (anon)"](o), CarHeader: (o) => {
  let n = o && Object.keys(o);
  return qe.Map(o) && ["version"].every((c) => n.includes(c)) && Object.entries(o).every(([c, u]) => Et["CarHeader > " + c] && Et["CarHeader > " + c](u));
} }, Os = Et.CarHeader, Ln = { SHA2_256: 18, LENGTH: 32, DAG_PB: 112 }, zs = 40;
async function Ar$1(o) {
  let n = await o.upTo(8);
  if (!n.length)
    throw new Error("Unexpected end of data");
  let c = He.default.decode(n);
  return o.seek(He.default.decode.bytes), c;
}
async function Gl(o) {
  let n = await o.exactly(zs), c = new DataView(n.buffer, n.byteOffset, n.byteLength), u = 0, h = { version: 2, characteristics: [c.getBigUint64(u, !0), c.getBigUint64(u += 8, !0)], dataOffset: Number(c.getBigUint64(u += 8, !0)), dataSize: Number(c.getBigUint64(u += 8, !0)), indexOffset: Number(c.getBigUint64(u += 8, !0)) };
  return o.seek(zs), h;
}
async function Tr(o, n) {
  let c = await Ar$1(o);
  if (c === 0)
    throw new Error("Invalid CAR header (zero length)");
  let u = await o.exactly(c);
  o.seek(c);
  let h = Ps(u);
  if (!Os(h))
    throw new Error("Invalid CAR header format");
  if (h.version !== 1 && h.version !== 2 || n !== void 0 && h.version !== n)
    throw new Error(`Invalid CAR version: ${h.version}${n !== void 0 ? ` (expected ${n})` : ""}`);
  let g = Array.isArray(h.roots);
  if (h.version === 1 && !g || h.version === 2 && g)
    throw new Error("Invalid CAR header format");
  if (h.version === 1)
    return h;
  let y = await Gl(o);
  o.seek(y.dataOffset - o.pos);
  let $ = await Tr(o, 1);
  return Object.assign($, y);
}
async function Wl(o) {
  let n = await o.upTo(8);
  He.default.decode(n);
  let c = He.default.decode.bytes, u = He.default.decode(n.subarray(He.default.decode.bytes)), h = c + He.default.decode.bytes + u, g = await o.exactly(h);
  return o.seek(h), g;
}
async function Jl(o) {
  let n = await o.exactly(2);
  if (n[0] === Ln.SHA2_256 && n[1] === Ln.LENGTH) {
    let y = await o.exactly(34);
    o.seek(34);
    let $ = ft(y);
    return x.create(0, Ln.DAG_PB, $);
  }
  let c = await Ar$1(o);
  if (c !== 1)
    throw new Error(`Unexpected CID version (${c})`);
  let u = await Ar$1(o), h = await Wl(o), g = ft(h);
  return x.create(c, u, g);
}
async function qs(o) {
  let n = o.pos, c = await Ar$1(o);
  if (c === 0)
    throw new Error("Invalid CAR section (zero length)");
  return c += o.pos - n, { cid: await Jl(o), length: c, blockLength: c - Number(o.pos - n) };
}
async function Xl(o) {
  let { cid: n, blockLength: c } = await qs(o), u = await o.exactly(c);
  return o.seek(c), { bytes: u, cid: n };
}
async function Yl(o) {
  let n = o.pos, { cid: c, length: u, blockLength: h } = await qs(o), g = { cid: c, length: u, blockLength: h, offset: n, blockOffset: o.pos };
  return o.seek(g.blockLength), g;
}
function Hs(o) {
  let n = (async () => {
    let c = await Tr(o);
    if (c.version === 2) {
      let u = o.pos - c.dataOffset;
      o = Zl(o, c.dataSize - u);
    }
    return c;
  })();
  return { header: () => n, async *blocks() {
    for (await n; (await o.upTo(8)).length > 0; )
      yield await Xl(o);
  }, async *blocksIndex() {
    for (await n; (await o.upTo(8)).length > 0; )
      yield await Yl(o);
  } };
}
function Ir(o) {
  let n = 0;
  return { upTo: async (c) => o.subarray(n, n + Math.min(c, o.length - n)), async exactly(c) {
    if (c > o.length - n)
      throw new Error("Unexpected end of data");
    return o.subarray(n, n + c);
  }, seek(c) {
    n += c;
  }, get pos() {
    return n;
  } };
}
function Ql(o) {
  let n = 0, c = 0, u = 0, h = new Uint8Array(0), g = async (y) => {
    c = h.length - u;
    let $ = [h.subarray(u)];
    for (; c < y; ) {
      let P = await o();
      if (P == null)
        break;
      c < 0 ? P.length > c && $.push(P.subarray(-c)) : $.push(P), c += P.length;
    }
    h = new Uint8Array($.reduce((P, L) => P + L.length, 0));
    let I = 0;
    for (let P of $)
      h.set(P, I), I += P.length;
    u = 0;
  };
  return { upTo: async (y) => (h.length - u < y && await g(y), h.subarray(u, u + Math.min(h.length - u, y))), async exactly(y) {
    if (h.length - u < y && await g(y), h.length - u < y)
      throw new Error("Unexpected end of data");
    return h.subarray(u, u + y);
  }, seek(y) {
    n += y, u += y;
  }, get pos() {
    return n;
  } };
}
function js(o) {
  let n = o[Symbol.asyncIterator]();
  return Ql(async function() {
    let c = await n.next();
    return c.done ? null : c.value;
  });
}
function Zl(o, n) {
  let c = 0;
  return { async upTo(u) {
    let h = await o.upTo(u);
    return h.length + c > n && (h = h.subarray(0, n - c)), h;
  }, async exactly(u) {
    let h = await o.exactly(u);
    if (h.length + c > n)
      throw new Error("Unexpected end of data");
    return h;
  }, seek(u) {
    c += u, o.seek(u);
  }, get pos() {
    return o.pos;
  } };
}
var Qe = class {
  constructor(o, n) {
    this._encoder = n, this._mutex = n.setRoots(o), this._ended = !1;
  }
  async put(o) {
    if (!(o.bytes instanceof Uint8Array && o.cid))
      throw new TypeError("Can only write {cid, bytes} objects");
    if (this._ended)
      throw new Error("Already closed");
    let n = x.asCID(o.cid);
    if (!n)
      throw new TypeError("Can only write {cid, bytes} objects");
    return this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid: n, bytes: o.bytes })), this._mutex;
  }
  async close() {
    if (this._ended)
      throw new Error("Already closed");
    return await this._mutex, this._ended = !0, this._encoder.close();
  }
  static create(o) {
    o = Kl(o);
    let { encoder: n, iterator: c } = Vs();
    return { writer: new Qe(o, n), out: new Sr(c) };
  }
  static createAppender() {
    let { encoder: o, iterator: n } = Vs();
    return o.setRoots = () => Promise.resolve(), { writer: new Qe([], o), out: new Sr(n) };
  }
  static async updateRootsInBytes(o, n) {
    let c = Ir(o);
    await Tr(c);
    let u = $n(n);
    if (Number(c.pos) !== u.length)
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${c.pos} bytes, new header is ${u.length} bytes)`);
    return o.set(u, 0), o;
  }
}, Sr = class {
  constructor(o) {
    this._iterator = o;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating)
      throw new Error("Multiple iterator not supported");
    return this._iterating = !0, this._iterator;
  }
};
function Vs() {
  let o = Ms(), { writer: n, iterator: c } = o;
  return { encoder: Rs(n), iterator: c };
}
function Kl(o) {
  if (o === void 0)
    return [];
  if (!Array.isArray(o)) {
    let c = x.asCID(o);
    if (!c)
      throw new TypeError("roots must be a single CID or an array of CIDs");
    return [c];
  }
  let n = [];
  for (let c of o) {
    let u = x.asCID(c);
    if (!u)
      throw new TypeError("roots must be a single CID or an array of CIDs");
    n.push(u);
  }
  return n;
}
a();
var na = J(Zs(), 1), oa = J(ea(), 1);
a();
var rd = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/giu;
function T(o = "", n = "ms") {
  var c = null;
  return (o = (o + "").replace(/(\d)[,_](\d)/g, "$1$2")).replace(rd, function(u, h, g) {
    (g = ta(g)) && (c = (c || 0) + parseFloat(h, 10) * g);
  }), c && c / (ta(n) || 1);
}
function ta(o) {
  return T[o] || T[o.toLowerCase().replace(/s$/, "")];
}
T.nanosecond = T.ns = 1e-6, T.\u00B5s = T.\u03BCs = T.us = T.microsecond = 1e-3, T.millisecond = T.ms = T[""] = 1, T.second = T.sec = T.s = 1e3 * T.ms, T.minute = T.min = T.m = 60 * T.s, T.hour = T.hr = T.h = 60 * T.m, T.day = T.d = 24 * T.h, T.week = T.wk = T.w = 7 * T.d, T.month = T.b = 30.4375 * T.d, T.year = T.yr = T.y = 365.25 * T.d;
var ra = T;
a();
var ve = class extends Error {
  constructor(o = "request timed out") {
    super(o), this.name = "TimeoutError", this.code = ve.code;
  }
};
function le(o, n) {
  return (...c) => {
    let u = c[n != null ? n : c.length - 1];
    if (!u || !u.timeout)
      return o(...c);
    let h = typeof u.timeout == "string" ? ra(u.timeout) : u.timeout, g = new na.TimeoutController(h);
    u.signal = (0, oa.anySignal)([u.signal, g.signal]);
    let y = o(...c), $ = new Promise((L, q) => {
      g.signal.addEventListener("abort", () => {
        q(new ve());
      });
    }), I = Date.now(), P = () => {
      if (g.signal.aborted)
        throw new ve();
      if (Date.now() - I > h)
        throw g.abort(), new ve();
    };
    return y[Symbol.asyncIterator] ? async function* () {
      let L = y[Symbol.asyncIterator]();
      try {
        for (; ; ) {
          let { value: q, done: N } = await Promise.race([L.next(), $]);
          if (N)
            break;
          P(), yield q;
        }
      } catch (q) {
        throw P(), q;
      } finally {
        g.clear(), L.return && L.return();
      }
    }() : (async () => {
      try {
        let L = await Promise.race([y, $]);
        return P(), L;
      } catch (L) {
        throw P(), L;
      } finally {
        g.clear();
      }
    })();
  };
}
ve.code = "ERR_TIMEOUT", a();
var Be = J(ca(), 1);
function kr(o) {
  return Object.assign((0, Be.default)(o), { error: (0, Be.default)(`${o}:error`), trace: (0, Be.default)(`${o}:trace`) });
}
Re(), ht(), zn(), Be.default.formatters.b = (o) => o == null ? "undefined" : Y.baseEncode(o), Be.default.formatters.t = (o) => o == null ? "undefined" : Me.baseEncode(o), Be.default.formatters.m = (o) => o == null ? "undefined" : Mn.baseEncode(o), Be.default.formatters.p = (o) => o == null ? "undefined" : o.toString(), Be.default.formatters.c = (o) => o == null ? "undefined" : o.toString(), Be.default.formatters.k = (o) => o == null ? "undefined" : o.toString(), qn(), Hn(), a(), Re();
var jn = async ({ cid: o, load: n, seen: c }) => {
  c = c || /* @__PURE__ */ new Set();
  let u = o.toString(Y);
  if (c.has(u))
    return;
  let h = await n(o);
  if (c.add(u), h !== null)
    for (let [, g] of h.links())
      await jn({ cid: g, load: n, seen: c });
}, pa = kr("ipfs:components:dag:import"), gd = [fa, da];
function ma({ repo: o, preload: n, codecs: c }) {
  return le(async function* (u, h = {}) {
    h.preload !== !1 && n(u);
    let g = x.asCID(u);
    if (!g)
      throw new Error(`Unexpected error converting CID type: ${u}`);
    pa(`Exporting ${g} as car`);
    let { writer: y, out: $ } = await Qe.create([g]), I = null;
    (async () => {
      try {
        let P = Dd(o, y, { signal: h.signal, timeout: h.timeout }, c);
        await jn({ cid: g, load: P });
      } catch (P) {
        I = P;
      } finally {
        y.close();
      }
    })();
    for await (let P of $) {
      if (I)
        break;
      yield P;
    }
    if (I)
      throw I;
  });
}
function Dd(o, n, c, u) {
  return async (h) => {
    let g = await u.getCodec(h.code);
    if (!g)
      throw new Error(`Can't decode links in block with codec 0x${h.code.toString(16)} to form complete DAG`);
    let y = await o.blocks.get(h, c);
    return pa(`Adding block ${h} to car`), await n.put({ cid: h, bytes: y }), gd.includes(h.code) ? null : bi({ bytes: y, cid: h, codec: g });
  };
}
a();
var ic = J(wa(), 1), sc = J(Da(), 1);
a(), J(Ku(), 1), Q(), a(), a(), a();
var ec$1 = (o = 21) => crypto.getRandomValues(new Uint8Array(o)).reduce((n, c) => n + ((c &= 63) < 36 ? c.toString(36) : c < 62 ? (c - 26).toString(36).toUpperCase() : c > 62 ? "-" : "_"), "");
Ke(), fo();
var ke = "/", tc = new TextEncoder().encode(ke), Vr = tc[0], G = class {
  constructor(o, n) {
    if (typeof o == "string")
      this._buf = co(o);
    else {
      if (!(o instanceof Uint8Array))
        throw new Error("Invalid key, should be String of Uint8Array");
      this._buf = o;
    }
    if (n == null && (n = !0), n && this.clean(), this._buf.byteLength === 0 || this._buf[0] !== Vr)
      throw new Error("Invalid key");
  }
  toString(o = "utf8") {
    return so(this._buf, o);
  }
  uint8Array() {
    return this._buf;
  }
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  static withNamespaces(o) {
    return new G(o.join(ke));
  }
  static random() {
    return new G(ec$1().replace(/-/g, ""));
  }
  static asKey(o) {
    return o instanceof Uint8Array || typeof o == "string" ? new G(o) : o.uint8Array ? new G(o.uint8Array()) : null;
  }
  clean() {
    if ((!this._buf || this._buf.byteLength === 0) && (this._buf = tc), this._buf[0] !== Vr) {
      let o = new Uint8Array(this._buf.byteLength + 1);
      o.fill(Vr, 0, 1), o.set(this._buf, 1), this._buf = o;
    }
    for (; this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === Vr; )
      this._buf = this._buf.subarray(0, -1);
  }
  less(o) {
    let n = this.list(), c = o.list();
    for (let u = 0; u < n.length; u++) {
      if (c.length < u + 1)
        return !1;
      let h = n[u], g = c[u];
      if (h < g)
        return !0;
      if (h > g)
        return !1;
    }
    return n.length < c.length;
  }
  reverse() {
    return G.withNamespaces(this.list().slice().reverse());
  }
  namespaces() {
    return this.list();
  }
  baseNamespace() {
    let o = this.namespaces();
    return o[o.length - 1];
  }
  list() {
    return this.toString().split(ke).slice(1);
  }
  type() {
    return Lh(this.baseNamespace());
  }
  name() {
    return Ph(this.baseNamespace());
  }
  instance(o) {
    return new G(this.toString() + ":" + o);
  }
  path() {
    let o = this.parent().toString();
    return o.endsWith(ke) || (o += ke), o += this.type(), new G(o);
  }
  parent() {
    let o = this.list();
    return o.length === 1 ? new G(ke) : new G(o.slice(0, -1).join(ke));
  }
  child(o) {
    return this.toString() === ke ? o : o.toString() === ke ? this : new G(this.toString() + o.toString(), !1);
  }
  isAncestorOf(o) {
    return o.toString() !== this.toString() && o.toString().startsWith(this.toString());
  }
  isDecendantOf(o) {
    return o.toString() !== this.toString() && this.toString().startsWith(o.toString());
  }
  isTopLevel() {
    return this.list().length === 1;
  }
  concat(...o) {
    return G.withNamespaces([...this.namespaces(), ...Rh(o.map((n) => n.namespaces()))]);
  }
};
function Lh(o) {
  let n = o.split(":");
  return n.length < 2 ? "" : n.slice(0, -1).join(":");
}
function Ph(o) {
  let n = o.split(":");
  return n[n.length - 1];
}
function Rh(o) {
  return [].concat(...o);
}
var _o = J(Yt(), 1);
a(), Q();
var ko = J(Yt(), 1), rc = "/ipfs/";
function Gr(o) {
  if (o instanceof Uint8Array)
    try {
      o = x.decode(o);
    } catch (h) {
      throw (0, ko.default)(h, "ERR_INVALID_CID");
    }
  let n = x.asCID(o);
  if (n)
    return { cid: n, path: void 0 };
  (o = o.toString()).startsWith(rc) && (o = o.substring(rc.length));
  let c, u = o.split("/");
  try {
    n = x.parse(u.shift() || "");
  } catch (h) {
    throw (0, ko.default)(h, "ERR_INVALID_CID");
  }
  return u.length && (c = `/${u.join("/")}`), { cid: n, path: c };
}
a(), Q(), a(), new TextDecoder(), a(), new TextEncoder(), a(), Q(), new TextEncoder();
var nc = 112;
new G("/local/filesroot");
var oc = async function(o, n, c, u = {}) {
  let { cid: h, path: g } = Gr(c);
  g && (u.path = g);
  let y = h, $ = u.path || "";
  if ($.startsWith("/") && ($ = $.substring(1)), u.path)
    try {
      for await (let { value: I, remainderPath: P } of Wr(h, u.path, n, o, { signal: u.signal })) {
        if (!x.asCID(I))
          break;
        $ = P, y = I;
      }
    } catch (I) {
      throw I.message.startsWith("Object has no property") && (I.message = `no link named "${$.split("/")[0]}" under ${y}`, I.code = "ERR_NO_LINK"), I;
    }
  return { cid: y, remainderPath: $ || "" };
}, Wr = async function* (o, n, c, u, h) {
  let g = async (P) => {
    let L = await c.getCodec(P.code), q = await u.blocks.get(P, h);
    return L.decode(q);
  }, y = n.split("/").filter(Boolean), $ = await g(o), I = o;
  for (; y.length; ) {
    let P = y.shift();
    if (!P)
      throw (0, _o.default)(new Error(`Could not resolve path "${n}"`), "ERR_INVALID_PATH");
    if (o.code === nc && Array.isArray($.Links)) {
      let L = $.Links.find((q) => q.Name === P);
      if (L) {
        yield { value: L.Hash, remainderPath: y.join("/") }, $ = await g(L.Hash), I = L.Hash;
        continue;
      }
    }
    if (!Object.prototype.hasOwnProperty.call($, P))
      throw (0, _o.default)(new Error(`no link named "${P}" under ${I}`), "ERR_NO_LINK");
    $ = $[P], yield { value: $, remainderPath: y.join("/") }, x.asCID($) && (I = $, $ = await g($));
  }
  yield { value: $, remainderPath: "" };
}, ac = J(Yt(), 1);
function uc({ codecs: o, repo: n, preload: c }) {
  return le(async function(u, h = {}) {
    if (h.preload !== !1 && c(u), h.path) {
      let $ = h.localResolve ? await (0, ic.default)(Wr(u, h.path, o, n, h)) : await (0, sc.default)(Wr(u, h.path, o, n, h));
      if (!$)
        throw (0, ac.default)(new Error("Not found"), "ERR_NOT_FOUND");
      return $;
    }
    let g = await o.getCodec(u.code), y = await n.blocks.get(u, h);
    return { value: g.decode(y), remainderPath: "" };
  });
}
a(), a();
var Jr = class {
  constructor(o, n, c) {
    this._version = o, this._roots = n, this._iterable = c, this._decoded = !1;
  }
  get version() {
    return this._version;
  }
  async getRoots() {
    return this._roots;
  }
}, tt = class extends Jr {
  [Symbol.asyncIterator]() {
    if (this._decoded)
      throw new Error("Cannot decode more than once");
    if (!this._iterable)
      throw new Error("Block iterable not found");
    return this._decoded = !0, this._iterable[Symbol.asyncIterator]();
  }
  static async fromBytes(o) {
    let { version: n, roots: c, iterator: u } = await cc(o);
    return new tt(n, c, u);
  }
  static async fromIterable(o) {
    let { version: n, roots: c, iterator: u } = await fc(o);
    return new tt(n, c, u);
  }
};
async function cc(o) {
  if (!(o instanceof Uint8Array))
    throw new TypeError("fromBytes() requires a Uint8Array");
  return lc(Ir(o));
}
async function fc(o) {
  if (!o || typeof o[Symbol.asyncIterator] != "function")
    throw new TypeError("fromIterable() requires an async iterable");
  return lc(js(o));
}
async function lc(o) {
  let n = Hs(o), { version: c, roots: u } = await n.header();
  return { version: c, roots: u, iterator: n.blocks() };
}
var gc = J(hc(), 1), Dc = J(mc(), 1), bc = J(wc(), 1), Ec = kr("ipfs:components:dag:import");
function xc({ repo: o }) {
  return le(async function* (n, c = {}) {
    let u = await o.gcLock.readLock();
    try {
      let h, g = { signal: c.signal, timeout: c.timeout }, y = (0, gc.default)(n), { value: $, done: I } = await y.peek();
      if (I)
        return;
      $ && y.push($), h = $ instanceof Uint8Array ? [y] : y;
      for await (let P of h) {
        let L = await jh(o, g, P);
        if (c.pinRoots !== !1)
          for (let q of L) {
            let N = "";
            try {
              await o.blocks.has(q) ? (Ec(`Pinning root ${q}`), await o.pins.pinRecursively(q)) : N = "blockstore: block not found";
            } catch (X) {
              N = X.message;
            }
            yield { root: { cid: q, pinErrorMsg: N } };
          }
      }
    } finally {
      u();
    }
  });
}
async function jh(o, n, c) {
  let u = await tt.fromIterable(c), h = await u.getRoots();
  return await (0, Dc.default)(o.blocks.putMany((0, bc.default)(u, ({ cid: g, bytes: y }) => (Ec(`Import block ${g}`), { key: g, value: y })), { signal: n.signal })), h;
}
function Cc({ repo: o, codecs: n, hashers: c, preload: u }) {
  return le(async function(h, g = {}) {
    let y = g.pin ? await o.gcLock.readLock() : null;
    try {
      let $ = await n.getCodec(g.storeCodec || "dag-cbor");
      if (!$)
        throw new Error(`Unknown storeCodec ${g.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);
      if (g.inputCodec) {
        if (!(h instanceof Uint8Array))
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        let X = await n.getCodec(g.inputCodec);
        if (!X)
          throw new Error(`Unknown inputCodec ${g.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);
        h = X.decode(h);
      }
      let I = g.version != null ? g.version : 1, P = await c.getHasher(g.hashAlg || "sha2-256");
      if (!P)
        throw new Error(`Unknown hash algorithm ${g.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);
      let L = $.encode(h), q = await P.digest(L), N = x.create(I, $.code, q);
      return await o.blocks.put(N, L, { signal: g.signal }), g.pin && await o.pins.pinRecursively(N), g.preload !== !1 && u(N), N;
    } finally {
      y && y();
    }
  });
}
function Bc({ repo: o, codecs: n, preload: c }) {
  return le(async function(u, h = {}) {
    let { cid: g } = Gr(u);
    return h.preload !== !1 && c(g), oc(o, n, u, h);
  });
}
a(), Q(), a();
var Ac = class {
  constructor({ repo: o, codecs: n, hashers: c, preload: u }) {
    this.export = ma({ repo: o, preload: u, codecs: n }), this.get = uc({ codecs: n, repo: o, preload: u }), this.import = xc({ repo: o }), this.resolve = Bc({ repo: o, codecs: n, preload: u }), this.put = Cc({ repo: o, codecs: n, hashers: c, preload: u });
  }
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
class JSONEncoder extends Array {
  constructor() {
    super(), this.inRecursive = [];
  }
  prefix(n) {
    const c = this.inRecursive[this.inRecursive.length - 1];
    c && (c.type === Type.array && (c.elements++, c.elements !== 1 && n.push([44])), c.type === Type.map && (c.elements++, c.elements !== 1 && (c.elements % 2 == 1 ? n.push([44]) : n.push([58]))));
  }
  [Type.uint.major](n, c) {
    this.prefix(n);
    const u = String(c.value), h = [];
    for (let g = 0; g < u.length; g++)
      h[g] = u.charCodeAt(g);
    n.push(h);
  }
  [Type.negint.major](n, c) {
    this[Type.uint.major](n, c);
  }
  [Type.bytes.major](n, c) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  [Type.string.major](n, c) {
    this.prefix(n);
    const u = fromString$7(JSON.stringify(c.value));
    n.push(u.length > 32 ? asU8A(u) : u);
  }
  [Type.array.major](n, c) {
    this.prefix(n), this.inRecursive.push({ type: Type.array, elements: 0 }), n.push([91]);
  }
  [Type.map.major](n, c) {
    this.prefix(n), this.inRecursive.push({ type: Type.map, elements: 0 }), n.push([123]);
  }
  [Type.tag.major](n, c) {
  }
  [Type.float.major](n, c) {
    if (c.type.name === "break") {
      const y = this.inRecursive.pop();
      if (y) {
        if (y.type === Type.array)
          n.push([93]);
        else {
          if (y.type !== Type.map)
            throw new Error("Unexpected recursive type; this should not happen!");
          n.push([125]);
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (c.value === void 0)
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    if (this.prefix(n), c.type.name === "true")
      return void n.push([116, 114, 117, 101]);
    if (c.type.name === "false")
      return void n.push([102, 97, 108, 115, 101]);
    if (c.type.name === "null")
      return void n.push([110, 117, 108, 108]);
    const u = String(c.value), h = [];
    let g = !1;
    for (let y = 0; y < u.length; y++)
      h[y] = u.charCodeAt(y), g || h[y] !== 46 && h[y] !== 101 && h[y] !== 69 || (g = !0);
    g || (h.push(46), h.push(48)), n.push(h);
  }
}
function mapSorter(o, n) {
  if (Array.isArray(o[0]) || Array.isArray(n[0]))
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  const c = o[0], u = n[0];
  if (c.type !== Type.string || u.type !== Type.string)
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  if (c < u)
    return -1;
  if (c > u)
    return 1;
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
const defaultEncodeOptions = { addBreakTokens: !0, mapSorter };
function encode$8(o, n) {
  return n = Object.assign({}, defaultEncodeOptions, n), encodeCustom(o, new JSONEncoder(), n);
}
class Tokenizer {
  constructor(n, c = {}) {
    this.pos = 0, this.data = n, this.options = c, this.modeStack = ["value"], this.lastToken = "";
  }
  done() {
    return this.pos >= this.data.length;
  }
  ch() {
    return this.data[this.pos];
  }
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let n = this.ch();
    for (; n === 32 || n === 9 || n === 13 || n === 10; )
      n = this.data[++this.pos];
  }
  expect(n) {
    if (this.data.length - this.pos < n.length)
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);
    for (let c = 0; c < n.length; c++)
      if (this.data[this.pos++] !== n[c])
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...n)}'`);
  }
  parseNumber() {
    const n = this.pos;
    let c = !1, u = !1;
    const h = ($) => {
      for (; !this.done(); ) {
        const I = this.ch();
        if (!$.includes(I))
          break;
        this.pos++;
      }
    };
    if (this.ch() === 45 && (c = !0, this.pos++), this.ch() === 48) {
      if (this.pos++, this.ch() !== 46)
        return new Token(Type.uint, 0, this.pos - n);
      this.pos++, u = !0;
    }
    if (h([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]), c && this.pos === n + 1)
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
    if (!this.done() && this.ch() === 46) {
      if (u)
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
      u = !0, this.pos++, h([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    }
    this.done() || this.ch() !== 101 && this.ch() !== 69 || (u = !0, this.pos++, this.done() || this.ch() !== 43 && this.ch() !== 45 || this.pos++, h([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]));
    const g = String.fromCharCode.apply(null, this.data.subarray(n, this.pos)), y = parseFloat(g);
    return u ? new Token(Type.float, y, this.pos - n) : this.options.allowBigInt !== !0 || Number.isSafeInteger(y) ? new Token(y >= 0 ? Type.uint : Type.negint, y, this.pos - n) : new Token(y >= 0 ? Type.uint : Type.negint, BigInt(g), this.pos - n);
  }
  parseString() {
    if (this.ch() !== 34)
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);
    this.pos++;
    for (let g = this.pos, y = 0; g < this.data.length && y < 65536; g++, y++) {
      const $ = this.data[g];
      if ($ === 92 || $ < 32 || $ >= 128)
        break;
      if ($ === 34) {
        const I = String.fromCharCode.apply(null, this.data.subarray(this.pos, g));
        return this.pos = g + 1, new Token(Type.string, I, y);
      }
    }
    const n = this.pos, c = [], u = () => {
      if (this.pos + 4 >= this.data.length)
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);
      let g = 0;
      for (let y = 0; y < 4; y++) {
        let $ = this.ch();
        if ($ >= 48 && $ <= 57)
          $ -= 48;
        else if ($ >= 97 && $ <= 102)
          $ = $ - 97 + 10;
        else {
          if (!($ >= 65 && $ <= 70))
            throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);
          $ = $ - 65 + 10;
        }
        g = 16 * g + $, this.pos++;
      }
      return g;
    }, h = () => {
      const g = this.ch();
      let y, $, I, P, L = null, q = g > 239 ? 4 : g > 223 ? 3 : g > 191 ? 2 : 1;
      if (this.pos + q > this.data.length)
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);
      switch (q) {
        case 1:
          g < 128 && (L = g);
          break;
        case 2:
          y = this.data[this.pos + 1], (192 & y) == 128 && (P = (31 & g) << 6 | 63 & y, P > 127 && (L = P));
          break;
        case 3:
          y = this.data[this.pos + 1], $ = this.data[this.pos + 2], (192 & y) == 128 && (192 & $) == 128 && (P = (15 & g) << 12 | (63 & y) << 6 | 63 & $, P > 2047 && (P < 55296 || P > 57343) && (L = P));
          break;
        case 4:
          y = this.data[this.pos + 1], $ = this.data[this.pos + 2], I = this.data[this.pos + 3], (192 & y) == 128 && (192 & $) == 128 && (192 & I) == 128 && (P = (15 & g) << 18 | (63 & y) << 12 | (63 & $) << 6 | 63 & I, P > 65535 && P < 1114112 && (L = P));
      }
      L === null ? (L = 65533, q = 1) : L > 65535 && (L -= 65536, c.push(L >>> 10 & 1023 | 55296), L = 56320 | 1023 & L), c.push(L), this.pos += q;
    };
    for (; !this.done(); ) {
      const g = this.ch();
      let y;
      switch (g) {
        case 92:
          if (this.pos++, this.done())
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);
          switch (y = this.ch(), this.pos++, y) {
            case 34:
            case 39:
            case 92:
            case 47:
              c.push(y);
              break;
            case 98:
              c.push(8);
              break;
            case 116:
              c.push(9);
              break;
            case 110:
              c.push(10);
              break;
            case 102:
              c.push(12);
              break;
            case 114:
              c.push(13);
              break;
            case 117:
              c.push(u());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`);
          }
          break;
        case 34:
          return this.pos++, new Token(Type.string, decodeCodePointsArray(c), this.pos - n);
        default:
          if (g < 32)
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);
          g < 128 ? (c.push(g), this.pos++) : h();
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`);
  }
  parseValue() {
    switch (this.ch()) {
      case 123:
        return this.modeStack.push("obj-start"), this.pos++, new Token(Type.map, 1 / 0, 1);
      case 91:
        return this.modeStack.push("array-start"), this.pos++, new Token(Type.array, 1 / 0, 1);
      case 34:
        return this.parseString();
      case 110:
        return this.expect([110, 117, 108, 108]), new Token(Type.null, null, 4);
      case 102:
        return this.expect([102, 97, 108, 115, 101]), new Token(Type.false, !1, 5);
      case 116:
        return this.expect([116, 114, 117, 101]), new Token(Type.true, !0, 4);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`);
    }
  }
  next() {
    switch (this.skipWhitespace(), this.currentMode()) {
      case "value":
        return this.modeStack.pop(), this.parseValue();
      case "array-value":
        if (this.modeStack.pop(), this.ch() === 93)
          return this.pos++, this.skipWhitespace(), new Token(Type.break, void 0, 1);
        if (this.ch() !== 44)
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        return this.pos++, this.modeStack.push("array-value"), this.skipWhitespace(), this.parseValue();
      case "array-start":
        return this.modeStack.pop(), this.ch() === 93 ? (this.pos++, this.skipWhitespace(), new Token(Type.break, void 0, 1)) : (this.modeStack.push("array-value"), this.skipWhitespace(), this.parseValue());
      case "obj-key":
        if (this.ch() === 125)
          return this.modeStack.pop(), this.pos++, this.skipWhitespace(), new Token(Type.break, void 0, 1);
        if (this.ch() !== 44)
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        this.pos++, this.skipWhitespace();
      case "obj-start": {
        if (this.modeStack.pop(), this.ch() === 125)
          return this.pos++, this.skipWhitespace(), new Token(Type.break, void 0, 1);
        const n = this.parseString();
        if (this.skipWhitespace(), this.ch() !== 58)
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        return this.pos++, this.modeStack.push("obj-value"), n;
      }
      case "obj-value":
        return this.modeStack.pop(), this.modeStack.push("obj-key"), this.skipWhitespace(), this.parseValue();
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`);
    }
  }
}
function decode$a(o, n) {
  return decode$u(o, n = Object.assign({ tokenizer: new Tokenizer(o, n) }, n));
}
function cidEncoder(o) {
  if (o.asCID !== o)
    return null;
  const n = CID$2.asCID(o);
  if (!n)
    return null;
  const c = n.toString();
  return [new Token(Type.map, 1 / 0, 1), new Token(Type.string, "/", 1), new Token(Type.string, c, c.length), new Token(Type.break, void 0, 1)];
}
function bytesEncoder(o) {
  const n = base64$3.encode(o).slice(1);
  return [new Token(Type.map, 1 / 0, 1), new Token(Type.string, "/", 1), new Token(Type.map, 1 / 0, 1), new Token(Type.string, "bytes", 5), new Token(Type.string, n, n.length), new Token(Type.break, void 0, 1), new Token(Type.break, void 0, 1)];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(o) {
  if (Number.isNaN(o))
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  if (o === 1 / 0 || o === -1 / 0)
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  return null;
}
const encodeOptions = { typeEncoders: { Object: cidEncoder, Uint8Array: bytesEncoder, Buffer: bytesEncoder, undefined: undefinedEncoder, number: numberEncoder } };
class DagJsonTokenizer extends Tokenizer {
  constructor(n, c) {
    super(n, c), this.tokenBuffer = [];
  }
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  _next() {
    return this.tokenBuffer.length > 0 ? this.tokenBuffer.pop() : super.next();
  }
  next() {
    const n = this._next();
    if (n.type === Type.map) {
      const c = this._next();
      if (c.type === Type.string && c.value === "/") {
        const u = this._next();
        if (u.type === Type.string) {
          if (this._next().type !== Type.break)
            throw new Error("Invalid encoded CID form");
          return this.tokenBuffer.push(u), new Token(Type.tag, 42, 0);
        }
        if (u.type === Type.map) {
          const h = this._next();
          if (h.type === Type.string && h.value === "bytes") {
            const g = this._next();
            if (g.type === Type.string) {
              for (let $ = 0; $ < 2; $++)
                if (this._next().type !== Type.break)
                  throw new Error("Invalid encoded Bytes form");
              const y = base64$3.decode(`m${g.value}`);
              return new Token(Type.bytes, y, g.value.length);
            }
            this.tokenBuffer.push(g);
          }
          this.tokenBuffer.push(h);
        }
        this.tokenBuffer.push(u);
      }
      this.tokenBuffer.push(c);
    }
    return n;
  }
}
const decodeOptions = { allowIndefinite: !1, allowUndefined: !1, allowNaN: !1, allowInfinity: !1, allowBigInt: !0, strict: !0, useMaps: !1, tags: [] };
decodeOptions.tags[42] = CID$2.parse;
const name$2 = "dag-json", code$3 = 297, encode$7 = (o) => encode$8(o, encodeOptions), decode$9 = (o) => decode$a(o, Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(o, decodeOptions) })), dagJSON = Object.freeze(Object.defineProperty({ __proto__: null, name: name$2, code: code$3, encode: encode$7, decode: decode$9 }, Symbol.toStringTag, { value: "Module" }));
function toBase64url(o) {
  return base64url$1.encode(o).slice(1);
}
function fromBase64url(o) {
  return base64url$1.decode(`u${o}`);
}
function fromSplit$1(o) {
  const [n, c, u] = o;
  return { payload: c, signatures: [{ protected: n, signature: u }], link: CID$2.decode(fromBase64url(c)) };
}
function encodeSignature(o) {
  const n = { signature: fromBase64url(o.signature) };
  return o.header && (n.header = o.header), o.protected && (n.protected = fromBase64url(o.protected)), n;
}
function encode$6(o) {
  const n = fromBase64url(o.payload);
  try {
    CID$2.decode(n);
  } catch {
    throw new Error("Not a valid DagJWS");
  }
  return { payload: n, signatures: o.signatures.map(encodeSignature) };
}
function decodeSignature(o) {
  const n = { signature: toBase64url(o.signature) };
  return o.header && (n.header = o.header), o.protected && (n.protected = toBase64url(o.protected)), n;
}
function decode$8(o) {
  const n = { payload: toBase64url(o.payload), signatures: o.signatures.map(decodeSignature) };
  return n.link = CID$2.decode(new Uint8Array(o.payload)), n;
}
function fromSplit(o) {
  const [n, c, u, h, g] = o, y = { ciphertext: h, iv: u, protected: n, tag: g };
  return c && (y.recipients = [{ encrypted_key: c }]), y;
}
function encodeRecipient(o) {
  const n = {};
  return o.encrypted_key && (n.encrypted_key = fromBase64url(o.encrypted_key)), o.header && (n.header = o.header), n;
}
function encode$5(o) {
  const n = { ciphertext: fromBase64url(o.ciphertext), protected: fromBase64url(o.protected), iv: fromBase64url(o.iv), tag: fromBase64url(o.tag) };
  return o.aad && (n.aad = fromBase64url(o.aad)), o.recipients && (n.recipients = o.recipients.map(encodeRecipient)), o.unprotected && (n.unprotected = o.unprotected), n;
}
function decodeRecipient(o) {
  const n = {};
  return o.encrypted_key && (n.encrypted_key = toBase64url(o.encrypted_key)), o.header && (n.header = o.header), n;
}
function decode$7(o) {
  const n = { ciphertext: toBase64url(o.ciphertext), protected: toBase64url(o.protected), iv: toBase64url(o.iv), tag: toBase64url(o.tag) };
  return o.aad && (n.aad = toBase64url(o.aad)), o.recipients && (n.recipients = o.recipients.map(decodeRecipient)), o.unprotected && (n.unprotected = o.unprotected), n;
}
const name$1 = "dag-jose", code$2 = 133;
function isDagJWS(o) {
  return "payload" in o && typeof o.payload == "string" && "signatures" in o && Array.isArray(o.signatures);
}
function isEncodedJWS(o) {
  return "payload" in o && o.payload instanceof Uint8Array && "signatures" in o && Array.isArray(o.signatures);
}
function isEncodedJWE(o) {
  return "ciphertext" in o && o.ciphertext instanceof Uint8Array && "iv" in o && o.iv instanceof Uint8Array && "protected" in o && o.protected instanceof Uint8Array && "tag" in o && o.tag instanceof Uint8Array;
}
function isDagJWE(o) {
  return "ciphertext" in o && typeof o.ciphertext == "string" && "iv" in o && typeof o.iv == "string" && "protected" in o && typeof o.protected == "string" && "tag" in o && typeof o.tag == "string";
}
function toGeneral(o) {
  if (typeof o == "string") {
    const n = o.split(".");
    if (n.length === 3)
      return fromSplit$1(n);
    if (n.length === 5)
      return fromSplit(n);
    throw new Error("Not a valid JOSE string");
  }
  if (isDagJWS(o) || isDagJWE(o))
    return o;
  throw new Error("Not a valid unencoded JOSE object");
}
function encode$4(o) {
  let n;
  if (typeof o == "string" && (o = toGeneral(o)), isDagJWS(o))
    n = encode$6(o);
  else {
    if (!isDagJWE(o))
      throw new Error("Not a valid JOSE object");
    n = encode$5(o);
  }
  return new Uint8Array(encode$p(n));
}
function decode$6(o) {
  let n;
  try {
    n = decode$p(o);
  } catch {
    throw new Error("Not a valid DAG-JOSE object");
  }
  if (isEncodedJWS(n))
    return decode$8(n);
  if (isEncodedJWE(n))
    return decode$7(n);
  throw new Error("Not a valid DAG-JOSE object");
}
const dagJOSE = Object.freeze(Object.defineProperty({ __proto__: null, name: name$1, code: code$2, toGeneral, encode: encode$4, decode: decode$6 }, Symbol.toStringTag, { value: "Module" })), LOAD_CODEC = (o) => Promise.reject(new Error(`No codec found for "${o}"`));
class Multicodecs {
  constructor(n) {
    this._codecsByName = {}, this._codecsByCode = {}, this._loadCodec = n.loadCodec || LOAD_CODEC;
    for (const c of n.codecs)
      this.addCodec(c);
  }
  addCodec(n) {
    if (this._codecsByName[n.name] || this._codecsByCode[n.code])
      throw new Error(`Resolver already exists for codec "${n.name}"`);
    this._codecsByName[n.name] = n, this._codecsByCode[n.code] = n;
  }
  removeCodec(n) {
    delete this._codecsByName[n.name], delete this._codecsByCode[n.code];
  }
  async getCodec(n) {
    const c = typeof n == "string" ? this._codecsByName : this._codecsByCode;
    if (c[n])
      return c[n];
    const u = await this._loadCodec(n);
    return c[n] == null && this.addCodec(u), u;
  }
  listCodecs() {
    return Object.values(this._codecsByName);
  }
}
const LOAD_HASHER = (o) => Promise.reject(new Error(`No hasher found for "${o}"`));
class Multihashes {
  constructor(n) {
    this._hashersByName = {}, this._hashersByCode = {}, this._loadHasher = n.loadHasher || LOAD_HASHER;
    for (const c of n.hashers)
      this.addHasher(c);
  }
  addHasher(n) {
    if (this._hashersByName[n.name] || this._hashersByCode[n.code])
      throw new Error(`Resolver already exists for codec "${n.name}"`);
    this._hashersByName[n.name] = n, this._hashersByCode[n.code] = n;
  }
  removeHasher(n) {
    delete this._hashersByName[n.name], delete this._hashersByCode[n.code];
  }
  async getHasher(n) {
    const c = typeof n == "string" ? this._hashersByName : this._hashersByCode;
    if (c[n])
      return c[n];
    const u = await this._loadHasher(n);
    return c[n] == null && this.addHasher(u), u;
  }
  listHashers() {
    return Object.values(this._hashersByName);
  }
}
async function* makeIterable(o) {
  let n = 0;
  for (; n < o.length; )
    yield o[n++];
}
function base$2(o, n) {
  if (o.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var c = new Uint8Array(256), u = 0; u < c.length; u++)
    c[u] = 255;
  for (var h = 0; h < o.length; h++) {
    var g = o.charAt(h), y = g.charCodeAt(0);
    if (c[y] !== 255)
      throw new TypeError(g + " is ambiguous");
    c[y] = h;
  }
  var $ = o.length, I = o.charAt(0), P = Math.log($) / Math.log(256), L = Math.log(256) / Math.log($);
  function q(N) {
    if (typeof N != "string")
      throw new TypeError("Expected String");
    if (N.length === 0)
      return new Uint8Array();
    var X = 0;
    if (N[X] !== " ") {
      for (var rt = 0, nt = 0; N[X] === I; )
        rt++, X++;
      for (var st = (N.length - X) * P + 1 >>> 0, ot = new Uint8Array(st); N[X]; ) {
        var St = c[N.charCodeAt(X)];
        if (St === 255)
          return;
        for (var Ct = 0, et = st - 1; (St !== 0 || Ct < nt) && et !== -1; et--, Ct++)
          St += $ * ot[et] >>> 0, ot[et] = St % 256 >>> 0, St = St / 256 >>> 0;
        if (St !== 0)
          throw new Error("Non-zero carry");
        nt = Ct, X++;
      }
      if (N[X] !== " ") {
        for (var at = st - nt; at !== st && ot[at] === 0; )
          at++;
        for (var _t = new Uint8Array(rt + (st - at)), Nt = rt; at !== st; )
          _t[Nt++] = ot[at++];
        return _t;
      }
    }
  }
  return { encode: function(N) {
    if (N instanceof Uint8Array || (ArrayBuffer.isView(N) ? N = new Uint8Array(N.buffer, N.byteOffset, N.byteLength) : Array.isArray(N) && (N = Uint8Array.from(N))), !(N instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (N.length === 0)
      return "";
    for (var X = 0, rt = 0, nt = 0, st = N.length; nt !== st && N[nt] === 0; )
      nt++, X++;
    for (var ot = (st - nt) * L + 1 >>> 0, St = new Uint8Array(ot); nt !== st; ) {
      for (var Ct = N[nt], et = 0, at = ot - 1; (Ct !== 0 || et < rt) && at !== -1; at--, et++)
        Ct += 256 * St[at] >>> 0, St[at] = Ct % $ >>> 0, Ct = Ct / $ >>> 0;
      if (Ct !== 0)
        throw new Error("Non-zero carry");
      rt = et, nt++;
    }
    for (var _t = ot - rt; _t !== ot && St[_t] === 0; )
      _t++;
    for (var Nt = I.repeat(X); _t < ot; ++_t)
      Nt += o.charAt(St[_t]);
    return Nt;
  }, decodeUnsafe: q, decode: function(N) {
    var X = q(N);
    if (X)
      return X;
    throw new Error(`Non-${n} character`);
  } };
}
var src = base$2, _brrp__multiformats_scope_baseX = src;
const equals$1 = (o, n) => {
  if (o === n)
    return !0;
  if (o.byteLength !== n.byteLength)
    return !1;
  for (let c = 0; c < o.byteLength; c++)
    if (o[c] !== n[c])
      return !1;
  return !0;
}, coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o))
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  throw new Error("Unknown type, must be binary type");
};
class Encoder {
  constructor(n, c, u) {
    this.name = n, this.prefix = c, this.baseEncode = u;
  }
  encode(n) {
    if (n instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(n)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Decoder {
  constructor(n, c, u) {
    if (this.name = n, this.prefix = c, c.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = c.codePointAt(0), this.baseDecode = u;
  }
  decode(n) {
    if (typeof n == "string") {
      if (n.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(n)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(n.slice(this.prefix.length));
    }
    throw Error("Can only multibase decode strings");
  }
  or(n) {
    return or(this, n);
  }
}
class ComposedDecoder {
  constructor(n) {
    this.decoders = n;
  }
  or(n) {
    return or(this, n);
  }
  decode(n) {
    const c = n[0], u = this.decoders[c];
    if (u)
      return u.decode(n);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(n)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const or = (o, n) => new ComposedDecoder({ ...o.decoders || { [o.prefix]: o }, ...n.decoders || { [n.prefix]: n } });
class Codec {
  constructor(n, c, u, h) {
    this.name = n, this.prefix = c, this.baseEncode = u, this.baseDecode = h, this.encoder = new Encoder(n, c, u), this.decoder = new Decoder(n, c, h);
  }
  encode(n) {
    return this.encoder.encode(n);
  }
  decode(n) {
    return this.decoder.decode(n);
  }
}
const from = ({ name: o, prefix: n, encode: c, decode: u }) => new Codec(o, n, c, u), baseX = ({ prefix: o, name: n, alphabet: c }) => {
  const { encode: u, decode: h } = _brrp__multiformats_scope_baseX(c, n);
  return from({ prefix: o, name: n, encode: u, decode: (g) => coerce(h(g)) });
}, decode$5 = (o, n, c, u) => {
  const h = {};
  for (let L = 0; L < n.length; ++L)
    h[n[L]] = L;
  let g = o.length;
  for (; o[g - 1] === "="; )
    --g;
  const y = new Uint8Array(g * c / 8 | 0);
  let $ = 0, I = 0, P = 0;
  for (let L = 0; L < g; ++L) {
    const q = h[o[L]];
    if (q === void 0)
      throw new SyntaxError(`Non-${u} character`);
    I = I << c | q, $ += c, $ >= 8 && ($ -= 8, y[P++] = 255 & I >> $);
  }
  if ($ >= c || 255 & I << 8 - $)
    throw new SyntaxError("Unexpected end of data");
  return y;
}, encode$3 = (o, n, c) => {
  const u = n[n.length - 1] === "=", h = (1 << c) - 1;
  let g = "", y = 0, $ = 0;
  for (let I = 0; I < o.length; ++I)
    for ($ = $ << 8 | o[I], y += 8; y > c; )
      y -= c, g += n[h & $ >> y];
  if (y && (g += n[h & $ << c - y]), u)
    for (; g.length * c & 7; )
      g += "=";
  return g;
}, rfc4648 = ({ name: o, prefix: n, bitsPerChar: c, alphabet: u }) => from({ prefix: n, name: o, encode: (h) => encode$3(h, u, c), decode: (h) => decode$5(h, u, c, o) }), base32 = rfc4648({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
rfc4648({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), rfc4648({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), rfc4648({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), rfc4648({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), rfc4648({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), rfc4648({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), rfc4648({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), rfc4648({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
const code$1 = 85;
var encode_1 = encode$2, MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode$2(o, n, c) {
  n = n || [];
  for (var u = c = c || 0; o >= INT; )
    n[c++] = 255 & o | MSB, o /= 128;
  for (; o & MSBALL; )
    n[c++] = 255 & o | MSB, o >>>= 7;
  return n[c] = 0 | o, encode$2.bytes = c - u + 1, n;
}
var decode$4 = read$2, MSB$1 = 128, REST$1 = 127;
function read$2(o, n) {
  var c, u = 0, h = 0, g = n = n || 0, y = o.length;
  do {
    if (g >= y)
      throw read$2.bytes = 0, new RangeError("Could not decode varint");
    c = o[g++], u += h < 28 ? (c & REST$1) << h : (c & REST$1) * Math.pow(2, h), h += 7;
  } while (c >= MSB$1);
  return read$2.bytes = g - n, u;
}
var N1 = Math.pow(2, 7), N2 = Math.pow(2, 14), N3 = Math.pow(2, 21), N4 = Math.pow(2, 28), N5 = Math.pow(2, 35), N6 = Math.pow(2, 42), N7 = Math.pow(2, 49), N8 = Math.pow(2, 56), N9 = Math.pow(2, 63), length = function(o) {
  return o < N1 ? 1 : o < N2 ? 2 : o < N3 ? 3 : o < N4 ? 4 : o < N5 ? 5 : o < N6 ? 6 : o < N7 ? 7 : o < N8 ? 8 : o < N9 ? 9 : 10;
}, varint = { encode: encode_1, decode: decode$4, encodingLength: length }, _brrp_varint = varint;
const decode$3 = (o, n = 0) => [_brrp_varint.decode(o, n), _brrp_varint.decode.bytes], encodeTo = (o, n, c = 0) => (_brrp_varint.encode(o, n, c), n), encodingLength = (o) => _brrp_varint.encodingLength(o), create = (o, n) => {
  const c = n.byteLength, u = encodingLength(o), h = u + encodingLength(c), g = new Uint8Array(h + c);
  return encodeTo(o, g, 0), encodeTo(c, g, u), g.set(n, h), new Digest(o, c, n, g);
}, decode$2 = (o) => {
  const n = coerce(o), [c, u] = decode$3(n), [h, g] = decode$3(n.subarray(u)), y = n.subarray(u + g);
  if (y.byteLength !== h)
    throw new Error("Incorrect length");
  return new Digest(c, h, y, n);
}, equals = (o, n) => {
  if (o === n)
    return !0;
  {
    const c = n;
    return o.code === c.code && o.size === c.size && c.bytes instanceof Uint8Array && equals$1(o.bytes, c.bytes);
  }
};
class Digest {
  constructor(n, c, u, h) {
    this.code = n, this.size = c, this.digest = u, this.bytes = h;
  }
}
const base58btc = baseX({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
baseX({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
const format = (o, n) => {
  const { bytes: c, version: u } = o;
  return u === 0 ? toStringV0(c, baseCache(o), n || base58btc.encoder) : toStringV1(c, baseCache(o), n || base32.encoder);
}, cache = /* @__PURE__ */ new WeakMap(), baseCache = (o) => {
  const n = cache.get(o);
  if (n == null) {
    const c = /* @__PURE__ */ new Map();
    return cache.set(o, c), c;
  }
  return n;
};
class CID {
  constructor(n, c, u, h) {
    this.code = c, this.version = n, this.multihash = u, this.bytes = h, this["/"] = h;
  }
  get asCID() {
    return this;
  }
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  get byteLength() {
    return this.bytes.byteLength;
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      case 1: {
        const { code: n, multihash: c } = this;
        if (n !== DAG_PB_CODE)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (c.code !== SHA_256_CODE)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return CID.createV0(c);
      }
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: n, digest: c } = this.multihash, u = create(n, c);
        return CID.createV1(this.code, u);
      }
      case 1:
        return this;
      default:
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
    }
  }
  equals(n) {
    return CID.equals(this, n);
  }
  static equals(n, c) {
    const u = c;
    return u && n.code === u.code && n.version === u.version && equals(n.multihash, u.multihash);
  }
  toString(n) {
    return format(this, n);
  }
  toJSON() {
    return { code: this.code, version: this.version, hash: this.multihash.bytes };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  static asCID(n) {
    if (n == null)
      return null;
    const c = n;
    if (c instanceof CID)
      return c;
    if (c["/"] != null && c["/"] === c.bytes || c.asCID === c) {
      const { version: u, code: h, multihash: g, bytes: y } = c;
      return new CID(u, h, g, y || encodeCID(u, h, g.bytes));
    }
    if (c[cidSymbol] === !0) {
      const { version: u, multihash: h, code: g } = c, y = decode$2(h);
      return CID.create(u, g, y);
    }
    return null;
  }
  static create(n, c, u) {
    if (typeof c != "number")
      throw new Error("String codecs are no longer supported");
    if (!(u.bytes instanceof Uint8Array))
      throw new Error("Invalid digest");
    switch (n) {
      case 0:
        if (c !== DAG_PB_CODE)
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        return new CID(n, c, u, u.bytes);
      case 1: {
        const h = encodeCID(n, c, u.bytes);
        return new CID(n, c, u, h);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(n) {
    return CID.create(0, DAG_PB_CODE, n);
  }
  static createV1(n, c) {
    return CID.create(1, n, c);
  }
  static decode(n) {
    const [c, u] = CID.decodeFirst(n);
    if (u.length)
      throw new Error("Incorrect length");
    return c;
  }
  static decodeFirst(n) {
    const c = CID.inspectBytes(n), u = c.size - c.multihashSize, h = coerce(n.subarray(u, u + c.multihashSize));
    if (h.byteLength !== c.multihashSize)
      throw new Error("Incorrect length");
    const g = h.subarray(c.multihashSize - c.digestSize), y = new Digest(c.multihashCode, c.digestSize, g, h);
    return [c.version === 0 ? CID.createV0(y) : CID.createV1(c.codec, y), n.subarray(c.size)];
  }
  static inspectBytes(n) {
    let c = 0;
    const u = () => {
      const [L, q] = decode$3(n.subarray(c));
      return c += q, L;
    };
    let h = u(), g = DAG_PB_CODE;
    if (h === 18 ? (h = 0, c = 0) : g = u(), h !== 0 && h !== 1)
      throw new RangeError(`Invalid CID version ${h}`);
    const y = c, $ = u(), I = u(), P = c + I;
    return { version: h, codec: g, multihashCode: $, digestSize: I, multihashSize: P - y, size: P };
  }
  static parse(n, c) {
    const [u, h] = parseCIDtoBytes(n, c), g = CID.decode(h);
    return baseCache(g).set(u, n), g;
  }
}
const parseCIDtoBytes = (o, n) => {
  switch (o[0]) {
    case "Q": {
      const c = n || base58btc;
      return [base58btc.prefix, c.decode(`${base58btc.prefix}${o}`)];
    }
    case base58btc.prefix: {
      const c = n || base58btc;
      return [base58btc.prefix, c.decode(o)];
    }
    case base32.prefix: {
      const c = n || base32;
      return [base32.prefix, c.decode(o)];
    }
    default:
      if (n == null)
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      return [o[0], n.decode(o)];
  }
}, toStringV0 = (o, n, c) => {
  const { prefix: u } = c;
  if (u !== base58btc.prefix)
    throw Error(`Cannot string encode V0 in ${c.name} encoding`);
  const h = n.get(u);
  if (h == null) {
    const g = c.encode(o).slice(1);
    return n.set(u, g), g;
  }
  return h;
}, toStringV1 = (o, n, c) => {
  const { prefix: u } = c, h = n.get(u);
  if (h == null) {
    const g = c.encode(o);
    return n.set(u, g), g;
  }
  return h;
}, DAG_PB_CODE = 112, SHA_256_CODE = 18, encodeCID = (o, n, c) => {
  const u = encodingLength(o), h = u + encodingLength(n), g = new Uint8Array(h + c.byteLength);
  return encodeTo(o, g, 0), encodeTo(n, g, u), g.set(c, h), g;
}, cidSymbol = Symbol.for("@ipld/js-cid/CID");
function notFoundError(o) {
  return o = o || new Error("Not Found"), errCode(o, "ERR_NOT_FOUND");
}
class MemoryBlockstore extends BaseBlockstore {
  constructor() {
    super(), this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  async put(n, c) {
    this.data[base32.encode(n.multihash.bytes)] = c;
  }
  async get(n) {
    if (!await this.has(n))
      throw notFoundError();
    return this.data[base32.encode(n.multihash.bytes)];
  }
  async has(n) {
    return this.data[base32.encode(n.multihash.bytes)] !== void 0;
  }
  async delete(n) {
    delete this.data[base32.encode(n.multihash.bytes)];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([n, c]) => ({ key: CID.createV1(code$1, decode$2(base32.decode(n))), value: c }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([n]) => CID.createV1(code$1, decode$2(base32.decode(n))));
  }
}
class DagRepo extends Ac {
  constructor({ repo: n, codecs: c, options: u }) {
    const h = Object.values(hashes);
    (u.ipld && u.ipld.hashers ? u.ipld.hashers : []).forEach((g) => h.push(g)), super({ repo: n, codecs: c, hashers: new Multihashes({ hashers: h, loadHasher: u.ipld && u.ipld.loadHasher }), preload: (g) => {
    } }), Object.assign(this, mitt()), this.repo = n, this.rootCID, this.tx = { pending: Transaction$1.create(), checkSize: async (g) => {
      const y = Transaction$1.create();
      return await y.add(g), y.size;
    }, getExistingTx: async () => {
      let g = {};
      try {
        let y = this.tx.pending.last;
        if (!y)
          return;
        g = (await this.tx.pending.get(y)).value;
      } catch {
        return g;
      }
      return g;
    }, addData: async (g) => await this.tx.pending.add(g), addTag: async (g, y) => await this.tx.add(g, y), add: async (g, y) => {
      if (!y)
        return;
      y = Object.fromEntries(Object.entries(y).map(([X, rt]) => rt === void 0 ? [X, null] : [X, rt]));
      let $ = !1, I = await this.tx.getExistingTx() || null;
      if (I && I[g])
        $ = !!I[g] && I[g];
      else if (this.rootCID)
        try {
          let X = (await this.get(this.rootCID)).value;
          $ = !!X[g] && X[g];
        } catch {
        }
      let P = await this.tx.pending.add(y), L = I && Object.keys(I).length !== 0 ? Object.fromEntries(Object.entries(I).filter(([X, rt]) => rt.hasOwnProperty("obj") && rt.hasOwnProperty("prev"))) : null, q = L && Object.keys(L).length !== 0 ? Object.assign({}, L, { [g]: { obj: P, prev: $ } }) : { [g]: { obj: P, prev: $ } }, N = await this.tx.pending.add(q);
      return this.emit("added", N), N;
    }, commit: async () => {
      let g = await this.tx.getExistingTx(), y = {};
      try {
        this.rootCID && (y = (await this.get(this.rootCID)).value);
        let I = Object.assign({}, y, Object.fromEntries(Object.entries(g).filter(([P, L]) => L.hasOwnProperty("obj") && L.hasOwnProperty("prev"))));
        this.rootCID = await this.tx.pending.add(I);
      } catch (I) {
        this.rootCID && console.log("thats odd", { error: I });
      }
      const $ = await this.tx.pending.commit();
      return await this.importBuffer($), this.tx.pending = Transaction$1.create(), $;
    } };
  }
  async latest(n) {
    return (await this.get(this.rootCID, { path: `/${n}/obj` })).value;
  }
  async importBuffers(n) {
    let c;
    for (const u of n)
      c = await this.importBuffer(u);
    return c;
  }
  async importBuffer(n) {
    return importBuffer(this, n);
  }
}
async function importBuffer(o, n) {
  const c = await makeIterable([n]), [{ root: u }] = await itAll(o.import(c));
  return u.cid;
}
async function createDagRepo(o = {}) {
  const n = { name: identity$4.name, code: identity$4.code, encode: (I) => I, decode: (I) => I }, c = Object.values(codecs);
  [dagCBOR, dagJSON, dagJOSE, n].concat(o.ipld && o.ipld.codecs || []).forEach((I) => c.push(I));
  const u = new Multicodecs({ codecs: c, loadCodec: o.ipld && o.ipld.loadCodec }), h = o.path || "ipfs";
  let g;
  g = o != null && o.persist ? createRepo(console.log, u, { path: h, autoMigrate: !0 }) : createRepo$1(h, (I) => u.getCodec(I), { blocks: new MemoryBlockstore(), datastore: new MemoryDatastore(), root: new MemoryDatastore(), keys: new MemoryDatastore(), pins: new MemoryDatastore() }, o);
  const y = {};
  try {
    await g.init(y), await g.open();
  } catch (I) {
    throw I;
  }
  const $ = await g.config.getAll();
  return new DagRepo({ repo: g, codecs: u, options: { ...o, repoConfig: $ } });
}
const index$3 = Object.freeze(Object.defineProperty({ __proto__: null, Transaction: Transaction$1, encode: encode$m, createDagRepo, DagRepo, importBuffer }, Symbol.toStringTag, { value: "Module" }));
let GQL_ENDPOINT = "https://arweave.net/graphql";
const setEndpointUrl = (o) => GQL_ENDPOINT = o, run = async (o, n) => {
  const c = JSON.stringify({ query: o, variables: n }), { data: u } = await axios.post(GQL_ENDPOINT, c, { headers: { "content-type": "application/json" } });
  return u;
}, all = async (o, n) => {
  let c = !0, u = [], h = "";
  for (; c; ) {
    const g = (await run(o, { ...n, cursor: h })).data.transactions;
    g.edges && g.edges.length && (u = u.concat(g.edges), h = g.edges[g.edges.length - 1].cursor), c = g.pageInfo.hasNextPage;
  }
  return u;
}, backupEndpoint = "https://arweave-search.goldsky.com/graphql";
async function getOwnerArDag({ arweave: o, searchTags: n, dagOwner: c }) {
  const { host: u, port: h, protocol: g } = o.api.config;
  setEndpointUrl(`${g}://${u}:${h}/graphql`);
  const y = `query($cursor: String) {
    transactions(
    owners: ["${c}"]
    tags: [{ name: "App-Name", values: ["ArDag"] }]
    after: $cursor
    first: 100
  ) {
    pageInfo {
      hasNextPage
    }
    edges {
      cursor
      node {
        id
      }
    }
  }
}`;
  try {
    return (await all(y)).map(($) => $.node);
  } catch ($) {
    console.log("ArGQL failed", $), setEndpointUrl(backupEndpoint);
  }
  try {
    return (await all(y)).map(($) => $.node);
  } catch ($) {
    console.log("ArGQL failed, both gateways down", $);
  }
}
const AR_DAG = "ArDag";
async function persist({ buffer: o = null, arweave: n = null, wallet: c = null, tags: u = [] }) {
  if (!o)
    throw new Error("buffer is required");
  if (!n) {
    if (!this.arweave)
      throw new Error("Arweave is required");
    n = this.arweave;
  }
  c || this.wallet && (c = this.wallet);
  const { root: h } = await Transaction$1.load(o), { cid: g } = await encode$m(o);
  let y = await n.createTransaction({ data: o });
  if (u.push({ name: "App-Name", value: [AR_DAG] }), u.push({ name: "Root-CID", value: [h.toString()] }), u.push({ name: "CAR-CID", value: [g.toString()] }), u && u.length)
    for (const $ of u)
      y.addTag($.name.toString(), $.value.toString());
  return await n.transactions.sign(y, c), await this.post(y), h;
}
async function load$1({ dagOwner: o, dag: n, arweave: c = null }) {
  if (!o)
    throw new Error("dagOwner is required");
  if (!n) {
    if (!this.dag)
      throw new Error("DagRepo is required");
    n = this.dag;
  }
  if (!c) {
    if (!this.arweave)
      throw new Error("Arweave is required");
    c = this.arweave;
  }
  const u = [{ name: "App-Name", values: [AR_DAG] }];
  let h, g = null;
  try {
    g = await getOwnerArDag({ arweave: c, searchTags: u, dagOwner: o });
  } catch ($) {
    console.log("ArDag get failed", $);
  }
  const y = async ($, I) => {
    try {
      const P = await getData({ arweave: c, txid: I.id }), L = await importBuffer($, P);
      h || (h = L), $.hasOwnProperty("rootCID") && !($ != null && $.rootCID) && ($.rootCID = L);
    } catch (P) {
      console.log("Import failed", P);
    }
  };
  for (const $ of g)
    await y(n, $);
  return h;
}
async function get({ dagOwner: o, tag: n = null, arweave: c = null, cid: u = null }) {
  if (!o)
    throw new Error("dagOwner is required");
  c || (c = this.arweave ? this.arweave : require("arweave").default.init({ host: "arweave.net", port: 443, protocol: "https", timeout: 2e4, logging: !1 }));
  const h = [{ name: "App-Name", values: [AR_DAG] }];
  let g, y = null;
  try {
    y = await getOwnerArDag({ arweave: c, searchTags: h, dagOwner: o });
  } catch (I) {
    console.log("ArDag get failed", I);
  }
  if (!y)
    return null;
  let $ = u;
  for (; !g && y.length; ) {
    let I, P = y.shift().id;
    try {
      I = await getData({ arweave: c, txid: P });
    } catch (X) {
      if (console.log("get Data txid failed", { txid: P }, X), !I)
        continue;
    }
    const { root: L, get: q } = await Transaction$1.load(I), N = await q(L);
    if (!n && !u)
      return N;
    n && N.hasOwnProperty(n) && !$ && ($ = N[n].obj);
    try {
      g = await q($);
    } catch {
    }
  }
  return g;
}
async function latest(o) {
  return (await this.dag.get(this.rootCID, { path: `/${o}/obj` })).value;
}
async function getInstance({ dag: o, wallet: n = null, dagOwner: c = !1 }) {
  if (!o)
    throw new Error("Supply a DagRepo from https://github.com/DougAnderson444/ipld-car-txs");
  return c ? this.rootCID = await this.load({ dag: o, dagOwner: c }) : c = await this.arweave.wallets.jwkToAddress(n), { arweave: this.arweave, post: this.post, dagOwner: c, wallet: n, dag: o, load: load$1, rootCID: this.rootCID || null, latest, persist, async save(u, h, { tags: g } = { tags: [] }) {
    const y = await this.dag.tx.add(u, h);
    this.rootCID = y;
    const $ = await this.dag.tx.commit();
    return await this.persist({ buffer: $, tags: g }), y;
  } };
}
function initializeArDag({ arweave: o, post: n = null }) {
  if (!o)
    throw new Error("Arweave instance must be provided");
  const c = o.transactions.post.bind(o.transactions);
  return { arweave: o, post: n || c, getData, getInstance, persist, get, load: load$1 };
}
async function getData({ arweave: o = null, txid: n }) {
  if (!n)
    throw new Error("txid is required");
  if (!o) {
    if (!this.arweave)
      throw new Error("Arweave is required");
    o = this.arweave;
  }
  try {
    let c = await o.api.get(`/${n}`, { responseType: "arraybuffer" });
    if (c.status >= 200 && c.status < 300)
      return new Uint8Array(c.data);
  } catch (c) {
    console.log("get Data failed", { txid: n }, c);
  }
}
var sha256$2 = {}, binary = {}, int = {};
(function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 }), o.mul = Math.imul || function(n, c) {
    var u = 65535 & n, h = 65535 & c;
    return u * h + ((n >>> 16 & 65535) * h + u * (c >>> 16 & 65535) << 16 >>> 0) | 0;
  }, o.add = function(n, c) {
    return n + c | 0;
  }, o.sub = function(n, c) {
    return n - c | 0;
  }, o.rotl = function(n, c) {
    return n << c | n >>> 32 - c;
  }, o.rotr = function(n, c) {
    return n << 32 - c | n >>> c;
  }, o.isInteger = Number.isInteger || function(n) {
    return typeof n == "number" && isFinite(n) && Math.floor(n) === n;
  }, o.MAX_SAFE_INTEGER = 9007199254740991, o.isSafeInteger = function(n) {
    return o.isInteger(n) && n >= -o.MAX_SAFE_INTEGER && n <= o.MAX_SAFE_INTEGER;
  };
})(int), Object.defineProperty(binary, "__esModule", { value: !0 });
var int_1 = int;
function readInt16BE(o, n) {
  return n === void 0 && (n = 0), (o[n + 0] << 8 | o[n + 1]) << 16 >> 16;
}
function readUint16BE(o, n) {
  return n === void 0 && (n = 0), (o[n + 0] << 8 | o[n + 1]) >>> 0;
}
function readInt16LE(o, n) {
  return n === void 0 && (n = 0), (o[n + 1] << 8 | o[n]) << 16 >> 16;
}
function readUint16LE(o, n) {
  return n === void 0 && (n = 0), (o[n + 1] << 8 | o[n]) >>> 0;
}
function writeUint16BE(o, n, c) {
  return n === void 0 && (n = new Uint8Array(2)), c === void 0 && (c = 0), n[c + 0] = o >>> 8, n[c + 1] = o >>> 0, n;
}
function writeUint16LE(o, n, c) {
  return n === void 0 && (n = new Uint8Array(2)), c === void 0 && (c = 0), n[c + 0] = o >>> 0, n[c + 1] = o >>> 8, n;
}
function readInt32BE(o, n) {
  return n === void 0 && (n = 0), o[n] << 24 | o[n + 1] << 16 | o[n + 2] << 8 | o[n + 3];
}
function readUint32BE(o, n) {
  return n === void 0 && (n = 0), (o[n] << 24 | o[n + 1] << 16 | o[n + 2] << 8 | o[n + 3]) >>> 0;
}
function readInt32LE(o, n) {
  return n === void 0 && (n = 0), o[n + 3] << 24 | o[n + 2] << 16 | o[n + 1] << 8 | o[n];
}
function readUint32LE(o, n) {
  return n === void 0 && (n = 0), (o[n + 3] << 24 | o[n + 2] << 16 | o[n + 1] << 8 | o[n]) >>> 0;
}
function writeUint32BE(o, n, c) {
  return n === void 0 && (n = new Uint8Array(4)), c === void 0 && (c = 0), n[c + 0] = o >>> 24, n[c + 1] = o >>> 16, n[c + 2] = o >>> 8, n[c + 3] = o >>> 0, n;
}
function writeUint32LE(o, n, c) {
  return n === void 0 && (n = new Uint8Array(4)), c === void 0 && (c = 0), n[c + 0] = o >>> 0, n[c + 1] = o >>> 8, n[c + 2] = o >>> 16, n[c + 3] = o >>> 24, n;
}
function readInt64BE(o, n) {
  n === void 0 && (n = 0);
  var c = readInt32BE(o, n), u = readInt32BE(o, n + 4);
  return 4294967296 * c + u - 4294967296 * (u >> 31);
}
function readUint64BE(o, n) {
  return n === void 0 && (n = 0), 4294967296 * readUint32BE(o, n) + readUint32BE(o, n + 4);
}
function readInt64LE(o, n) {
  n === void 0 && (n = 0);
  var c = readInt32LE(o, n);
  return 4294967296 * readInt32LE(o, n + 4) + c - 4294967296 * (c >> 31);
}
function readUint64LE(o, n) {
  n === void 0 && (n = 0);
  var c = readUint32LE(o, n);
  return 4294967296 * readUint32LE(o, n + 4) + c;
}
function writeUint64BE(o, n, c) {
  return n === void 0 && (n = new Uint8Array(8)), c === void 0 && (c = 0), writeUint32BE(o / 4294967296 >>> 0, n, c), writeUint32BE(o >>> 0, n, c + 4), n;
}
function writeUint64LE(o, n, c) {
  return n === void 0 && (n = new Uint8Array(8)), c === void 0 && (c = 0), writeUint32LE(o >>> 0, n, c), writeUint32LE(o / 4294967296 >>> 0, n, c + 4), n;
}
function readUintBE(o, n, c) {
  if (c === void 0 && (c = 0), o % 8 != 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (o / 8 > n.length - c)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var u = 0, h = 1, g = o / 8 + c - 1; g >= c; g--)
    u += n[g] * h, h *= 256;
  return u;
}
function readUintLE(o, n, c) {
  if (c === void 0 && (c = 0), o % 8 != 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (o / 8 > n.length - c)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var u = 0, h = 1, g = c; g < c + o / 8; g++)
    u += n[g] * h, h *= 256;
  return u;
}
function writeUintBE(o, n, c, u) {
  if (c === void 0 && (c = new Uint8Array(o / 8)), u === void 0 && (u = 0), o % 8 != 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(n))
    throw new Error("writeUintBE value must be an integer");
  for (var h = 1, g = o / 8 + u - 1; g >= u; g--)
    c[g] = n / h & 255, h *= 256;
  return c;
}
function writeUintLE(o, n, c, u) {
  if (c === void 0 && (c = new Uint8Array(o / 8)), u === void 0 && (u = 0), o % 8 != 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(n))
    throw new Error("writeUintLE value must be an integer");
  for (var h = 1, g = u; g < u + o / 8; g++)
    c[g] = n / h & 255, h *= 256;
  return c;
}
function readFloat32BE(o, n) {
  return n === void 0 && (n = 0), new DataView(o.buffer, o.byteOffset, o.byteLength).getFloat32(n);
}
function readFloat32LE(o, n) {
  return n === void 0 && (n = 0), new DataView(o.buffer, o.byteOffset, o.byteLength).getFloat32(n, !0);
}
function readFloat64BE(o, n) {
  return n === void 0 && (n = 0), new DataView(o.buffer, o.byteOffset, o.byteLength).getFloat64(n);
}
function readFloat64LE(o, n) {
  return n === void 0 && (n = 0), new DataView(o.buffer, o.byteOffset, o.byteLength).getFloat64(n, !0);
}
function writeFloat32BE(o, n, c) {
  return n === void 0 && (n = new Uint8Array(4)), c === void 0 && (c = 0), new DataView(n.buffer, n.byteOffset, n.byteLength).setFloat32(c, o), n;
}
function writeFloat32LE(o, n, c) {
  return n === void 0 && (n = new Uint8Array(4)), c === void 0 && (c = 0), new DataView(n.buffer, n.byteOffset, n.byteLength).setFloat32(c, o, !0), n;
}
function writeFloat64BE(o, n, c) {
  return n === void 0 && (n = new Uint8Array(8)), c === void 0 && (c = 0), new DataView(n.buffer, n.byteOffset, n.byteLength).setFloat64(c, o), n;
}
function writeFloat64LE(o, n, c) {
  return n === void 0 && (n = new Uint8Array(8)), c === void 0 && (c = 0), new DataView(n.buffer, n.byteOffset, n.byteLength).setFloat64(c, o, !0), n;
}
binary.readInt16BE = readInt16BE, binary.readUint16BE = readUint16BE, binary.readInt16LE = readInt16LE, binary.readUint16LE = readUint16LE, binary.writeUint16BE = writeUint16BE, binary.writeInt16BE = writeUint16BE, binary.writeUint16LE = writeUint16LE, binary.writeInt16LE = writeUint16LE, binary.readInt32BE = readInt32BE, binary.readUint32BE = readUint32BE, binary.readInt32LE = readInt32LE, binary.readUint32LE = readUint32LE, binary.writeUint32BE = writeUint32BE, binary.writeInt32BE = writeUint32BE, binary.writeUint32LE = writeUint32LE, binary.writeInt32LE = writeUint32LE, binary.readInt64BE = readInt64BE, binary.readUint64BE = readUint64BE, binary.readInt64LE = readInt64LE, binary.readUint64LE = readUint64LE, binary.writeUint64BE = writeUint64BE, binary.writeInt64BE = writeUint64BE, binary.writeUint64LE = writeUint64LE, binary.writeInt64LE = writeUint64LE, binary.readUintBE = readUintBE, binary.readUintLE = readUintLE, binary.writeUintBE = writeUintBE, binary.writeUintLE = writeUintLE, binary.readFloat32BE = readFloat32BE, binary.readFloat32LE = readFloat32LE, binary.readFloat64BE = readFloat64BE, binary.readFloat64LE = readFloat64LE, binary.writeFloat32BE = writeFloat32BE, binary.writeFloat32LE = writeFloat32LE, binary.writeFloat64BE = writeFloat64BE, binary.writeFloat64LE = writeFloat64LE;
var wipe$1 = {};
function wipe(o) {
  for (var n = 0; n < o.length; n++)
    o[n] = 0;
  return o;
}
function getArweaveAddress(o) {
  const n = decodeURLSafe_1(o.n), c = sha256$2.hash(n);
  return encodeURLSafe_1(new Uint8Array(c)).replace("=", "");
}
function isDID(o) {
  const n = typeof o == "string" && o.startsWith("did:ar");
  return console.log("isDID", n), n;
}
function isAddress(o) {
  return typeof o == "string" && o.length === 43;
}
async function fromDid(o) {
  const n = await init({ inMemory: !0 });
  return console.log("arnsInstance", n), await n.resolveDID(o);
}
Object.defineProperty(wipe$1, "__esModule", { value: !0 }), wipe$1.wipe = wipe, function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 });
  var n = binary, c = wipe$1;
  o.DIGEST_LENGTH = 32, o.BLOCK_SIZE = 64;
  var u = function() {
    function y() {
      this.digestLength = o.DIGEST_LENGTH, this.blockSize = o.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
    }
    return y.prototype._initState = function() {
      this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
    }, y.prototype.reset = function() {
      return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
    }, y.prototype.clean = function() {
      c.wipe(this._buffer), c.wipe(this._temp), this.reset();
    }, y.prototype.update = function($, I) {
      if (I === void 0 && (I = $.length), this._finished)
        throw new Error("SHA256: can't update because hash was finished.");
      var P = 0;
      if (this._bytesHashed += I, this._bufferLength > 0) {
        for (; this._bufferLength < this.blockSize && I > 0; )
          this._buffer[this._bufferLength++] = $[P++], I--;
        this._bufferLength === this.blockSize && (g(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
      }
      for (I >= this.blockSize && (P = g(this._temp, this._state, $, P, I), I %= this.blockSize); I > 0; )
        this._buffer[this._bufferLength++] = $[P++], I--;
      return this;
    }, y.prototype.finish = function($) {
      if (!this._finished) {
        var I = this._bytesHashed, P = this._bufferLength, L = I / 536870912 | 0, q = I << 3, N = I % 64 < 56 ? 64 : 128;
        this._buffer[P] = 128;
        for (var X = P + 1; X < N - 8; X++)
          this._buffer[X] = 0;
        n.writeUint32BE(L, this._buffer, N - 8), n.writeUint32BE(q, this._buffer, N - 4), g(this._temp, this._state, this._buffer, 0, N), this._finished = !0;
      }
      for (X = 0; X < this.digestLength / 4; X++)
        n.writeUint32BE(this._state[X], $, 4 * X);
      return this;
    }, y.prototype.digest = function() {
      var $ = new Uint8Array(this.digestLength);
      return this.finish($), $;
    }, y.prototype.saveState = function() {
      if (this._finished)
        throw new Error("SHA256: cannot save finished state");
      return { state: new Int32Array(this._state), buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0, bufferLength: this._bufferLength, bytesHashed: this._bytesHashed };
    }, y.prototype.restoreState = function($) {
      return this._state.set($.state), this._bufferLength = $.bufferLength, $.buffer && this._buffer.set($.buffer), this._bytesHashed = $.bytesHashed, this._finished = !1, this;
    }, y.prototype.cleanSavedState = function($) {
      c.wipe($.state), $.buffer && c.wipe($.buffer), $.bufferLength = 0, $.bytesHashed = 0;
    }, y;
  }();
  o.SHA256 = u;
  var h = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
  function g(y, $, I, P, L) {
    for (; L >= 64; ) {
      for (var q = $[0], N = $[1], X = $[2], rt = $[3], nt = $[4], st = $[5], ot = $[6], St = $[7], Ct = 0; Ct < 16; Ct++) {
        var et = P + 4 * Ct;
        y[Ct] = n.readUint32BE(I, et);
      }
      for (Ct = 16; Ct < 64; Ct++) {
        var at = y[Ct - 2], _t = (at >>> 17 | at << 15) ^ (at >>> 19 | at << 13) ^ at >>> 10, Nt = ((at = y[Ct - 15]) >>> 7 | at << 25) ^ (at >>> 18 | at << 14) ^ at >>> 3;
        y[Ct] = (_t + y[Ct - 7] | 0) + (Nt + y[Ct - 16] | 0);
      }
      for (Ct = 0; Ct < 64; Ct++)
        _t = (((nt >>> 6 | nt << 26) ^ (nt >>> 11 | nt << 21) ^ (nt >>> 25 | nt << 7)) + (nt & st ^ ~nt & ot) | 0) + (St + (h[Ct] + y[Ct] | 0) | 0) | 0, Nt = ((q >>> 2 | q << 30) ^ (q >>> 13 | q << 19) ^ (q >>> 22 | q << 10)) + (q & N ^ q & X ^ N & X) | 0, St = ot, ot = st, st = nt, nt = rt + _t | 0, rt = X, X = N, N = q, q = _t + Nt | 0;
      $[0] += q, $[1] += N, $[2] += X, $[3] += rt, $[4] += nt, $[5] += st, $[6] += ot, $[7] += St, P += 64, L -= 64;
    }
    return P;
  }
  o.hash = function(y) {
    var $ = new u();
    $.update(y);
    var I = $.digest();
    return $.clean(), I;
  };
}(sha256$2);
const arweaveConfig = { host: "arweave.net", port: 443, protocol: "https", timeout: 2e4, logging: !1 };
function create_if_block$1(o) {
  let n, c, u, h;
  const g = [create_if_block_1, create_else_block], y = [];
  function $(I, P) {
    var L, q;
    return (q = (L = I[1]) == null ? void 0 : L.meta) != null && q.networkRequired ? 0 : 1;
  }
  return n = $(o), c = y[n] = g[n](o), { c() {
    c.c(), u = empty$1();
  }, m(I, P) {
    y[n].m(I, P), insert(I, u, P), h = !0;
  }, p(I, P) {
    let L = n;
    n = $(I), n === L ? y[n].p(I, P) : (group_outros(), transition_out(y[L], 1, 1, () => {
      y[L] = null;
    }), check_outros(), c = y[n], c ? c.p(I, P) : (c = y[n] = g[n](I), c.c()), transition_in(c, 1), c.m(u.parentNode, u));
  }, i(I) {
    h || (transition_in(c), h = !0);
  }, o(I) {
    transition_out(c), h = !1;
  }, d(I) {
    y[n].d(I), I && detach(u);
  } };
}
function create_else_block(o) {
  let n, c, u;
  var h = o[0];
  function g(y) {
    return { props: { esModule: y[2], props: y[3] } };
  }
  return h && (n = construct_svelte_component(h, g(o)), n.$on("change", o[12])), { c() {
    n && create_component(n.$$.fragment), c = empty$1();
  }, m(y, $) {
    n && mount_component(n, y, $), insert(y, c, $), u = !0;
  }, p(y, $) {
    const I = {};
    if (4 & $ && (I.esModule = y[2]), 8 & $ && (I.props = y[3]), h !== (h = y[0])) {
      if (n) {
        group_outros();
        const P = n;
        transition_out(P.$$.fragment, 1, 0, () => {
          destroy_component(P, 1);
        }), check_outros();
      }
      h ? (n = construct_svelte_component(h, g(y)), n.$on("change", y[12]), create_component(n.$$.fragment), transition_in(n.$$.fragment, 1), mount_component(n, c.parentNode, c)) : n = null;
    } else
      h && n.$set(I);
  }, i(y) {
    u || (n && transition_in(n.$$.fragment, y), u = !0);
  }, o(y) {
    n && transition_out(n.$$.fragment, y), u = !1;
  }, d(y) {
    y && detach(c), n && destroy_component(n, y);
  } };
}
function create_if_block_1(o) {
  let n, c;
  return n = new Mount({ props: { src: o[2], props: o[3] } }), n.$on("target", o[8]), n.$on("ready", o[9]), n.$on("mounted", o[10]), n.$on("change", o[11]), { c() {
    create_component(n.$$.fragment);
  }, m(u, h) {
    mount_component(n, u, h), c = !0;
  }, p(u, h) {
    const g = {};
    4 & h && (g.src = u[2]), 8 & h && (g.props = u[3]), n.$set(g);
  }, i(u) {
    c || (transition_in(n.$$.fragment, u), c = !0);
  }, o(u) {
    transition_out(n.$$.fragment, u), c = !1;
  }, d(u) {
    destroy_component(n, u);
  } };
}
function create_fragment$4(o) {
  let n, c, u = o[0] && (o[2] || o[3] && o[2]) && create_if_block$1(o);
  return { c() {
    u && u.c(), n = empty$1();
  }, m(h, g) {
    u && u.m(h, g), insert(h, n, g), c = !0;
  }, p(h, [g]) {
    h[0] && (h[2] || h[3] && h[2]) ? u ? (u.p(h, g), 13 & g && transition_in(u, 1)) : (u = create_if_block$1(h), u.c(), transition_in(u, 1), u.m(n.parentNode, n)) : u && (group_outros(), transition_out(u, 1, 1, () => {
      u = null;
    }), check_outros());
  }, i(h) {
    c || (transition_in(u), c = !0);
  }, o(h) {
    transition_out(u), c = !1;
  }, d(h) {
    u && u.d(h), h && detach(n);
  } };
}
function instance$4(o, n, c) {
  let u, h, g, y, $, I, { namespace: P } = n, { tag: L } = n, { arweave: q = null } = n, { arweaveConfig: N = arweaveConfig } = n;
  return onMount(async () => {
    const X = new RegExp("^[a-zA-Z0-9_-]+$");
    if (!new RegExp("^.*(^[^/]+.ar|^[^/]+.arweave.dev|^[a-zA-Z0-9_-]{43}|^did:ar.*:[a-zA-Z0-9_-]{43})$").test(P) && !X.test(P))
      throw new Error(`Invalid namespace: ${P}. Must be a valid arweave address, name.ar, name.arweave.dev address, or did:ar address.`);
    if (c(0, { Gateway: g } = await Promise.resolve().then(() => index), g), u || globalThis.dag)
      u = globalThis.dag;
    else {
      const { createDagRepo: nt } = await Promise.resolve().then(() => index$3);
      u = await nt({ persist: !1 }), globalThis.dag = u;
    }
    let rt;
    if (isAddress(P))
      rt = [P];
    else {
      let nt;
      try {
        nt = isDID(P) ? await fromDid(P) : await arnsResolver(P.replace(/\.ar$|\.arweave\.dev$/, ""));
      } catch (ot) {
        console.log("Failed to resolve", P, ot);
      }
      const st = nt.verificationMethod.filter((ot) => ot.publicKeyJwk.kty === "RSA");
      if (!st.length)
        throw new Error("No RSA keys found in DID document");
      rt = st.map((ot) => getArweaveAddress(ot.publicKeyJwk));
    }
    c(4, q = q || Arweave.init(N)), h = initializeArDag({ arweave: q });
    for (const nt of rt)
      try {
        const st = await h.getInstance({ dag: u, dagOwner: nt });
        async function ot(St) {
          var et, at;
          if (!y[St])
            return null;
          let Ct;
          try {
            Ct = (at = (et = await u.get(y[St])) == null ? void 0 : et.value) == null ? void 0 : at.value;
          } catch {
            console.log("No props given. Set as null."), Ct = null;
          }
          return Ct;
        }
        c(1, y = await st.latest(L)), (y == null ? void 0 : y.dappowner) && y.dappowner !== nt && (console.log("Using another person's app, load it into the dag so the CID is present"), await h.load({ dagOwner: y.dappowner, dag: u })), c(2, $ = await ot("compiled")), c(3, I = await ot("data")), console.log({ esModule: $, props: I });
        break;
      } catch (st) {
        console.log(`No ArDag on address ${nt}`, st);
      }
  }), o.$$set = (X) => {
    "namespace" in X && c(5, P = X.namespace), "tag" in X && c(6, L = X.tag), "arweave" in X && c(4, q = X.arweave), "arweaveConfig" in X && c(7, N = X.arweaveConfig);
  }, [g, y, $, I, q, P, L, N, function(X) {
    bubble.call(this, o, X);
  }, function(X) {
    bubble.call(this, o, X);
  }, function(X) {
    bubble.call(this, o, X);
  }, function(X) {
    bubble.call(this, o, X);
  }, function(X) {
    bubble.call(this, o, X);
  }];
}
class NameTag extends SvelteComponent {
  constructor(n) {
    super(), init$1(this, n, instance$4, create_fragment$4, safe_not_equal, { namespace: 5, tag: 6, arweave: 4, arweaveConfig: 7 });
  }
}
var cjs = {}, ConsoleLogger$1 = {}, LoggerSettings = {};
(function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 }), o.lvlToOrder = o.LogLevelOrder = void 0, o.LogLevelOrder = { silly: 0, trace: 1, debug: 2, info: 3, warn: 4, error: 5, fatal: 6, none: 7 }, o.lvlToOrder = function(n) {
    return o.LogLevelOrder[n];
  };
})(LoggerSettings), Object.defineProperty(ConsoleLogger$1, "__esModule", { value: !0 }), ConsoleLogger$1.ConsoleLogger = void 0;
const LoggerSettings_1 = LoggerSettings;
class ConsoleLogger {
  constructor(n, c) {
    this.moduleName = n, this.settings = c;
  }
  trace(n, ...c) {
    this.shouldLog("trace") && console.debug(this.message("trace", n), c);
  }
  error(n, ...c) {
    this.shouldLog("error") && console.error(this.message("error", n), c);
  }
  info(n, ...c) {
    this.shouldLog("info") && console.info(this.message("info", n), c);
  }
  silly(n, ...c) {
    this.shouldLog("silly") && console.debug(this.message("silly", n), c);
  }
  debug(n, ...c) {
    this.shouldLog("debug") && console.debug(this.message("debug", n), c);
  }
  warn(n, ...c) {
    this.shouldLog("warn") && console.warn(this.message("warn", n), c);
  }
  log(n, ...c) {
    this.shouldLog("info") && console.info(this.message("info", n), c);
  }
  fatal(n, ...c) {
    this.shouldLog("fatal") && console.error(this.message("fatal", n), c);
  }
  shouldLog(n) {
    return (0, LoggerSettings_1.lvlToOrder)(n) >= (0, LoggerSettings_1.lvlToOrder)(this.settings.minLevel);
  }
  setSettings(n) {
    this.settings = n;
  }
  message(n, c) {
    return `${new Date().toISOString()} ${n.toUpperCase()} [${this.moduleName}] ${c}`;
  }
}
ConsoleLogger$1.ConsoleLogger = ConsoleLogger;
var ConsoleLoggerFactory$1 = {};
Object.defineProperty(ConsoleLoggerFactory$1, "__esModule", { value: !0 }), ConsoleLoggerFactory$1.ConsoleLoggerFactory = void 0;
const ConsoleLogger_1 = ConsoleLogger$1;
class ConsoleLoggerFactory {
  constructor() {
    this.registeredLoggers = {}, this.registeredOptions = {}, this.defOptions = { minLevel: "info" }, this.setOptions = this.setOptions.bind(this), this.getOptions = this.getOptions.bind(this), this.create = this.create.bind(this), this.logLevel = this.logLevel.bind(this);
  }
  setOptions(n, c) {
    c ? this.registeredLoggers[c] ? this.registeredLoggers[c].setSettings({ ...this.registeredLoggers[c].settings, ...n }) : this.registeredOptions[c] = { ...this.defOptions, ...n } : (this.defOptions = n, Object.keys(this.registeredLoggers).forEach((u) => {
      this.registeredLoggers[u].setSettings({ ...this.registeredLoggers[u].settings, ...n });
    }));
  }
  getOptions(n) {
    return n ? this.registeredLoggers[n] ? this.registeredLoggers[n].settings : this.registeredOptions[n] ? this.registeredOptions[n] : this.defOptions : this.defOptions;
  }
  logLevel(n, c) {
    this.setOptions({ minLevel: n }, c);
  }
  create(n = "SWC") {
    return Object.prototype.hasOwnProperty.call(this.registeredLoggers, n) || (this.registeredLoggers[n] = new ConsoleLogger_1.ConsoleLogger(n, this.getOptions(n))), this.registeredLoggers[n];
  }
}
ConsoleLoggerFactory$1.ConsoleLoggerFactory = ConsoleLoggerFactory;
var WarpLogger = {};
Object.defineProperty(WarpLogger, "__esModule", { value: !0 });
var LoggerFactory$1 = {};
Object.defineProperty(LoggerFactory$1, "__esModule", { value: !0 }), LoggerFactory$1.LoggerFactory = void 0;
const ConsoleLoggerFactory_1 = ConsoleLoggerFactory$1;
class LoggerFactory {
  constructor() {
  }
  setOptions(n, c) {
    LoggerFactory.INST.setOptions(n, c);
  }
  getOptions(n) {
    return LoggerFactory.INST.getOptions(n);
  }
  logLevel(n, c) {
    LoggerFactory.INST.logLevel(n, c);
  }
  create(n) {
    return LoggerFactory.INST.create(n);
  }
  static use(n) {
    LoggerFactory.INST = n;
  }
}
LoggerFactory$1.LoggerFactory = LoggerFactory, LoggerFactory.INST = new ConsoleLoggerFactory_1.ConsoleLoggerFactory();
var Benchmark$1 = {};
Object.defineProperty(Benchmark$1, "__esModule", { value: !0 }), Benchmark$1.Benchmark = void 0;
class Benchmark {
  constructor() {
    this.start = Date.now(), this.end = null;
  }
  static measure() {
    return new Benchmark();
  }
  reset() {
    this.start = Date.now(), this.end = null;
  }
  stop() {
    this.end = Date.now();
  }
  elapsed(n = !1) {
    this.end === null && (this.end = Date.now());
    const c = this.end - this.start;
    return n ? c : `${(this.end - this.start).toFixed(0)}ms`;
  }
}
Benchmark$1.Benchmark = Benchmark;
var DefinitionLoader = {};
Object.defineProperty(DefinitionLoader, "__esModule", { value: !0 });
var ExecutorFactory = {};
Object.defineProperty(ExecutorFactory, "__esModule", { value: !0 });
var InteractionsLoader = {};
Object.defineProperty(InteractionsLoader, "__esModule", { value: !0 });
var InteractionsSorter = {};
Object.defineProperty(InteractionsSorter, "__esModule", { value: !0 });
var StateEvaluator = {};
Object.defineProperty(StateEvaluator, "__esModule", { value: !0 }), StateEvaluator.DefaultEvaluationOptions = StateEvaluator.EvalStateResult = void 0;
class EvalStateResult {
  constructor(n, c, u) {
    this.state = n, this.validity = c, this.errorMessages = u;
  }
}
StateEvaluator.EvalStateResult = EvalStateResult;
class DefaultEvaluationOptions {
  constructor() {
    this.ignoreExceptions = !0, this.waitForConfirmation = !1, this.updateCacheForEachInteraction = !1, this.internalWrites = !1, this.maxCallDepth = 7, this.maxInteractionEvaluationTimeSeconds = 60, this.stackTrace = { saveState: !1 }, this.bundlerUrl = "https://d1o5nlqr4okus2.cloudfront.net/", this.gasLimit = Number.MAX_SAFE_INTEGER, this.useFastCopy = !0, this.useVM2 = !1, this.allowUnsafeClient = !1, this.allowBigInt = !1, this.walletBalanceUrl = "http://nyc-1.dev.arweave.net:1984/", this.mineArLocalBlocks = !0, this.throwOnInternalWriteError = !0;
  }
}
StateEvaluator.DefaultEvaluationOptions = DefaultEvaluationOptions;
var ContractDefinitionLoader = {}, SmartWeaveTags = {};
(function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 }), o.SmartWeaveTags = void 0, function(n) {
    n.APP_NAME = "App-Name", n.APP_VERSION = "App-Version", n.CONTRACT_TX_ID = "Contract", n.INPUT = "Input", n.CONTENT_TYPE = "Content-Type", n.CONTRACT_SRC_TX_ID = "Contract-Src", n.SDK = "SDK", n.MIN_FEE = "Min-Fee", n.INIT_STATE = "Init-State", n.INIT_STATE_TX = "Init-State-TX", n.INTERACT_WRITE = "Interact-Write", n.WASM_LANG = "Wasm-Lang", n.WASM_LANG_VERSION = "Wasm-Lang-Version", n.WASM_META = "Wasm-Meta", n.REQUEST_VRF = "Request-Vrf";
  }(o.SmartWeaveTags || (o.SmartWeaveTags = {}));
})(SmartWeaveTags);
var utils$p = {};
function getTag$4(o, n) {
  const c = o.get("tags");
  for (const u of c)
    try {
      if (u.get("name", { decode: !0, string: !0 }) === n)
        return u.get("value", { decode: !0, string: !0 });
    } catch {
    }
  return !1;
}
function arrayToHex(o) {
  let n = "";
  for (const c of o)
    n += ("0" + c.toString(16)).slice(-2);
  return n;
}
Object.defineProperty(utils$p, "__esModule", { value: !0 }), utils$p.arrayToHex = utils$p.getTag = void 0, utils$p.getTag = getTag$4, utils$p.arrayToHex = arrayToHex;
var ArweaveWrapper = {}, transaction = {}, utils$o = {}, __createBinding$6 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, c, u) {
  u === void 0 && (u = c);
  var h = Object.getOwnPropertyDescriptor(n, c);
  h && !("get" in h ? !n.__esModule : h.writable || h.configurable) || (h = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(o, u, h);
} : function(o, n, c, u) {
  u === void 0 && (u = c), o[u] = n[c];
}), __setModuleDefault$6 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$6 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var c in o)
      c !== "default" && Object.prototype.hasOwnProperty.call(o, c) && __createBinding$6(n, o, c);
  return __setModuleDefault$6(n, o), n;
};
Object.defineProperty(utils$o, "__esModule", { value: !0 }), utils$o.b64UrlDecode = utils$o.b64UrlEncode = utils$o.bufferTob64Url = utils$o.bufferTob64 = utils$o.b64UrlToBuffer = utils$o.stringToB64Url = utils$o.stringToBuffer = utils$o.bufferToString = utils$o.b64UrlToString = utils$o.concatBuffers = void 0;
const B64js = __importStar$6(base64Js);
function concatBuffers(o) {
  let n = 0;
  for (let h = 0; h < o.length; h++)
    n += o[h].byteLength;
  let c = new Uint8Array(n), u = 0;
  c.set(new Uint8Array(o[0]), u), u += o[0].byteLength;
  for (let h = 1; h < o.length; h++)
    c.set(new Uint8Array(o[h]), u), u += o[h].byteLength;
  return c;
}
function b64UrlToString(o) {
  return bufferToString(b64UrlToBuffer(o));
}
function bufferToString(o) {
  return typeof TextDecoder > "u" ? new (requireUtil()).TextDecoder("utf-8", { fatal: !0 }).decode(o) : new TextDecoder("utf-8", { fatal: !0 }).decode(o);
}
function stringToBuffer(o) {
  return typeof TextEncoder > "u" ? new (requireUtil()).TextEncoder().encode(o) : new TextEncoder().encode(o);
}
function stringToB64Url(o) {
  return bufferTob64Url(stringToBuffer(o));
}
function b64UrlToBuffer(o) {
  return new Uint8Array(B64js.toByteArray(b64UrlDecode(o)));
}
function bufferTob64(o) {
  return B64js.fromByteArray(new Uint8Array(o));
}
function bufferTob64Url(o) {
  return b64UrlEncode(bufferTob64(o));
}
function b64UrlEncode(o) {
  return o.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
}
function b64UrlDecode(o) {
  let n;
  return n = (o = o.replace(/\-/g, "+").replace(/\_/g, "/")).length % 4 == 0 ? 0 : 4 - o.length % 4, o.concat("=".repeat(n));
}
utils$o.concatBuffers = concatBuffers, utils$o.b64UrlToString = b64UrlToString, utils$o.bufferToString = bufferToString, utils$o.stringToBuffer = stringToBuffer, utils$o.stringToB64Url = stringToB64Url, utils$o.b64UrlToBuffer = b64UrlToBuffer, utils$o.bufferTob64 = bufferTob64, utils$o.bufferTob64Url = bufferTob64Url, utils$o.b64UrlEncode = b64UrlEncode, utils$o.b64UrlDecode = b64UrlDecode;
var deepHash = {}, common$6 = {}, ar = {};
Object.defineProperty(ar, "__esModule", { value: !0 });
const bignumber_js_1$1 = bignumber.exports;
class Ar {
  constructor() {
    this.BigNum = (n, c) => new (bignumber_js_1$1.BigNumber.clone({ DECIMAL_PLACES: c }))(n);
  }
  winstonToAr(n, { formatted: c = !1, decimals: u = 12, trim: h = !0 } = {}) {
    let g = this.stringToBigNum(n, u).shiftedBy(-12);
    return c ? g.toFormat(u) : g.toFixed(u);
  }
  arToWinston(n, { formatted: c = !1 } = {}) {
    let u = this.stringToBigNum(n).shiftedBy(12);
    return c ? u.toFormat() : u.toFixed(0);
  }
  compare(n, c) {
    let u = this.stringToBigNum(n), h = this.stringToBigNum(c);
    return u.comparedTo(h);
  }
  isEqual(n, c) {
    return this.compare(n, c) === 0;
  }
  isLessThan(n, c) {
    let u = this.stringToBigNum(n), h = this.stringToBigNum(c);
    return u.isLessThan(h);
  }
  isGreaterThan(n, c) {
    let u = this.stringToBigNum(n), h = this.stringToBigNum(c);
    return u.isGreaterThan(h);
  }
  add(n, c) {
    let u = this.stringToBigNum(n);
    return this.stringToBigNum(c), u.plus(c).toFixed(0);
  }
  sub(n, c) {
    let u = this.stringToBigNum(n);
    return this.stringToBigNum(c), u.minus(c).toFixed(0);
  }
  stringToBigNum(n, c = 12) {
    return this.BigNum(n, c);
  }
}
ar.default = Ar;
var api$1 = {}, __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(api$1, "__esModule", { value: !0 });
const axios_1 = __importDefault$8(axios$3.exports);
class Api {
  constructor(n) {
    this.METHOD_GET = "GET", this.METHOD_POST = "POST", this.applyConfig(n);
  }
  applyConfig(n) {
    this.config = this.mergeDefaults(n);
  }
  getConfig() {
    return this.config;
  }
  mergeDefaults(n) {
    const c = n.protocol || "http", u = n.port || (c === "https" ? 443 : 80);
    return { host: n.host || "127.0.0.1", protocol: c, port: u, timeout: n.timeout || 2e4, logging: n.logging || !1, logger: n.logger || console.log, network: n.network };
  }
  async get(n, c) {
    try {
      return await this.request().get(n, c);
    } catch (u) {
      if (u.response && u.response.status)
        return u.response;
      throw u;
    }
  }
  async post(n, c, u) {
    try {
      return await this.request().post(n, c, u);
    } catch (h) {
      if (h.response && h.response.status)
        return h.response;
      throw h;
    }
  }
  request() {
    const n = {};
    this.config.network && (n["x-network"] = this.config.network);
    let c = axios_1.default.create({ baseURL: `${this.config.protocol}://${this.config.host}:${this.config.port}`, timeout: this.config.timeout, maxContentLength: 536870912, headers: n });
    return this.config.logging && (c.interceptors.request.use((u) => (this.config.logger(`Requesting: ${u.baseURL}/${u.url}`), u)), c.interceptors.response.use((u) => (this.config.logger(`Response:   ${u.config.url} - ${u.status}`), u))), c;
  }
}
api$1.default = Api;
var nodeDriver = {}, pem$2 = {}, asn1 = {}, bn$3 = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({ __proto__: null, default: __viteBrowserExternal }, Symbol.toStringTag, { value: "Module" })), require$$2$1 = getAugmentedNamespace(__viteBrowserExternal$1);
(function(o, n) {
  function c(m, A) {
    if (!m)
      throw new Error(A || "Assertion failed");
  }
  function u(m, A) {
    m.super_ = A;
    var E = function() {
    };
    E.prototype = A.prototype, m.prototype = new E(), m.prototype.constructor = m;
  }
  function h(m, A, E) {
    if (h.isBN(m))
      return m;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, m !== null && (A !== "le" && A !== "be" || (E = A, A = 10), this._init(m || 0, A || 10, E || "be"));
  }
  var g;
  typeof bn$3 == "object" ? bn$3.exports = h : n.BN = h, h.BN = h, h.wordSize = 26;
  try {
    g = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function y(m, A) {
    var E = m.charCodeAt(A);
    return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
  }
  function $(m, A, E) {
    var w = y(m, E);
    return E - 1 >= A && (w |= y(m, E - 1) << 4), w;
  }
  function I(m, A, E, w) {
    for (var v = 0, k = Math.min(m.length, E), O = A; O < k; O++) {
      var W = m.charCodeAt(O) - 48;
      v *= w, v += W >= 49 ? W - 49 + 10 : W >= 17 ? W - 17 + 10 : W;
    }
    return v;
  }
  h.isBN = function(m) {
    return m instanceof h || m !== null && typeof m == "object" && m.constructor.wordSize === h.wordSize && Array.isArray(m.words);
  }, h.max = function(m, A) {
    return m.cmp(A) > 0 ? m : A;
  }, h.min = function(m, A) {
    return m.cmp(A) < 0 ? m : A;
  }, h.prototype._init = function(m, A, E) {
    if (typeof m == "number")
      return this._initNumber(m, A, E);
    if (typeof m == "object")
      return this._initArray(m, A, E);
    A === "hex" && (A = 16), c(A === (0 | A) && A >= 2 && A <= 36);
    var w = 0;
    (m = m.toString().replace(/\s+/g, ""))[0] === "-" && (w++, this.negative = 1), w < m.length && (A === 16 ? this._parseHex(m, w, E) : (this._parseBase(m, A, w), E === "le" && this._initArray(this.toArray(), A, E)));
  }, h.prototype._initNumber = function(m, A, E) {
    m < 0 && (this.negative = 1, m = -m), m < 67108864 ? (this.words = [67108863 & m], this.length = 1) : m < 4503599627370496 ? (this.words = [67108863 & m, m / 67108864 & 67108863], this.length = 2) : (c(m < 9007199254740992), this.words = [67108863 & m, m / 67108864 & 67108863, 1], this.length = 3), E === "le" && this._initArray(this.toArray(), A, E);
  }, h.prototype._initArray = function(m, A, E) {
    if (c(typeof m.length == "number"), m.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(m.length / 3), this.words = new Array(this.length);
    for (var w = 0; w < this.length; w++)
      this.words[w] = 0;
    var v, k, O = 0;
    if (E === "be")
      for (w = m.length - 1, v = 0; w >= 0; w -= 3)
        k = m[w] | m[w - 1] << 8 | m[w - 2] << 16, this.words[v] |= k << O & 67108863, this.words[v + 1] = k >>> 26 - O & 67108863, (O += 24) >= 26 && (O -= 26, v++);
    else if (E === "le")
      for (w = 0, v = 0; w < m.length; w += 3)
        k = m[w] | m[w + 1] << 8 | m[w + 2] << 16, this.words[v] |= k << O & 67108863, this.words[v + 1] = k >>> 26 - O & 67108863, (O += 24) >= 26 && (O -= 26, v++);
    return this.strip();
  }, h.prototype._parseHex = function(m, A, E) {
    this.length = Math.ceil((m.length - A) / 6), this.words = new Array(this.length);
    for (var w = 0; w < this.length; w++)
      this.words[w] = 0;
    var v, k = 0, O = 0;
    if (E === "be")
      for (w = m.length - 1; w >= A; w -= 2)
        v = $(m, A, w) << k, this.words[O] |= 67108863 & v, k >= 18 ? (k -= 18, O += 1, this.words[O] |= v >>> 26) : k += 8;
    else
      for (w = (m.length - A) % 2 == 0 ? A + 1 : A; w < m.length; w += 2)
        v = $(m, A, w) << k, this.words[O] |= 67108863 & v, k >= 18 ? (k -= 18, O += 1, this.words[O] |= v >>> 26) : k += 8;
    this.strip();
  }, h.prototype._parseBase = function(m, A, E) {
    this.words = [0], this.length = 1;
    for (var w = 0, v = 1; v <= 67108863; v *= A)
      w++;
    w--, v = v / A | 0;
    for (var k = m.length - E, O = k % w, W = Math.min(k, k - O) + E, it = 0, vt = E; vt < W; vt += w)
      it = I(m, vt, vt + w, A), this.imuln(v), this.words[0] + it < 67108864 ? this.words[0] += it : this._iaddn(it);
    if (O !== 0) {
      var xt = 1;
      for (it = I(m, vt, m.length, A), vt = 0; vt < O; vt++)
        xt *= A;
      this.imuln(xt), this.words[0] + it < 67108864 ? this.words[0] += it : this._iaddn(it);
    }
    this.strip();
  }, h.prototype.copy = function(m) {
    m.words = new Array(this.length);
    for (var A = 0; A < this.length; A++)
      m.words[A] = this.words[A];
    m.length = this.length, m.negative = this.negative, m.red = this.red;
  }, h.prototype.clone = function() {
    var m = new h(null);
    return this.copy(m), m;
  }, h.prototype._expand = function(m) {
    for (; this.length < m; )
      this.words[this.length++] = 0;
    return this;
  }, h.prototype.strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, h.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, h.prototype.inspect = function() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  };
  var P = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], L = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function N(m, A, E) {
    E.negative = A.negative ^ m.negative;
    var w = m.length + A.length | 0;
    E.length = w, w = w - 1 | 0;
    var v = 0 | m.words[0], k = 0 | A.words[0], O = v * k, W = 67108863 & O, it = O / 67108864 | 0;
    E.words[0] = W;
    for (var vt = 1; vt < w; vt++) {
      for (var xt = it >>> 26, It = 67108863 & it, Wt = Math.min(vt, A.length - 1), Ut = Math.max(0, vt - m.length + 1); Ut <= Wt; Ut++) {
        var zt = vt - Ut | 0;
        xt += (O = (v = 0 | m.words[zt]) * (k = 0 | A.words[Ut]) + It) / 67108864 | 0, It = 67108863 & O;
      }
      E.words[vt] = 0 | It, it = 0 | xt;
    }
    return it !== 0 ? E.words[vt] = 0 | it : E.length--, E.strip();
  }
  h.prototype.toString = function(m, A) {
    var E;
    if (A = 0 | A || 1, (m = m || 10) === 16 || m === "hex") {
      E = "";
      for (var w = 0, v = 0, k = 0; k < this.length; k++) {
        var O = this.words[k], W = (16777215 & (O << w | v)).toString(16);
        E = (v = O >>> 24 - w & 16777215) != 0 || k !== this.length - 1 ? P[6 - W.length] + W + E : W + E, (w += 2) >= 26 && (w -= 26, k--);
      }
      for (v !== 0 && (E = v.toString(16) + E); E.length % A != 0; )
        E = "0" + E;
      return this.negative !== 0 && (E = "-" + E), E;
    }
    if (m === (0 | m) && m >= 2 && m <= 36) {
      var it = L[m], vt = q[m];
      E = "";
      var xt = this.clone();
      for (xt.negative = 0; !xt.isZero(); ) {
        var It = xt.modn(vt).toString(m);
        E = (xt = xt.idivn(vt)).isZero() ? It + E : P[it - It.length] + It + E;
      }
      for (this.isZero() && (E = "0" + E); E.length % A != 0; )
        E = "0" + E;
      return this.negative !== 0 && (E = "-" + E), E;
    }
    c(!1, "Base should be between 2 and 36");
  }, h.prototype.toNumber = function() {
    var m = this.words[0];
    return this.length === 2 ? m += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? m += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && c(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -m : m;
  }, h.prototype.toJSON = function() {
    return this.toString(16);
  }, h.prototype.toBuffer = function(m, A) {
    return c(g !== void 0), this.toArrayLike(g, m, A);
  }, h.prototype.toArray = function(m, A) {
    return this.toArrayLike(Array, m, A);
  }, h.prototype.toArrayLike = function(m, A, E) {
    var w = this.byteLength(), v = E || Math.max(1, w);
    c(w <= v, "byte array longer than desired length"), c(v > 0, "Requested array length <= 0"), this.strip();
    var k, O, W = A === "le", it = new m(v), vt = this.clone();
    if (W) {
      for (O = 0; !vt.isZero(); O++)
        k = vt.andln(255), vt.iushrn(8), it[O] = k;
      for (; O < v; O++)
        it[O] = 0;
    } else {
      for (O = 0; O < v - w; O++)
        it[O] = 0;
      for (O = 0; !vt.isZero(); O++)
        k = vt.andln(255), vt.iushrn(8), it[v - O - 1] = k;
    }
    return it;
  }, Math.clz32 ? h.prototype._countBits = function(m) {
    return 32 - Math.clz32(m);
  } : h.prototype._countBits = function(m) {
    var A = m, E = 0;
    return A >= 4096 && (E += 13, A >>>= 13), A >= 64 && (E += 7, A >>>= 7), A >= 8 && (E += 4, A >>>= 4), A >= 2 && (E += 2, A >>>= 2), E + A;
  }, h.prototype._zeroBits = function(m) {
    if (m === 0)
      return 26;
    var A = m, E = 0;
    return (8191 & A) == 0 && (E += 13, A >>>= 13), (127 & A) == 0 && (E += 7, A >>>= 7), (15 & A) == 0 && (E += 4, A >>>= 4), (3 & A) == 0 && (E += 2, A >>>= 2), (1 & A) == 0 && E++, E;
  }, h.prototype.bitLength = function() {
    var m = this.words[this.length - 1], A = this._countBits(m);
    return 26 * (this.length - 1) + A;
  }, h.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var m = 0, A = 0; A < this.length; A++) {
      var E = this._zeroBits(this.words[A]);
      if (m += E, E !== 26)
        break;
    }
    return m;
  }, h.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, h.prototype.toTwos = function(m) {
    return this.negative !== 0 ? this.abs().inotn(m).iaddn(1) : this.clone();
  }, h.prototype.fromTwos = function(m) {
    return this.testn(m - 1) ? this.notn(m).iaddn(1).ineg() : this.clone();
  }, h.prototype.isNeg = function() {
    return this.negative !== 0;
  }, h.prototype.neg = function() {
    return this.clone().ineg();
  }, h.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, h.prototype.iuor = function(m) {
    for (; this.length < m.length; )
      this.words[this.length++] = 0;
    for (var A = 0; A < m.length; A++)
      this.words[A] = this.words[A] | m.words[A];
    return this.strip();
  }, h.prototype.ior = function(m) {
    return c((this.negative | m.negative) == 0), this.iuor(m);
  }, h.prototype.or = function(m) {
    return this.length > m.length ? this.clone().ior(m) : m.clone().ior(this);
  }, h.prototype.uor = function(m) {
    return this.length > m.length ? this.clone().iuor(m) : m.clone().iuor(this);
  }, h.prototype.iuand = function(m) {
    var A;
    A = this.length > m.length ? m : this;
    for (var E = 0; E < A.length; E++)
      this.words[E] = this.words[E] & m.words[E];
    return this.length = A.length, this.strip();
  }, h.prototype.iand = function(m) {
    return c((this.negative | m.negative) == 0), this.iuand(m);
  }, h.prototype.and = function(m) {
    return this.length > m.length ? this.clone().iand(m) : m.clone().iand(this);
  }, h.prototype.uand = function(m) {
    return this.length > m.length ? this.clone().iuand(m) : m.clone().iuand(this);
  }, h.prototype.iuxor = function(m) {
    var A, E;
    this.length > m.length ? (A = this, E = m) : (A = m, E = this);
    for (var w = 0; w < E.length; w++)
      this.words[w] = A.words[w] ^ E.words[w];
    if (this !== A)
      for (; w < A.length; w++)
        this.words[w] = A.words[w];
    return this.length = A.length, this.strip();
  }, h.prototype.ixor = function(m) {
    return c((this.negative | m.negative) == 0), this.iuxor(m);
  }, h.prototype.xor = function(m) {
    return this.length > m.length ? this.clone().ixor(m) : m.clone().ixor(this);
  }, h.prototype.uxor = function(m) {
    return this.length > m.length ? this.clone().iuxor(m) : m.clone().iuxor(this);
  }, h.prototype.inotn = function(m) {
    c(typeof m == "number" && m >= 0);
    var A = 0 | Math.ceil(m / 26), E = m % 26;
    this._expand(A), E > 0 && A--;
    for (var w = 0; w < A; w++)
      this.words[w] = 67108863 & ~this.words[w];
    return E > 0 && (this.words[w] = ~this.words[w] & 67108863 >> 26 - E), this.strip();
  }, h.prototype.notn = function(m) {
    return this.clone().inotn(m);
  }, h.prototype.setn = function(m, A) {
    c(typeof m == "number" && m >= 0);
    var E = m / 26 | 0, w = m % 26;
    return this._expand(E + 1), this.words[E] = A ? this.words[E] | 1 << w : this.words[E] & ~(1 << w), this.strip();
  }, h.prototype.iadd = function(m) {
    var A, E, w;
    if (this.negative !== 0 && m.negative === 0)
      return this.negative = 0, A = this.isub(m), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && m.negative !== 0)
      return m.negative = 0, A = this.isub(m), m.negative = 1, A._normSign();
    this.length > m.length ? (E = this, w = m) : (E = m, w = this);
    for (var v = 0, k = 0; k < w.length; k++)
      A = (0 | E.words[k]) + (0 | w.words[k]) + v, this.words[k] = 67108863 & A, v = A >>> 26;
    for (; v !== 0 && k < E.length; k++)
      A = (0 | E.words[k]) + v, this.words[k] = 67108863 & A, v = A >>> 26;
    if (this.length = E.length, v !== 0)
      this.words[this.length] = v, this.length++;
    else if (E !== this)
      for (; k < E.length; k++)
        this.words[k] = E.words[k];
    return this;
  }, h.prototype.add = function(m) {
    var A;
    return m.negative !== 0 && this.negative === 0 ? (m.negative = 0, A = this.sub(m), m.negative ^= 1, A) : m.negative === 0 && this.negative !== 0 ? (this.negative = 0, A = m.sub(this), this.negative = 1, A) : this.length > m.length ? this.clone().iadd(m) : m.clone().iadd(this);
  }, h.prototype.isub = function(m) {
    if (m.negative !== 0) {
      m.negative = 0;
      var A = this.iadd(m);
      return m.negative = 1, A._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(m), this.negative = 1, this._normSign();
    var E, w, v = this.cmp(m);
    if (v === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    v > 0 ? (E = this, w = m) : (E = m, w = this);
    for (var k = 0, O = 0; O < w.length; O++)
      k = (A = (0 | E.words[O]) - (0 | w.words[O]) + k) >> 26, this.words[O] = 67108863 & A;
    for (; k !== 0 && O < E.length; O++)
      k = (A = (0 | E.words[O]) + k) >> 26, this.words[O] = 67108863 & A;
    if (k === 0 && O < E.length && E !== this)
      for (; O < E.length; O++)
        this.words[O] = E.words[O];
    return this.length = Math.max(this.length, O), E !== this && (this.negative = 1), this.strip();
  }, h.prototype.sub = function(m) {
    return this.clone().isub(m);
  };
  var X = function(m, A, E) {
    var w, v, k, O = m.words, W = A.words, it = E.words, vt = 0, xt = 0 | O[0], It = 8191 & xt, Wt = xt >>> 13, Ut = 0 | O[1], zt = 8191 & Ut, Jt = Ut >>> 13, Xt = 0 | O[2], ie = 8191 & Xt, oe = Xt >>> 13, De = 0 | O[3], ue = 8191 & De, xe = De >>> 13, se = 0 | O[4], he = 8191 & se, je = se >>> 13, jr = 0 | O[5], de = 8191 & jr, We = jr >>> 13, B = 0 | O[6], j = 8191 & B, Z = B >>> 13, kt = 0 | O[7], $t = 8191 & kt, At = kt >>> 13, Bt = 0 | O[8], Ft = 8191 & Bt, Kt = Bt >>> 13, Zt = 0 | O[9], Gt = 8191 & Zt, Qt = Zt >>> 13, Ae = 0 | W[0], ae = 8191 & Ae, we = Ae >>> 13, ir = 0 | W[1], ge = 8191 & ir, _e = ir >>> 13, rr = 0 | W[2], be = 8191 & rr, Ge = rr >>> 13, Rr = 0 | W[3], Te = 8191 & Rr, Ie = Rr >>> 13, Pr = 0 | W[4], Ee = 8191 & Pr, er = Pr >>> 13, Or = 0 | W[5], Ve = 8191 & Or, sr = Or >>> 13, qr = 0 | W[6], Je = 8191 & qr, ur = qr >>> 13, Kr = 0 | W[7], Ze = 8191 & Kr, vr = Kr >>> 13, Hr = 0 | W[8], Ye = 8191 & Hr, _r = Hr >>> 13, zr = 0 | W[9], tr = 8191 & zr, Mr = zr >>> 13;
    E.negative = m.negative ^ A.negative, E.length = 19;
    var Ur = (vt + (w = Math.imul(It, ae)) | 0) + ((8191 & (v = (v = Math.imul(It, we)) + Math.imul(Wt, ae) | 0)) << 13) | 0;
    vt = ((k = Math.imul(Wt, we)) + (v >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, w = Math.imul(zt, ae), v = (v = Math.imul(zt, we)) + Math.imul(Jt, ae) | 0, k = Math.imul(Jt, we);
    var Fr = (vt + (w = w + Math.imul(It, ge) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, _e) | 0) + Math.imul(Wt, ge) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, _e) | 0) + (v >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, w = Math.imul(ie, ae), v = (v = Math.imul(ie, we)) + Math.imul(oe, ae) | 0, k = Math.imul(oe, we), w = w + Math.imul(zt, ge) | 0, v = (v = v + Math.imul(zt, _e) | 0) + Math.imul(Jt, ge) | 0, k = k + Math.imul(Jt, _e) | 0;
    var Zr = (vt + (w = w + Math.imul(It, be) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, Ge) | 0) + Math.imul(Wt, be) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, Ge) | 0) + (v >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, w = Math.imul(ue, ae), v = (v = Math.imul(ue, we)) + Math.imul(xe, ae) | 0, k = Math.imul(xe, we), w = w + Math.imul(ie, ge) | 0, v = (v = v + Math.imul(ie, _e) | 0) + Math.imul(oe, ge) | 0, k = k + Math.imul(oe, _e) | 0, w = w + Math.imul(zt, be) | 0, v = (v = v + Math.imul(zt, Ge) | 0) + Math.imul(Jt, be) | 0, k = k + Math.imul(Jt, Ge) | 0;
    var Qr = (vt + (w = w + Math.imul(It, Te) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, Ie) | 0) + Math.imul(Wt, Te) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, Ie) | 0) + (v >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, w = Math.imul(he, ae), v = (v = Math.imul(he, we)) + Math.imul(je, ae) | 0, k = Math.imul(je, we), w = w + Math.imul(ue, ge) | 0, v = (v = v + Math.imul(ue, _e) | 0) + Math.imul(xe, ge) | 0, k = k + Math.imul(xe, _e) | 0, w = w + Math.imul(ie, be) | 0, v = (v = v + Math.imul(ie, Ge) | 0) + Math.imul(oe, be) | 0, k = k + Math.imul(oe, Ge) | 0, w = w + Math.imul(zt, Te) | 0, v = (v = v + Math.imul(zt, Ie) | 0) + Math.imul(Jt, Te) | 0, k = k + Math.imul(Jt, Ie) | 0;
    var Xr = (vt + (w = w + Math.imul(It, Ee) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, er) | 0) + Math.imul(Wt, Ee) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, er) | 0) + (v >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, w = Math.imul(de, ae), v = (v = Math.imul(de, we)) + Math.imul(We, ae) | 0, k = Math.imul(We, we), w = w + Math.imul(he, ge) | 0, v = (v = v + Math.imul(he, _e) | 0) + Math.imul(je, ge) | 0, k = k + Math.imul(je, _e) | 0, w = w + Math.imul(ue, be) | 0, v = (v = v + Math.imul(ue, Ge) | 0) + Math.imul(xe, be) | 0, k = k + Math.imul(xe, Ge) | 0, w = w + Math.imul(ie, Te) | 0, v = (v = v + Math.imul(ie, Ie) | 0) + Math.imul(oe, Te) | 0, k = k + Math.imul(oe, Ie) | 0, w = w + Math.imul(zt, Ee) | 0, v = (v = v + Math.imul(zt, er) | 0) + Math.imul(Jt, Ee) | 0, k = k + Math.imul(Jt, er) | 0;
    var Yr = (vt + (w = w + Math.imul(It, Ve) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, sr) | 0) + Math.imul(Wt, Ve) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, sr) | 0) + (v >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, w = Math.imul(j, ae), v = (v = Math.imul(j, we)) + Math.imul(Z, ae) | 0, k = Math.imul(Z, we), w = w + Math.imul(de, ge) | 0, v = (v = v + Math.imul(de, _e) | 0) + Math.imul(We, ge) | 0, k = k + Math.imul(We, _e) | 0, w = w + Math.imul(he, be) | 0, v = (v = v + Math.imul(he, Ge) | 0) + Math.imul(je, be) | 0, k = k + Math.imul(je, Ge) | 0, w = w + Math.imul(ue, Te) | 0, v = (v = v + Math.imul(ue, Ie) | 0) + Math.imul(xe, Te) | 0, k = k + Math.imul(xe, Ie) | 0, w = w + Math.imul(ie, Ee) | 0, v = (v = v + Math.imul(ie, er) | 0) + Math.imul(oe, Ee) | 0, k = k + Math.imul(oe, er) | 0, w = w + Math.imul(zt, Ve) | 0, v = (v = v + Math.imul(zt, sr) | 0) + Math.imul(Jt, Ve) | 0, k = k + Math.imul(Jt, sr) | 0;
    var tn = (vt + (w = w + Math.imul(It, Je) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, ur) | 0) + Math.imul(Wt, Je) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, ur) | 0) + (v >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, w = Math.imul($t, ae), v = (v = Math.imul($t, we)) + Math.imul(At, ae) | 0, k = Math.imul(At, we), w = w + Math.imul(j, ge) | 0, v = (v = v + Math.imul(j, _e) | 0) + Math.imul(Z, ge) | 0, k = k + Math.imul(Z, _e) | 0, w = w + Math.imul(de, be) | 0, v = (v = v + Math.imul(de, Ge) | 0) + Math.imul(We, be) | 0, k = k + Math.imul(We, Ge) | 0, w = w + Math.imul(he, Te) | 0, v = (v = v + Math.imul(he, Ie) | 0) + Math.imul(je, Te) | 0, k = k + Math.imul(je, Ie) | 0, w = w + Math.imul(ue, Ee) | 0, v = (v = v + Math.imul(ue, er) | 0) + Math.imul(xe, Ee) | 0, k = k + Math.imul(xe, er) | 0, w = w + Math.imul(ie, Ve) | 0, v = (v = v + Math.imul(ie, sr) | 0) + Math.imul(oe, Ve) | 0, k = k + Math.imul(oe, sr) | 0, w = w + Math.imul(zt, Je) | 0, v = (v = v + Math.imul(zt, ur) | 0) + Math.imul(Jt, Je) | 0, k = k + Math.imul(Jt, ur) | 0;
    var en = (vt + (w = w + Math.imul(It, Ze) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, vr) | 0) + Math.imul(Wt, Ze) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, vr) | 0) + (v >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, w = Math.imul(Ft, ae), v = (v = Math.imul(Ft, we)) + Math.imul(Kt, ae) | 0, k = Math.imul(Kt, we), w = w + Math.imul($t, ge) | 0, v = (v = v + Math.imul($t, _e) | 0) + Math.imul(At, ge) | 0, k = k + Math.imul(At, _e) | 0, w = w + Math.imul(j, be) | 0, v = (v = v + Math.imul(j, Ge) | 0) + Math.imul(Z, be) | 0, k = k + Math.imul(Z, Ge) | 0, w = w + Math.imul(de, Te) | 0, v = (v = v + Math.imul(de, Ie) | 0) + Math.imul(We, Te) | 0, k = k + Math.imul(We, Ie) | 0, w = w + Math.imul(he, Ee) | 0, v = (v = v + Math.imul(he, er) | 0) + Math.imul(je, Ee) | 0, k = k + Math.imul(je, er) | 0, w = w + Math.imul(ue, Ve) | 0, v = (v = v + Math.imul(ue, sr) | 0) + Math.imul(xe, Ve) | 0, k = k + Math.imul(xe, sr) | 0, w = w + Math.imul(ie, Je) | 0, v = (v = v + Math.imul(ie, ur) | 0) + Math.imul(oe, Je) | 0, k = k + Math.imul(oe, ur) | 0, w = w + Math.imul(zt, Ze) | 0, v = (v = v + Math.imul(zt, vr) | 0) + Math.imul(Jt, Ze) | 0, k = k + Math.imul(Jt, vr) | 0;
    var rn = (vt + (w = w + Math.imul(It, Ye) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, _r) | 0) + Math.imul(Wt, Ye) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, _r) | 0) + (v >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, w = Math.imul(Gt, ae), v = (v = Math.imul(Gt, we)) + Math.imul(Qt, ae) | 0, k = Math.imul(Qt, we), w = w + Math.imul(Ft, ge) | 0, v = (v = v + Math.imul(Ft, _e) | 0) + Math.imul(Kt, ge) | 0, k = k + Math.imul(Kt, _e) | 0, w = w + Math.imul($t, be) | 0, v = (v = v + Math.imul($t, Ge) | 0) + Math.imul(At, be) | 0, k = k + Math.imul(At, Ge) | 0, w = w + Math.imul(j, Te) | 0, v = (v = v + Math.imul(j, Ie) | 0) + Math.imul(Z, Te) | 0, k = k + Math.imul(Z, Ie) | 0, w = w + Math.imul(de, Ee) | 0, v = (v = v + Math.imul(de, er) | 0) + Math.imul(We, Ee) | 0, k = k + Math.imul(We, er) | 0, w = w + Math.imul(he, Ve) | 0, v = (v = v + Math.imul(he, sr) | 0) + Math.imul(je, Ve) | 0, k = k + Math.imul(je, sr) | 0, w = w + Math.imul(ue, Je) | 0, v = (v = v + Math.imul(ue, ur) | 0) + Math.imul(xe, Je) | 0, k = k + Math.imul(xe, ur) | 0, w = w + Math.imul(ie, Ze) | 0, v = (v = v + Math.imul(ie, vr) | 0) + Math.imul(oe, Ze) | 0, k = k + Math.imul(oe, vr) | 0, w = w + Math.imul(zt, Ye) | 0, v = (v = v + Math.imul(zt, _r) | 0) + Math.imul(Jt, Ye) | 0, k = k + Math.imul(Jt, _r) | 0;
    var nn = (vt + (w = w + Math.imul(It, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, Mr) | 0) + Math.imul(Wt, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, Mr) | 0) + (v >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, w = Math.imul(Gt, ge), v = (v = Math.imul(Gt, _e)) + Math.imul(Qt, ge) | 0, k = Math.imul(Qt, _e), w = w + Math.imul(Ft, be) | 0, v = (v = v + Math.imul(Ft, Ge) | 0) + Math.imul(Kt, be) | 0, k = k + Math.imul(Kt, Ge) | 0, w = w + Math.imul($t, Te) | 0, v = (v = v + Math.imul($t, Ie) | 0) + Math.imul(At, Te) | 0, k = k + Math.imul(At, Ie) | 0, w = w + Math.imul(j, Ee) | 0, v = (v = v + Math.imul(j, er) | 0) + Math.imul(Z, Ee) | 0, k = k + Math.imul(Z, er) | 0, w = w + Math.imul(de, Ve) | 0, v = (v = v + Math.imul(de, sr) | 0) + Math.imul(We, Ve) | 0, k = k + Math.imul(We, sr) | 0, w = w + Math.imul(he, Je) | 0, v = (v = v + Math.imul(he, ur) | 0) + Math.imul(je, Je) | 0, k = k + Math.imul(je, ur) | 0, w = w + Math.imul(ue, Ze) | 0, v = (v = v + Math.imul(ue, vr) | 0) + Math.imul(xe, Ze) | 0, k = k + Math.imul(xe, vr) | 0, w = w + Math.imul(ie, Ye) | 0, v = (v = v + Math.imul(ie, _r) | 0) + Math.imul(oe, Ye) | 0, k = k + Math.imul(oe, _r) | 0;
    var on = (vt + (w = w + Math.imul(zt, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(zt, Mr) | 0) + Math.imul(Jt, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Jt, Mr) | 0) + (v >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, w = Math.imul(Gt, be), v = (v = Math.imul(Gt, Ge)) + Math.imul(Qt, be) | 0, k = Math.imul(Qt, Ge), w = w + Math.imul(Ft, Te) | 0, v = (v = v + Math.imul(Ft, Ie) | 0) + Math.imul(Kt, Te) | 0, k = k + Math.imul(Kt, Ie) | 0, w = w + Math.imul($t, Ee) | 0, v = (v = v + Math.imul($t, er) | 0) + Math.imul(At, Ee) | 0, k = k + Math.imul(At, er) | 0, w = w + Math.imul(j, Ve) | 0, v = (v = v + Math.imul(j, sr) | 0) + Math.imul(Z, Ve) | 0, k = k + Math.imul(Z, sr) | 0, w = w + Math.imul(de, Je) | 0, v = (v = v + Math.imul(de, ur) | 0) + Math.imul(We, Je) | 0, k = k + Math.imul(We, ur) | 0, w = w + Math.imul(he, Ze) | 0, v = (v = v + Math.imul(he, vr) | 0) + Math.imul(je, Ze) | 0, k = k + Math.imul(je, vr) | 0, w = w + Math.imul(ue, Ye) | 0, v = (v = v + Math.imul(ue, _r) | 0) + Math.imul(xe, Ye) | 0, k = k + Math.imul(xe, _r) | 0;
    var an = (vt + (w = w + Math.imul(ie, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(ie, Mr) | 0) + Math.imul(oe, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(oe, Mr) | 0) + (v >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, w = Math.imul(Gt, Te), v = (v = Math.imul(Gt, Ie)) + Math.imul(Qt, Te) | 0, k = Math.imul(Qt, Ie), w = w + Math.imul(Ft, Ee) | 0, v = (v = v + Math.imul(Ft, er) | 0) + Math.imul(Kt, Ee) | 0, k = k + Math.imul(Kt, er) | 0, w = w + Math.imul($t, Ve) | 0, v = (v = v + Math.imul($t, sr) | 0) + Math.imul(At, Ve) | 0, k = k + Math.imul(At, sr) | 0, w = w + Math.imul(j, Je) | 0, v = (v = v + Math.imul(j, ur) | 0) + Math.imul(Z, Je) | 0, k = k + Math.imul(Z, ur) | 0, w = w + Math.imul(de, Ze) | 0, v = (v = v + Math.imul(de, vr) | 0) + Math.imul(We, Ze) | 0, k = k + Math.imul(We, vr) | 0, w = w + Math.imul(he, Ye) | 0, v = (v = v + Math.imul(he, _r) | 0) + Math.imul(je, Ye) | 0, k = k + Math.imul(je, _r) | 0;
    var sn = (vt + (w = w + Math.imul(ue, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(ue, Mr) | 0) + Math.imul(xe, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(xe, Mr) | 0) + (v >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, w = Math.imul(Gt, Ee), v = (v = Math.imul(Gt, er)) + Math.imul(Qt, Ee) | 0, k = Math.imul(Qt, er), w = w + Math.imul(Ft, Ve) | 0, v = (v = v + Math.imul(Ft, sr) | 0) + Math.imul(Kt, Ve) | 0, k = k + Math.imul(Kt, sr) | 0, w = w + Math.imul($t, Je) | 0, v = (v = v + Math.imul($t, ur) | 0) + Math.imul(At, Je) | 0, k = k + Math.imul(At, ur) | 0, w = w + Math.imul(j, Ze) | 0, v = (v = v + Math.imul(j, vr) | 0) + Math.imul(Z, Ze) | 0, k = k + Math.imul(Z, vr) | 0, w = w + Math.imul(de, Ye) | 0, v = (v = v + Math.imul(de, _r) | 0) + Math.imul(We, Ye) | 0, k = k + Math.imul(We, _r) | 0;
    var cn = (vt + (w = w + Math.imul(he, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(he, Mr) | 0) + Math.imul(je, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(je, Mr) | 0) + (v >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, w = Math.imul(Gt, Ve), v = (v = Math.imul(Gt, sr)) + Math.imul(Qt, Ve) | 0, k = Math.imul(Qt, sr), w = w + Math.imul(Ft, Je) | 0, v = (v = v + Math.imul(Ft, ur) | 0) + Math.imul(Kt, Je) | 0, k = k + Math.imul(Kt, ur) | 0, w = w + Math.imul($t, Ze) | 0, v = (v = v + Math.imul($t, vr) | 0) + Math.imul(At, Ze) | 0, k = k + Math.imul(At, vr) | 0, w = w + Math.imul(j, Ye) | 0, v = (v = v + Math.imul(j, _r) | 0) + Math.imul(Z, Ye) | 0, k = k + Math.imul(Z, _r) | 0;
    var Cn = (vt + (w = w + Math.imul(de, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(de, Mr) | 0) + Math.imul(We, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(We, Mr) | 0) + (v >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, w = Math.imul(Gt, Je), v = (v = Math.imul(Gt, ur)) + Math.imul(Qt, Je) | 0, k = Math.imul(Qt, ur), w = w + Math.imul(Ft, Ze) | 0, v = (v = v + Math.imul(Ft, vr) | 0) + Math.imul(Kt, Ze) | 0, k = k + Math.imul(Kt, vr) | 0, w = w + Math.imul($t, Ye) | 0, v = (v = v + Math.imul($t, _r) | 0) + Math.imul(At, Ye) | 0, k = k + Math.imul(At, _r) | 0;
    var xn = (vt + (w = w + Math.imul(j, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(j, Mr) | 0) + Math.imul(Z, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Z, Mr) | 0) + (v >>> 13) | 0) + (xn >>> 26) | 0, xn &= 67108863, w = Math.imul(Gt, Ze), v = (v = Math.imul(Gt, vr)) + Math.imul(Qt, Ze) | 0, k = Math.imul(Qt, vr), w = w + Math.imul(Ft, Ye) | 0, v = (v = v + Math.imul(Ft, _r) | 0) + Math.imul(Kt, Ye) | 0, k = k + Math.imul(Kt, _r) | 0;
    var Pn = (vt + (w = w + Math.imul($t, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul($t, Mr) | 0) + Math.imul(At, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(At, Mr) | 0) + (v >>> 13) | 0) + (Pn >>> 26) | 0, Pn &= 67108863, w = Math.imul(Gt, Ye), v = (v = Math.imul(Gt, _r)) + Math.imul(Qt, Ye) | 0, k = Math.imul(Qt, _r);
    var Rn = (vt + (w = w + Math.imul(Ft, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(Ft, Mr) | 0) + Math.imul(Kt, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Kt, Mr) | 0) + (v >>> 13) | 0) + (Rn >>> 26) | 0, Rn &= 67108863;
    var Gn = (vt + (w = Math.imul(Gt, tr)) | 0) + ((8191 & (v = (v = Math.imul(Gt, Mr)) + Math.imul(Qt, tr) | 0)) << 13) | 0;
    return vt = ((k = Math.imul(Qt, Mr)) + (v >>> 13) | 0) + (Gn >>> 26) | 0, Gn &= 67108863, it[0] = Ur, it[1] = Fr, it[2] = Zr, it[3] = Qr, it[4] = Xr, it[5] = Yr, it[6] = tn, it[7] = en, it[8] = rn, it[9] = nn, it[10] = on, it[11] = an, it[12] = sn, it[13] = cn, it[14] = Cn, it[15] = xn, it[16] = Pn, it[17] = Rn, it[18] = Gn, vt !== 0 && (it[19] = vt, E.length++), E;
  };
  function rt(m, A, E) {
    return new nt().mulp(m, A, E);
  }
  function nt(m, A) {
    this.x = m, this.y = A;
  }
  Math.imul || (X = N), h.prototype.mulTo = function(m, A) {
    var E, w = this.length + m.length;
    return E = this.length === 10 && m.length === 10 ? X(this, m, A) : w < 63 ? N(this, m, A) : w < 1024 ? function(v, k, O) {
      O.negative = k.negative ^ v.negative, O.length = v.length + k.length;
      for (var W = 0, it = 0, vt = 0; vt < O.length - 1; vt++) {
        var xt = it;
        it = 0;
        for (var It = 67108863 & W, Wt = Math.min(vt, k.length - 1), Ut = Math.max(0, vt - v.length + 1); Ut <= Wt; Ut++) {
          var zt = vt - Ut, Jt = (0 | v.words[zt]) * (0 | k.words[Ut]), Xt = 67108863 & Jt;
          It = 67108863 & (Xt = Xt + It | 0), it += (xt = (xt = xt + (Jt / 67108864 | 0) | 0) + (Xt >>> 26) | 0) >>> 26, xt &= 67108863;
        }
        O.words[vt] = It, W = xt, xt = it;
      }
      return W !== 0 ? O.words[vt] = W : O.length--, O.strip();
    }(this, m, A) : rt(this, m, A), E;
  }, nt.prototype.makeRBT = function(m) {
    for (var A = new Array(m), E = h.prototype._countBits(m) - 1, w = 0; w < m; w++)
      A[w] = this.revBin(w, E, m);
    return A;
  }, nt.prototype.revBin = function(m, A, E) {
    if (m === 0 || m === E - 1)
      return m;
    for (var w = 0, v = 0; v < A; v++)
      w |= (1 & m) << A - v - 1, m >>= 1;
    return w;
  }, nt.prototype.permute = function(m, A, E, w, v, k) {
    for (var O = 0; O < k; O++)
      w[O] = A[m[O]], v[O] = E[m[O]];
  }, nt.prototype.transform = function(m, A, E, w, v, k) {
    this.permute(k, m, A, E, w, v);
    for (var O = 1; O < v; O <<= 1)
      for (var W = O << 1, it = Math.cos(2 * Math.PI / W), vt = Math.sin(2 * Math.PI / W), xt = 0; xt < v; xt += W)
        for (var It = it, Wt = vt, Ut = 0; Ut < O; Ut++) {
          var zt = E[xt + Ut], Jt = w[xt + Ut], Xt = E[xt + Ut + O], ie = w[xt + Ut + O], oe = It * Xt - Wt * ie;
          ie = It * ie + Wt * Xt, Xt = oe, E[xt + Ut] = zt + Xt, w[xt + Ut] = Jt + ie, E[xt + Ut + O] = zt - Xt, w[xt + Ut + O] = Jt - ie, Ut !== W && (oe = it * It - vt * Wt, Wt = it * Wt + vt * It, It = oe);
        }
  }, nt.prototype.guessLen13b = function(m, A) {
    var E = 1 | Math.max(A, m), w = 1 & E, v = 0;
    for (E = E / 2 | 0; E; E >>>= 1)
      v++;
    return 1 << v + 1 + w;
  }, nt.prototype.conjugate = function(m, A, E) {
    if (!(E <= 1))
      for (var w = 0; w < E / 2; w++) {
        var v = m[w];
        m[w] = m[E - w - 1], m[E - w - 1] = v, v = A[w], A[w] = -A[E - w - 1], A[E - w - 1] = -v;
      }
  }, nt.prototype.normalize13b = function(m, A) {
    for (var E = 0, w = 0; w < A / 2; w++) {
      var v = 8192 * Math.round(m[2 * w + 1] / A) + Math.round(m[2 * w] / A) + E;
      m[w] = 67108863 & v, E = v < 67108864 ? 0 : v / 67108864 | 0;
    }
    return m;
  }, nt.prototype.convert13b = function(m, A, E, w) {
    for (var v = 0, k = 0; k < A; k++)
      v += 0 | m[k], E[2 * k] = 8191 & v, v >>>= 13, E[2 * k + 1] = 8191 & v, v >>>= 13;
    for (k = 2 * A; k < w; ++k)
      E[k] = 0;
    c(v === 0), c((-8192 & v) == 0);
  }, nt.prototype.stub = function(m) {
    for (var A = new Array(m), E = 0; E < m; E++)
      A[E] = 0;
    return A;
  }, nt.prototype.mulp = function(m, A, E) {
    var w = 2 * this.guessLen13b(m.length, A.length), v = this.makeRBT(w), k = this.stub(w), O = new Array(w), W = new Array(w), it = new Array(w), vt = new Array(w), xt = new Array(w), It = new Array(w), Wt = E.words;
    Wt.length = w, this.convert13b(m.words, m.length, O, w), this.convert13b(A.words, A.length, vt, w), this.transform(O, k, W, it, w, v), this.transform(vt, k, xt, It, w, v);
    for (var Ut = 0; Ut < w; Ut++) {
      var zt = W[Ut] * xt[Ut] - it[Ut] * It[Ut];
      it[Ut] = W[Ut] * It[Ut] + it[Ut] * xt[Ut], W[Ut] = zt;
    }
    return this.conjugate(W, it, w), this.transform(W, it, Wt, k, w, v), this.conjugate(Wt, k, w), this.normalize13b(Wt, w), E.negative = m.negative ^ A.negative, E.length = m.length + A.length, E.strip();
  }, h.prototype.mul = function(m) {
    var A = new h(null);
    return A.words = new Array(this.length + m.length), this.mulTo(m, A);
  }, h.prototype.mulf = function(m) {
    var A = new h(null);
    return A.words = new Array(this.length + m.length), rt(this, m, A);
  }, h.prototype.imul = function(m) {
    return this.clone().mulTo(m, this);
  }, h.prototype.imuln = function(m) {
    c(typeof m == "number"), c(m < 67108864);
    for (var A = 0, E = 0; E < this.length; E++) {
      var w = (0 | this.words[E]) * m, v = (67108863 & w) + (67108863 & A);
      A >>= 26, A += w / 67108864 | 0, A += v >>> 26, this.words[E] = 67108863 & v;
    }
    return A !== 0 && (this.words[E] = A, this.length++), this;
  }, h.prototype.muln = function(m) {
    return this.clone().imuln(m);
  }, h.prototype.sqr = function() {
    return this.mul(this);
  }, h.prototype.isqr = function() {
    return this.imul(this.clone());
  }, h.prototype.pow = function(m) {
    var A = function(k) {
      for (var O = new Array(k.bitLength()), W = 0; W < O.length; W++) {
        var it = W / 26 | 0, vt = W % 26;
        O[W] = (k.words[it] & 1 << vt) >>> vt;
      }
      return O;
    }(m);
    if (A.length === 0)
      return new h(1);
    for (var E = this, w = 0; w < A.length && A[w] === 0; w++, E = E.sqr())
      ;
    if (++w < A.length)
      for (var v = E.sqr(); w < A.length; w++, v = v.sqr())
        A[w] !== 0 && (E = E.mul(v));
    return E;
  }, h.prototype.iushln = function(m) {
    c(typeof m == "number" && m >= 0);
    var A, E = m % 26, w = (m - E) / 26, v = 67108863 >>> 26 - E << 26 - E;
    if (E !== 0) {
      var k = 0;
      for (A = 0; A < this.length; A++) {
        var O = this.words[A] & v, W = (0 | this.words[A]) - O << E;
        this.words[A] = W | k, k = O >>> 26 - E;
      }
      k && (this.words[A] = k, this.length++);
    }
    if (w !== 0) {
      for (A = this.length - 1; A >= 0; A--)
        this.words[A + w] = this.words[A];
      for (A = 0; A < w; A++)
        this.words[A] = 0;
      this.length += w;
    }
    return this.strip();
  }, h.prototype.ishln = function(m) {
    return c(this.negative === 0), this.iushln(m);
  }, h.prototype.iushrn = function(m, A, E) {
    var w;
    c(typeof m == "number" && m >= 0), w = A ? (A - A % 26) / 26 : 0;
    var v = m % 26, k = Math.min((m - v) / 26, this.length), O = 67108863 ^ 67108863 >>> v << v, W = E;
    if (w -= k, w = Math.max(0, w), W) {
      for (var it = 0; it < k; it++)
        W.words[it] = this.words[it];
      W.length = k;
    }
    if (k !== 0)
      if (this.length > k)
        for (this.length -= k, it = 0; it < this.length; it++)
          this.words[it] = this.words[it + k];
      else
        this.words[0] = 0, this.length = 1;
    var vt = 0;
    for (it = this.length - 1; it >= 0 && (vt !== 0 || it >= w); it--) {
      var xt = 0 | this.words[it];
      this.words[it] = vt << 26 - v | xt >>> v, vt = xt & O;
    }
    return W && vt !== 0 && (W.words[W.length++] = vt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
  }, h.prototype.ishrn = function(m, A, E) {
    return c(this.negative === 0), this.iushrn(m, A, E);
  }, h.prototype.shln = function(m) {
    return this.clone().ishln(m);
  }, h.prototype.ushln = function(m) {
    return this.clone().iushln(m);
  }, h.prototype.shrn = function(m) {
    return this.clone().ishrn(m);
  }, h.prototype.ushrn = function(m) {
    return this.clone().iushrn(m);
  }, h.prototype.testn = function(m) {
    c(typeof m == "number" && m >= 0);
    var A = m % 26, E = (m - A) / 26, w = 1 << A;
    return !(this.length <= E || !(this.words[E] & w));
  }, h.prototype.imaskn = function(m) {
    c(typeof m == "number" && m >= 0);
    var A = m % 26, E = (m - A) / 26;
    if (c(this.negative === 0, "imaskn works only with positive numbers"), this.length <= E)
      return this;
    if (A !== 0 && E++, this.length = Math.min(E, this.length), A !== 0) {
      var w = 67108863 ^ 67108863 >>> A << A;
      this.words[this.length - 1] &= w;
    }
    return this.strip();
  }, h.prototype.maskn = function(m) {
    return this.clone().imaskn(m);
  }, h.prototype.iaddn = function(m) {
    return c(typeof m == "number"), c(m < 67108864), m < 0 ? this.isubn(-m) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < m ? (this.words[0] = m - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(m), this.negative = 1, this) : this._iaddn(m);
  }, h.prototype._iaddn = function(m) {
    this.words[0] += m;
    for (var A = 0; A < this.length && this.words[A] >= 67108864; A++)
      this.words[A] -= 67108864, A === this.length - 1 ? this.words[A + 1] = 1 : this.words[A + 1]++;
    return this.length = Math.max(this.length, A + 1), this;
  }, h.prototype.isubn = function(m) {
    if (c(typeof m == "number"), c(m < 67108864), m < 0)
      return this.iaddn(-m);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(m), this.negative = 1, this;
    if (this.words[0] -= m, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var A = 0; A < this.length && this.words[A] < 0; A++)
        this.words[A] += 67108864, this.words[A + 1] -= 1;
    return this.strip();
  }, h.prototype.addn = function(m) {
    return this.clone().iaddn(m);
  }, h.prototype.subn = function(m) {
    return this.clone().isubn(m);
  }, h.prototype.iabs = function() {
    return this.negative = 0, this;
  }, h.prototype.abs = function() {
    return this.clone().iabs();
  }, h.prototype._ishlnsubmul = function(m, A, E) {
    var w, v, k = m.length + E;
    this._expand(k);
    var O = 0;
    for (w = 0; w < m.length; w++) {
      v = (0 | this.words[w + E]) + O;
      var W = (0 | m.words[w]) * A;
      O = ((v -= 67108863 & W) >> 26) - (W / 67108864 | 0), this.words[w + E] = 67108863 & v;
    }
    for (; w < this.length - E; w++)
      O = (v = (0 | this.words[w + E]) + O) >> 26, this.words[w + E] = 67108863 & v;
    if (O === 0)
      return this.strip();
    for (c(O === -1), O = 0, w = 0; w < this.length; w++)
      O = (v = -(0 | this.words[w]) + O) >> 26, this.words[w] = 67108863 & v;
    return this.negative = 1, this.strip();
  }, h.prototype._wordDiv = function(m, A) {
    var E = (this.length, m.length), w = this.clone(), v = m, k = 0 | v.words[v.length - 1];
    (E = 26 - this._countBits(k)) != 0 && (v = v.ushln(E), w.iushln(E), k = 0 | v.words[v.length - 1]);
    var O, W = w.length - v.length;
    if (A !== "mod") {
      (O = new h(null)).length = W + 1, O.words = new Array(O.length);
      for (var it = 0; it < O.length; it++)
        O.words[it] = 0;
    }
    var vt = w.clone()._ishlnsubmul(v, 1, W);
    vt.negative === 0 && (w = vt, O && (O.words[W] = 1));
    for (var xt = W - 1; xt >= 0; xt--) {
      var It = 67108864 * (0 | w.words[v.length + xt]) + (0 | w.words[v.length + xt - 1]);
      for (It = Math.min(It / k | 0, 67108863), w._ishlnsubmul(v, It, xt); w.negative !== 0; )
        It--, w.negative = 0, w._ishlnsubmul(v, 1, xt), w.isZero() || (w.negative ^= 1);
      O && (O.words[xt] = It);
    }
    return O && O.strip(), w.strip(), A !== "div" && E !== 0 && w.iushrn(E), { div: O || null, mod: w };
  }, h.prototype.divmod = function(m, A, E) {
    return c(!m.isZero()), this.isZero() ? { div: new h(0), mod: new h(0) } : this.negative !== 0 && m.negative === 0 ? (k = this.neg().divmod(m, A), A !== "mod" && (w = k.div.neg()), A !== "div" && (v = k.mod.neg(), E && v.negative !== 0 && v.iadd(m)), { div: w, mod: v }) : this.negative === 0 && m.negative !== 0 ? (k = this.divmod(m.neg(), A), A !== "mod" && (w = k.div.neg()), { div: w, mod: k.mod }) : (this.negative & m.negative) != 0 ? (k = this.neg().divmod(m.neg(), A), A !== "div" && (v = k.mod.neg(), E && v.negative !== 0 && v.isub(m)), { div: k.div, mod: v }) : m.length > this.length || this.cmp(m) < 0 ? { div: new h(0), mod: this } : m.length === 1 ? A === "div" ? { div: this.divn(m.words[0]), mod: null } : A === "mod" ? { div: null, mod: new h(this.modn(m.words[0])) } : { div: this.divn(m.words[0]), mod: new h(this.modn(m.words[0])) } : this._wordDiv(m, A);
    var w, v, k;
  }, h.prototype.div = function(m) {
    return this.divmod(m, "div", !1).div;
  }, h.prototype.mod = function(m) {
    return this.divmod(m, "mod", !1).mod;
  }, h.prototype.umod = function(m) {
    return this.divmod(m, "mod", !0).mod;
  }, h.prototype.divRound = function(m) {
    var A = this.divmod(m);
    if (A.mod.isZero())
      return A.div;
    var E = A.div.negative !== 0 ? A.mod.isub(m) : A.mod, w = m.ushrn(1), v = m.andln(1), k = E.cmp(w);
    return k < 0 || v === 1 && k === 0 ? A.div : A.div.negative !== 0 ? A.div.isubn(1) : A.div.iaddn(1);
  }, h.prototype.modn = function(m) {
    c(m <= 67108863);
    for (var A = (1 << 26) % m, E = 0, w = this.length - 1; w >= 0; w--)
      E = (A * E + (0 | this.words[w])) % m;
    return E;
  }, h.prototype.idivn = function(m) {
    c(m <= 67108863);
    for (var A = 0, E = this.length - 1; E >= 0; E--) {
      var w = (0 | this.words[E]) + 67108864 * A;
      this.words[E] = w / m | 0, A = w % m;
    }
    return this.strip();
  }, h.prototype.divn = function(m) {
    return this.clone().idivn(m);
  }, h.prototype.egcd = function(m) {
    c(m.negative === 0), c(!m.isZero());
    var A = this, E = m.clone();
    A = A.negative !== 0 ? A.umod(m) : A.clone();
    for (var w = new h(1), v = new h(0), k = new h(0), O = new h(1), W = 0; A.isEven() && E.isEven(); )
      A.iushrn(1), E.iushrn(1), ++W;
    for (var it = E.clone(), vt = A.clone(); !A.isZero(); ) {
      for (var xt = 0, It = 1; (A.words[0] & It) == 0 && xt < 26; ++xt, It <<= 1)
        ;
      if (xt > 0)
        for (A.iushrn(xt); xt-- > 0; )
          (w.isOdd() || v.isOdd()) && (w.iadd(it), v.isub(vt)), w.iushrn(1), v.iushrn(1);
      for (var Wt = 0, Ut = 1; (E.words[0] & Ut) == 0 && Wt < 26; ++Wt, Ut <<= 1)
        ;
      if (Wt > 0)
        for (E.iushrn(Wt); Wt-- > 0; )
          (k.isOdd() || O.isOdd()) && (k.iadd(it), O.isub(vt)), k.iushrn(1), O.iushrn(1);
      A.cmp(E) >= 0 ? (A.isub(E), w.isub(k), v.isub(O)) : (E.isub(A), k.isub(w), O.isub(v));
    }
    return { a: k, b: O, gcd: E.iushln(W) };
  }, h.prototype._invmp = function(m) {
    c(m.negative === 0), c(!m.isZero());
    var A = this, E = m.clone();
    A = A.negative !== 0 ? A.umod(m) : A.clone();
    for (var w, v = new h(1), k = new h(0), O = E.clone(); A.cmpn(1) > 0 && E.cmpn(1) > 0; ) {
      for (var W = 0, it = 1; (A.words[0] & it) == 0 && W < 26; ++W, it <<= 1)
        ;
      if (W > 0)
        for (A.iushrn(W); W-- > 0; )
          v.isOdd() && v.iadd(O), v.iushrn(1);
      for (var vt = 0, xt = 1; (E.words[0] & xt) == 0 && vt < 26; ++vt, xt <<= 1)
        ;
      if (vt > 0)
        for (E.iushrn(vt); vt-- > 0; )
          k.isOdd() && k.iadd(O), k.iushrn(1);
      A.cmp(E) >= 0 ? (A.isub(E), v.isub(k)) : (E.isub(A), k.isub(v));
    }
    return (w = A.cmpn(1) === 0 ? v : k).cmpn(0) < 0 && w.iadd(m), w;
  }, h.prototype.gcd = function(m) {
    if (this.isZero())
      return m.abs();
    if (m.isZero())
      return this.abs();
    var A = this.clone(), E = m.clone();
    A.negative = 0, E.negative = 0;
    for (var w = 0; A.isEven() && E.isEven(); w++)
      A.iushrn(1), E.iushrn(1);
    for (; ; ) {
      for (; A.isEven(); )
        A.iushrn(1);
      for (; E.isEven(); )
        E.iushrn(1);
      var v = A.cmp(E);
      if (v < 0) {
        var k = A;
        A = E, E = k;
      } else if (v === 0 || E.cmpn(1) === 0)
        break;
      A.isub(E);
    }
    return E.iushln(w);
  }, h.prototype.invm = function(m) {
    return this.egcd(m).a.umod(m);
  }, h.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, h.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, h.prototype.andln = function(m) {
    return this.words[0] & m;
  }, h.prototype.bincn = function(m) {
    c(typeof m == "number");
    var A = m % 26, E = (m - A) / 26, w = 1 << A;
    if (this.length <= E)
      return this._expand(E + 1), this.words[E] |= w, this;
    for (var v = w, k = E; v !== 0 && k < this.length; k++) {
      var O = 0 | this.words[k];
      v = (O += v) >>> 26, O &= 67108863, this.words[k] = O;
    }
    return v !== 0 && (this.words[k] = v, this.length++), this;
  }, h.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, h.prototype.cmpn = function(m) {
    var A, E = m < 0;
    if (this.negative !== 0 && !E)
      return -1;
    if (this.negative === 0 && E)
      return 1;
    if (this.strip(), this.length > 1)
      A = 1;
    else {
      E && (m = -m), c(m <= 67108863, "Number is too big");
      var w = 0 | this.words[0];
      A = w === m ? 0 : w < m ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -A : A;
  }, h.prototype.cmp = function(m) {
    if (this.negative !== 0 && m.negative === 0)
      return -1;
    if (this.negative === 0 && m.negative !== 0)
      return 1;
    var A = this.ucmp(m);
    return this.negative !== 0 ? 0 | -A : A;
  }, h.prototype.ucmp = function(m) {
    if (this.length > m.length)
      return 1;
    if (this.length < m.length)
      return -1;
    for (var A = 0, E = this.length - 1; E >= 0; E--) {
      var w = 0 | this.words[E], v = 0 | m.words[E];
      if (w !== v) {
        w < v ? A = -1 : w > v && (A = 1);
        break;
      }
    }
    return A;
  }, h.prototype.gtn = function(m) {
    return this.cmpn(m) === 1;
  }, h.prototype.gt = function(m) {
    return this.cmp(m) === 1;
  }, h.prototype.gten = function(m) {
    return this.cmpn(m) >= 0;
  }, h.prototype.gte = function(m) {
    return this.cmp(m) >= 0;
  }, h.prototype.ltn = function(m) {
    return this.cmpn(m) === -1;
  }, h.prototype.lt = function(m) {
    return this.cmp(m) === -1;
  }, h.prototype.lten = function(m) {
    return this.cmpn(m) <= 0;
  }, h.prototype.lte = function(m) {
    return this.cmp(m) <= 0;
  }, h.prototype.eqn = function(m) {
    return this.cmpn(m) === 0;
  }, h.prototype.eq = function(m) {
    return this.cmp(m) === 0;
  }, h.red = function(m) {
    return new _t(m);
  }, h.prototype.toRed = function(m) {
    return c(!this.red, "Already a number in reduction context"), c(this.negative === 0, "red works only with positives"), m.convertTo(this)._forceRed(m);
  }, h.prototype.fromRed = function() {
    return c(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, h.prototype._forceRed = function(m) {
    return this.red = m, this;
  }, h.prototype.forceRed = function(m) {
    return c(!this.red, "Already a number in reduction context"), this._forceRed(m);
  }, h.prototype.redAdd = function(m) {
    return c(this.red, "redAdd works only with red numbers"), this.red.add(this, m);
  }, h.prototype.redIAdd = function(m) {
    return c(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, m);
  }, h.prototype.redSub = function(m) {
    return c(this.red, "redSub works only with red numbers"), this.red.sub(this, m);
  }, h.prototype.redISub = function(m) {
    return c(this.red, "redISub works only with red numbers"), this.red.isub(this, m);
  }, h.prototype.redShl = function(m) {
    return c(this.red, "redShl works only with red numbers"), this.red.shl(this, m);
  }, h.prototype.redMul = function(m) {
    return c(this.red, "redMul works only with red numbers"), this.red._verify2(this, m), this.red.mul(this, m);
  }, h.prototype.redIMul = function(m) {
    return c(this.red, "redMul works only with red numbers"), this.red._verify2(this, m), this.red.imul(this, m);
  }, h.prototype.redSqr = function() {
    return c(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, h.prototype.redISqr = function() {
    return c(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, h.prototype.redSqrt = function() {
    return c(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, h.prototype.redInvm = function() {
    return c(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, h.prototype.redNeg = function() {
    return c(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, h.prototype.redPow = function(m) {
    return c(this.red && !m.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, m);
  };
  var st = { k256: null, p224: null, p192: null, p25519: null };
  function ot(m, A) {
    this.name = m, this.p = new h(A, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function St() {
    ot.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function Ct() {
    ot.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function et() {
    ot.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function at() {
    ot.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function _t(m) {
    if (typeof m == "string") {
      var A = h._prime(m);
      this.m = A.p, this.prime = A;
    } else
      c(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
  }
  function Nt(m) {
    _t.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  ot.prototype._tmp = function() {
    var m = new h(null);
    return m.words = new Array(Math.ceil(this.n / 13)), m;
  }, ot.prototype.ireduce = function(m) {
    var A, E = m;
    do
      this.split(E, this.tmp), A = (E = (E = this.imulK(E)).iadd(this.tmp)).bitLength();
    while (A > this.n);
    var w = A < this.n ? -1 : E.ucmp(this.p);
    return w === 0 ? (E.words[0] = 0, E.length = 1) : w > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
  }, ot.prototype.split = function(m, A) {
    m.iushrn(this.n, 0, A);
  }, ot.prototype.imulK = function(m) {
    return m.imul(this.k);
  }, u(St, ot), St.prototype.split = function(m, A) {
    for (var E = 4194303, w = Math.min(m.length, 9), v = 0; v < w; v++)
      A.words[v] = m.words[v];
    if (A.length = w, m.length <= 9)
      return m.words[0] = 0, void (m.length = 1);
    var k = m.words[9];
    for (A.words[A.length++] = k & E, v = 10; v < m.length; v++) {
      var O = 0 | m.words[v];
      m.words[v - 10] = (O & E) << 4 | k >>> 22, k = O;
    }
    k >>>= 22, m.words[v - 10] = k, k === 0 && m.length > 10 ? m.length -= 10 : m.length -= 9;
  }, St.prototype.imulK = function(m) {
    m.words[m.length] = 0, m.words[m.length + 1] = 0, m.length += 2;
    for (var A = 0, E = 0; E < m.length; E++) {
      var w = 0 | m.words[E];
      A += 977 * w, m.words[E] = 67108863 & A, A = 64 * w + (A / 67108864 | 0);
    }
    return m.words[m.length - 1] === 0 && (m.length--, m.words[m.length - 1] === 0 && m.length--), m;
  }, u(Ct, ot), u(et, ot), u(at, ot), at.prototype.imulK = function(m) {
    for (var A = 0, E = 0; E < m.length; E++) {
      var w = 19 * (0 | m.words[E]) + A, v = 67108863 & w;
      w >>>= 26, m.words[E] = v, A = w;
    }
    return A !== 0 && (m.words[m.length++] = A), m;
  }, h._prime = function(m) {
    if (st[m])
      return st[m];
    var A;
    if (m === "k256")
      A = new St();
    else if (m === "p224")
      A = new Ct();
    else if (m === "p192")
      A = new et();
    else {
      if (m !== "p25519")
        throw new Error("Unknown prime " + m);
      A = new at();
    }
    return st[m] = A, A;
  }, _t.prototype._verify1 = function(m) {
    c(m.negative === 0, "red works only with positives"), c(m.red, "red works only with red numbers");
  }, _t.prototype._verify2 = function(m, A) {
    c((m.negative | A.negative) == 0, "red works only with positives"), c(m.red && m.red === A.red, "red works only with red numbers");
  }, _t.prototype.imod = function(m) {
    return this.prime ? this.prime.ireduce(m)._forceRed(this) : m.umod(this.m)._forceRed(this);
  }, _t.prototype.neg = function(m) {
    return m.isZero() ? m.clone() : this.m.sub(m)._forceRed(this);
  }, _t.prototype.add = function(m, A) {
    this._verify2(m, A);
    var E = m.add(A);
    return E.cmp(this.m) >= 0 && E.isub(this.m), E._forceRed(this);
  }, _t.prototype.iadd = function(m, A) {
    this._verify2(m, A);
    var E = m.iadd(A);
    return E.cmp(this.m) >= 0 && E.isub(this.m), E;
  }, _t.prototype.sub = function(m, A) {
    this._verify2(m, A);
    var E = m.sub(A);
    return E.cmpn(0) < 0 && E.iadd(this.m), E._forceRed(this);
  }, _t.prototype.isub = function(m, A) {
    this._verify2(m, A);
    var E = m.isub(A);
    return E.cmpn(0) < 0 && E.iadd(this.m), E;
  }, _t.prototype.shl = function(m, A) {
    return this._verify1(m), this.imod(m.ushln(A));
  }, _t.prototype.imul = function(m, A) {
    return this._verify2(m, A), this.imod(m.imul(A));
  }, _t.prototype.mul = function(m, A) {
    return this._verify2(m, A), this.imod(m.mul(A));
  }, _t.prototype.isqr = function(m) {
    return this.imul(m, m.clone());
  }, _t.prototype.sqr = function(m) {
    return this.mul(m, m);
  }, _t.prototype.sqrt = function(m) {
    if (m.isZero())
      return m.clone();
    var A = this.m.andln(3);
    if (c(A % 2 == 1), A === 3) {
      var E = this.m.add(new h(1)).iushrn(2);
      return this.pow(m, E);
    }
    for (var w = this.m.subn(1), v = 0; !w.isZero() && w.andln(1) === 0; )
      v++, w.iushrn(1);
    c(!w.isZero());
    var k = new h(1).toRed(this), O = k.redNeg(), W = this.m.subn(1).iushrn(1), it = this.m.bitLength();
    for (it = new h(2 * it * it).toRed(this); this.pow(it, W).cmp(O) !== 0; )
      it.redIAdd(O);
    for (var vt = this.pow(it, w), xt = this.pow(m, w.addn(1).iushrn(1)), It = this.pow(m, w), Wt = v; It.cmp(k) !== 0; ) {
      for (var Ut = It, zt = 0; Ut.cmp(k) !== 0; zt++)
        Ut = Ut.redSqr();
      c(zt < Wt);
      var Jt = this.pow(vt, new h(1).iushln(Wt - zt - 1));
      xt = xt.redMul(Jt), vt = Jt.redSqr(), It = It.redMul(vt), Wt = zt;
    }
    return xt;
  }, _t.prototype.invm = function(m) {
    var A = m._invmp(this.m);
    return A.negative !== 0 ? (A.negative = 0, this.imod(A).redNeg()) : this.imod(A);
  }, _t.prototype.pow = function(m, A) {
    if (A.isZero())
      return new h(1).toRed(this);
    if (A.cmpn(1) === 0)
      return m.clone();
    var E = new Array(16);
    E[0] = new h(1).toRed(this), E[1] = m;
    for (var w = 2; w < E.length; w++)
      E[w] = this.mul(E[w - 1], m);
    var v = E[0], k = 0, O = 0, W = A.bitLength() % 26;
    for (W === 0 && (W = 26), w = A.length - 1; w >= 0; w--) {
      for (var it = A.words[w], vt = W - 1; vt >= 0; vt--) {
        var xt = it >> vt & 1;
        v !== E[0] && (v = this.sqr(v)), xt !== 0 || k !== 0 ? (k <<= 1, k |= xt, (++O == 4 || w === 0 && vt === 0) && (v = this.mul(v, E[k]), O = 0, k = 0)) : O = 0;
      }
      W = 26;
    }
    return v;
  }, _t.prototype.convertTo = function(m) {
    var A = m.umod(this.m);
    return A === m ? A.clone() : A;
  }, _t.prototype.convertFrom = function(m) {
    var A = m.clone();
    return A.red = null, A;
  }, h.mont = function(m) {
    return new Nt(m);
  }, u(Nt, _t), Nt.prototype.convertTo = function(m) {
    return this.imod(m.ushln(this.shift));
  }, Nt.prototype.convertFrom = function(m) {
    var A = this.imod(m.mul(this.rinv));
    return A.red = null, A;
  }, Nt.prototype.imul = function(m, A) {
    if (m.isZero() || A.isZero())
      return m.words[0] = 0, m.length = 1, m;
    var E = m.imul(A), w = E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = E.isub(w).iushrn(this.shift), k = v;
    return v.cmp(this.m) >= 0 ? k = v.isub(this.m) : v.cmpn(0) < 0 && (k = v.iadd(this.m)), k._forceRed(this);
  }, Nt.prototype.mul = function(m, A) {
    if (m.isZero() || A.isZero())
      return new h(0)._forceRed(this);
    var E = m.mul(A), w = E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = E.isub(w).iushrn(this.shift), k = v;
    return v.cmp(this.m) >= 0 ? k = v.isub(this.m) : v.cmpn(0) < 0 && (k = v.iadd(this.m)), k._forceRed(this);
  }, Nt.prototype.invm = function(m) {
    return this.imod(m._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var api = {}, encoders = {}, buffer$1 = buffer$2, Buffer$8 = buffer$1.Buffer, safer = {}, key$3;
for (key$3 in buffer$1)
  buffer$1.hasOwnProperty(key$3) && key$3 !== "SlowBuffer" && key$3 !== "Buffer" && (safer[key$3] = buffer$1[key$3]);
var Safer = safer.Buffer = {};
for (key$3 in Buffer$8)
  Buffer$8.hasOwnProperty(key$3) && key$3 !== "allocUnsafe" && key$3 !== "allocUnsafeSlow" && (Safer[key$3] = Buffer$8[key$3]);
if (safer.Buffer.prototype = Buffer$8.prototype, Safer.from && Safer.from !== Uint8Array.from || (Safer.from = function(o, n, c) {
  if (typeof o == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof o);
  if (o && o.length === void 0)
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof o);
  return Buffer$8(o, n, c);
}), Safer.alloc || (Safer.alloc = function(o, n, c) {
  if (typeof o != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof o);
  if (o < 0 || o >= 2 * (1 << 30))
    throw new RangeError('The value "' + o + '" is invalid for option "size"');
  var u = Buffer$8(o);
  return n && n.length !== 0 ? typeof c == "string" ? u.fill(n, c) : u.fill(n) : u.fill(0), u;
}), !safer.kStringMaxLength)
  try {
    safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch (o) {
  }
safer.constants || (safer.constants = { MAX_LENGTH: safer.kMaxLength }, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength));
var safer_1 = safer, reporter = {};
const inherits$9 = requireInherits_browser();
function Reporter$2(o) {
  this._reporterState = { obj: null, path: [], options: o || {}, errors: [] };
}
function ReporterError(o, n) {
  this.path = o, this.rethrow(n);
}
reporter.Reporter = Reporter$2, Reporter$2.prototype.isError = function(o) {
  return o instanceof ReporterError;
}, Reporter$2.prototype.save = function() {
  const o = this._reporterState;
  return { obj: o.obj, pathLen: o.path.length };
}, Reporter$2.prototype.restore = function(o) {
  const n = this._reporterState;
  n.obj = o.obj, n.path = n.path.slice(0, o.pathLen);
}, Reporter$2.prototype.enterKey = function(o) {
  return this._reporterState.path.push(o);
}, Reporter$2.prototype.exitKey = function(o) {
  const n = this._reporterState;
  n.path = n.path.slice(0, o - 1);
}, Reporter$2.prototype.leaveKey = function(o, n, c) {
  const u = this._reporterState;
  this.exitKey(o), u.obj !== null && (u.obj[n] = c);
}, Reporter$2.prototype.path = function() {
  return this._reporterState.path.join("/");
}, Reporter$2.prototype.enterObject = function() {
  const o = this._reporterState, n = o.obj;
  return o.obj = {}, n;
}, Reporter$2.prototype.leaveObject = function(o) {
  const n = this._reporterState, c = n.obj;
  return n.obj = o, c;
}, Reporter$2.prototype.error = function(o) {
  let n;
  const c = this._reporterState, u = o instanceof ReporterError;
  if (n = u ? o : new ReporterError(c.path.map(function(h) {
    return "[" + JSON.stringify(h) + "]";
  }).join(""), o.message || o, o.stack), !c.options.partial)
    throw n;
  return u || c.errors.push(n), n;
}, Reporter$2.prototype.wrapResult = function(o) {
  const n = this._reporterState;
  return n.options.partial ? { result: this.isError(o) ? null : o, errors: n.errors } : o;
}, inherits$9(ReporterError, Error), ReporterError.prototype.rethrow = function(o) {
  if (this.message = o + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (n) {
      this.stack = n.stack;
    }
  return this;
};
var buffer = {};
const inherits$8 = requireInherits_browser(), Reporter$1 = reporter.Reporter, Buffer$7 = safer_1.Buffer;
function DecoderBuffer$2(o, n) {
  Reporter$1.call(this, n), Buffer$7.isBuffer(o) ? (this.base = o, this.offset = 0, this.length = o.length) : this.error("Input not Buffer");
}
function EncoderBuffer$1(o, n) {
  if (Array.isArray(o))
    this.length = 0, this.value = o.map(function(c) {
      return EncoderBuffer$1.isEncoderBuffer(c) || (c = new EncoderBuffer$1(c, n)), this.length += c.length, c;
    }, this);
  else if (typeof o == "number") {
    if (!(0 <= o && o <= 255))
      return n.error("non-byte EncoderBuffer value");
    this.value = o, this.length = 1;
  } else if (typeof o == "string")
    this.value = o, this.length = Buffer$7.byteLength(o);
  else {
    if (!Buffer$7.isBuffer(o))
      return n.error("Unsupported type: " + typeof o);
    this.value = o, this.length = o.length;
  }
}
inherits$8(DecoderBuffer$2, Reporter$1), buffer.DecoderBuffer = DecoderBuffer$2, DecoderBuffer$2.isDecoderBuffer = function(o) {
  return o instanceof DecoderBuffer$2 || typeof o == "object" && Buffer$7.isBuffer(o.base) && o.constructor.name === "DecoderBuffer" && typeof o.offset == "number" && typeof o.length == "number" && typeof o.save == "function" && typeof o.restore == "function" && typeof o.isEmpty == "function" && typeof o.readUInt8 == "function" && typeof o.skip == "function" && typeof o.raw == "function";
}, DecoderBuffer$2.prototype.save = function() {
  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
}, DecoderBuffer$2.prototype.restore = function(o) {
  const n = new DecoderBuffer$2(this.base);
  return n.offset = o.offset, n.length = this.offset, this.offset = o.offset, Reporter$1.prototype.restore.call(this, o.reporter), n;
}, DecoderBuffer$2.prototype.isEmpty = function() {
  return this.offset === this.length;
}, DecoderBuffer$2.prototype.readUInt8 = function(o) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(o || "DecoderBuffer overrun");
}, DecoderBuffer$2.prototype.skip = function(o, n) {
  if (!(this.offset + o <= this.length))
    return this.error(n || "DecoderBuffer overrun");
  const c = new DecoderBuffer$2(this.base);
  return c._reporterState = this._reporterState, c.offset = this.offset, c.length = this.offset + o, this.offset += o, c;
}, DecoderBuffer$2.prototype.raw = function(o) {
  return this.base.slice(o ? o.offset : this.offset, this.length);
}, buffer.EncoderBuffer = EncoderBuffer$1, EncoderBuffer$1.isEncoderBuffer = function(o) {
  return o instanceof EncoderBuffer$1 || typeof o == "object" && o.constructor.name === "EncoderBuffer" && typeof o.length == "number" && typeof o.join == "function";
}, EncoderBuffer$1.prototype.join = function(o, n) {
  return o || (o = Buffer$7.alloc(this.length)), n || (n = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(c) {
    c.join(o, n), n += c.length;
  }) : (typeof this.value == "number" ? o[n] = this.value : typeof this.value == "string" ? o.write(this.value, n) : Buffer$7.isBuffer(this.value) && this.value.copy(o, n), n += this.length)), o;
};
var minimalisticAssert = assert$g;
function assert$g(o, n) {
  if (!o)
    throw new Error(n || "Assertion failed");
}
assert$g.equal = function(o, n, c) {
  if (o != n)
    throw new Error(c || "Assertion failed: " + o + " != " + n);
};
const Reporter = reporter.Reporter, EncoderBuffer = buffer.EncoderBuffer, DecoderBuffer$1 = buffer.DecoderBuffer, assert$f = minimalisticAssert, tags = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], methods = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(tags), overrided = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
function Node$2(o, n, c) {
  const u = {};
  this._baseState = u, u.name = c, u.enc = o, u.parent = n || null, u.children = null, u.tag = null, u.args = null, u.reverseArgs = null, u.choice = null, u.optional = !1, u.any = !1, u.obj = !1, u.use = null, u.useDecoder = null, u.key = null, u.default = null, u.explicit = null, u.implicit = null, u.contains = null, u.parent || (u.children = [], this._wrap());
}
var node = Node$2;
const stateProps = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
Node$2.prototype.clone = function() {
  const o = this._baseState, n = {};
  stateProps.forEach(function(u) {
    n[u] = o[u];
  });
  const c = new this.constructor(n.parent);
  return c._baseState = n, c;
}, Node$2.prototype._wrap = function() {
  const o = this._baseState;
  methods.forEach(function(n) {
    this[n] = function() {
      const c = new this.constructor(this);
      return o.children.push(c), c[n].apply(c, arguments);
    };
  }, this);
}, Node$2.prototype._init = function(o) {
  const n = this._baseState;
  assert$f(n.parent === null), o.call(this), n.children = n.children.filter(function(c) {
    return c._baseState.parent === this;
  }, this), assert$f.equal(n.children.length, 1, "Root node can have only one child");
}, Node$2.prototype._useArgs = function(o) {
  const n = this._baseState, c = o.filter(function(u) {
    return u instanceof this.constructor;
  }, this);
  o = o.filter(function(u) {
    return !(u instanceof this.constructor);
  }, this), c.length !== 0 && (assert$f(n.children === null), n.children = c, c.forEach(function(u) {
    u._baseState.parent = this;
  }, this)), o.length !== 0 && (assert$f(n.args === null), n.args = o, n.reverseArgs = o.map(function(u) {
    if (typeof u != "object" || u.constructor !== Object)
      return u;
    const h = {};
    return Object.keys(u).forEach(function(g) {
      g == (0 | g) && (g |= 0);
      const y = u[g];
      h[y] = g;
    }), h;
  }));
}, overrided.forEach(function(o) {
  Node$2.prototype[o] = function() {
    const n = this._baseState;
    throw new Error(o + " not implemented for encoding: " + n.enc);
  };
}), tags.forEach(function(o) {
  Node$2.prototype[o] = function() {
    const n = this._baseState, c = Array.prototype.slice.call(arguments);
    return assert$f(n.tag === null), n.tag = o, this._useArgs(c), this;
  };
}), Node$2.prototype.use = function(o) {
  assert$f(o);
  const n = this._baseState;
  return assert$f(n.use === null), n.use = o, this;
}, Node$2.prototype.optional = function() {
  return this._baseState.optional = !0, this;
}, Node$2.prototype.def = function(o) {
  const n = this._baseState;
  return assert$f(n.default === null), n.default = o, n.optional = !0, this;
}, Node$2.prototype.explicit = function(o) {
  const n = this._baseState;
  return assert$f(n.explicit === null && n.implicit === null), n.explicit = o, this;
}, Node$2.prototype.implicit = function(o) {
  const n = this._baseState;
  return assert$f(n.explicit === null && n.implicit === null), n.implicit = o, this;
}, Node$2.prototype.obj = function() {
  const o = this._baseState, n = Array.prototype.slice.call(arguments);
  return o.obj = !0, n.length !== 0 && this._useArgs(n), this;
}, Node$2.prototype.key = function(o) {
  const n = this._baseState;
  return assert$f(n.key === null), n.key = o, this;
}, Node$2.prototype.any = function() {
  return this._baseState.any = !0, this;
}, Node$2.prototype.choice = function(o) {
  const n = this._baseState;
  return assert$f(n.choice === null), n.choice = o, this._useArgs(Object.keys(o).map(function(c) {
    return o[c];
  })), this;
}, Node$2.prototype.contains = function(o) {
  const n = this._baseState;
  return assert$f(n.use === null), n.contains = o, this;
}, Node$2.prototype._decode = function(o, n) {
  const c = this._baseState;
  if (c.parent === null)
    return o.wrapResult(c.children[0]._decode(o, n));
  let u, h = c.default, g = !0, y = null;
  if (c.key !== null && (y = o.enterKey(c.key)), c.optional) {
    let $ = null;
    if (c.explicit !== null ? $ = c.explicit : c.implicit !== null ? $ = c.implicit : c.tag !== null && ($ = c.tag), $ !== null || c.any) {
      if (g = this._peekTag(o, $, c.any), o.isError(g))
        return g;
    } else {
      const I = o.save();
      try {
        c.choice === null ? this._decodeGeneric(c.tag, o, n) : this._decodeChoice(o, n), g = !0;
      } catch {
        g = !1;
      }
      o.restore(I);
    }
  }
  if (c.obj && g && (u = o.enterObject()), g) {
    if (c.explicit !== null) {
      const I = this._decodeTag(o, c.explicit);
      if (o.isError(I))
        return I;
      o = I;
    }
    const $ = o.offset;
    if (c.use === null && c.choice === null) {
      let I;
      c.any && (I = o.save());
      const P = this._decodeTag(o, c.implicit !== null ? c.implicit : c.tag, c.any);
      if (o.isError(P))
        return P;
      c.any ? h = o.raw(I) : o = P;
    }
    if (n && n.track && c.tag !== null && n.track(o.path(), $, o.length, "tagged"), n && n.track && c.tag !== null && n.track(o.path(), o.offset, o.length, "content"), c.any || (h = c.choice === null ? this._decodeGeneric(c.tag, o, n) : this._decodeChoice(o, n)), o.isError(h))
      return h;
    if (c.any || c.choice !== null || c.children === null || c.children.forEach(function(I) {
      I._decode(o, n);
    }), c.contains && (c.tag === "octstr" || c.tag === "bitstr")) {
      const I = new DecoderBuffer$1(h);
      h = this._getUse(c.contains, o._reporterState.obj)._decode(I, n);
    }
  }
  return c.obj && g && (h = o.leaveObject(u)), c.key === null || h === null && g !== !0 ? y !== null && o.exitKey(y) : o.leaveKey(y, c.key, h), h;
}, Node$2.prototype._decodeGeneric = function(o, n, c) {
  const u = this._baseState;
  return o === "seq" || o === "set" ? null : o === "seqof" || o === "setof" ? this._decodeList(n, o, u.args[0], c) : /str$/.test(o) ? this._decodeStr(n, o, c) : o === "objid" && u.args ? this._decodeObjid(n, u.args[0], u.args[1], c) : o === "objid" ? this._decodeObjid(n, null, null, c) : o === "gentime" || o === "utctime" ? this._decodeTime(n, o, c) : o === "null_" ? this._decodeNull(n, c) : o === "bool" ? this._decodeBool(n, c) : o === "objDesc" ? this._decodeStr(n, o, c) : o === "int" || o === "enum" ? this._decodeInt(n, u.args && u.args[0], c) : u.use !== null ? this._getUse(u.use, n._reporterState.obj)._decode(n, c) : n.error("unknown tag: " + o);
}, Node$2.prototype._getUse = function(o, n) {
  const c = this._baseState;
  return c.useDecoder = this._use(o, n), assert$f(c.useDecoder._baseState.parent === null), c.useDecoder = c.useDecoder._baseState.children[0], c.implicit !== c.useDecoder._baseState.implicit && (c.useDecoder = c.useDecoder.clone(), c.useDecoder._baseState.implicit = c.implicit), c.useDecoder;
}, Node$2.prototype._decodeChoice = function(o, n) {
  const c = this._baseState;
  let u = null, h = !1;
  return Object.keys(c.choice).some(function(g) {
    const y = o.save(), $ = c.choice[g];
    try {
      const I = $._decode(o, n);
      if (o.isError(I))
        return !1;
      u = { type: g, value: I }, h = !0;
    } catch {
      return o.restore(y), !1;
    }
    return !0;
  }, this), h ? u : o.error("Choice not matched");
}, Node$2.prototype._createEncoderBuffer = function(o) {
  return new EncoderBuffer(o, this.reporter);
}, Node$2.prototype._encode = function(o, n, c) {
  const u = this._baseState;
  if (u.default !== null && u.default === o)
    return;
  const h = this._encodeValue(o, n, c);
  return h === void 0 || this._skipDefault(h, n, c) ? void 0 : h;
}, Node$2.prototype._encodeValue = function(o, n, c) {
  const u = this._baseState;
  if (u.parent === null)
    return u.children[0]._encode(o, n || new Reporter());
  let h = null;
  if (this.reporter = n, u.optional && o === void 0) {
    if (u.default === null)
      return;
    o = u.default;
  }
  let g = null, y = !1;
  if (u.any)
    h = this._createEncoderBuffer(o);
  else if (u.choice)
    h = this._encodeChoice(o, n);
  else if (u.contains)
    g = this._getUse(u.contains, c)._encode(o, n), y = !0;
  else if (u.children)
    g = u.children.map(function($) {
      if ($._baseState.tag === "null_")
        return $._encode(null, n, o);
      if ($._baseState.key === null)
        return n.error("Child should have a key");
      const I = n.enterKey($._baseState.key);
      if (typeof o != "object")
        return n.error("Child expected, but input is not object");
      const P = $._encode(o[$._baseState.key], n, o);
      return n.leaveKey(I), P;
    }, this).filter(function($) {
      return $;
    }), g = this._createEncoderBuffer(g);
  else if (u.tag === "seqof" || u.tag === "setof") {
    if (!u.args || u.args.length !== 1)
      return n.error("Too many args for : " + u.tag);
    if (!Array.isArray(o))
      return n.error("seqof/setof, but data is not Array");
    const $ = this.clone();
    $._baseState.implicit = null, g = this._createEncoderBuffer(o.map(function(I) {
      const P = this._baseState;
      return this._getUse(P.args[0], o)._encode(I, n);
    }, $));
  } else
    u.use !== null ? h = this._getUse(u.use, c)._encode(o, n) : (g = this._encodePrimitive(u.tag, o), y = !0);
  if (!u.any && u.choice === null) {
    const $ = u.implicit !== null ? u.implicit : u.tag, I = u.implicit === null ? "universal" : "context";
    $ === null ? u.use === null && n.error("Tag could be omitted only for .use()") : u.use === null && (h = this._encodeComposite($, y, I, g));
  }
  return u.explicit !== null && (h = this._encodeComposite(u.explicit, !1, "context", h)), h;
}, Node$2.prototype._encodeChoice = function(o, n) {
  const c = this._baseState, u = c.choice[o.type];
  return u || assert$f(!1, o.type + " not found in " + JSON.stringify(Object.keys(c.choice))), u._encode(o.value, n);
}, Node$2.prototype._encodePrimitive = function(o, n) {
  const c = this._baseState;
  if (/str$/.test(o))
    return this._encodeStr(n, o);
  if (o === "objid" && c.args)
    return this._encodeObjid(n, c.reverseArgs[0], c.args[1]);
  if (o === "objid")
    return this._encodeObjid(n, null, null);
  if (o === "gentime" || o === "utctime")
    return this._encodeTime(n, o);
  if (o === "null_")
    return this._encodeNull();
  if (o === "int" || o === "enum")
    return this._encodeInt(n, c.args && c.reverseArgs[0]);
  if (o === "bool")
    return this._encodeBool(n);
  if (o === "objDesc")
    return this._encodeStr(n, o);
  throw new Error("Unsupported tag: " + o);
}, Node$2.prototype._isNumstr = function(o) {
  return /^[0-9 ]*$/.test(o);
}, Node$2.prototype._isPrintstr = function(o) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(o);
};
var der$2 = {};
(function(o) {
  function n(c) {
    const u = {};
    return Object.keys(c).forEach(function(h) {
      (0 | h) == h && (h |= 0);
      const g = c[h];
      u[g] = h;
    }), u;
  }
  o.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }, o.tagClassByName = n(o.tagClass), o.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }, o.tagByName = n(o.tag);
})(der$2);
const inherits$7 = requireInherits_browser(), Buffer$6 = safer_1.Buffer, Node$1 = node, der$1 = der$2;
function DEREncoder$1(o) {
  this.enc = "der", this.name = o.name, this.entity = o, this.tree = new DERNode$1(), this.tree._init(o.body);
}
var der_1$1 = DEREncoder$1;
function DERNode$1(o) {
  Node$1.call(this, "der", o);
}
function two(o) {
  return o < 10 ? "0" + o : o;
}
function encodeTag(o, n, c, u) {
  let h;
  if (o === "seqof" ? o = "seq" : o === "setof" && (o = "set"), der$1.tagByName.hasOwnProperty(o))
    h = der$1.tagByName[o];
  else {
    if (typeof o != "number" || (0 | o) !== o)
      return u.error("Unknown tag: " + o);
    h = o;
  }
  return h >= 31 ? u.error("Multi-octet tag encoding unsupported") : (n || (h |= 32), h |= der$1.tagClassByName[c || "universal"] << 6, h);
}
DEREncoder$1.prototype.encode = function(o, n) {
  return this.tree._encode(o, n).join();
}, inherits$7(DERNode$1, Node$1), DERNode$1.prototype._encodeComposite = function(o, n, c, u) {
  const h = encodeTag(o, n, c, this.reporter);
  if (u.length < 128) {
    const $ = Buffer$6.alloc(2);
    return $[0] = h, $[1] = u.length, this._createEncoderBuffer([$, u]);
  }
  let g = 1;
  for (let $ = u.length; $ >= 256; $ >>= 8)
    g++;
  const y = Buffer$6.alloc(2 + g);
  y[0] = h, y[1] = 128 | g;
  for (let $ = 1 + g, I = u.length; I > 0; $--, I >>= 8)
    y[$] = 255 & I;
  return this._createEncoderBuffer([y, u]);
}, DERNode$1.prototype._encodeStr = function(o, n) {
  if (n === "bitstr")
    return this._createEncoderBuffer([0 | o.unused, o.data]);
  if (n === "bmpstr") {
    const c = Buffer$6.alloc(2 * o.length);
    for (let u = 0; u < o.length; u++)
      c.writeUInt16BE(o.charCodeAt(u), 2 * u);
    return this._createEncoderBuffer(c);
  }
  return n === "numstr" ? this._isNumstr(o) ? this._createEncoderBuffer(o) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : n === "printstr" ? this._isPrintstr(o) ? this._createEncoderBuffer(o) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(n) || n === "objDesc" ? this._createEncoderBuffer(o) : this.reporter.error("Encoding of string type: " + n + " unsupported");
}, DERNode$1.prototype._encodeObjid = function(o, n, c) {
  if (typeof o == "string") {
    if (!n)
      return this.reporter.error("string objid given, but no values map found");
    if (!n.hasOwnProperty(o))
      return this.reporter.error("objid not found in values map");
    o = n[o].split(/[\s.]+/g);
    for (let y = 0; y < o.length; y++)
      o[y] |= 0;
  } else if (Array.isArray(o)) {
    o = o.slice();
    for (let y = 0; y < o.length; y++)
      o[y] |= 0;
  }
  if (!Array.isArray(o))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(o));
  if (!c) {
    if (o[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    o.splice(0, 2, 40 * o[0] + o[1]);
  }
  let u = 0;
  for (let y = 0; y < o.length; y++) {
    let $ = o[y];
    for (u++; $ >= 128; $ >>= 7)
      u++;
  }
  const h = Buffer$6.alloc(u);
  let g = h.length - 1;
  for (let y = o.length - 1; y >= 0; y--) {
    let $ = o[y];
    for (h[g--] = 127 & $; ($ >>= 7) > 0; )
      h[g--] = 128 | 127 & $;
  }
  return this._createEncoderBuffer(h);
}, DERNode$1.prototype._encodeTime = function(o, n) {
  let c;
  const u = new Date(o);
  return n === "gentime" ? c = [two(u.getUTCFullYear()), two(u.getUTCMonth() + 1), two(u.getUTCDate()), two(u.getUTCHours()), two(u.getUTCMinutes()), two(u.getUTCSeconds()), "Z"].join("") : n === "utctime" ? c = [two(u.getUTCFullYear() % 100), two(u.getUTCMonth() + 1), two(u.getUTCDate()), two(u.getUTCHours()), two(u.getUTCMinutes()), two(u.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + n + " time is not supported yet"), this._encodeStr(c, "octstr");
}, DERNode$1.prototype._encodeNull = function() {
  return this._createEncoderBuffer("");
}, DERNode$1.prototype._encodeInt = function(o, n) {
  if (typeof o == "string") {
    if (!n)
      return this.reporter.error("String int or enum given, but no values map");
    if (!n.hasOwnProperty(o))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(o));
    o = n[o];
  }
  if (typeof o != "number" && !Buffer$6.isBuffer(o)) {
    const h = o.toArray();
    !o.sign && 128 & h[0] && h.unshift(0), o = Buffer$6.from(h);
  }
  if (Buffer$6.isBuffer(o)) {
    let h = o.length;
    o.length === 0 && h++;
    const g = Buffer$6.alloc(h);
    return o.copy(g), o.length === 0 && (g[0] = 0), this._createEncoderBuffer(g);
  }
  if (o < 128)
    return this._createEncoderBuffer(o);
  if (o < 256)
    return this._createEncoderBuffer([0, o]);
  let c = 1;
  for (let h = o; h >= 256; h >>= 8)
    c++;
  const u = new Array(c);
  for (let h = u.length - 1; h >= 0; h--)
    u[h] = 255 & o, o >>= 8;
  return 128 & u[0] && u.unshift(0), this._createEncoderBuffer(Buffer$6.from(u));
}, DERNode$1.prototype._encodeBool = function(o) {
  return this._createEncoderBuffer(o ? 255 : 0);
}, DERNode$1.prototype._use = function(o, n) {
  return typeof o == "function" && (o = o(n)), o._getEncoder("der").tree;
}, DERNode$1.prototype._skipDefault = function(o, n, c) {
  const u = this._baseState;
  let h;
  if (u.default === null)
    return !1;
  const g = o.join();
  if (u.defaultBuffer === void 0 && (u.defaultBuffer = this._encodeValue(u.default, n, c).join()), g.length !== u.defaultBuffer.length)
    return !1;
  for (h = 0; h < g.length; h++)
    if (g[h] !== u.defaultBuffer[h])
      return !1;
  return !0;
};
const inherits$6 = requireInherits_browser(), DEREncoder = der_1$1;
function PEMEncoder(o) {
  DEREncoder.call(this, o), this.enc = "pem";
}
inherits$6(PEMEncoder, DEREncoder);
var pem$1 = PEMEncoder;
PEMEncoder.prototype.encode = function(o, n) {
  const c = DEREncoder.prototype.encode.call(this, o).toString("base64"), u = ["-----BEGIN " + n.label + "-----"];
  for (let h = 0; h < c.length; h += 64)
    u.push(c.slice(h, h + 64));
  return u.push("-----END " + n.label + "-----"), u.join(`
`);
}, function(o) {
  const n = encoders;
  n.der = der_1$1, n.pem = pem$1;
}();
var decoders = {};
const inherits$5 = requireInherits_browser(), bignum = bn$3.exports, DecoderBuffer = buffer.DecoderBuffer, Node = node, der = der$2;
function DERDecoder$1(o) {
  this.enc = "der", this.name = o.name, this.entity = o, this.tree = new DERNode(), this.tree._init(o.body);
}
var der_1 = DERDecoder$1;
function DERNode(o) {
  Node.call(this, "der", o);
}
function derDecodeTag(o, n) {
  let c = o.readUInt8(n);
  if (o.isError(c))
    return c;
  const u = der.tagClass[c >> 6], h = (32 & c) == 0;
  if ((31 & c) == 31) {
    let g = c;
    for (c = 0; (128 & g) == 128; ) {
      if (g = o.readUInt8(n), o.isError(g))
        return g;
      c <<= 7, c |= 127 & g;
    }
  } else
    c &= 31;
  return { cls: u, primitive: h, tag: c, tagStr: der.tag[c] };
}
function derDecodeLen(o, n, c) {
  let u = o.readUInt8(c);
  if (o.isError(u))
    return u;
  if (!n && u === 128)
    return null;
  if ((128 & u) == 0)
    return u;
  const h = 127 & u;
  if (h > 4)
    return o.error("length octect is too long");
  u = 0;
  for (let g = 0; g < h; g++) {
    u <<= 8;
    const y = o.readUInt8(c);
    if (o.isError(y))
      return y;
    u |= y;
  }
  return u;
}
DERDecoder$1.prototype.decode = function(o, n) {
  return DecoderBuffer.isDecoderBuffer(o) || (o = new DecoderBuffer(o, n)), this.tree._decode(o, n);
}, inherits$5(DERNode, Node), DERNode.prototype._peekTag = function(o, n, c) {
  if (o.isEmpty())
    return !1;
  const u = o.save(), h = derDecodeTag(o, 'Failed to peek tag: "' + n + '"');
  return o.isError(h) ? h : (o.restore(u), h.tag === n || h.tagStr === n || h.tagStr + "of" === n || c);
}, DERNode.prototype._decodeTag = function(o, n, c) {
  const u = derDecodeTag(o, 'Failed to decode tag of "' + n + '"');
  if (o.isError(u))
    return u;
  let h = derDecodeLen(o, u.primitive, 'Failed to get length of "' + n + '"');
  if (o.isError(h))
    return h;
  if (!c && u.tag !== n && u.tagStr !== n && u.tagStr + "of" !== n)
    return o.error('Failed to match tag: "' + n + '"');
  if (u.primitive || h !== null)
    return o.skip(h, 'Failed to match body of: "' + n + '"');
  const g = o.save(), y = this._skipUntilEnd(o, 'Failed to skip indefinite length body: "' + this.tag + '"');
  return o.isError(y) ? y : (h = o.offset - g.offset, o.restore(g), o.skip(h, 'Failed to match body of: "' + n + '"'));
}, DERNode.prototype._skipUntilEnd = function(o, n) {
  for (; ; ) {
    const c = derDecodeTag(o, n);
    if (o.isError(c))
      return c;
    const u = derDecodeLen(o, c.primitive, n);
    if (o.isError(u))
      return u;
    let h;
    if (h = c.primitive || u !== null ? o.skip(u) : this._skipUntilEnd(o, n), o.isError(h))
      return h;
    if (c.tagStr === "end")
      break;
  }
}, DERNode.prototype._decodeList = function(o, n, c, u) {
  const h = [];
  for (; !o.isEmpty(); ) {
    const g = this._peekTag(o, "end");
    if (o.isError(g))
      return g;
    const y = c.decode(o, "der", u);
    if (o.isError(y) && g)
      break;
    h.push(y);
  }
  return h;
}, DERNode.prototype._decodeStr = function(o, n) {
  if (n === "bitstr") {
    const c = o.readUInt8();
    return o.isError(c) ? c : { unused: c, data: o.raw() };
  }
  if (n === "bmpstr") {
    const c = o.raw();
    if (c.length % 2 == 1)
      return o.error("Decoding of string type: bmpstr length mismatch");
    let u = "";
    for (let h = 0; h < c.length / 2; h++)
      u += String.fromCharCode(c.readUInt16BE(2 * h));
    return u;
  }
  if (n === "numstr") {
    const c = o.raw().toString("ascii");
    return this._isNumstr(c) ? c : o.error("Decoding of string type: numstr unsupported characters");
  }
  if (n === "octstr" || n === "objDesc")
    return o.raw();
  if (n === "printstr") {
    const c = o.raw().toString("ascii");
    return this._isPrintstr(c) ? c : o.error("Decoding of string type: printstr unsupported characters");
  }
  return /str$/.test(n) ? o.raw().toString() : o.error("Decoding of string type: " + n + " unsupported");
}, DERNode.prototype._decodeObjid = function(o, n, c) {
  let u;
  const h = [];
  let g = 0, y = 0;
  for (; !o.isEmpty(); )
    y = o.readUInt8(), g <<= 7, g |= 127 & y, (128 & y) == 0 && (h.push(g), g = 0);
  128 & y && h.push(g);
  const $ = h[0] / 40 | 0, I = h[0] % 40;
  if (u = c ? h : [$, I].concat(h.slice(1)), n) {
    let P = n[u.join(" ")];
    P === void 0 && (P = n[u.join(".")]), P !== void 0 && (u = P);
  }
  return u;
}, DERNode.prototype._decodeTime = function(o, n) {
  const c = o.raw().toString();
  let u, h, g, y, $, I;
  if (n === "gentime")
    u = 0 | c.slice(0, 4), h = 0 | c.slice(4, 6), g = 0 | c.slice(6, 8), y = 0 | c.slice(8, 10), $ = 0 | c.slice(10, 12), I = 0 | c.slice(12, 14);
  else {
    if (n !== "utctime")
      return o.error("Decoding " + n + " time is not supported yet");
    u = 0 | c.slice(0, 2), h = 0 | c.slice(2, 4), g = 0 | c.slice(4, 6), y = 0 | c.slice(6, 8), $ = 0 | c.slice(8, 10), I = 0 | c.slice(10, 12), u = u < 70 ? 2e3 + u : 1900 + u;
  }
  return Date.UTC(u, h - 1, g, y, $, I, 0);
}, DERNode.prototype._decodeNull = function() {
  return null;
}, DERNode.prototype._decodeBool = function(o) {
  const n = o.readUInt8();
  return o.isError(n) ? n : n !== 0;
}, DERNode.prototype._decodeInt = function(o, n) {
  const c = o.raw();
  let u = new bignum(c);
  return n && (u = n[u.toString(10)] || u), u;
}, DERNode.prototype._use = function(o, n) {
  return typeof o == "function" && (o = o(n)), o._getDecoder("der").tree;
};
const inherits$4 = requireInherits_browser(), Buffer$5 = safer_1.Buffer, DERDecoder = der_1;
function PEMDecoder(o) {
  DERDecoder.call(this, o), this.enc = "pem";
}
inherits$4(PEMDecoder, DERDecoder);
var pem = PEMDecoder;
PEMDecoder.prototype.decode = function(o, n) {
  const c = o.toString().split(/[\r\n]+/g), u = n.label.toUpperCase(), h = /^-----(BEGIN|END) ([^-]+)-----$/;
  let g = -1, y = -1;
  for (let P = 0; P < c.length; P++) {
    const L = c[P].match(h);
    if (L !== null && L[2] === u) {
      if (g !== -1) {
        if (L[1] !== "END")
          break;
        y = P;
        break;
      }
      if (L[1] !== "BEGIN")
        break;
      g = P;
    }
  }
  if (g === -1 || y === -1)
    throw new Error("PEM section not found for: " + u);
  const $ = c.slice(g + 1, y).join("");
  $.replace(/[^a-z0-9+/=]+/gi, "");
  const I = Buffer$5.from($, "base64");
  return DERDecoder.prototype.decode.call(this, I, n);
}, function(o) {
  const n = decoders;
  n.der = der_1, n.pem = pem;
}(), function(o) {
  const n = encoders, c = decoders, u = requireInherits_browser();
  function h(g, y) {
    this.name = g, this.body = y, this.decoders = {}, this.encoders = {};
  }
  o.define = function(g, y) {
    return new h(g, y);
  }, h.prototype._createNamed = function(g) {
    const y = this.name;
    function $(I) {
      this._initNamed(I, y);
    }
    return u($, g), $.prototype._initNamed = function(I, P) {
      g.call(this, I, P);
    }, new $(this);
  }, h.prototype._getDecoder = function(g) {
    return g = g || "der", this.decoders.hasOwnProperty(g) || (this.decoders[g] = this._createNamed(c[g])), this.decoders[g];
  }, h.prototype.decode = function(g, y, $) {
    return this._getDecoder(y).decode(g, $);
  }, h.prototype._getEncoder = function(g) {
    return g = g || "der", this.encoders.hasOwnProperty(g) || (this.encoders[g] = this._createNamed(n[g])), this.encoders[g];
  }, h.prototype.encode = function(g, y, $) {
    return this._getEncoder(y).encode(g, $);
  };
}(api);
var base$1 = {};
(function(o) {
  const n = base$1;
  n.Reporter = reporter.Reporter, n.DecoderBuffer = buffer.DecoderBuffer, n.EncoderBuffer = buffer.EncoderBuffer, n.Node = node;
})();
var constants$1 = {};
(function(o) {
  const n = constants$1;
  n._reverse = function(c) {
    const u = {};
    return Object.keys(c).forEach(function(h) {
      (0 | h) == h && (h |= 0);
      const g = c[h];
      u[g] = h;
    }), u;
  }, n.der = der$2;
})(), function(o) {
  const n = asn1;
  n.bignum = bn$3.exports, n.define = api.define, n.base = base$1, n.constants = constants$1, n.decoders = decoders, n.encoders = encoders;
}();
var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, c, u) {
  u === void 0 && (u = c);
  var h = Object.getOwnPropertyDescriptor(n, c);
  h && !("get" in h ? !n.__esModule : h.writable || h.configurable) || (h = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(o, u, h);
} : function(o, n, c, u) {
  u === void 0 && (u = c), o[u] = n[c];
}), __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var c in o)
      c !== "default" && Object.prototype.hasOwnProperty.call(o, c) && __createBinding$5(n, o, c);
  return __setModuleDefault$5(n, o), n;
};
Object.defineProperty(pem$2, "__esModule", { value: !0 }), pem$2.jwkTopem = pem$2.pemTojwk = void 0;
const asn = __importStar$5(asn1);
function urlize(o) {
  return o.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hex2b64url(o) {
  return urlize(Buffer.from(o, "hex").toString("base64"));
}
var RSAPublicKey = asn.define("RSAPublicKey", function() {
  this.seq().obj(this.key("n").int(), this.key("e").int());
}), AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
}), PublicKeyInfo = asn.define("PublicKeyInfo", function() {
  this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("publicKey").bitstr());
}), Version = asn.define("Version", function() {
  this.int({ 0: "two-prime", 1: "multi" });
}), OtherPrimeInfos = asn.define("OtherPrimeInfos", function() {
  this.seq().obj(this.key("ri").int(), this.key("di").int(), this.key("ti").int());
}), RSAPrivateKey = asn.define("RSAPrivateKey", function() {
  this.seq().obj(this.key("version").use(Version), this.key("n").int(), this.key("e").int(), this.key("d").int(), this.key("p").int(), this.key("q").int(), this.key("dp").int(), this.key("dq").int(), this.key("qi").int(), this.key("other").optional().use(OtherPrimeInfos));
}), PrivateKeyInfo = asn.define("PrivateKeyInfo", function() {
  this.seq().obj(this.key("version").use(Version), this.key("algorithm").use(AlgorithmIdentifier), this.key("privateKey").bitstr());
});
function addExtras(o, n) {
  return n = n || {}, Object.keys(n).forEach(function(c) {
    o[c] = n[c];
  }), o;
}
function pad(o) {
  return o.length % 2 == 1 ? "0" + o : o;
}
function decodeRsaPublic(o, n) {
  var c = RSAPublicKey.decode(o, "der"), u = pad(c.e.toString(16));
  return addExtras({ kty: "RSA", n: bn2base64url(c.n), e: hex2b64url(u) }, n);
}
function decodeRsaPrivate(o, n) {
  var c = RSAPrivateKey.decode(o, "der"), u = pad(c.e.toString(16));
  return addExtras({ kty: "RSA", n: bn2base64url(c.n), e: hex2b64url(u), d: bn2base64url(c.d), p: bn2base64url(c.p), q: bn2base64url(c.q), dp: bn2base64url(c.dp), dq: bn2base64url(c.dq), qi: bn2base64url(c.qi) }, n);
}
function decodePublic(o, n) {
  return decodeRsaPublic(PublicKeyInfo.decode(o, "der").publicKey.data, n);
}
function decodePrivate(o, n) {
  return decodeRsaPrivate(PrivateKeyInfo.decode(o, "der").privateKey.data, n);
}
function getDecoder(o) {
  var n = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(o);
  if (!n)
    return null;
  var c = !!n[1];
  return n[2] === "PRIVATE" ? c ? decodeRsaPrivate : decodePrivate : c ? decodeRsaPublic : decodePublic;
}
function parse(o) {
  return { n: string2bn(o.n), e: string2bn(o.e), d: o.d && string2bn(o.d), p: o.p && string2bn(o.p), q: o.q && string2bn(o.q), dp: o.dp && string2bn(o.dp), dq: o.dq && string2bn(o.dq), qi: o.qi && string2bn(o.qi) };
}
function bn2base64url(o) {
  return hex2b64url(pad(o.toString(16)));
}
function base64url2bn(o) {
  return new asn.bignum(Buffer.from(o, "base64"));
}
function string2bn(o) {
  return /^[0-9]+$/.test(o) ? new asn.bignum(o, 10) : base64url2bn(o);
}
function pemTojwk(o, n) {
  var c = o.toString().split(/(\r\n|\r|\n)+/g), u = getDecoder((c = c.filter(function(h) {
    return h.trim().length !== 0;
  }))[0]);
  return c = c.slice(1, -1).join(""), u(Buffer.from(c.replace(/[^\w\d\+\/=]+/g, ""), "base64"), n);
}
function jwkTopem(o) {
  var n = parse(o), c = !!n.d, u = c ? "PRIVATE" : "PUBLIC", h = "-----BEGIN RSA " + u + ` KEY-----
`, g = `
-----END RSA ` + u + ` KEY-----
`, y = Buffer.alloc(0);
  return c ? (n.version = "two-prime", y = RSAPrivateKey.encode(n, "der")) : y = RSAPublicKey.encode(n, "der"), h + y.toString("base64").match(/.{1,64}/g).join(`
`) + g;
}
pem$2.pemTojwk = pemTojwk, pem$2.jwkTopem = jwkTopem;
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, c, u) {
  u === void 0 && (u = c);
  var h = Object.getOwnPropertyDescriptor(n, c);
  h && !("get" in h ? !n.__esModule : h.writable || h.configurable) || (h = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(o, u, h);
} : function(o, n, c, u) {
  u === void 0 && (u = c), o[u] = n[c];
}), __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var c in o)
      c !== "default" && Object.prototype.hasOwnProperty.call(o, c) && __createBinding$4(n, o, c);
  return __setModuleDefault$4(n, o), n;
};
Object.defineProperty(nodeDriver, "__esModule", { value: !0 });
const pem_1 = pem$2, crypto$2 = __importStar$4(require$$2$1), constants = __importStar$4(require$$2$1);
class NodeCryptoDriver {
  constructor() {
    this.keyLength = 4096, this.publicExponent = 65537, this.hashAlgorithm = "sha256", this.encryptionAlgorithm = "aes-256-cbc";
  }
  generateJWK() {
    if (typeof crypto$2.generateKeyPair != "function")
      throw new Error("Keypair generation not supported in this version of Node, only supported in versions 10+");
    return new Promise((n, c) => {
      crypto$2.generateKeyPair("rsa", { modulusLength: this.keyLength, publicExponent: this.publicExponent, privateKeyEncoding: { type: "pkcs1", format: "pem" }, publicKeyEncoding: { type: "pkcs1", format: "pem" } }, (u, h, g) => {
        u && c(u), n(this.pemToJWK(g));
      });
    });
  }
  sign(n, c, { saltLength: u } = {}) {
    return new Promise((h, g) => {
      h(crypto$2.createSign(this.hashAlgorithm).update(c).sign({ key: this.jwkToPem(n), padding: constants.RSA_PKCS1_PSS_PADDING, saltLength: u }));
    });
  }
  verify(n, c, u) {
    return new Promise((h, g) => {
      const y = { kty: "RSA", e: "AQAB", n }, $ = this.jwkToPem(y);
      h(crypto$2.createVerify(this.hashAlgorithm).update(c).verify({ key: $, padding: constants.RSA_PKCS1_PSS_PADDING }, u));
    });
  }
  hash(n, c = "SHA-256") {
    return new Promise((u, h) => {
      u(crypto$2.createHash(this.parseHashAlgorithm(c)).update(n).digest());
    });
  }
  async encrypt(n, c, u) {
    const h = crypto$2.pbkdf2Sync(c, u = u || "salt", 1e5, 32, this.hashAlgorithm), g = crypto$2.randomBytes(16), y = crypto$2.createCipheriv(this.encryptionAlgorithm, h, g);
    return Buffer.concat([g, y.update(n), y.final()]);
  }
  async decrypt(n, c, u) {
    try {
      const h = crypto$2.pbkdf2Sync(c, u = u || "salt", 1e5, 32, this.hashAlgorithm), g = n.slice(0, 16), y = n.slice(16), $ = crypto$2.createDecipheriv(this.encryptionAlgorithm, h, g);
      return Buffer.concat([$.update(y), $.final()]);
    } catch {
      throw new Error("Failed to decrypt");
    }
  }
  jwkToPem(n) {
    return (0, pem_1.jwkTopem)(n);
  }
  pemToJWK(n) {
    return (0, pem_1.pemTojwk)(n);
  }
  parseHashAlgorithm(n) {
    switch (n) {
      case "SHA-256":
        return "sha256";
      case "SHA-384":
        return "sha384";
      default:
        throw new Error(`Algorithm not supported: ${n}`);
    }
  }
}
nodeDriver.default = NodeCryptoDriver;
var network = {};
Object.defineProperty(network, "__esModule", { value: !0 });
class Network {
  constructor(n) {
    this.api = n;
  }
  getInfo() {
    return this.api.get("info").then((n) => n.data);
  }
  getPeers() {
    return this.api.get("peers").then((n) => n.data);
  }
}
network.default = Network;
var transactions = {}, error = {};
Object.defineProperty(error, "__esModule", { value: !0 }), error.getError = void 0;
class ArweaveError extends Error {
  constructor(n, c = {}) {
    c.message ? super(c.message) : super(), this.type = n, this.response = c.response;
  }
  getType() {
    return this.type;
  }
}
function getError(o) {
  let n = o.data;
  if (typeof o.data == "string")
    try {
      n = JSON.parse(o.data);
    } catch {
    }
  if (o.data instanceof ArrayBuffer || o.data instanceof Uint8Array)
    try {
      n = JSON.parse(n.toString());
    } catch {
    }
  return n ? n.error || n : o.statusText || "unknown";
}
error.default = ArweaveError, error.getError = getError;
var transactionUploader = {}, merkle = {}, hasRequiredMerkle, hasRequiredTransactionUploader, hasRequiredTransactions;
function requireMerkle() {
  return hasRequiredMerkle || (hasRequiredMerkle = 1, function(o) {
    var n = commonjsGlobal && commonjsGlobal.__importDefault || function(nt) {
      return nt && nt.__esModule ? nt : { default: nt };
    };
    Object.defineProperty(o, "__esModule", { value: !0 }), o.debug = o.validatePath = o.arrayCompare = o.bufferToInt = o.intToBuffer = o.arrayFlatten = o.generateProofs = o.buildLayers = o.generateTransactionChunks = o.generateTree = o.computeRootHash = o.generateLeaves = o.chunkData = o.MIN_CHUNK_SIZE = o.MAX_CHUNK_SIZE = void 0;
    const c = n(requireCommon()), u = utils$o;
    o.MAX_CHUNK_SIZE = 262144, o.MIN_CHUNK_SIZE = 32768;
    async function h(nt) {
      let st = [], ot = nt, St = 0;
      for (; ot.byteLength >= o.MAX_CHUNK_SIZE; ) {
        let Ct = o.MAX_CHUNK_SIZE, et = ot.byteLength - o.MAX_CHUNK_SIZE;
        et > 0 && et < o.MIN_CHUNK_SIZE && (Ct = Math.ceil(ot.byteLength / 2));
        const at = ot.slice(0, Ct), _t = await c.default.crypto.hash(at);
        St += at.byteLength, st.push({ dataHash: _t, minByteRange: St - at.byteLength, maxByteRange: St }), ot = ot.slice(Ct);
      }
      return st.push({ dataHash: await c.default.crypto.hash(ot), minByteRange: St, maxByteRange: St + ot.byteLength }), st;
    }
    async function g(nt) {
      return Promise.all(nt.map(async ({ dataHash: st, minByteRange: ot, maxByteRange: St }) => ({ type: "leaf", id: await N(await Promise.all([N(st), N(X(St))])), dataHash: st, minByteRange: ot, maxByteRange: St })));
    }
    async function y(nt) {
      return await $(await g(await h(nt)));
    }
    async function $(nt, st = 0) {
      if (nt.length < 2)
        return nt[0];
      const ot = [];
      for (let St = 0; St < nt.length; St += 2)
        ot.push(await q(nt[St], nt[St + 1]));
      return $(ot, st + 1);
    }
    function I(nt) {
      const st = P(nt);
      return Array.isArray(st) ? L(st) : [st];
    }
    function P(nt, st = new Uint8Array(), ot = 0) {
      if (nt.type == "leaf")
        return { offset: nt.maxByteRange - 1, proof: (0, u.concatBuffers)([st, nt.dataHash, X(nt.maxByteRange)]) };
      if (nt.type == "branch") {
        const St = (0, u.concatBuffers)([st, nt.leftChild.id, nt.rightChild.id, X(nt.byteRange)]);
        return [P(nt.leftChild, St, ot + 1), P(nt.rightChild, St, ot + 1)];
      }
      throw new Error("Unexpected node type");
    }
    function L(nt) {
      const st = [];
      return nt.forEach((ot) => {
        Array.isArray(ot) ? st.push(...L(ot)) : st.push(ot);
      }), st;
    }
    async function q(nt, st) {
      return st ? { type: "branch", id: await N([await N(nt.id), await N(st.id), await N(X(nt.maxByteRange))]), byteRange: nt.maxByteRange, maxByteRange: st.maxByteRange, leftChild: nt, rightChild: st } : nt;
    }
    async function N(nt) {
      return Array.isArray(nt) && (nt = c.default.utils.concatBuffers(nt)), new Uint8Array(await c.default.crypto.hash(nt));
    }
    function X(nt) {
      const st = new Uint8Array(32);
      for (var ot = st.length - 1; ot >= 0; ot--) {
        var St = nt % 256;
        st[ot] = St, nt = (nt - St) / 256;
      }
      return st;
    }
    function rt(nt) {
      let st = 0;
      for (var ot = 0; ot < nt.length; ot++)
        st *= 256, st += nt[ot];
      return st;
    }
    o.chunkData = h, o.generateLeaves = g, o.computeRootHash = async function(nt) {
      return (await y(nt)).id;
    }, o.generateTree = y, o.generateTransactionChunks = async function(nt) {
      const st = await h(nt), ot = await g(st), St = await $(ot), Ct = await I(St), et = st.slice(-1)[0];
      return et.maxByteRange - et.minByteRange == 0 && (st.splice(st.length - 1, 1), Ct.splice(Ct.length - 1, 1)), { data_root: St.id, chunks: st, proofs: Ct };
    }, o.buildLayers = $, o.generateProofs = I, o.arrayFlatten = L, o.intToBuffer = X, o.bufferToInt = rt, o.arrayCompare = (nt, st) => nt.every((ot, St) => st[St] === ot), o.validatePath = async function nt(st, ot, St, Ct, et) {
      if (Ct <= 0)
        return !1;
      if (ot >= Ct)
        return nt(st, 0, Ct - 1, Ct, et);
      if (ot < 0)
        return nt(st, 0, 0, Ct, et);
      if (et.length == 64) {
        const w = et.slice(0, 32), v = et.slice(w.length, w.length + 32), k = await N([await N(w), await N(v)]);
        return !!(0, o.arrayCompare)(st, k) && { offset: Ct - 1, leftBound: St, rightBound: Ct, chunkSize: Ct - St };
      }
      const at = et.slice(0, 32), _t = et.slice(at.length, at.length + 32), Nt = et.slice(at.length + _t.length, at.length + _t.length + 32), m = rt(Nt), A = et.slice(at.length + _t.length + Nt.length), E = await N([await N(at), await N(_t), await N(Nt)]);
      return !!(0, o.arrayCompare)(st, E) && (ot < m ? await nt(at, ot, St, Math.min(Ct, m), A) : await nt(_t, ot, Math.max(St, m), Ct, A));
    }, o.debug = async function nt(st, ot = "") {
      if (st.byteLength < 1)
        return ot;
      const St = st.slice(0, 32), Ct = st.slice(St.length, St.length + 32), et = st.slice(St.length + Ct.length, St.length + Ct.length + 32), at = rt(et), _t = st.slice(St.length + Ct.length + et.length), Nt = await N([await N(St), await N(Ct), await N(et)]);
      return nt(_t, `${ot}
${JSON.stringify(Buffer.from(St))},${JSON.stringify(Buffer.from(Ct))},${at} => ${JSON.stringify(Nt)}`);
    };
  }(merkle)), merkle;
}
function requireTransactionUploader() {
  if (hasRequiredTransactionUploader)
    return transactionUploader;
  hasRequiredTransactionUploader = 1;
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(L, q, N, X) {
    X === void 0 && (X = N);
    var rt = Object.getOwnPropertyDescriptor(q, N);
    rt && !("get" in rt ? !q.__esModule : rt.writable || rt.configurable) || (rt = { enumerable: !0, get: function() {
      return q[N];
    } }), Object.defineProperty(L, X, rt);
  } : function(L, q, N, X) {
    X === void 0 && (X = N), L[X] = q[N];
  }), n = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(L, q) {
    Object.defineProperty(L, "default", { enumerable: !0, value: q });
  } : function(L, q) {
    L.default = q;
  }), c = commonjsGlobal && commonjsGlobal.__importStar || function(L) {
    if (L && L.__esModule)
      return L;
    var q = {};
    if (L != null)
      for (var N in L)
        N !== "default" && Object.prototype.hasOwnProperty.call(L, N) && o(q, L, N);
    return n(q, L), q;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(L) {
    return L && L.__esModule ? L : { default: L };
  };
  Object.defineProperty(transactionUploader, "__esModule", { value: !0 }), transactionUploader.TransactionUploader = void 0;
  const h = u(requireTransaction()), g = c(utils$o), y = error, $ = requireMerkle(), I = ["invalid_json", "chunk_too_big", "data_path_too_big", "offset_too_big", "data_size_too_big", "chunk_proof_ratio_not_attractive", "invalid_proof"];
  class P {
    constructor(q, N) {
      if (this.api = q, this.chunkIndex = 0, this.txPosted = !1, this.lastRequestTimeEnd = 0, this.totalErrors = 0, this.lastResponseStatus = 0, this.lastResponseError = "", !N.id)
        throw new Error("Transaction is not signed");
      if (!N.chunks)
        throw new Error("Transaction chunks not prepared");
      this.data = N.data, this.transaction = new h.default(Object.assign({}, N, { data: new Uint8Array(0) }));
    }
    get isComplete() {
      return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
    }
    get totalChunks() {
      return this.transaction.chunks.chunks.length;
    }
    get uploadedChunks() {
      return this.chunkIndex;
    }
    get pctComplete() {
      return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
    }
    async uploadChunk(q) {
      if (this.isComplete)
        throw new Error("Upload is already complete");
      if (this.lastResponseError !== "" ? this.totalErrors++ : this.totalErrors = 0, this.totalErrors === 100)
        throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
      let N = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + 4e4 - Date.now(), 4e4);
      if (N > 0 && (N -= N * Math.random() * 0.3, await new Promise((nt) => setTimeout(nt, N))), this.lastResponseError = "", !this.txPosted)
        return void await this.postTransaction();
      q && (this.chunkIndex = q);
      const X = this.transaction.getChunk(q || this.chunkIndex, this.data);
      if (!await (0, $.validatePath)(this.transaction.chunks.data_root, parseInt(X.offset), 0, parseInt(X.data_size), g.b64UrlToBuffer(X.data_path)))
        throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
      const rt = await this.api.post("chunk", this.transaction.getChunk(this.chunkIndex, this.data)).catch((nt) => (console.error(nt.message), { status: -1, data: { error: nt.message } }));
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = rt.status, this.lastResponseStatus == 200)
        this.chunkIndex++;
      else if (this.lastResponseError = (0, y.getError)(rt), I.includes(this.lastResponseError))
        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
    }
    static async fromSerialized(q, N, X) {
      if (!N || typeof N.chunkIndex != "number" || typeof N.transaction != "object")
        throw new Error("Serialized object does not match expected format.");
      var rt = new h.default(N.transaction);
      rt.chunks || await rt.prepareChunks(X);
      const nt = new P(q, rt);
      if (nt.chunkIndex = N.chunkIndex, nt.lastRequestTimeEnd = N.lastRequestTimeEnd, nt.lastResponseError = N.lastResponseError, nt.lastResponseStatus = N.lastResponseStatus, nt.txPosted = N.txPosted, nt.data = X, nt.transaction.data_root !== N.transaction.data_root)
        throw new Error("Data mismatch: Uploader doesn't match provided data.");
      return nt;
    }
    static async fromTransactionId(q, N) {
      const X = await q.get(`tx/${N}`);
      if (X.status !== 200)
        throw new Error(`Tx ${N} not found: ${X.status}`);
      const rt = X.data;
      return rt.data = new Uint8Array(0), { txPosted: !0, chunkIndex: 0, lastResponseError: "", lastRequestTimeEnd: 0, lastResponseStatus: 0, transaction: rt };
    }
    toJSON() {
      return { chunkIndex: this.chunkIndex, transaction: this.transaction, lastRequestTimeEnd: this.lastRequestTimeEnd, lastResponseStatus: this.lastResponseStatus, lastResponseError: this.lastResponseError, txPosted: this.txPosted };
    }
    async postTransaction() {
      if (this.totalChunks <= 1) {
        this.transaction.data = this.data;
        const N = await this.api.post("tx", this.transaction).catch((X) => (console.error(X), { status: -1, data: { error: X.message } }));
        if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = N.status, this.transaction.data = new Uint8Array(0), N.status >= 200 && N.status < 300)
          return this.txPosted = !0, void (this.chunkIndex = 1);
        throw this.lastResponseError = (0, y.getError)(N), new Error(`Unable to upload transaction: ${N.status}, ${this.lastResponseError}`);
      }
      const q = await this.api.post("tx", this.transaction);
      if (this.lastRequestTimeEnd = Date.now(), this.lastResponseStatus = q.status, !(q.status >= 200 && q.status < 300))
        throw this.lastResponseError = (0, y.getError)(q), new Error(`Unable to upload transaction: ${q.status}, ${this.lastResponseError}`);
      this.txPosted = !0;
    }
  }
  return transactionUploader.TransactionUploader = P, transactionUploader;
}
function requireTransactions() {
  if (hasRequiredTransactions)
    return transactions;
  hasRequiredTransactions = 1;
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(L, q, N, X) {
    X === void 0 && (X = N);
    var rt = Object.getOwnPropertyDescriptor(q, N);
    rt && !("get" in rt ? !q.__esModule : rt.writable || rt.configurable) || (rt = { enumerable: !0, get: function() {
      return q[N];
    } }), Object.defineProperty(L, X, rt);
  } : function(L, q, N, X) {
    X === void 0 && (X = N), L[X] = q[N];
  }), n = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(L, q) {
    Object.defineProperty(L, "default", { enumerable: !0, value: q });
  } : function(L, q) {
    L.default = q;
  }), c = commonjsGlobal && commonjsGlobal.__importStar || function(L) {
    if (L && L.__esModule)
      return L;
    var q = {};
    if (L != null)
      for (var N in L)
        N !== "default" && Object.prototype.hasOwnProperty.call(L, N) && o(q, L, N);
    return n(q, L), q;
  }, u = commonjsGlobal && commonjsGlobal.__await || function(L) {
    return this instanceof u ? (this.v = L, this) : new u(L);
  }, h = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(L, q, N) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var X, rt = N.apply(L, q || []), nt = [];
    return X = {}, st("next"), st("throw"), st("return"), X[Symbol.asyncIterator] = function() {
      return this;
    }, X;
    function st(at) {
      rt[at] && (X[at] = function(_t) {
        return new Promise(function(Nt, m) {
          nt.push([at, _t, Nt, m]) > 1 || ot(at, _t);
        });
      });
    }
    function ot(at, _t) {
      try {
        (function(Nt) {
          Nt.value instanceof u ? Promise.resolve(Nt.value.v).then(St, Ct) : et(nt[0][2], Nt);
        })(rt[at](_t));
      } catch (Nt) {
        et(nt[0][3], Nt);
      }
    }
    function St(at) {
      ot("next", at);
    }
    function Ct(at) {
      ot("throw", at);
    }
    function et(at, _t) {
      at(_t), nt.shift(), nt.length && ot(nt[0][0], nt[0][1]);
    }
  }, g = commonjsGlobal && commonjsGlobal.__importDefault || function(L) {
    return L && L.__esModule ? L : { default: L };
  };
  Object.defineProperty(transactions, "__esModule", { value: !0 });
  const y = g(error), $ = g(requireTransaction()), I = c(utils$o), P = requireTransactionUploader();
  return transactions.default = class {
    constructor(L, q, N) {
      this.api = L, this.crypto = q, this.chunks = N;
    }
    getTransactionAnchor() {
      return this.api.get("tx_anchor", { transformResponse: [] }).then((L) => L.data);
    }
    getPrice(L, q) {
      let N = q ? `price/${L}/${q}` : `price/${L}`;
      return this.api.get(N, { transformResponse: [function(X) {
        return X;
      }] }).then((X) => X.data);
    }
    async get(L) {
      const q = await this.api.get(`tx/${L}`);
      if (q.status == 200) {
        const N = parseInt(q.data.data_size);
        if (q.data.format >= 2 && N > 0 && N <= 12582912) {
          const X = await this.getData(L);
          return new $.default(Object.assign(Object.assign({}, q.data), { data: X }));
        }
        return new $.default(Object.assign(Object.assign({}, q.data), { format: q.data.format || 1 }));
      }
      throw q.status == 404 ? new y.default("TX_NOT_FOUND") : q.status == 410 ? new y.default("TX_FAILED") : new y.default("TX_INVALID");
    }
    fromRaw(L) {
      return new $.default(L);
    }
    async search(L, q) {
      return this.api.post("arql", { op: "equals", expr1: L, expr2: q }).then((N) => N.data ? N.data : []);
    }
    getStatus(L) {
      return this.api.get(`tx/${L}/status`).then((q) => q.status == 200 ? { status: 200, confirmed: q.data } : { status: q.status, confirmed: null });
    }
    async getData(L, q) {
      let N;
      try {
        N = await this.chunks.downloadChunkedData(L);
      } catch (X) {
        console.error(`Error while trying to download chunked data for ${L}`), console.error(X);
      }
      if (!N) {
        console.warn(`Falling back to gateway cache for ${L}`);
        try {
          N = (await this.api.get(`/${L}`)).data;
        } catch (X) {
          console.error(`Error while trying to download contiguous data from gateway cache for ${L}`), console.error(X);
        }
      }
      if (!N)
        throw new Error(`${L} was not found!`);
      return q && q.decode && !q.string ? N : q && q.decode && q.string ? I.bufferToString(N) : I.bufferTob64Url(N);
    }
    async sign(L, q, N) {
      if (!(q || typeof window < "u" && window.arweaveWallet))
        throw new Error("A new Arweave transaction must provide the jwk parameter.");
      if (q && q !== "use_wallet") {
        L.setOwner(q.n);
        let X = await L.getSignatureData(), rt = await this.crypto.sign(q, X, N), nt = await this.crypto.hash(rt);
        L.setSignature({ id: I.bufferTob64Url(nt), owner: q.n, signature: I.bufferTob64Url(rt) });
      } else {
        try {
          (await window.arweaveWallet.getPermissions()).includes("SIGN_TRANSACTION") || await window.arweaveWallet.connect(["SIGN_TRANSACTION"]);
        } catch {
        }
        const X = await window.arweaveWallet.sign(L, N);
        L.setSignature({ id: X.id, owner: X.owner, reward: X.reward, tags: X.tags, signature: X.signature });
      }
    }
    async verify(L) {
      const q = await L.getSignatureData(), N = L.get("signature", { decode: !0, string: !1 }), X = I.bufferTob64Url(await this.crypto.hash(N));
      if (L.id !== X)
        throw new Error("Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.");
      return this.crypto.verify(L.owner, q, N);
    }
    async post(L) {
      if (typeof L == "string" ? L = new $.default(JSON.parse(L)) : typeof L.readInt32BE == "function" ? L = new $.default(JSON.parse(L.toString())) : typeof L != "object" || L instanceof $.default || (L = new $.default(L)), !(L instanceof $.default))
        throw new Error("Must be Transaction object");
      L.chunks || await L.prepareChunks(L.data);
      const q = await this.getUploader(L, L.data);
      try {
        for (; !q.isComplete; )
          await q.uploadChunk();
      } catch (N) {
        if (q.lastResponseStatus > 0)
          return { status: q.lastResponseStatus, statusText: q.lastResponseError, data: { error: q.lastResponseError } };
        throw N;
      }
      return { status: 200, statusText: "OK", data: {} };
    }
    async getUploader(L, q) {
      let N;
      if (q instanceof ArrayBuffer && (q = new Uint8Array(q)), L instanceof $.default) {
        if (q || (q = L.data), !(q instanceof Uint8Array))
          throw new Error("Data format is invalid");
        L.chunks || await L.prepareChunks(q), N = new P.TransactionUploader(this.api, L), N.data && N.data.length !== 0 || (N.data = q);
      } else {
        if (typeof L == "string" && (L = await P.TransactionUploader.fromTransactionId(this.api, L)), !(q && q instanceof Uint8Array))
          throw new Error("Must provide data when resuming upload");
        N = await P.TransactionUploader.fromSerialized(this.api, L, q);
      }
      return N;
    }
    upload(L, q) {
      return h(this, arguments, function* () {
        const N = yield u(this.getUploader(L, q));
        for (; !N.isComplete; )
          yield u(N.uploadChunk()), yield yield u(N);
        return yield u(N);
      });
    }
  }, transactions;
}
var wallets = {}, __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, c, u) {
  u === void 0 && (u = c);
  var h = Object.getOwnPropertyDescriptor(n, c);
  h && !("get" in h ? !n.__esModule : h.writable || h.configurable) || (h = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(o, u, h);
} : function(o, n, c, u) {
  u === void 0 && (u = c), o[u] = n[c];
}), __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var c in o)
      c !== "default" && Object.prototype.hasOwnProperty.call(o, c) && __createBinding$3(n, o, c);
  return __setModuleDefault$3(n, o), n;
};
Object.defineProperty(wallets, "__esModule", { value: !0 });
const ArweaveUtils$2 = __importStar$3(utils$o);
class Wallets {
  constructor(n, c) {
    this.api = n, this.crypto = c;
  }
  getBalance(n) {
    return this.api.get(`wallet/${n}/balance`, { transformResponse: [function(c) {
      return c;
    }] }).then((c) => c.data);
  }
  getLastTransactionID(n) {
    return this.api.get(`wallet/${n}/last_tx`).then((c) => c.data);
  }
  generate() {
    return this.crypto.generateJWK();
  }
  async jwkToAddress(n) {
    return n && n !== "use_wallet" ? this.getAddress(n) : this.getAddress();
  }
  async getAddress(n) {
    if (n && n !== "use_wallet")
      return this.ownerToAddress(n.n);
    try {
      await window.arweaveWallet.connect(["ACCESS_ADDRESS"]);
    } catch {
    }
    return window.arweaveWallet.getActiveAddress();
  }
  async ownerToAddress(n) {
    return ArweaveUtils$2.bufferTob64Url(await this.crypto.hash(ArweaveUtils$2.b64UrlToBuffer(n)));
  }
}
wallets.default = Wallets;
var silo = {}, __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, c, u) {
  u === void 0 && (u = c);
  var h = Object.getOwnPropertyDescriptor(n, c);
  h && !("get" in h ? !n.__esModule : h.writable || h.configurable) || (h = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(o, u, h);
} : function(o, n, c, u) {
  u === void 0 && (u = c), o[u] = n[c];
}), __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var c in o)
      c !== "default" && Object.prototype.hasOwnProperty.call(o, c) && __createBinding$2(n, o, c);
  return __setModuleDefault$2(n, o), n;
};
Object.defineProperty(silo, "__esModule", { value: !0 }), silo.SiloResource = void 0;
const ArweaveUtils$1 = __importStar$2(utils$o);
class Silo {
  constructor(n, c, u) {
    this.api = n, this.crypto = c, this.transactions = u;
  }
  async get(n) {
    if (!n)
      throw new Error("No Silo URI specified");
    const c = await this.parseUri(n), u = await this.transactions.search("Silo-Name", c.getAccessKey());
    if (u.length == 0)
      throw new Error(`No data could be found for the Silo URI: ${n}`);
    const h = await this.transactions.get(u[0]);
    if (!h)
      throw new Error(`No data could be found for the Silo URI: ${n}`);
    const g = h.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(g, c.getEncryptionKey());
  }
  async readTransactionData(n, c) {
    if (!c)
      throw new Error("No Silo URI specified");
    const u = await this.parseUri(c), h = n.get("data", { decode: !0, string: !1 });
    return this.crypto.decrypt(h, u.getEncryptionKey());
  }
  async parseUri(n) {
    const c = n.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
    if (!c)
      throw new Error("Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'");
    const u = c[1], h = Math.pow(2, parseInt(c[2])), g = await this.hash(ArweaveUtils$1.stringToBuffer(u), h), y = ArweaveUtils$1.bufferTob64(g.slice(0, 15)), $ = await this.hash(g.slice(16, 31), 1);
    return new SiloResource(n, y, $);
  }
  async hash(n, c) {
    let u = await this.crypto.hash(n);
    for (let h = 0; h < c - 1; h++)
      u = await this.crypto.hash(u);
    return u;
  }
}
silo.default = Silo;
class SiloResource {
  constructor(n, c, u) {
    this.uri = n, this.accessKey = c, this.encryptionKey = u;
  }
  getUri() {
    return this.uri;
  }
  getAccessKey() {
    return this.accessKey;
  }
  getEncryptionKey() {
    return this.encryptionKey;
  }
}
silo.SiloResource = SiloResource;
var chunks = {}, __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, c, u) {
  u === void 0 && (u = c);
  var h = Object.getOwnPropertyDescriptor(n, c);
  h && !("get" in h ? !n.__esModule : h.writable || h.configurable) || (h = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(o, u, h);
} : function(o, n, c, u) {
  u === void 0 && (u = c), o[u] = n[c];
}), __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var c in o)
      c !== "default" && Object.prototype.hasOwnProperty.call(o, c) && __createBinding$1(n, o, c);
  return __setModuleDefault$1(n, o), n;
};
Object.defineProperty(chunks, "__esModule", { value: !0 });
const error_1$1 = error, ArweaveUtils = __importStar$1(utils$o);
class Chunks {
  constructor(n) {
    this.api = n;
  }
  async getTransactionOffset(n) {
    const c = await this.api.get(`tx/${n}/offset`);
    if (c.status === 200)
      return c.data;
    throw new Error(`Unable to get transaction offset: ${(0, error_1$1.getError)(c)}`);
  }
  async getChunk(n) {
    const c = await this.api.get(`chunk/${n}`);
    if (c.status === 200)
      return c.data;
    throw new Error(`Unable to get chunk: ${(0, error_1$1.getError)(c)}`);
  }
  async getChunkData(n) {
    const c = await this.getChunk(n);
    return ArweaveUtils.b64UrlToBuffer(c.chunk);
  }
  firstChunkOffset(n) {
    return parseInt(n.offset) - parseInt(n.size) + 1;
  }
  async downloadChunkedData(n) {
    const c = await this.getTransactionOffset(n), u = parseInt(c.size), h = parseInt(c.offset) - u + 1, g = new Uint8Array(u);
    let y = 0;
    for (; y < u; ) {
      let $;
      this.api.config.logging && console.log(`[chunk] ${y}/${u}`);
      try {
        $ = await this.getChunkData(h + y);
      } catch {
        console.error(`[chunk] Failed to fetch chunk at offset ${h + y}`), console.error("[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node");
      }
      if (!$)
        throw new Error(`Couldn't complete data download at ${y}/${u}`);
      g.set($, y), y += $.length;
    }
    return g;
  }
}
chunks.default = Chunks;
var blocks = {}, __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(blocks, "__esModule", { value: !0 });
const error_1 = __importDefault$7(error);
class Blocks {
  constructor(n, c) {
    this.api = n, this.network = c;
  }
  async get(n) {
    const c = await this.api.get(`${Blocks.ENDPOINT}${n}`);
    if (c.status === 200)
      return c.data;
    throw c.status === 404 ? new error_1.default("BLOCK_NOT_FOUND") : new Error(`Error while loading block data: ${c}`);
  }
  async getCurrent() {
    const { current: n } = await this.network.getInfo();
    return await this.get(n);
  }
}
var hasRequiredCommon, hasRequiredDeepHash, hasRequiredTransaction;
function requireCommon() {
  if (hasRequiredCommon)
    return common$6;
  hasRequiredCommon = 1;
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(st, ot, St, Ct) {
    Ct === void 0 && (Ct = St);
    var et = Object.getOwnPropertyDescriptor(ot, St);
    et && !("get" in et ? !ot.__esModule : et.writable || et.configurable) || (et = { enumerable: !0, get: function() {
      return ot[St];
    } }), Object.defineProperty(st, Ct, et);
  } : function(st, ot, St, Ct) {
    Ct === void 0 && (Ct = St), st[Ct] = ot[St];
  }), n = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(st, ot) {
    Object.defineProperty(st, "default", { enumerable: !0, value: ot });
  } : function(st, ot) {
    st.default = ot;
  }), c = commonjsGlobal && commonjsGlobal.__importStar || function(st) {
    if (st && st.__esModule)
      return st;
    var ot = {};
    if (st != null)
      for (var St in st)
        St !== "default" && Object.prototype.hasOwnProperty.call(st, St) && o(ot, st, St);
    return n(ot, st), ot;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(st) {
    return st && st.__esModule ? st : { default: st };
  };
  Object.defineProperty(common$6, "__esModule", { value: !0 });
  const h = u(ar), g = u(api$1), y = u(nodeDriver), $ = u(network), I = u(requireTransactions()), P = u(wallets), L = u(requireTransaction()), q = c(utils$o), N = u(silo), X = u(chunks), rt = u(blocks);
  class nt {
    constructor(ot) {
      this.api = new g.default(ot), this.wallets = new P.default(this.api, nt.crypto), this.chunks = new X.default(this.api), this.transactions = new I.default(this.api, nt.crypto, this.chunks), this.silo = new N.default(this.api, this.crypto, this.transactions), this.network = new $.default(this.api), this.blocks = new rt.default(this.api, this.network), this.ar = new h.default();
    }
    get crypto() {
      return nt.crypto;
    }
    get utils() {
      return nt.utils;
    }
    getConfig() {
      return { api: this.api.getConfig(), crypto: null };
    }
    async createTransaction(ot, St) {
      const Ct = {};
      if (Object.assign(Ct, ot), !(ot.data || ot.target && ot.quantity))
        throw new Error("A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.");
      if (ot.owner == null && St && St !== "use_wallet" && (Ct.owner = St.n), ot.last_tx == null && (Ct.last_tx = await this.transactions.getTransactionAnchor()), typeof ot.data == "string" && (ot.data = q.stringToBuffer(ot.data)), ot.data instanceof ArrayBuffer && (ot.data = new Uint8Array(ot.data)), ot.data && !(ot.data instanceof Uint8Array))
        throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
      if (ot.reward == null) {
        const at = ot.data ? ot.data.byteLength : 0;
        Ct.reward = await this.transactions.getPrice(at, Ct.target);
      }
      Ct.data_root = "", Ct.data_size = ot.data ? ot.data.byteLength.toString() : "0", Ct.data = ot.data || new Uint8Array(0);
      const et = new L.default(Ct);
      return await et.getSignatureData(), et;
    }
    async createSiloTransaction(ot, St, Ct) {
      const et = {};
      if (Object.assign(et, ot), !ot.data)
        throw new Error("Silo transactions must have a 'data' value");
      if (!Ct)
        throw new Error("No Silo URI specified.");
      if (ot.target || ot.quantity)
        throw new Error("Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.");
      if (ot.owner == null) {
        if (!St || !St.n)
          throw new Error("A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.");
        et.owner = St.n;
      }
      ot.last_tx == null && (et.last_tx = await this.transactions.getTransactionAnchor());
      const at = await this.silo.parseUri(Ct);
      if (typeof ot.data == "string") {
        const Nt = await this.crypto.encrypt(q.stringToBuffer(ot.data), at.getEncryptionKey());
        et.reward = await this.transactions.getPrice(Nt.byteLength), et.data = q.bufferTob64Url(Nt);
      }
      if (ot.data instanceof Uint8Array) {
        const Nt = await this.crypto.encrypt(ot.data, at.getEncryptionKey());
        et.reward = await this.transactions.getPrice(Nt.byteLength), et.data = q.bufferTob64Url(Nt);
      }
      const _t = new L.default(et);
      return _t.addTag("Silo-Name", at.getAccessKey()), _t.addTag("Silo-Version", "0.1.0"), _t;
    }
    arql(ot) {
      return this.api.post("/arql", ot).then((St) => St.data || []);
    }
  }
  return common$6.default = nt, nt.crypto = new y.default(), nt.utils = q, common$6;
}
function requireDeepHash() {
  if (hasRequiredDeepHash)
    return deepHash;
  hasRequiredDeepHash = 1;
  var o = commonjsGlobal && commonjsGlobal.__importDefault || function(h) {
    return h && h.__esModule ? h : { default: h };
  };
  Object.defineProperty(deepHash, "__esModule", { value: !0 });
  const n = o(requireCommon());
  async function c(h) {
    if (Array.isArray(h)) {
      const $ = n.default.utils.concatBuffers([n.default.utils.stringToBuffer("list"), n.default.utils.stringToBuffer(h.length.toString())]);
      return await u(h, await n.default.crypto.hash($, "SHA-384"));
    }
    const g = n.default.utils.concatBuffers([n.default.utils.stringToBuffer("blob"), n.default.utils.stringToBuffer(h.byteLength.toString())]), y = n.default.utils.concatBuffers([await n.default.crypto.hash(g, "SHA-384"), await n.default.crypto.hash(h, "SHA-384")]);
    return await n.default.crypto.hash(y, "SHA-384");
  }
  async function u(h, g) {
    if (h.length < 1)
      return g;
    const y = n.default.utils.concatBuffers([g, await c(h[0])]), $ = await n.default.crypto.hash(y, "SHA-384");
    return await u(h.slice(1), $);
  }
  return deepHash.default = c, deepHash;
}
function requireTransaction() {
  if (hasRequiredTransaction)
    return transaction;
  hasRequiredTransaction = 1;
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(P, L, q, N) {
    N === void 0 && (N = q);
    var X = Object.getOwnPropertyDescriptor(L, q);
    X && !("get" in X ? !L.__esModule : X.writable || X.configurable) || (X = { enumerable: !0, get: function() {
      return L[q];
    } }), Object.defineProperty(P, N, X);
  } : function(P, L, q, N) {
    N === void 0 && (N = q), P[N] = L[q];
  }), n = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(P, L) {
    Object.defineProperty(P, "default", { enumerable: !0, value: L });
  } : function(P, L) {
    P.default = L;
  }), c = commonjsGlobal && commonjsGlobal.__importStar || function(P) {
    if (P && P.__esModule)
      return P;
    var L = {};
    if (P != null)
      for (var q in P)
        q !== "default" && Object.prototype.hasOwnProperty.call(P, q) && o(L, P, q);
    return n(L, P), L;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(P) {
    return P && P.__esModule ? P : { default: P };
  };
  Object.defineProperty(transaction, "__esModule", { value: !0 }), transaction.Tag = void 0;
  const h = c(utils$o), g = u(requireDeepHash()), y = requireMerkle();
  class $ {
    get(L, q) {
      if (!Object.getOwnPropertyNames(this).includes(L))
        throw new Error(`Field "${L}" is not a property of the Arweave Transaction class.`);
      return this[L] instanceof Uint8Array ? q && q.decode && q.string ? h.bufferToString(this[L]) : q && q.decode && !q.string ? this[L] : h.bufferTob64Url(this[L]) : q && q.decode == 1 ? q && q.string ? h.b64UrlToString(this[L]) : h.b64UrlToBuffer(this[L]) : this[L];
    }
  }
  class I extends $ {
    constructor(L, q, N = !1) {
      super(), this.name = L, this.value = q;
    }
  }
  return transaction.Tag = I, transaction.default = class extends $ {
    constructor(P = {}) {
      super(), this.format = 2, this.id = "", this.last_tx = "", this.owner = "", this.tags = [], this.target = "", this.quantity = "0", this.data_size = "0", this.data = new Uint8Array(), this.data_root = "", this.reward = "0", this.signature = "", Object.assign(this, P), typeof this.data == "string" && (this.data = h.b64UrlToBuffer(this.data)), P.tags && (this.tags = P.tags.map((L) => new I(L.name, L.value)));
    }
    addTag(P, L) {
      this.tags.push(new I(h.stringToB64Url(P), h.stringToB64Url(L)));
    }
    toJSON() {
      return { format: this.format, id: this.id, last_tx: this.last_tx, owner: this.owner, tags: this.tags, target: this.target, quantity: this.quantity, data: h.bufferTob64Url(this.data), data_size: this.data_size, data_root: this.data_root, data_tree: this.data_tree, reward: this.reward, signature: this.signature };
    }
    setOwner(P) {
      this.owner = P;
    }
    setSignature({ id: P, owner: L, reward: q, tags: N, signature: X }) {
      this.id = P, this.owner = L, q && (this.reward = q), N && (this.tags = N), this.signature = X;
    }
    async prepareChunks(P) {
      !this.chunks && P.byteLength > 0 && (this.chunks = await (0, y.generateTransactionChunks)(P), this.data_root = h.bufferTob64Url(this.chunks.data_root)), this.chunks || P.byteLength !== 0 || (this.chunks = { chunks: [], data_root: new Uint8Array(), proofs: [] }, this.data_root = "");
    }
    getChunk(P, L) {
      if (!this.chunks)
        throw new Error("Chunks have not been prepared");
      const q = this.chunks.proofs[P], N = this.chunks.chunks[P];
      return { data_root: this.data_root, data_size: this.data_size, data_path: h.bufferTob64Url(q.proof), offset: q.offset.toString(), chunk: h.bufferTob64Url(L.slice(N.minByteRange, N.maxByteRange)) };
    }
    async getSignatureData() {
      switch (this.format) {
        case 1:
          let P = this.tags.reduce((q, N) => h.concatBuffers([q, N.get("name", { decode: !0, string: !1 }), N.get("value", { decode: !0, string: !1 })]), new Uint8Array());
          return h.concatBuffers([this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), this.get("data", { decode: !0, string: !1 }), h.stringToBuffer(this.quantity), h.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), P]);
        case 2:
          this.data_root || await this.prepareChunks(this.data);
          const L = this.tags.map((q) => [q.get("name", { decode: !0, string: !1 }), q.get("value", { decode: !0, string: !1 })]);
          return await (0, g.default)([h.stringToBuffer(this.format.toString()), this.get("owner", { decode: !0, string: !1 }), this.get("target", { decode: !0, string: !1 }), h.stringToBuffer(this.quantity), h.stringToBuffer(this.reward), this.get("last_tx", { decode: !0, string: !1 }), L, h.stringToBuffer(this.data_size), this.get("data_root", { decode: !0, string: !1 })]);
        default:
          throw new Error(`Unexpected transaction format: ${this.format}`);
      }
    }
  }, transaction;
}
blocks.default = Blocks, Blocks.ENDPOINT = "block/hash/";
var npmBrowser$1 = {};
window.global = window, commonjsGlobal.fetch = window.fetch, npmBrowser$1.Buffer = buffer$2.Buffer;
var WarpFactory = {}, LevelDbCache$1 = {}, memoryLevel = {}, rbtree = createRBTree, RED = 0, BLACK = 1;
function RBNode(o, n, c, u, h, g) {
  this._color = o, this.key = n, this.value = c, this.left = u, this.right = h, this._count = g;
}
function cloneNode(o) {
  return new RBNode(o._color, o.key, o.value, o.left, o.right, o._count);
}
function repaint(o, n) {
  return new RBNode(o, n.key, n.value, n.left, n.right, n._count);
}
function recount(o) {
  o._count = 1 + (o.left ? o.left._count : 0) + (o.right ? o.right._count : 0);
}
function RedBlackTree(o, n) {
  this._compare = o, this.root = n;
}
var proto = RedBlackTree.prototype;
function doVisitFull(o, n) {
  var c;
  return n.left && (c = doVisitFull(o, n.left)) ? c : (c = o(n.key, n.value)) || (n.right ? doVisitFull(o, n.right) : void 0);
}
function doVisitHalf(o, n, c, u) {
  if (n(o, u.key) <= 0) {
    var h;
    if (u.left && (h = doVisitHalf(o, n, c, u.left)) || (h = c(u.key, u.value)))
      return h;
  }
  if (u.right)
    return doVisitHalf(o, n, c, u.right);
}
function doVisit(o, n, c, u, h) {
  var g, y = c(o, h.key), $ = c(n, h.key);
  if (y <= 0 && (h.left && (g = doVisit(o, n, c, u, h.left)) || $ > 0 && (g = u(h.key, h.value))))
    return g;
  if ($ > 0 && h.right)
    return doVisit(o, n, c, u, h.right);
}
function RedBlackTreeIterator(o, n) {
  this.tree = o, this._stack = n;
}
Object.defineProperty(proto, "keys", { get: function() {
  var o = [];
  return this.forEach(function(n, c) {
    o.push(n);
  }), o;
} }), Object.defineProperty(proto, "values", { get: function() {
  var o = [];
  return this.forEach(function(n, c) {
    o.push(c);
  }), o;
} }), Object.defineProperty(proto, "length", { get: function() {
  return this.root ? this.root._count : 0;
} }), proto.insert = function(o, n) {
  for (var c = this._compare, u = this.root, h = [], g = []; u; ) {
    var y = c(o, u.key);
    h.push(u), g.push(y), u = y <= 0 ? u.left : u.right;
  }
  h.push(new RBNode(RED, o, n, null, null, 1));
  for (var $ = h.length - 2; $ >= 0; --$)
    u = h[$], g[$] <= 0 ? h[$] = new RBNode(u._color, u.key, u.value, h[$ + 1], u.right, u._count + 1) : h[$] = new RBNode(u._color, u.key, u.value, u.left, h[$ + 1], u._count + 1);
  for ($ = h.length - 1; $ > 1; --$) {
    var I = h[$ - 1];
    if (u = h[$], I._color === BLACK || u._color === BLACK)
      break;
    var P = h[$ - 2];
    if (P.left === I)
      if (I.left === u) {
        if (!(L = P.right) || L._color !== RED) {
          P._color = RED, P.left = I.right, I._color = BLACK, I.right = P, h[$ - 2] = I, h[$ - 1] = u, recount(P), recount(I), $ >= 3 && ((q = h[$ - 3]).left === P ? q.left = I : q.right = I);
          break;
        }
        I._color = BLACK, P.right = repaint(BLACK, L), P._color = RED, $ -= 1;
      } else {
        if (!(L = P.right) || L._color !== RED) {
          I.right = u.left, P._color = RED, P.left = u.right, u._color = BLACK, u.left = I, u.right = P, h[$ - 2] = u, h[$ - 1] = I, recount(P), recount(I), recount(u), $ >= 3 && ((q = h[$ - 3]).left === P ? q.left = u : q.right = u);
          break;
        }
        I._color = BLACK, P.right = repaint(BLACK, L), P._color = RED, $ -= 1;
      }
    else if (I.right === u) {
      if (!(L = P.left) || L._color !== RED) {
        P._color = RED, P.right = I.left, I._color = BLACK, I.left = P, h[$ - 2] = I, h[$ - 1] = u, recount(P), recount(I), $ >= 3 && ((q = h[$ - 3]).right === P ? q.right = I : q.left = I);
        break;
      }
      I._color = BLACK, P.left = repaint(BLACK, L), P._color = RED, $ -= 1;
    } else {
      var L;
      if (!(L = P.left) || L._color !== RED) {
        var q;
        I.left = u.right, P._color = RED, P.right = u.left, u._color = BLACK, u.right = I, u.left = P, h[$ - 2] = u, h[$ - 1] = I, recount(P), recount(I), recount(u), $ >= 3 && ((q = h[$ - 3]).right === P ? q.right = u : q.left = u);
        break;
      }
      I._color = BLACK, P.left = repaint(BLACK, L), P._color = RED, $ -= 1;
    }
  }
  return h[0]._color = BLACK, new RedBlackTree(c, h[0]);
}, proto.forEach = function(o, n, c) {
  if (this.root)
    switch (arguments.length) {
      case 1:
        return doVisitFull(o, this.root);
      case 2:
        return doVisitHalf(n, this._compare, o, this.root);
      case 3:
        return this._compare(n, c) >= 0 ? void 0 : doVisit(n, c, this._compare, o, this.root);
    }
}, Object.defineProperty(proto, "begin", { get: function() {
  for (var o = [], n = this.root; n; )
    o.push(n), n = n.left;
  return new RedBlackTreeIterator(this, o);
} }), Object.defineProperty(proto, "end", { get: function() {
  for (var o = [], n = this.root; n; )
    o.push(n), n = n.right;
  return new RedBlackTreeIterator(this, o);
} }), proto.at = function(o) {
  if (o < 0)
    return new RedBlackTreeIterator(this, []);
  for (var n = this.root, c = []; ; ) {
    if (c.push(n), n.left) {
      if (o < n.left._count) {
        n = n.left;
        continue;
      }
      o -= n.left._count;
    }
    if (!o)
      return new RedBlackTreeIterator(this, c);
    if (o -= 1, !n.right || o >= n.right._count)
      break;
    n = n.right;
  }
  return new RedBlackTreeIterator(this, []);
}, proto.ge = function(o) {
  for (var n = this._compare, c = this.root, u = [], h = 0; c; ) {
    var g = n(o, c.key);
    u.push(c), g <= 0 && (h = u.length), c = g <= 0 ? c.left : c.right;
  }
  return u.length = h, new RedBlackTreeIterator(this, u);
}, proto.gt = function(o) {
  for (var n = this._compare, c = this.root, u = [], h = 0; c; ) {
    var g = n(o, c.key);
    u.push(c), g < 0 && (h = u.length), c = g < 0 ? c.left : c.right;
  }
  return u.length = h, new RedBlackTreeIterator(this, u);
}, proto.lt = function(o) {
  for (var n = this._compare, c = this.root, u = [], h = 0; c; ) {
    var g = n(o, c.key);
    u.push(c), g > 0 && (h = u.length), c = g <= 0 ? c.left : c.right;
  }
  return u.length = h, new RedBlackTreeIterator(this, u);
}, proto.le = function(o) {
  for (var n = this._compare, c = this.root, u = [], h = 0; c; ) {
    var g = n(o, c.key);
    u.push(c), g >= 0 && (h = u.length), c = g < 0 ? c.left : c.right;
  }
  return u.length = h, new RedBlackTreeIterator(this, u);
}, proto.find = function(o) {
  for (var n = this._compare, c = this.root, u = []; c; ) {
    var h = n(o, c.key);
    if (u.push(c), h === 0)
      return new RedBlackTreeIterator(this, u);
    c = h <= 0 ? c.left : c.right;
  }
  return new RedBlackTreeIterator(this, []);
}, proto.remove = function(o) {
  var n = this.find(o);
  return n ? n.remove() : this;
}, proto.get = function(o) {
  for (var n = this._compare, c = this.root; c; ) {
    var u = n(o, c.key);
    if (u === 0)
      return c.value;
    c = u <= 0 ? c.left : c.right;
  }
};
var iproto = RedBlackTreeIterator.prototype;
function swapNode(o, n) {
  o.key = n.key, o.value = n.value, o.left = n.left, o.right = n.right, o._color = n._color, o._count = n._count;
}
function fixDoubleBlack(o) {
  for (var n, c, u, h, g = o.length - 1; g >= 0; --g) {
    if (n = o[g], g === 0)
      return void (n._color = BLACK);
    if ((c = o[g - 1]).left === n) {
      if ((u = c.right).right && u.right._color === RED)
        return h = (u = c.right = cloneNode(u)).right = cloneNode(u.right), c.right = u.left, u.left = c, u.right = h, u._color = c._color, n._color = BLACK, c._color = BLACK, h._color = BLACK, recount(c), recount(u), g > 1 && ((y = o[g - 2]).left === c ? y.left = u : y.right = u), void (o[g - 1] = u);
      if (u.left && u.left._color === RED)
        return h = (u = c.right = cloneNode(u)).left = cloneNode(u.left), c.right = h.left, u.left = h.right, h.left = c, h.right = u, h._color = c._color, c._color = BLACK, u._color = BLACK, n._color = BLACK, recount(c), recount(u), recount(h), g > 1 && ((y = o[g - 2]).left === c ? y.left = h : y.right = h), void (o[g - 1] = h);
      if (u._color === BLACK) {
        if (c._color === RED)
          return c._color = BLACK, void (c.right = repaint(RED, u));
        c.right = repaint(RED, u);
        continue;
      }
      u = cloneNode(u), c.right = u.left, u.left = c, u._color = c._color, c._color = RED, recount(c), recount(u), g > 1 && ((y = o[g - 2]).left === c ? y.left = u : y.right = u), o[g - 1] = u, o[g] = c, g + 1 < o.length ? o[g + 1] = n : o.push(n), g += 2;
    } else {
      if ((u = c.left).left && u.left._color === RED)
        return h = (u = c.left = cloneNode(u)).left = cloneNode(u.left), c.left = u.right, u.right = c, u.left = h, u._color = c._color, n._color = BLACK, c._color = BLACK, h._color = BLACK, recount(c), recount(u), g > 1 && ((y = o[g - 2]).right === c ? y.right = u : y.left = u), void (o[g - 1] = u);
      if (u.right && u.right._color === RED)
        return h = (u = c.left = cloneNode(u)).right = cloneNode(u.right), c.left = h.right, u.right = h.left, h.right = c, h.left = u, h._color = c._color, c._color = BLACK, u._color = BLACK, n._color = BLACK, recount(c), recount(u), recount(h), g > 1 && ((y = o[g - 2]).right === c ? y.right = h : y.left = h), void (o[g - 1] = h);
      if (u._color === BLACK) {
        if (c._color === RED)
          return c._color = BLACK, void (c.left = repaint(RED, u));
        c.left = repaint(RED, u);
        continue;
      }
      var y;
      u = cloneNode(u), c.left = u.right, u.right = c, u._color = c._color, c._color = RED, recount(c), recount(u), g > 1 && ((y = o[g - 2]).right === c ? y.right = u : y.left = u), o[g - 1] = u, o[g] = c, g + 1 < o.length ? o[g + 1] = n : o.push(n), g += 2;
    }
  }
}
function defaultCompare(o, n) {
  return o < n ? -1 : o > n ? 1 : 0;
}
function createRBTree(o) {
  return new RedBlackTree(o || defaultCompare, null);
}
Object.defineProperty(iproto, "valid", { get: function() {
  return this._stack.length > 0;
} }), Object.defineProperty(iproto, "node", { get: function() {
  return this._stack.length > 0 ? this._stack[this._stack.length - 1] : null;
}, enumerable: !0 }), iproto.clone = function() {
  return new RedBlackTreeIterator(this.tree, this._stack.slice());
}, iproto.remove = function() {
  var o = this._stack;
  if (o.length === 0)
    return this.tree;
  var n = new Array(o.length), c = o[o.length - 1];
  n[n.length - 1] = new RBNode(c._color, c.key, c.value, c.left, c.right, c._count);
  for (var u = o.length - 2; u >= 0; --u)
    (c = o[u]).left === o[u + 1] ? n[u] = new RBNode(c._color, c.key, c.value, n[u + 1], c.right, c._count) : n[u] = new RBNode(c._color, c.key, c.value, c.left, n[u + 1], c._count);
  if ((c = n[n.length - 1]).left && c.right) {
    var h = n.length;
    for (c = c.left; c.right; )
      n.push(c), c = c.right;
    var g = n[h - 1];
    for (n.push(new RBNode(c._color, g.key, g.value, c.left, c.right, c._count)), n[h - 1].key = c.key, n[h - 1].value = c.value, u = n.length - 2; u >= h; --u)
      c = n[u], n[u] = new RBNode(c._color, c.key, c.value, c.left, n[u + 1], c._count);
    n[h - 1].left = n[h];
  }
  if ((c = n[n.length - 1])._color === RED) {
    var y = n[n.length - 2];
    for (y.left === c ? y.left = null : y.right === c && (y.right = null), n.pop(), u = 0; u < n.length; ++u)
      n[u]._count--;
    return new RedBlackTree(this.tree._compare, n[0]);
  }
  if (c.left || c.right) {
    for (c.left ? swapNode(c, c.left) : c.right && swapNode(c, c.right), c._color = BLACK, u = 0; u < n.length - 1; ++u)
      n[u]._count--;
    return new RedBlackTree(this.tree._compare, n[0]);
  }
  if (n.length === 1)
    return new RedBlackTree(this.tree._compare, null);
  for (u = 0; u < n.length; ++u)
    n[u]._count--;
  var $ = n[n.length - 2];
  return fixDoubleBlack(n), $.left === c ? $.left = null : $.right = null, new RedBlackTree(this.tree._compare, n[0]);
}, Object.defineProperty(iproto, "key", { get: function() {
  if (this._stack.length > 0)
    return this._stack[this._stack.length - 1].key;
}, enumerable: !0 }), Object.defineProperty(iproto, "value", { get: function() {
  if (this._stack.length > 0)
    return this._stack[this._stack.length - 1].value;
}, enumerable: !0 }), Object.defineProperty(iproto, "index", { get: function() {
  var o = 0, n = this._stack;
  if (n.length === 0) {
    var c = this.tree.root;
    return c ? c._count : 0;
  }
  n[n.length - 1].left && (o = n[n.length - 1].left._count);
  for (var u = n.length - 2; u >= 0; --u)
    n[u + 1] === n[u].right && (++o, n[u].left && (o += n[u].left._count));
  return o;
}, enumerable: !0 }), iproto.next = function() {
  var o = this._stack;
  if (o.length !== 0) {
    var n = o[o.length - 1];
    if (n.right)
      for (n = n.right; n; )
        o.push(n), n = n.left;
    else
      for (o.pop(); o.length > 0 && o[o.length - 1].right === n; )
        n = o[o.length - 1], o.pop();
  }
}, Object.defineProperty(iproto, "hasNext", { get: function() {
  var o = this._stack;
  if (o.length === 0)
    return !1;
  if (o[o.length - 1].right)
    return !0;
  for (var n = o.length - 1; n > 0; --n)
    if (o[n - 1].left === o[n])
      return !0;
  return !1;
} }), iproto.update = function(o) {
  var n = this._stack;
  if (n.length === 0)
    throw new Error("Can't update empty node!");
  var c = new Array(n.length), u = n[n.length - 1];
  c[c.length - 1] = new RBNode(u._color, u.key, o, u.left, u.right, u._count);
  for (var h = n.length - 2; h >= 0; --h)
    (u = n[h]).left === n[h + 1] ? c[h] = new RBNode(u._color, u.key, u.value, c[h + 1], u.right, u._count) : c[h] = new RBNode(u._color, u.key, u.value, u.left, c[h + 1], u._count);
  return new RedBlackTree(this.tree._compare, c[0]);
}, iproto.prev = function() {
  var o = this._stack;
  if (o.length !== 0) {
    var n = o[o.length - 1];
    if (n.left)
      for (n = n.left; n; )
        o.push(n), n = n.right;
    else
      for (o.pop(); o.length > 0 && o[o.length - 1].left === n; )
        n = o[o.length - 1], o.pop();
  }
}, Object.defineProperty(iproto, "hasPrev", { get: function() {
  var o = this._stack;
  if (o.length === 0)
    return !1;
  if (o[o.length - 1].left)
    return !0;
  for (var n = o.length - 1; n > 0; --n)
    if (o[n - 1].right === o[n])
      return !0;
  return !1;
} });
const { AbstractLevel, AbstractIterator, AbstractKeyIterator, AbstractValueIterator } = abstractLevel$1, ModuleError = moduleError, createRBT = rbtree, rangeOptions = /* @__PURE__ */ new Set(["gt", "gte", "lt", "lte"]), kNone = Symbol("none"), kTree = Symbol("tree"), kIterator = Symbol("iterator"), kLowerBound = Symbol("lowerBound"), kUpperBound = Symbol("upperBound"), kOutOfRange = Symbol("outOfRange"), kReverse = Symbol("reverse"), kOptions = Symbol("options"), kTest = Symbol("test"), kAdvance = Symbol("advance"), kInit = Symbol("init");
function compare(o, n) {
  if (typeof o == "string")
    return o < n ? -1 : o > n ? 1 : 0;
  const c = Math.min(o.byteLength, n.byteLength);
  for (let u = 0; u < c; u++) {
    const h = o[u] - n[u];
    if (h !== 0)
      return h;
  }
  return o.byteLength - n.byteLength;
}
function gt(o) {
  return compare(o, this[kUpperBound]) > 0;
}
function gte(o) {
  return compare(o, this[kUpperBound]) >= 0;
}
function lt(o) {
  return compare(o, this[kUpperBound]) < 0;
}
function lte(o) {
  return compare(o, this[kUpperBound]) <= 0;
}
class MemoryIterator extends AbstractIterator {
  constructor(n, c) {
    super(n, c), this[kInit](n[kTree], c);
  }
  _next(n) {
    if (!this[kIterator].valid)
      return this.nextTick(n);
    const c = this[kIterator].key, u = this[kIterator].value;
    if (!this[kTest](c))
      return this.nextTick(n);
    this[kIterator][this[kAdvance]](), this.nextTick(n, null, c, u);
  }
  _nextv(n, c, u) {
    const h = this[kIterator], g = [];
    for (; h.valid && g.length < n && this[kTest](h.key); )
      g.push([h.key, h.value]), h[this[kAdvance]]();
    this.nextTick(u, null, g);
  }
  _all(n, c) {
    const u = this.limit - this.count, h = this[kIterator], g = [];
    for (; h.valid && g.length < u && this[kTest](h.key); )
      g.push([h.key, h.value]), h[this[kAdvance]]();
    this.nextTick(c, null, g);
  }
}
class MemoryKeyIterator extends AbstractKeyIterator {
  constructor(n, c) {
    super(n, c), this[kInit](n[kTree], c);
  }
  _next(n) {
    if (!this[kIterator].valid)
      return this.nextTick(n);
    const c = this[kIterator].key;
    if (!this[kTest](c))
      return this.nextTick(n);
    this[kIterator][this[kAdvance]](), this.nextTick(n, null, c);
  }
  _nextv(n, c, u) {
    const h = this[kIterator], g = [];
    for (; h.valid && g.length < n && this[kTest](h.key); )
      g.push(h.key), h[this[kAdvance]]();
    this.nextTick(u, null, g);
  }
  _all(n, c) {
    const u = this.limit - this.count, h = this[kIterator], g = [];
    for (; h.valid && g.length < u && this[kTest](h.key); )
      g.push(h.key), h[this[kAdvance]]();
    this.nextTick(c, null, g);
  }
}
class MemoryValueIterator extends AbstractValueIterator {
  constructor(n, c) {
    super(n, c), this[kInit](n[kTree], c);
  }
  _next(n) {
    if (!this[kIterator].valid)
      return this.nextTick(n);
    const c = this[kIterator].key, u = this[kIterator].value;
    if (!this[kTest](c))
      return this.nextTick(n);
    this[kIterator][this[kAdvance]](), this.nextTick(n, null, u);
  }
  _nextv(n, c, u) {
    const h = this[kIterator], g = [];
    for (; h.valid && g.length < n && this[kTest](h.key); )
      g.push(h.value), h[this[kAdvance]]();
    this.nextTick(u, null, g);
  }
  _all(n, c) {
    const u = this.limit - this.count, h = this[kIterator], g = [];
    for (; h.valid && g.length < u && this[kTest](h.key); )
      g.push(h.value), h[this[kAdvance]]();
    this.nextTick(c, null, g);
  }
}
for (const o of [MemoryIterator, MemoryKeyIterator, MemoryValueIterator])
  o.prototype[kInit] = function(n, c) {
    this[kReverse] = c.reverse, this[kOptions] = c, this[kReverse] ? (this[kAdvance] = "prev", this[kLowerBound] = "lte" in c ? c.lte : "lt" in c ? c.lt : kNone, this[kUpperBound] = "gte" in c ? c.gte : "gt" in c ? c.gt : kNone, this[kLowerBound] === kNone ? this[kIterator] = n.end : this[kIterator] = "lte" in c ? n.le(this[kLowerBound]) : n.lt(this[kLowerBound]), this[kUpperBound] !== kNone && (this[kTest] = "gte" in c ? gte : gt)) : (this[kAdvance] = "next", this[kLowerBound] = "gte" in c ? c.gte : "gt" in c ? c.gt : kNone, this[kUpperBound] = "lte" in c ? c.lte : "lt" in c ? c.lt : kNone, this[kLowerBound] === kNone ? this[kIterator] = n.begin : this[kIterator] = "gte" in c ? n.ge(this[kLowerBound]) : n.gt(this[kLowerBound]), this[kUpperBound] !== kNone && (this[kTest] = "lte" in c ? lte : lt));
  }, o.prototype[kTest] = function() {
    return !0;
  }, o.prototype[kOutOfRange] = function(n) {
    return !this[kTest](n) || this[kLowerBound] !== kNone && (this[kReverse] ? "lte" in this[kOptions] ? compare(n, this[kLowerBound]) > 0 : compare(n, this[kLowerBound]) >= 0 : "gte" in this[kOptions] ? compare(n, this[kLowerBound]) < 0 : compare(n, this[kLowerBound]) <= 0);
  }, o.prototype._seek = function(n, c) {
    this[kOutOfRange](n) ? (this[kIterator] = this[kIterator].tree.end, this[kIterator].next()) : this[kReverse] ? this[kIterator] = this[kIterator].tree.le(n) : this[kIterator] = this[kIterator].tree.ge(n);
  };
class MemoryLevel extends AbstractLevel {
  constructor(n, c, u) {
    if (typeof n == "object" && n !== null && (c = n), typeof n == "function" || typeof c == "function" || typeof u == "function")
      throw new ModuleError("The levelup-style callback argument has been removed", { code: "LEVEL_LEGACY" });
    let { storeEncoding: h, ...g } = c || {};
    if (h = h || "buffer", !["buffer", "view", "utf8"].includes(h))
      throw new ModuleError("The storeEncoding option must be 'buffer', 'view' or 'utf8'", { code: "LEVEL_ENCODING_NOT_SUPPORTED" });
    super({ seek: !0, permanence: !1, createIfMissing: !1, errorIfExists: !1, encodings: { [h]: !0 } }, g), this[kTree] = createRBT(compare);
  }
  _put(n, c, u, h) {
    const g = this[kTree].find(n);
    g.valid ? this[kTree] = g.update(c) : this[kTree] = this[kTree].insert(n, c), this.nextTick(h);
  }
  _get(n, c, u) {
    const h = this[kTree].get(n);
    if (h === void 0)
      return this.nextTick(u, new Error("NotFound"));
    this.nextTick(u, null, h);
  }
  _getMany(n, c, u) {
    this.nextTick(u, null, n.map((h) => this[kTree].get(h)));
  }
  _del(n, c, u) {
    this[kTree] = this[kTree].remove(n), this.nextTick(u);
  }
  _batch(n, c, u) {
    let h = this[kTree];
    for (const g of n) {
      const y = g.key, $ = h.find(y);
      h = g.type === "put" ? $.valid ? $.update(g.value) : h.insert(y, g.value) : $.remove();
    }
    this[kTree] = h, this.nextTick(u);
  }
  _clear(n, c) {
    if (n.limit === -1 && !Object.keys(n).some(isRangeOption))
      return this[kTree] = createRBT(compare), this.nextTick(c);
    const u = this._keys({ ...n }), h = u.limit;
    let g = 0;
    const y = () => {
      for (let $ = 0; $ < 500; $++) {
        if (++g > h || !u[kIterator].valid || !u[kTest](u[kIterator].key))
          return c();
        this[kTree] = this[kTree].remove(u[kIterator].key), u[kIterator][u[kAdvance]]();
      }
      this.nextTick(y);
    };
    this.nextTick(y);
  }
  _iterator(n) {
    return new MemoryIterator(this, n);
  }
  _keys(n) {
    return new MemoryKeyIterator(this, n);
  }
  _values(n) {
    return new MemoryValueIterator(this, n);
  }
}
if (memoryLevel.MemoryLevel = MemoryLevel, typeof process < "u" && !process.browser && commonjsGlobal !== void 0 && typeof commonjsGlobal.setImmediate == "function") {
  const o = commonjsGlobal.setImmediate;
  MemoryLevel.prototype.nextTick = function(n, ...c) {
    c.length === 0 ? o(n) : o(() => n(...c));
  };
}
function isRangeOption(o) {
  return rangeOptions.has(o);
}
Object.defineProperty(LevelDbCache$1, "__esModule", { value: !0 }), LevelDbCache$1.LevelDbCache = void 0;
const level_1 = browser, memory_level_1 = memoryLevel, LoggerFactory_1$e = LoggerFactory$1;
class LevelDbCache {
  constructor(n) {
    if (this.logger = LoggerFactory_1$e.LoggerFactory.INST.create("LevelDbCache"), n.inMemory)
      this.db = new memory_level_1.MemoryLevel({ valueEncoding: "json" });
    else {
      if (!n.dbLocation)
        throw new Error("LevelDb cache configuration error - no db location specified");
      const c = n.dbLocation;
      this.logger.info(`Using location ${c}`), this.db = new level_1.Level(c, { valueEncoding: "json" });
    }
  }
  async get(n, c, u) {
    const h = this.db.sublevel(n, { valueEncoding: "json" });
    try {
      return { sortKey: c, cachedValue: await h.get(c) };
    } catch (g) {
      if (g.code == "LEVEL_NOT_FOUND")
        return null;
      throw g;
    }
  }
  async getLast(n) {
    const c = this.db.sublevel(n, { valueEncoding: "json" }), u = await c.keys({ reverse: !0, limit: 1 }).all();
    return u.length ? { sortKey: u[0], cachedValue: await c.get(u[0]) } : null;
  }
  async getLessOrEqual(n, c) {
    const u = this.db.sublevel(n, { valueEncoding: "json" }), h = await u.keys({ reverse: !0, lte: c, limit: 1 }).all();
    return h.length ? { sortKey: h[0], cachedValue: await u.get(h[0]) } : null;
  }
  async put(n, c) {
    const u = this.db.sublevel(n.contractTxId, { valueEncoding: "json" });
    await u.open(), await u.put(n.sortKey, c);
  }
  close() {
    return this.db.close();
  }
  async dump() {
    return await this.db.iterator().all();
  }
  async getLastSortKey() {
    let n = "";
    const c = await this.db.keys().all();
    for (const u of c) {
      const h = u.substring(45);
      h.localeCompare(n) > 0 && (n = h);
    }
    return n == "" ? null : n;
  }
  async allContracts() {
    const n = await this.db.keys().all(), c = /* @__PURE__ */ new Set();
    return n.forEach((u) => c.add(u.substring(1, 44))), Array.from(c);
  }
}
LevelDbCache$1.LevelDbCache = LevelDbCache;
var MemCache$1 = {};
Object.defineProperty(MemCache$1, "__esModule", { value: !0 }), MemCache$1.MemCache = void 0;
class MemCache {
  constructor() {
    this.storage = {};
  }
  clearAll() {
    Object.keys(this.storage).forEach((n) => {
      delete this.storage[n];
    });
  }
  contains(n) {
    return Object.prototype.hasOwnProperty.call(this.storage, n);
  }
  get(n) {
    return this.storage[n];
  }
  put(n, c) {
    this.storage[n] = c;
  }
  remove(n) {
    delete this.storage[n];
  }
}
MemCache$1.MemCache = MemCache;
var CacheableExecutorFactory$1 = {};
Object.defineProperty(CacheableExecutorFactory$1, "__esModule", { value: !0 }), CacheableExecutorFactory$1.CacheableExecutorFactory = void 0;
const LoggerFactory_1$d = LoggerFactory$1;
class CacheableExecutorFactory {
  constructor(n, c, u) {
    this.arweave = n, this.baseImplementation = c, this.cache = u, this.logger = LoggerFactory_1$d.LoggerFactory.INST.create("CacheableExecutorFactory");
  }
  async create(n, c) {
    return await this.baseImplementation.create(n, c);
  }
}
CacheableExecutorFactory$1.CacheableExecutorFactory = CacheableExecutorFactory;
var Evolve$1 = {}, errors = {};
(function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 }), o.SmartWeaveError = o.SmartWeaveErrorType = void 0, (o.SmartWeaveErrorType || (o.SmartWeaveErrorType = {})).CONTRACT_NOT_FOUND = "CONTRACT_NOT_FOUND";
  class n extends Error {
    constructor(u, h = {}) {
      h.message ? super(h.message) : super(), this.type = u, this.otherInfo = h;
    }
    getType() {
      return this.type;
    }
  }
  o.SmartWeaveError = n;
})(errors), Object.defineProperty(Evolve$1, "__esModule", { value: !0 }), Evolve$1.Evolve = void 0;
const LoggerFactory_1$c = LoggerFactory$1, errors_1 = errors;
function isEvolveCompatible(o) {
  if (!o)
    return !1;
  const n = evalSettings(o);
  return o.evolve !== void 0 || n.has("evolve");
}
class Evolve {
  constructor() {
    this.logger = LoggerFactory_1$c.LoggerFactory.INST.create("Evolve"), this.modify = this.modify.bind(this);
  }
  async modify(n, c) {
    const { definitionLoader: u, executorFactory: h } = c.warp, g = c.contractDefinition.txId, y = Evolve.evolvedSrcTxId(n), $ = c.contractDefinition.srcTxId;
    if (y && (this.logger.debug("Checking evolve:", { current: $, evolvedSrcTxId: y }), $ !== y))
      try {
        this.logger.info("Evolving to: ", y);
        const I = await u.load(g, y), P = await h.create(I, c.evaluationOptions);
        return c.contractDefinition = I, c.handler = P, c.handler.initState(n), this.logger.debug("evolved to:", { evolve: y, newSrcTxId: c.contractDefinition.srcTxId, current: $, txId: c.contractDefinition.txId }), c;
      } catch {
        throw new errors_1.SmartWeaveError(errors_1.SmartWeaveErrorType.CONTRACT_NOT_FOUND, { message: `Contract having txId: ${g} not found`, requestedTxId: g });
      }
    return c;
  }
  static evolvedSrcTxId(n) {
    if (!isEvolveCompatible(n))
      return;
    const c = evalSettings(n), u = n.evolve || c.get("evolve");
    let h = n.canEvolve || c.get("canEvolve");
    return h == null && (h = !0), u && /[a-z0-9_-]{43}/i.test(u) && h ? u : void 0;
  }
}
function evalSettings(o) {
  let n = /* @__PURE__ */ new Map();
  return o.settings && (isIterable(o.settings) ? n = new Map(o.settings) : isObject$6(o.settings) && (n = new Map(Object.entries(o.settings)))), n;
}
function isIterable(o) {
  return o != null && typeof o[Symbol.iterator] == "function";
}
function isObject$6(o) {
  return typeof o == "object" && o !== null && !Array.isArray(o);
}
Evolve$1.Evolve = Evolve;
var CacheableStateEvaluator$1 = {}, SortKeyCache = {};
Object.defineProperty(SortKeyCache, "__esModule", { value: !0 }), SortKeyCache.SortKeyCacheResult = SortKeyCache.CacheKey = void 0;
class CacheKey {
  constructor(n, c) {
    this.contractTxId = n, this.sortKey = c;
  }
}
SortKeyCache.CacheKey = CacheKey;
class SortKeyCacheResult {
  constructor(n, c) {
    this.sortKey = n, this.cachedValue = c;
  }
}
SortKeyCache.SortKeyCacheResult = SortKeyCacheResult;
var utils$n = {};
function listCacheClear$1() {
  this.__data__ = [], this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$2(o, n) {
  return o === n || o != o && n != n;
}
var eq_1 = eq$2, eq$1 = eq_1;
function assocIndexOf$4(o, n) {
  for (var c = o.length; c--; )
    if (eq$1(o[c][0], n))
      return c;
  return -1;
}
var _assocIndexOf = assocIndexOf$4, assocIndexOf$3 = _assocIndexOf, arrayProto = Array.prototype, splice = arrayProto.splice;
function listCacheDelete$1(o) {
  var n = this.__data__, c = assocIndexOf$3(n, o);
  return !(c < 0 || (c == n.length - 1 ? n.pop() : splice.call(n, c, 1), --this.size, 0));
}
var _listCacheDelete = listCacheDelete$1, assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(o) {
  var n = this.__data__, c = assocIndexOf$2(n, o);
  return c < 0 ? void 0 : n[c][1];
}
var _listCacheGet = listCacheGet$1, assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(o) {
  return assocIndexOf$1(this.__data__, o) > -1;
}
var _listCacheHas = listCacheHas$1, assocIndexOf = _assocIndexOf;
function listCacheSet$1(o, n) {
  var c = this.__data__, u = assocIndexOf(c, o);
  return u < 0 ? (++this.size, c.push([o, n])) : c[u][1] = n, this;
}
var _listCacheSet = listCacheSet$1, listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(o) {
  var n = -1, c = o == null ? 0 : o.length;
  for (this.clear(); ++n < c; ) {
    var u = o[n];
    this.set(u[0], u[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear, ListCache$4.prototype.delete = listCacheDelete, ListCache$4.prototype.get = listCacheGet, ListCache$4.prototype.has = listCacheHas, ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4, ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3(), this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(o) {
  var n = this.__data__, c = n.delete(o);
  return this.size = n.size, c;
}
var _stackDelete = stackDelete$1;
function stackGet$1(o) {
  return this.__data__.get(o);
}
var _stackGet = stackGet$1;
function stackHas$1(o) {
  return this.__data__.has(o);
}
var _stackHas = stackHas$1, freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, _freeGlobal = freeGlobal$1, freeGlobal = _freeGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root$8 = freeGlobal || freeSelf || Function("return this")(), _root = root$8, root$7 = _root, Symbol$4 = root$7.Symbol, _Symbol = Symbol$4, Symbol$3 = _Symbol, objectProto$c = Object.prototype, hasOwnProperty$9 = objectProto$c.hasOwnProperty, nativeObjectToString$1 = objectProto$c.toString, symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(o) {
  var n = hasOwnProperty$9.call(o, symToStringTag$1), c = o[symToStringTag$1];
  try {
    o[symToStringTag$1] = void 0;
    var u = !0;
  } catch {
  }
  var h = nativeObjectToString$1.call(o);
  return u && (n ? o[symToStringTag$1] = c : delete o[symToStringTag$1]), h;
}
var _getRawTag = getRawTag$1, objectProto$b = Object.prototype, nativeObjectToString = objectProto$b.toString;
function objectToString$1(o) {
  return nativeObjectToString.call(o);
}
var _objectToString = objectToString$1, Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$4(o) {
  return o == null ? o === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(o) ? getRawTag(o) : objectToString(o);
}
var _baseGetTag = baseGetTag$4;
function isObject$5(o) {
  var n = typeof o;
  return o != null && (n == "object" || n == "function");
}
var isObject_1 = isObject$5, baseGetTag$3 = _baseGetTag, isObject$4 = isObject_1, asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(o) {
  if (!isObject$4(o))
    return !1;
  var n = baseGetTag$3(o);
  return n == funcTag$2 || n == genTag$1 || n == asyncTag || n == proxyTag;
}
var isFunction_1 = isFunction$2, root$6 = _root, coreJsData$1 = root$6["__core-js_shared__"], _coreJsData = coreJsData$1, coreJsData = _coreJsData, maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || ""), uid ? "Symbol(src)_1." + uid : ""), uid;
function isMasked$1(o) {
  return !!maskSrcKey && maskSrcKey in o;
}
var _isMasked = isMasked$1, funcProto$1 = Function.prototype, funcToString$1 = funcProto$1.toString;
function toSource$2(o) {
  if (o != null) {
    try {
      return funcToString$1.call(o);
    } catch {
    }
    try {
      return o + "";
    } catch {
    }
  }
  return "";
}
var _toSource = toSource$2, isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$3 = isObject_1, toSource$1 = _toSource, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto$a = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$8 = objectProto$a.hasOwnProperty, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(o) {
  return !(!isObject$3(o) || isMasked(o)) && (isFunction$1(o) ? reIsNative : reIsHostCtor).test(toSource$1(o));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(o, n) {
  return o == null ? void 0 : o[n];
}
var _getValue = getValue$1, baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(o, n) {
  var c = getValue(o, n);
  return baseIsNative(c) ? c : void 0;
}
var _getNative = getNative$7, getNative$6 = _getNative, root$5 = _root, Map$4 = getNative$6(root$5, "Map"), _Map = Map$4, getNative$5 = _getNative, nativeCreate$4 = getNative$5(Object, "create"), _nativeCreate = nativeCreate$4, nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {}, this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(o) {
  var n = this.has(o) && delete this.__data__[o];
  return this.size -= n ? 1 : 0, n;
}
var _hashDelete = hashDelete$1, nativeCreate$2 = _nativeCreate, HASH_UNDEFINED$1 = "__lodash_hash_undefined__", objectProto$9 = Object.prototype, hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashGet$1(o) {
  var n = this.__data__;
  if (nativeCreate$2) {
    var c = n[o];
    return c === HASH_UNDEFINED$1 ? void 0 : c;
  }
  return hasOwnProperty$7.call(n, o) ? n[o] : void 0;
}
var _hashGet = hashGet$1, nativeCreate$1 = _nativeCreate, objectProto$8 = Object.prototype, hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashHas$1(o) {
  var n = this.__data__;
  return nativeCreate$1 ? n[o] !== void 0 : hasOwnProperty$6.call(n, o);
}
var _hashHas = hashHas$1, nativeCreate = _nativeCreate, HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(o, n) {
  var c = this.__data__;
  return this.size += this.has(o) ? 0 : 1, c[o] = nativeCreate && n === void 0 ? HASH_UNDEFINED : n, this;
}
var _hashSet = hashSet$1, hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(o) {
  var n = -1, c = o == null ? 0 : o.length;
  for (this.clear(); ++n < c; ) {
    var u = o[n];
    this.set(u[0], u[1]);
  }
}
Hash$1.prototype.clear = hashClear, Hash$1.prototype.delete = hashDelete, Hash$1.prototype.get = hashGet, Hash$1.prototype.has = hashHas, Hash$1.prototype.set = hashSet;
var _Hash = Hash$1, Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0, this.__data__ = { hash: new Hash(), map: new (Map$3 || ListCache$2)(), string: new Hash() };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(o) {
  var n = typeof o;
  return n == "string" || n == "number" || n == "symbol" || n == "boolean" ? o !== "__proto__" : o === null;
}
var _isKeyable = isKeyable$1, isKeyable = _isKeyable;
function getMapData$4(o, n) {
  var c = o.__data__;
  return isKeyable(n) ? c[typeof n == "string" ? "string" : "hash"] : c.map;
}
var _getMapData = getMapData$4, getMapData$3 = _getMapData;
function mapCacheDelete$1(o) {
  var n = getMapData$3(this, o).delete(o);
  return this.size -= n ? 1 : 0, n;
}
var _mapCacheDelete = mapCacheDelete$1, getMapData$2 = _getMapData;
function mapCacheGet$1(o) {
  return getMapData$2(this, o).get(o);
}
var _mapCacheGet = mapCacheGet$1, getMapData$1 = _getMapData;
function mapCacheHas$1(o) {
  return getMapData$1(this, o).has(o);
}
var _mapCacheHas = mapCacheHas$1, getMapData = _getMapData;
function mapCacheSet$1(o, n) {
  var c = getMapData(this, o), u = c.size;
  return c.set(o, n), this.size += c.size == u ? 0 : 1, this;
}
var _mapCacheSet = mapCacheSet$1, mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1(o) {
  var n = -1, c = o == null ? 0 : o.length;
  for (this.clear(); ++n < c; ) {
    var u = o[n];
    this.set(u[0], u[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear, MapCache$1.prototype.delete = mapCacheDelete, MapCache$1.prototype.get = mapCacheGet, MapCache$1.prototype.has = mapCacheHas, MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1, ListCache$1 = _ListCache, Map$2 = _Map, MapCache = _MapCache, LARGE_ARRAY_SIZE = 200;
function stackSet$1(o, n) {
  var c = this.__data__;
  if (c instanceof ListCache$1) {
    var u = c.__data__;
    if (!Map$2 || u.length < LARGE_ARRAY_SIZE - 1)
      return u.push([o, n]), this.size = ++c.size, this;
    c = this.__data__ = new MapCache(u);
  }
  return c.set(o, n), this.size = c.size, this;
}
var _stackSet = stackSet$1, ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$1(o) {
  var n = this.__data__ = new ListCache(o);
  this.size = n.size;
}
Stack$1.prototype.clear = stackClear, Stack$1.prototype.delete = stackDelete, Stack$1.prototype.get = stackGet, Stack$1.prototype.has = stackHas, Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;
function arrayEach$1(o, n) {
  for (var c = -1, u = o == null ? 0 : o.length; ++c < u && n(o[c], c, o) !== !1; )
    ;
  return o;
}
var _arrayEach = arrayEach$1, getNative$4 = _getNative, defineProperty$1 = function() {
  try {
    var o = getNative$4(Object, "defineProperty");
    return o({}, "", {}), o;
  } catch {
  }
}(), _defineProperty = defineProperty$1, defineProperty = _defineProperty;
function baseAssignValue$2(o, n, c) {
  n == "__proto__" && defineProperty ? defineProperty(o, n, { configurable: !0, enumerable: !0, value: c, writable: !0 }) : o[n] = c;
}
var _baseAssignValue = baseAssignValue$2, baseAssignValue$1 = _baseAssignValue, eq = eq_1, objectProto$7 = Object.prototype, hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function assignValue$2(o, n, c) {
  var u = o[n];
  hasOwnProperty$5.call(o, n) && eq(u, c) && (c !== void 0 || n in o) || baseAssignValue$1(o, n, c);
}
var _assignValue = assignValue$2, assignValue$1 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$4(o, n, c, u) {
  var h = !c;
  c || (c = {});
  for (var g = -1, y = n.length; ++g < y; ) {
    var $ = n[g], I = u ? u(c[$], o[$], $, c, o) : void 0;
    I === void 0 && (I = o[$]), h ? baseAssignValue(c, $, I) : assignValue$1(c, $, I);
  }
  return c;
}
var _copyObject = copyObject$4;
function baseTimes$1(o, n) {
  for (var c = -1, u = Array(o); ++c < o; )
    u[c] = n(c);
  return u;
}
var _baseTimes = baseTimes$1;
function isObjectLike$5(o) {
  return o != null && typeof o == "object";
}
var isObjectLike_1 = isObjectLike$5, baseGetTag$2 = _baseGetTag, isObjectLike$4 = isObjectLike_1, argsTag$2 = "[object Arguments]";
function baseIsArguments$1(o) {
  return isObjectLike$4(o) && baseGetTag$2(o) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1, baseIsArguments = _baseIsArguments, isObjectLike$3 = isObjectLike_1, objectProto$6 = Object.prototype, hasOwnProperty$4 = objectProto$6.hasOwnProperty, propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable, isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(o) {
  return isObjectLike$3(o) && hasOwnProperty$4.call(o, "callee") && !propertyIsEnumerable$1.call(o, "callee");
}, isArguments_1 = isArguments$1, isArray$3 = Array.isArray, isArray_1 = isArray$3, isBuffer$2 = { exports: {} };
function stubFalse() {
  return !1;
}
var stubFalse_1 = stubFalse;
(function(o, n) {
  var c = _root, u = stubFalse_1, h = n && !n.nodeType && n, g = h && o && !o.nodeType && o, y = g && g.exports === h ? c.Buffer : void 0, $ = (y ? y.isBuffer : void 0) || u;
  o.exports = $;
})(isBuffer$2, isBuffer$2.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(o, n) {
  var c = typeof o;
  return !!(n = n == null ? MAX_SAFE_INTEGER$1 : n) && (c == "number" || c != "symbol" && reIsUint.test(o)) && o > -1 && o % 1 == 0 && o < n;
}
var _isIndex = isIndex$1, MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(o) {
  return typeof o == "number" && o > -1 && o % 1 == 0 && o <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2, baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$2 = isObjectLike_1, argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
function baseIsTypedArray$1(o) {
  return isObjectLike$2(o) && isLength$1(o.length) && !!typedArrayTags[baseGetTag$1(o)];
}
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0, typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = !1;
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(o) {
  return function(n) {
    return o(n);
  };
}
var _baseUnary = baseUnary$3, _nodeUtil = { exports: {} };
(function(o, n) {
  var c = _freeGlobal, u = n && !n.nodeType && n, h = u && o && !o.nodeType && o, g = h && h.exports === u && c.process, y = function() {
    try {
      return h && h.require && h.require("util").types || g && g.binding && g.binding("util");
    } catch {
    }
  }();
  o.exports = y;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtil.exports, nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray, isTypedArray$1 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray, isTypedArray_1 = isTypedArray$1, baseTimes = _baseTimes, isArguments = isArguments_1, isArray$2 = isArray_1, isBuffer$1 = isBuffer$2.exports, isIndex = _isIndex, isTypedArray = isTypedArray_1, objectProto$5 = Object.prototype, hasOwnProperty$3 = objectProto$5.hasOwnProperty;
function arrayLikeKeys$2(o, n) {
  var c = isArray$2(o), u = !c && isArguments(o), h = !c && !u && isBuffer$1(o), g = !c && !u && !h && isTypedArray(o), y = c || u || h || g, $ = y ? baseTimes(o.length, String) : [], I = $.length;
  for (var P in o)
    !n && !hasOwnProperty$3.call(o, P) || y && (P == "length" || h && (P == "offset" || P == "parent") || g && (P == "buffer" || P == "byteLength" || P == "byteOffset") || isIndex(P, I)) || $.push(P);
  return $;
}
var _arrayLikeKeys = arrayLikeKeys$2, objectProto$4 = Object.prototype;
function isPrototype$3(o) {
  var n = o && o.constructor;
  return o === (typeof n == "function" && n.prototype || objectProto$4);
}
var _isPrototype = isPrototype$3;
function overArg$2(o, n) {
  return function(c) {
    return o(n(c));
  };
}
var _overArg = overArg$2, overArg$1 = _overArg, nativeKeys$1 = overArg$1(Object.keys, Object), _nativeKeys = nativeKeys$1, isPrototype$2 = _isPrototype, nativeKeys = _nativeKeys, objectProto$3 = Object.prototype, hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeys$1(o) {
  if (!isPrototype$2(o))
    return nativeKeys(o);
  var n = [];
  for (var c in Object(o))
    hasOwnProperty$2.call(o, c) && c != "constructor" && n.push(c);
  return n;
}
var _baseKeys = baseKeys$1, isFunction = isFunction_1, isLength = isLength_1;
function isArrayLike$2(o) {
  return o != null && isLength(o.length) && !isFunction(o);
}
var isArrayLike_1 = isArrayLike$2, arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
function keys$3(o) {
  return isArrayLike$1(o) ? arrayLikeKeys$1(o) : baseKeys(o);
}
var keys_1 = keys$3, copyObject$3 = _copyObject, keys$2 = keys_1;
function baseAssign$1(o, n) {
  return o && copyObject$3(n, keys$2(n), o);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$1(o) {
  var n = [];
  if (o != null)
    for (var c in Object(o))
      n.push(c);
  return n;
}
var _nativeKeysIn = nativeKeysIn$1, isObject$2 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn, objectProto$2 = Object.prototype, hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function baseKeysIn$1(o) {
  if (!isObject$2(o))
    return nativeKeysIn(o);
  var n = isPrototype$1(o), c = [];
  for (var u in o)
    (u != "constructor" || !n && hasOwnProperty$1.call(o, u)) && c.push(u);
  return c;
}
var _baseKeysIn = baseKeysIn$1, arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike = isArrayLike_1;
function keysIn$3(o) {
  return isArrayLike(o) ? arrayLikeKeys(o, !0) : baseKeysIn(o);
}
var keysIn_1 = keysIn$3, copyObject$2 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(o, n) {
  return o && copyObject$2(n, keysIn$2(n), o);
}
var _baseAssignIn = baseAssignIn$1, _cloneBuffer = { exports: {} };
function copyArray$1(o, n) {
  var c = -1, u = o.length;
  for (n || (n = Array(u)); ++c < u; )
    n[c] = o[c];
  return n;
}
(function(o, n) {
  var c = _root, u = n && !n.nodeType && n, h = u && o && !o.nodeType && o, g = h && h.exports === u ? c.Buffer : void 0, y = g ? g.allocUnsafe : void 0;
  o.exports = function($, I) {
    if (I)
      return $.slice();
    var P = $.length, L = y ? y(P) : new $.constructor(P);
    return $.copy(L), L;
  };
})(_cloneBuffer, _cloneBuffer.exports);
var _copyArray = copyArray$1;
function arrayFilter$1(o, n) {
  for (var c = -1, u = o == null ? 0 : o.length, h = 0, g = []; ++c < u; ) {
    var y = o[c];
    n(y, c, o) && (g[h++] = y);
  }
  return g;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2, arrayFilter = _arrayFilter, stubArray$1 = stubArray_1, objectProto$1 = Object.prototype, propertyIsEnumerable = objectProto$1.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols$3 = nativeGetSymbols$1 ? function(o) {
  return o == null ? [] : (o = Object(o), arrayFilter(nativeGetSymbols$1(o), function(n) {
    return propertyIsEnumerable.call(o, n);
  }));
} : stubArray$1, _getSymbols = getSymbols$3, copyObject$1 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(o, n) {
  return copyObject$1(o, getSymbols$2(o), n);
}
var _copySymbols = copySymbols$1;
function arrayPush$2(o, n) {
  for (var c = -1, u = n.length, h = o.length; ++c < u; )
    o[h + c] = n[c];
  return o;
}
var _arrayPush = arrayPush$2, overArg = _overArg, getPrototype$2 = overArg(Object.getPrototypeOf, Object), _getPrototype = getPrototype$2, arrayPush$1 = _arrayPush, getPrototype$1 = _getPrototype, getSymbols$1 = _getSymbols, stubArray = stubArray_1, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn$2 = nativeGetSymbols ? function(o) {
  for (var n = []; o; )
    arrayPush$1(n, getSymbols$1(o)), o = getPrototype$1(o);
  return n;
} : stubArray, _getSymbolsIn = getSymbolsIn$2, copyObject = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(o, n) {
  return copyObject(o, getSymbolsIn$1(o), n);
}
var _copySymbolsIn = copySymbolsIn$1, arrayPush = _arrayPush, isArray$1 = isArray_1;
function baseGetAllKeys$2(o, n, c) {
  var u = n(o);
  return isArray$1(o) ? u : arrayPush(u, c(o));
}
var _baseGetAllKeys = baseGetAllKeys$2, baseGetAllKeys$1 = _baseGetAllKeys, getSymbols = _getSymbols, keys$1 = keys_1;
function getAllKeys$1(o) {
  return baseGetAllKeys$1(o, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1, baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$1(o) {
  return baseGetAllKeys(o, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1, getNative$3 = _getNative, root$4 = _root, DataView$2 = getNative$3(root$4, "DataView"), _DataView = DataView$2, getNative$2 = _getNative, root$3 = _root, Promise$2 = getNative$2(root$3, "Promise"), _Promise = Promise$2, getNative$1 = _getNative, root$2 = _root, Set$2 = getNative$1(root$2, "Set"), _Set = Set$2, getNative = _getNative, root$1 = _root, WeakMap$2 = getNative(root$1, "WeakMap"), _WeakMap = WeakMap$2, DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource, mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$2 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1), getTag$3 = baseGetTag;
(DataView$1 && getTag$3(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$3(new Map$1()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set$1 && getTag$3(new Set$1()) != setTag$3 || WeakMap$1 && getTag$3(new WeakMap$1()) != weakMapTag$1) && (getTag$3 = function(o) {
  var n = baseGetTag(o), c = n == objectTag$1 ? o.constructor : void 0, u = c ? toSource(c) : "";
  if (u)
    switch (u) {
      case dataViewCtorString:
        return dataViewTag$2;
      case mapCtorString:
        return mapTag$3;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$3;
      case weakMapCtorString:
        return weakMapTag$1;
    }
  return n;
});
var _getTag = getTag$3, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray$1(o) {
  var n = o.length, c = new o.constructor(n);
  return n && typeof o[0] == "string" && hasOwnProperty.call(o, "index") && (c.index = o.index, c.input = o.input), c;
}
var _initCloneArray = initCloneArray$1, root = _root, Uint8Array$2 = root.Uint8Array, _Uint8Array = Uint8Array$2, Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(o) {
  var n = new o.constructor(o.byteLength);
  return new Uint8Array$1(n).set(new Uint8Array$1(o)), n;
}
var _cloneArrayBuffer = cloneArrayBuffer$3, cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(o, n) {
  var c = n ? cloneArrayBuffer$2(o.buffer) : o.buffer;
  return new o.constructor(c, o.byteOffset, o.byteLength);
}
var _cloneDataView = cloneDataView$1, reFlags = /\w*$/;
function cloneRegExp$1(o) {
  var n = new o.constructor(o.source, reFlags.exec(o));
  return n.lastIndex = o.lastIndex, n;
}
var _cloneRegExp = cloneRegExp$1, Symbol$1 = _Symbol, symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(o) {
  return symbolValueOf ? Object(symbolValueOf.call(o)) : {};
}
var _cloneSymbol = cloneSymbol$1, cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(o, n) {
  var c = n ? cloneArrayBuffer$1(o.buffer) : o.buffer;
  return new o.constructor(c, o.byteOffset, o.length);
}
var _cloneTypedArray = cloneTypedArray$1, cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray, boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(o, n, c) {
  var u = o.constructor;
  switch (n) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(o);
    case boolTag$1:
    case dateTag$1:
      return new u(+o);
    case dataViewTag$1:
      return cloneDataView(o, c);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(o, c);
    case mapTag$2:
      return new u();
    case numberTag$1:
    case stringTag$1:
      return new u(o);
    case regexpTag$1:
      return cloneRegExp(o);
    case setTag$2:
      return new u();
    case symbolTag$1:
      return cloneSymbol(o);
  }
}
var _initCloneByTag = initCloneByTag$1, isObject$1 = isObject_1, objectCreate = Object.create, baseCreate$1 = function() {
  function o() {
  }
  return function(n) {
    if (!isObject$1(n))
      return {};
    if (objectCreate)
      return objectCreate(n);
    o.prototype = n;
    var c = new o();
    return o.prototype = void 0, c;
  };
}(), _baseCreate = baseCreate$1, baseCreate = _baseCreate, getPrototype = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(o) {
  return typeof o.constructor != "function" || isPrototype(o) ? {} : baseCreate(getPrototype(o));
}
var _initCloneObject = initCloneObject$1, getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1, mapTag$1 = "[object Map]";
function baseIsMap$1(o) {
  return isObjectLike$1(o) && getTag$2(o) == mapTag$1;
}
var _baseIsMap = baseIsMap$1, baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtil.exports, nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap, isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap, isMap_1 = isMap$1, getTag$1 = _getTag, isObjectLike = isObjectLike_1, setTag$1 = "[object Set]";
function baseIsSet$1(o) {
  return isObjectLike(o) && getTag$1(o) == setTag$1;
}
var _baseIsSet = baseIsSet$1, baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports, nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, isSet_1 = isSet$1, Stack = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBuffer.exports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray = isArray_1, isBuffer = isBuffer$2.exports, isMap = isMap_1, isObject = isObject_1, isSet = isSet_1, keys = keys_1, keysIn = keysIn_1, CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4, argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
function baseClone$1(o, n, c, u, h, g) {
  var y, $ = n & CLONE_DEEP_FLAG$1, I = n & CLONE_FLAT_FLAG, P = n & CLONE_SYMBOLS_FLAG$1;
  if (c && (y = h ? c(o, u, h, g) : c(o)), y !== void 0)
    return y;
  if (!isObject(o))
    return o;
  var L = isArray(o);
  if (L) {
    if (y = initCloneArray(o), !$)
      return copyArray(o, y);
  } else {
    var q = getTag(o), N = q == funcTag || q == genTag;
    if (isBuffer(o))
      return cloneBuffer(o, $);
    if (q == objectTag || q == argsTag || N && !h) {
      if (y = I || N ? {} : initCloneObject(o), !$)
        return I ? copySymbolsIn(o, baseAssignIn(y, o)) : copySymbols(o, baseAssign(y, o));
    } else {
      if (!cloneableTags[q])
        return h ? o : {};
      y = initCloneByTag(o, q, $);
    }
  }
  g || (g = new Stack());
  var X = g.get(o);
  if (X)
    return X;
  g.set(o, y), isSet(o) ? o.forEach(function(nt) {
    y.add(baseClone$1(nt, n, c, nt, o, g));
  }) : isMap(o) && o.forEach(function(nt, st) {
    y.set(st, baseClone$1(nt, n, c, st, o, g));
  });
  var rt = L ? void 0 : (P ? I ? getAllKeysIn : getAllKeys : I ? keysIn : keys)(o);
  return arrayEach(rt || o, function(nt, st) {
    rt && (nt = o[st = nt]), assignValue(y, st, baseClone$1(nt, n, c, st, o, g));
  }), y;
}
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
var _baseClone = baseClone$1, baseClone = _baseClone, CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(o) {
  return baseClone(o, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1$1 = cloneDeep, fastCopy = { exports: {} };
fastCopy.exports = function() {
  var o = Function.prototype.toString, n = Object.create, c = Object.defineProperty, u = Object.getOwnPropertyDescriptor, h = Object.getOwnPropertyNames, g = Object.getOwnPropertySymbols, y = Object.getPrototypeOf, $ = Object.prototype, I = $.hasOwnProperty, P = $.propertyIsEnumerable, L = typeof g == "function", q = typeof WeakMap == "function", N = function() {
    if (q)
      return function() {
        return /* @__PURE__ */ new WeakMap();
      };
    var et = function() {
      function at() {
        this._keys = [], this._values = [];
      }
      return at.prototype.has = function(_t) {
        return !!~this._keys.indexOf(_t);
      }, at.prototype.get = function(_t) {
        return this._values[this._keys.indexOf(_t)];
      }, at.prototype.set = function(_t, Nt) {
        this._keys.push(_t), this._values.push(Nt);
      }, at;
    }();
    return function() {
      return new et();
    };
  }(), X = function(et, at) {
    var _t = et.__proto__ || y(et);
    if (!_t)
      return n(null);
    var Nt = _t.constructor;
    if (Nt === at.Object)
      return _t === at.Object.prototype ? {} : n(_t);
    if (~o.call(Nt).indexOf("[native code]"))
      try {
        return new Nt();
      } catch {
      }
    return n(_t);
  }, rt = function(et, at, _t, Nt) {
    var m = X(et, at);
    for (var A in Nt.set(et, m), et)
      I.call(et, A) && (m[A] = _t(et[A], Nt));
    if (L)
      for (var E = g(et), w = 0, v = E.length, k = void 0; w < v; ++w)
        k = E[w], P.call(et, k) && (m[k] = _t(et[k], Nt));
    return m;
  }, nt = function(et, at, _t, Nt) {
    var m = X(et, at);
    Nt.set(et, m);
    for (var A = L ? h(et).concat(g(et)) : h(et), E = 0, w = A.length, v = void 0, k = void 0; E < w; ++E)
      if ((v = A[E]) !== "callee" && v !== "caller")
        if (k = u(et, v)) {
          k.get || k.set || (k.value = _t(et[v], Nt));
          try {
            c(m, v, k);
          } catch {
            m[v] = k.value;
          }
        } else
          m[v] = _t(et[v], Nt);
    return m;
  }, st = Array.isArray, ot = Object.getPrototypeOf, St = function() {
    return typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal !== void 0 ? commonjsGlobal : (console && console.error && console.error('Unable to locate global object, returning "this".'), this);
  }();
  function Ct(et, at) {
    var _t = !(!at || !at.isStrict), Nt = at && at.realm || St, m = _t ? nt : rt, A = function(E, w) {
      if (!E || typeof E != "object")
        return E;
      if (w.has(E))
        return w.get(E);
      var v, k = E.__proto__ || ot(E), O = k && k.constructor;
      if (!O || O === Nt.Object)
        return m(E, Nt, A, w);
      if (st(E)) {
        if (_t)
          return nt(E, Nt, A, w);
        v = new O(), w.set(E, v);
        for (var W = 0, it = E.length; W < it; ++W)
          v[W] = A(E[W], w);
        return v;
      }
      if (E instanceof Nt.Date)
        return new O(E.getTime());
      if (E instanceof Nt.RegExp)
        return (v = new O(E.source, E.flags || function(vt) {
          var xt = "";
          return vt.global && (xt += "g"), vt.ignoreCase && (xt += "i"), vt.multiline && (xt += "m"), vt.unicode && (xt += "u"), vt.sticky && (xt += "y"), xt;
        }(E))).lastIndex = E.lastIndex, v;
      if (Nt.Map && E instanceof Nt.Map)
        return v = new O(), w.set(E, v), E.forEach(function(vt, xt) {
          v.set(xt, A(vt, w));
        }), v;
      if (Nt.Set && E instanceof Nt.Set)
        return v = new O(), w.set(E, v), E.forEach(function(vt) {
          v.add(A(vt, w));
        }), v;
      if (Nt.Blob && E instanceof Nt.Blob)
        return E.slice(0, E.size, E.type);
      if (Nt.Buffer && Nt.Buffer.isBuffer(E))
        return v = Nt.Buffer.allocUnsafe ? Nt.Buffer.allocUnsafe(E.length) : new O(E.length), w.set(E, v), E.copy(v), v;
      if (Nt.ArrayBuffer) {
        if (Nt.ArrayBuffer.isView(E))
          return v = new O(E.buffer.slice(0)), w.set(E, v), v;
        if (E instanceof Nt.ArrayBuffer)
          return v = E.slice(0), w.set(E, v), v;
      }
      return typeof E.then == "function" || E instanceof Error || Nt.WeakMap && E instanceof Nt.WeakMap || Nt.WeakSet && E instanceof Nt.WeakSet ? E : m(E, Nt, A, w);
    };
    return A(et, N());
  }
  return Ct.default = Ct, Ct.strict = function(et, at) {
    return Ct(et, { isStrict: !0, realm: at ? at.realm : void 0 });
  }, Ct;
}();
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(utils$n, "__esModule", { value: !0 }), utils$n.isomorphicRandomUUID = utils$n.bufToBn = utils$n.indent = utils$n.stripTrailingSlash = utils$n.timeout = utils$n.descS = utils$n.desc = utils$n.ascS = utils$n.asc = utils$n.mapReviver = utils$n.mapReplacer = utils$n.deepCopy = utils$n.sleep = void 0;
const cloneDeep_1 = __importDefault$6(cloneDeep_1$1), fast_copy_1 = __importDefault$6(fastCopy.exports), crypto_1 = require$$2$1, sleep = (o) => new Promise((n) => setTimeout(n, o));
utils$n.sleep = sleep;
const deepCopy = (o, n = !1) => n ? (0, fast_copy_1.default)(o) : (0, cloneDeep_1.default)(o);
utils$n.deepCopy = deepCopy;
const mapReplacer = (o, n) => n instanceof Map ? { dataType: "Map", value: Array.from(n.entries()) } : n;
utils$n.mapReplacer = mapReplacer;
const mapReviver = (o, n) => typeof n == "object" && n !== null && n.dataType === "Map" ? new Map(n.value) : n;
utils$n.mapReviver = mapReviver;
const asc = (o, n) => o - n;
utils$n.asc = asc;
const ascS = (o, n) => +o - +n;
utils$n.ascS = ascS;
const desc = (o, n) => n - o;
utils$n.desc = desc;
const descS = (o, n) => +n - +o;
function timeout(o) {
  let n = null;
  const c = new Promise((u, h) => {
    n = setTimeout(() => {
      clearTimeout(n), h("timeout");
    }, 1e3 * o);
  });
  return { timeoutId: n, timeoutPromise: c };
}
function stripTrailingSlash(o) {
  return o.endsWith("/") ? o.slice(0, -1) : o;
}
function indent(o) {
  return "".padEnd(2 * o, " ");
}
function bufToBn(o) {
  const n = [];
  return Uint8Array.from(o).forEach(function(c) {
    let u = c.toString(16);
    u.length % 2 && (u = "0" + u), n.push(u);
  }), BigInt("0x" + n.join(""));
}
function isomorphicRandomUUID() {
  return isBrowser() && self.crypto ? self.crypto.randomUUID() : (0, crypto_1.randomUUID)();
}
utils$n.descS = descS, utils$n.timeout = timeout, utils$n.stripTrailingSlash = stripTrailingSlash, utils$n.indent = indent, utils$n.bufToBn = bufToBn, utils$n.isomorphicRandomUUID = isomorphicRandomUUID;
const isBrowser = new Function("try {return this===window;}catch(e){ return false;}");
var DefaultStateEvaluator$1 = {}, elliptic$1 = {};
const name = "elliptic", version = "6.5.4", description = "EC cryptography", main = "lib/elliptic.js", files = ["lib"], scripts = { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository = { type: "git", url: "git@github.com:indutny/elliptic" }, keywords = ["EC", "Elliptic", "curve", "Cryptography"], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = { url: "https://github.com/indutny/elliptic/issues" }, homepage = "https://github.com/indutny/elliptic", devDependencies = { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies = { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" }, require$$0$2 = { name, version, description, main, files, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, dependencies };
var utils$m = {}, bn$2 = { exports: {} };
(function(o, n) {
  function c(m, A) {
    if (!m)
      throw new Error(A || "Assertion failed");
  }
  function u(m, A) {
    m.super_ = A;
    var E = function() {
    };
    E.prototype = A.prototype, m.prototype = new E(), m.prototype.constructor = m;
  }
  function h(m, A, E) {
    if (h.isBN(m))
      return m;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, m !== null && (A !== "le" && A !== "be" || (E = A, A = 10), this._init(m || 0, A || 10, E || "be"));
  }
  var g;
  typeof bn$2 == "object" ? bn$2.exports = h : n.BN = h, h.BN = h, h.wordSize = 26;
  try {
    g = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function y(m, A) {
    var E = m.charCodeAt(A);
    return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
  }
  function $(m, A, E) {
    var w = y(m, E);
    return E - 1 >= A && (w |= y(m, E - 1) << 4), w;
  }
  function I(m, A, E, w) {
    for (var v = 0, k = Math.min(m.length, E), O = A; O < k; O++) {
      var W = m.charCodeAt(O) - 48;
      v *= w, v += W >= 49 ? W - 49 + 10 : W >= 17 ? W - 17 + 10 : W;
    }
    return v;
  }
  h.isBN = function(m) {
    return m instanceof h || m !== null && typeof m == "object" && m.constructor.wordSize === h.wordSize && Array.isArray(m.words);
  }, h.max = function(m, A) {
    return m.cmp(A) > 0 ? m : A;
  }, h.min = function(m, A) {
    return m.cmp(A) < 0 ? m : A;
  }, h.prototype._init = function(m, A, E) {
    if (typeof m == "number")
      return this._initNumber(m, A, E);
    if (typeof m == "object")
      return this._initArray(m, A, E);
    A === "hex" && (A = 16), c(A === (0 | A) && A >= 2 && A <= 36);
    var w = 0;
    (m = m.toString().replace(/\s+/g, ""))[0] === "-" && (w++, this.negative = 1), w < m.length && (A === 16 ? this._parseHex(m, w, E) : (this._parseBase(m, A, w), E === "le" && this._initArray(this.toArray(), A, E)));
  }, h.prototype._initNumber = function(m, A, E) {
    m < 0 && (this.negative = 1, m = -m), m < 67108864 ? (this.words = [67108863 & m], this.length = 1) : m < 4503599627370496 ? (this.words = [67108863 & m, m / 67108864 & 67108863], this.length = 2) : (c(m < 9007199254740992), this.words = [67108863 & m, m / 67108864 & 67108863, 1], this.length = 3), E === "le" && this._initArray(this.toArray(), A, E);
  }, h.prototype._initArray = function(m, A, E) {
    if (c(typeof m.length == "number"), m.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(m.length / 3), this.words = new Array(this.length);
    for (var w = 0; w < this.length; w++)
      this.words[w] = 0;
    var v, k, O = 0;
    if (E === "be")
      for (w = m.length - 1, v = 0; w >= 0; w -= 3)
        k = m[w] | m[w - 1] << 8 | m[w - 2] << 16, this.words[v] |= k << O & 67108863, this.words[v + 1] = k >>> 26 - O & 67108863, (O += 24) >= 26 && (O -= 26, v++);
    else if (E === "le")
      for (w = 0, v = 0; w < m.length; w += 3)
        k = m[w] | m[w + 1] << 8 | m[w + 2] << 16, this.words[v] |= k << O & 67108863, this.words[v + 1] = k >>> 26 - O & 67108863, (O += 24) >= 26 && (O -= 26, v++);
    return this.strip();
  }, h.prototype._parseHex = function(m, A, E) {
    this.length = Math.ceil((m.length - A) / 6), this.words = new Array(this.length);
    for (var w = 0; w < this.length; w++)
      this.words[w] = 0;
    var v, k = 0, O = 0;
    if (E === "be")
      for (w = m.length - 1; w >= A; w -= 2)
        v = $(m, A, w) << k, this.words[O] |= 67108863 & v, k >= 18 ? (k -= 18, O += 1, this.words[O] |= v >>> 26) : k += 8;
    else
      for (w = (m.length - A) % 2 == 0 ? A + 1 : A; w < m.length; w += 2)
        v = $(m, A, w) << k, this.words[O] |= 67108863 & v, k >= 18 ? (k -= 18, O += 1, this.words[O] |= v >>> 26) : k += 8;
    this.strip();
  }, h.prototype._parseBase = function(m, A, E) {
    this.words = [0], this.length = 1;
    for (var w = 0, v = 1; v <= 67108863; v *= A)
      w++;
    w--, v = v / A | 0;
    for (var k = m.length - E, O = k % w, W = Math.min(k, k - O) + E, it = 0, vt = E; vt < W; vt += w)
      it = I(m, vt, vt + w, A), this.imuln(v), this.words[0] + it < 67108864 ? this.words[0] += it : this._iaddn(it);
    if (O !== 0) {
      var xt = 1;
      for (it = I(m, vt, m.length, A), vt = 0; vt < O; vt++)
        xt *= A;
      this.imuln(xt), this.words[0] + it < 67108864 ? this.words[0] += it : this._iaddn(it);
    }
    this.strip();
  }, h.prototype.copy = function(m) {
    m.words = new Array(this.length);
    for (var A = 0; A < this.length; A++)
      m.words[A] = this.words[A];
    m.length = this.length, m.negative = this.negative, m.red = this.red;
  }, h.prototype.clone = function() {
    var m = new h(null);
    return this.copy(m), m;
  }, h.prototype._expand = function(m) {
    for (; this.length < m; )
      this.words[this.length++] = 0;
    return this;
  }, h.prototype.strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, h.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, h.prototype.inspect = function() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  };
  var P = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], L = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function N(m, A, E) {
    E.negative = A.negative ^ m.negative;
    var w = m.length + A.length | 0;
    E.length = w, w = w - 1 | 0;
    var v = 0 | m.words[0], k = 0 | A.words[0], O = v * k, W = 67108863 & O, it = O / 67108864 | 0;
    E.words[0] = W;
    for (var vt = 1; vt < w; vt++) {
      for (var xt = it >>> 26, It = 67108863 & it, Wt = Math.min(vt, A.length - 1), Ut = Math.max(0, vt - m.length + 1); Ut <= Wt; Ut++) {
        var zt = vt - Ut | 0;
        xt += (O = (v = 0 | m.words[zt]) * (k = 0 | A.words[Ut]) + It) / 67108864 | 0, It = 67108863 & O;
      }
      E.words[vt] = 0 | It, it = 0 | xt;
    }
    return it !== 0 ? E.words[vt] = 0 | it : E.length--, E.strip();
  }
  h.prototype.toString = function(m, A) {
    var E;
    if (A = 0 | A || 1, (m = m || 10) === 16 || m === "hex") {
      E = "";
      for (var w = 0, v = 0, k = 0; k < this.length; k++) {
        var O = this.words[k], W = (16777215 & (O << w | v)).toString(16);
        E = (v = O >>> 24 - w & 16777215) != 0 || k !== this.length - 1 ? P[6 - W.length] + W + E : W + E, (w += 2) >= 26 && (w -= 26, k--);
      }
      for (v !== 0 && (E = v.toString(16) + E); E.length % A != 0; )
        E = "0" + E;
      return this.negative !== 0 && (E = "-" + E), E;
    }
    if (m === (0 | m) && m >= 2 && m <= 36) {
      var it = L[m], vt = q[m];
      E = "";
      var xt = this.clone();
      for (xt.negative = 0; !xt.isZero(); ) {
        var It = xt.modn(vt).toString(m);
        E = (xt = xt.idivn(vt)).isZero() ? It + E : P[it - It.length] + It + E;
      }
      for (this.isZero() && (E = "0" + E); E.length % A != 0; )
        E = "0" + E;
      return this.negative !== 0 && (E = "-" + E), E;
    }
    c(!1, "Base should be between 2 and 36");
  }, h.prototype.toNumber = function() {
    var m = this.words[0];
    return this.length === 2 ? m += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? m += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && c(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -m : m;
  }, h.prototype.toJSON = function() {
    return this.toString(16);
  }, h.prototype.toBuffer = function(m, A) {
    return c(g !== void 0), this.toArrayLike(g, m, A);
  }, h.prototype.toArray = function(m, A) {
    return this.toArrayLike(Array, m, A);
  }, h.prototype.toArrayLike = function(m, A, E) {
    var w = this.byteLength(), v = E || Math.max(1, w);
    c(w <= v, "byte array longer than desired length"), c(v > 0, "Requested array length <= 0"), this.strip();
    var k, O, W = A === "le", it = new m(v), vt = this.clone();
    if (W) {
      for (O = 0; !vt.isZero(); O++)
        k = vt.andln(255), vt.iushrn(8), it[O] = k;
      for (; O < v; O++)
        it[O] = 0;
    } else {
      for (O = 0; O < v - w; O++)
        it[O] = 0;
      for (O = 0; !vt.isZero(); O++)
        k = vt.andln(255), vt.iushrn(8), it[v - O - 1] = k;
    }
    return it;
  }, Math.clz32 ? h.prototype._countBits = function(m) {
    return 32 - Math.clz32(m);
  } : h.prototype._countBits = function(m) {
    var A = m, E = 0;
    return A >= 4096 && (E += 13, A >>>= 13), A >= 64 && (E += 7, A >>>= 7), A >= 8 && (E += 4, A >>>= 4), A >= 2 && (E += 2, A >>>= 2), E + A;
  }, h.prototype._zeroBits = function(m) {
    if (m === 0)
      return 26;
    var A = m, E = 0;
    return (8191 & A) == 0 && (E += 13, A >>>= 13), (127 & A) == 0 && (E += 7, A >>>= 7), (15 & A) == 0 && (E += 4, A >>>= 4), (3 & A) == 0 && (E += 2, A >>>= 2), (1 & A) == 0 && E++, E;
  }, h.prototype.bitLength = function() {
    var m = this.words[this.length - 1], A = this._countBits(m);
    return 26 * (this.length - 1) + A;
  }, h.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var m = 0, A = 0; A < this.length; A++) {
      var E = this._zeroBits(this.words[A]);
      if (m += E, E !== 26)
        break;
    }
    return m;
  }, h.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, h.prototype.toTwos = function(m) {
    return this.negative !== 0 ? this.abs().inotn(m).iaddn(1) : this.clone();
  }, h.prototype.fromTwos = function(m) {
    return this.testn(m - 1) ? this.notn(m).iaddn(1).ineg() : this.clone();
  }, h.prototype.isNeg = function() {
    return this.negative !== 0;
  }, h.prototype.neg = function() {
    return this.clone().ineg();
  }, h.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, h.prototype.iuor = function(m) {
    for (; this.length < m.length; )
      this.words[this.length++] = 0;
    for (var A = 0; A < m.length; A++)
      this.words[A] = this.words[A] | m.words[A];
    return this.strip();
  }, h.prototype.ior = function(m) {
    return c((this.negative | m.negative) == 0), this.iuor(m);
  }, h.prototype.or = function(m) {
    return this.length > m.length ? this.clone().ior(m) : m.clone().ior(this);
  }, h.prototype.uor = function(m) {
    return this.length > m.length ? this.clone().iuor(m) : m.clone().iuor(this);
  }, h.prototype.iuand = function(m) {
    var A;
    A = this.length > m.length ? m : this;
    for (var E = 0; E < A.length; E++)
      this.words[E] = this.words[E] & m.words[E];
    return this.length = A.length, this.strip();
  }, h.prototype.iand = function(m) {
    return c((this.negative | m.negative) == 0), this.iuand(m);
  }, h.prototype.and = function(m) {
    return this.length > m.length ? this.clone().iand(m) : m.clone().iand(this);
  }, h.prototype.uand = function(m) {
    return this.length > m.length ? this.clone().iuand(m) : m.clone().iuand(this);
  }, h.prototype.iuxor = function(m) {
    var A, E;
    this.length > m.length ? (A = this, E = m) : (A = m, E = this);
    for (var w = 0; w < E.length; w++)
      this.words[w] = A.words[w] ^ E.words[w];
    if (this !== A)
      for (; w < A.length; w++)
        this.words[w] = A.words[w];
    return this.length = A.length, this.strip();
  }, h.prototype.ixor = function(m) {
    return c((this.negative | m.negative) == 0), this.iuxor(m);
  }, h.prototype.xor = function(m) {
    return this.length > m.length ? this.clone().ixor(m) : m.clone().ixor(this);
  }, h.prototype.uxor = function(m) {
    return this.length > m.length ? this.clone().iuxor(m) : m.clone().iuxor(this);
  }, h.prototype.inotn = function(m) {
    c(typeof m == "number" && m >= 0);
    var A = 0 | Math.ceil(m / 26), E = m % 26;
    this._expand(A), E > 0 && A--;
    for (var w = 0; w < A; w++)
      this.words[w] = 67108863 & ~this.words[w];
    return E > 0 && (this.words[w] = ~this.words[w] & 67108863 >> 26 - E), this.strip();
  }, h.prototype.notn = function(m) {
    return this.clone().inotn(m);
  }, h.prototype.setn = function(m, A) {
    c(typeof m == "number" && m >= 0);
    var E = m / 26 | 0, w = m % 26;
    return this._expand(E + 1), this.words[E] = A ? this.words[E] | 1 << w : this.words[E] & ~(1 << w), this.strip();
  }, h.prototype.iadd = function(m) {
    var A, E, w;
    if (this.negative !== 0 && m.negative === 0)
      return this.negative = 0, A = this.isub(m), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && m.negative !== 0)
      return m.negative = 0, A = this.isub(m), m.negative = 1, A._normSign();
    this.length > m.length ? (E = this, w = m) : (E = m, w = this);
    for (var v = 0, k = 0; k < w.length; k++)
      A = (0 | E.words[k]) + (0 | w.words[k]) + v, this.words[k] = 67108863 & A, v = A >>> 26;
    for (; v !== 0 && k < E.length; k++)
      A = (0 | E.words[k]) + v, this.words[k] = 67108863 & A, v = A >>> 26;
    if (this.length = E.length, v !== 0)
      this.words[this.length] = v, this.length++;
    else if (E !== this)
      for (; k < E.length; k++)
        this.words[k] = E.words[k];
    return this;
  }, h.prototype.add = function(m) {
    var A;
    return m.negative !== 0 && this.negative === 0 ? (m.negative = 0, A = this.sub(m), m.negative ^= 1, A) : m.negative === 0 && this.negative !== 0 ? (this.negative = 0, A = m.sub(this), this.negative = 1, A) : this.length > m.length ? this.clone().iadd(m) : m.clone().iadd(this);
  }, h.prototype.isub = function(m) {
    if (m.negative !== 0) {
      m.negative = 0;
      var A = this.iadd(m);
      return m.negative = 1, A._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(m), this.negative = 1, this._normSign();
    var E, w, v = this.cmp(m);
    if (v === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    v > 0 ? (E = this, w = m) : (E = m, w = this);
    for (var k = 0, O = 0; O < w.length; O++)
      k = (A = (0 | E.words[O]) - (0 | w.words[O]) + k) >> 26, this.words[O] = 67108863 & A;
    for (; k !== 0 && O < E.length; O++)
      k = (A = (0 | E.words[O]) + k) >> 26, this.words[O] = 67108863 & A;
    if (k === 0 && O < E.length && E !== this)
      for (; O < E.length; O++)
        this.words[O] = E.words[O];
    return this.length = Math.max(this.length, O), E !== this && (this.negative = 1), this.strip();
  }, h.prototype.sub = function(m) {
    return this.clone().isub(m);
  };
  var X = function(m, A, E) {
    var w, v, k, O = m.words, W = A.words, it = E.words, vt = 0, xt = 0 | O[0], It = 8191 & xt, Wt = xt >>> 13, Ut = 0 | O[1], zt = 8191 & Ut, Jt = Ut >>> 13, Xt = 0 | O[2], ie = 8191 & Xt, oe = Xt >>> 13, De = 0 | O[3], ue = 8191 & De, xe = De >>> 13, se = 0 | O[4], he = 8191 & se, je = se >>> 13, jr = 0 | O[5], de = 8191 & jr, We = jr >>> 13, B = 0 | O[6], j = 8191 & B, Z = B >>> 13, kt = 0 | O[7], $t = 8191 & kt, At = kt >>> 13, Bt = 0 | O[8], Ft = 8191 & Bt, Kt = Bt >>> 13, Zt = 0 | O[9], Gt = 8191 & Zt, Qt = Zt >>> 13, Ae = 0 | W[0], ae = 8191 & Ae, we = Ae >>> 13, ir = 0 | W[1], ge = 8191 & ir, _e = ir >>> 13, rr = 0 | W[2], be = 8191 & rr, Ge = rr >>> 13, Rr = 0 | W[3], Te = 8191 & Rr, Ie = Rr >>> 13, Pr = 0 | W[4], Ee = 8191 & Pr, er = Pr >>> 13, Or = 0 | W[5], Ve = 8191 & Or, sr = Or >>> 13, qr = 0 | W[6], Je = 8191 & qr, ur = qr >>> 13, Kr = 0 | W[7], Ze = 8191 & Kr, vr = Kr >>> 13, Hr = 0 | W[8], Ye = 8191 & Hr, _r = Hr >>> 13, zr = 0 | W[9], tr = 8191 & zr, Mr = zr >>> 13;
    E.negative = m.negative ^ A.negative, E.length = 19;
    var Ur = (vt + (w = Math.imul(It, ae)) | 0) + ((8191 & (v = (v = Math.imul(It, we)) + Math.imul(Wt, ae) | 0)) << 13) | 0;
    vt = ((k = Math.imul(Wt, we)) + (v >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, w = Math.imul(zt, ae), v = (v = Math.imul(zt, we)) + Math.imul(Jt, ae) | 0, k = Math.imul(Jt, we);
    var Fr = (vt + (w = w + Math.imul(It, ge) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, _e) | 0) + Math.imul(Wt, ge) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, _e) | 0) + (v >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, w = Math.imul(ie, ae), v = (v = Math.imul(ie, we)) + Math.imul(oe, ae) | 0, k = Math.imul(oe, we), w = w + Math.imul(zt, ge) | 0, v = (v = v + Math.imul(zt, _e) | 0) + Math.imul(Jt, ge) | 0, k = k + Math.imul(Jt, _e) | 0;
    var Zr = (vt + (w = w + Math.imul(It, be) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, Ge) | 0) + Math.imul(Wt, be) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, Ge) | 0) + (v >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, w = Math.imul(ue, ae), v = (v = Math.imul(ue, we)) + Math.imul(xe, ae) | 0, k = Math.imul(xe, we), w = w + Math.imul(ie, ge) | 0, v = (v = v + Math.imul(ie, _e) | 0) + Math.imul(oe, ge) | 0, k = k + Math.imul(oe, _e) | 0, w = w + Math.imul(zt, be) | 0, v = (v = v + Math.imul(zt, Ge) | 0) + Math.imul(Jt, be) | 0, k = k + Math.imul(Jt, Ge) | 0;
    var Qr = (vt + (w = w + Math.imul(It, Te) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, Ie) | 0) + Math.imul(Wt, Te) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, Ie) | 0) + (v >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, w = Math.imul(he, ae), v = (v = Math.imul(he, we)) + Math.imul(je, ae) | 0, k = Math.imul(je, we), w = w + Math.imul(ue, ge) | 0, v = (v = v + Math.imul(ue, _e) | 0) + Math.imul(xe, ge) | 0, k = k + Math.imul(xe, _e) | 0, w = w + Math.imul(ie, be) | 0, v = (v = v + Math.imul(ie, Ge) | 0) + Math.imul(oe, be) | 0, k = k + Math.imul(oe, Ge) | 0, w = w + Math.imul(zt, Te) | 0, v = (v = v + Math.imul(zt, Ie) | 0) + Math.imul(Jt, Te) | 0, k = k + Math.imul(Jt, Ie) | 0;
    var Xr = (vt + (w = w + Math.imul(It, Ee) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, er) | 0) + Math.imul(Wt, Ee) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, er) | 0) + (v >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, w = Math.imul(de, ae), v = (v = Math.imul(de, we)) + Math.imul(We, ae) | 0, k = Math.imul(We, we), w = w + Math.imul(he, ge) | 0, v = (v = v + Math.imul(he, _e) | 0) + Math.imul(je, ge) | 0, k = k + Math.imul(je, _e) | 0, w = w + Math.imul(ue, be) | 0, v = (v = v + Math.imul(ue, Ge) | 0) + Math.imul(xe, be) | 0, k = k + Math.imul(xe, Ge) | 0, w = w + Math.imul(ie, Te) | 0, v = (v = v + Math.imul(ie, Ie) | 0) + Math.imul(oe, Te) | 0, k = k + Math.imul(oe, Ie) | 0, w = w + Math.imul(zt, Ee) | 0, v = (v = v + Math.imul(zt, er) | 0) + Math.imul(Jt, Ee) | 0, k = k + Math.imul(Jt, er) | 0;
    var Yr = (vt + (w = w + Math.imul(It, Ve) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, sr) | 0) + Math.imul(Wt, Ve) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, sr) | 0) + (v >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, w = Math.imul(j, ae), v = (v = Math.imul(j, we)) + Math.imul(Z, ae) | 0, k = Math.imul(Z, we), w = w + Math.imul(de, ge) | 0, v = (v = v + Math.imul(de, _e) | 0) + Math.imul(We, ge) | 0, k = k + Math.imul(We, _e) | 0, w = w + Math.imul(he, be) | 0, v = (v = v + Math.imul(he, Ge) | 0) + Math.imul(je, be) | 0, k = k + Math.imul(je, Ge) | 0, w = w + Math.imul(ue, Te) | 0, v = (v = v + Math.imul(ue, Ie) | 0) + Math.imul(xe, Te) | 0, k = k + Math.imul(xe, Ie) | 0, w = w + Math.imul(ie, Ee) | 0, v = (v = v + Math.imul(ie, er) | 0) + Math.imul(oe, Ee) | 0, k = k + Math.imul(oe, er) | 0, w = w + Math.imul(zt, Ve) | 0, v = (v = v + Math.imul(zt, sr) | 0) + Math.imul(Jt, Ve) | 0, k = k + Math.imul(Jt, sr) | 0;
    var tn = (vt + (w = w + Math.imul(It, Je) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, ur) | 0) + Math.imul(Wt, Je) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, ur) | 0) + (v >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, w = Math.imul($t, ae), v = (v = Math.imul($t, we)) + Math.imul(At, ae) | 0, k = Math.imul(At, we), w = w + Math.imul(j, ge) | 0, v = (v = v + Math.imul(j, _e) | 0) + Math.imul(Z, ge) | 0, k = k + Math.imul(Z, _e) | 0, w = w + Math.imul(de, be) | 0, v = (v = v + Math.imul(de, Ge) | 0) + Math.imul(We, be) | 0, k = k + Math.imul(We, Ge) | 0, w = w + Math.imul(he, Te) | 0, v = (v = v + Math.imul(he, Ie) | 0) + Math.imul(je, Te) | 0, k = k + Math.imul(je, Ie) | 0, w = w + Math.imul(ue, Ee) | 0, v = (v = v + Math.imul(ue, er) | 0) + Math.imul(xe, Ee) | 0, k = k + Math.imul(xe, er) | 0, w = w + Math.imul(ie, Ve) | 0, v = (v = v + Math.imul(ie, sr) | 0) + Math.imul(oe, Ve) | 0, k = k + Math.imul(oe, sr) | 0, w = w + Math.imul(zt, Je) | 0, v = (v = v + Math.imul(zt, ur) | 0) + Math.imul(Jt, Je) | 0, k = k + Math.imul(Jt, ur) | 0;
    var en = (vt + (w = w + Math.imul(It, Ze) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, vr) | 0) + Math.imul(Wt, Ze) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, vr) | 0) + (v >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, w = Math.imul(Ft, ae), v = (v = Math.imul(Ft, we)) + Math.imul(Kt, ae) | 0, k = Math.imul(Kt, we), w = w + Math.imul($t, ge) | 0, v = (v = v + Math.imul($t, _e) | 0) + Math.imul(At, ge) | 0, k = k + Math.imul(At, _e) | 0, w = w + Math.imul(j, be) | 0, v = (v = v + Math.imul(j, Ge) | 0) + Math.imul(Z, be) | 0, k = k + Math.imul(Z, Ge) | 0, w = w + Math.imul(de, Te) | 0, v = (v = v + Math.imul(de, Ie) | 0) + Math.imul(We, Te) | 0, k = k + Math.imul(We, Ie) | 0, w = w + Math.imul(he, Ee) | 0, v = (v = v + Math.imul(he, er) | 0) + Math.imul(je, Ee) | 0, k = k + Math.imul(je, er) | 0, w = w + Math.imul(ue, Ve) | 0, v = (v = v + Math.imul(ue, sr) | 0) + Math.imul(xe, Ve) | 0, k = k + Math.imul(xe, sr) | 0, w = w + Math.imul(ie, Je) | 0, v = (v = v + Math.imul(ie, ur) | 0) + Math.imul(oe, Je) | 0, k = k + Math.imul(oe, ur) | 0, w = w + Math.imul(zt, Ze) | 0, v = (v = v + Math.imul(zt, vr) | 0) + Math.imul(Jt, Ze) | 0, k = k + Math.imul(Jt, vr) | 0;
    var rn = (vt + (w = w + Math.imul(It, Ye) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, _r) | 0) + Math.imul(Wt, Ye) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, _r) | 0) + (v >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, w = Math.imul(Gt, ae), v = (v = Math.imul(Gt, we)) + Math.imul(Qt, ae) | 0, k = Math.imul(Qt, we), w = w + Math.imul(Ft, ge) | 0, v = (v = v + Math.imul(Ft, _e) | 0) + Math.imul(Kt, ge) | 0, k = k + Math.imul(Kt, _e) | 0, w = w + Math.imul($t, be) | 0, v = (v = v + Math.imul($t, Ge) | 0) + Math.imul(At, be) | 0, k = k + Math.imul(At, Ge) | 0, w = w + Math.imul(j, Te) | 0, v = (v = v + Math.imul(j, Ie) | 0) + Math.imul(Z, Te) | 0, k = k + Math.imul(Z, Ie) | 0, w = w + Math.imul(de, Ee) | 0, v = (v = v + Math.imul(de, er) | 0) + Math.imul(We, Ee) | 0, k = k + Math.imul(We, er) | 0, w = w + Math.imul(he, Ve) | 0, v = (v = v + Math.imul(he, sr) | 0) + Math.imul(je, Ve) | 0, k = k + Math.imul(je, sr) | 0, w = w + Math.imul(ue, Je) | 0, v = (v = v + Math.imul(ue, ur) | 0) + Math.imul(xe, Je) | 0, k = k + Math.imul(xe, ur) | 0, w = w + Math.imul(ie, Ze) | 0, v = (v = v + Math.imul(ie, vr) | 0) + Math.imul(oe, Ze) | 0, k = k + Math.imul(oe, vr) | 0, w = w + Math.imul(zt, Ye) | 0, v = (v = v + Math.imul(zt, _r) | 0) + Math.imul(Jt, Ye) | 0, k = k + Math.imul(Jt, _r) | 0;
    var nn = (vt + (w = w + Math.imul(It, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, Mr) | 0) + Math.imul(Wt, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, Mr) | 0) + (v >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, w = Math.imul(Gt, ge), v = (v = Math.imul(Gt, _e)) + Math.imul(Qt, ge) | 0, k = Math.imul(Qt, _e), w = w + Math.imul(Ft, be) | 0, v = (v = v + Math.imul(Ft, Ge) | 0) + Math.imul(Kt, be) | 0, k = k + Math.imul(Kt, Ge) | 0, w = w + Math.imul($t, Te) | 0, v = (v = v + Math.imul($t, Ie) | 0) + Math.imul(At, Te) | 0, k = k + Math.imul(At, Ie) | 0, w = w + Math.imul(j, Ee) | 0, v = (v = v + Math.imul(j, er) | 0) + Math.imul(Z, Ee) | 0, k = k + Math.imul(Z, er) | 0, w = w + Math.imul(de, Ve) | 0, v = (v = v + Math.imul(de, sr) | 0) + Math.imul(We, Ve) | 0, k = k + Math.imul(We, sr) | 0, w = w + Math.imul(he, Je) | 0, v = (v = v + Math.imul(he, ur) | 0) + Math.imul(je, Je) | 0, k = k + Math.imul(je, ur) | 0, w = w + Math.imul(ue, Ze) | 0, v = (v = v + Math.imul(ue, vr) | 0) + Math.imul(xe, Ze) | 0, k = k + Math.imul(xe, vr) | 0, w = w + Math.imul(ie, Ye) | 0, v = (v = v + Math.imul(ie, _r) | 0) + Math.imul(oe, Ye) | 0, k = k + Math.imul(oe, _r) | 0;
    var on = (vt + (w = w + Math.imul(zt, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(zt, Mr) | 0) + Math.imul(Jt, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Jt, Mr) | 0) + (v >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, w = Math.imul(Gt, be), v = (v = Math.imul(Gt, Ge)) + Math.imul(Qt, be) | 0, k = Math.imul(Qt, Ge), w = w + Math.imul(Ft, Te) | 0, v = (v = v + Math.imul(Ft, Ie) | 0) + Math.imul(Kt, Te) | 0, k = k + Math.imul(Kt, Ie) | 0, w = w + Math.imul($t, Ee) | 0, v = (v = v + Math.imul($t, er) | 0) + Math.imul(At, Ee) | 0, k = k + Math.imul(At, er) | 0, w = w + Math.imul(j, Ve) | 0, v = (v = v + Math.imul(j, sr) | 0) + Math.imul(Z, Ve) | 0, k = k + Math.imul(Z, sr) | 0, w = w + Math.imul(de, Je) | 0, v = (v = v + Math.imul(de, ur) | 0) + Math.imul(We, Je) | 0, k = k + Math.imul(We, ur) | 0, w = w + Math.imul(he, Ze) | 0, v = (v = v + Math.imul(he, vr) | 0) + Math.imul(je, Ze) | 0, k = k + Math.imul(je, vr) | 0, w = w + Math.imul(ue, Ye) | 0, v = (v = v + Math.imul(ue, _r) | 0) + Math.imul(xe, Ye) | 0, k = k + Math.imul(xe, _r) | 0;
    var an = (vt + (w = w + Math.imul(ie, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(ie, Mr) | 0) + Math.imul(oe, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(oe, Mr) | 0) + (v >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, w = Math.imul(Gt, Te), v = (v = Math.imul(Gt, Ie)) + Math.imul(Qt, Te) | 0, k = Math.imul(Qt, Ie), w = w + Math.imul(Ft, Ee) | 0, v = (v = v + Math.imul(Ft, er) | 0) + Math.imul(Kt, Ee) | 0, k = k + Math.imul(Kt, er) | 0, w = w + Math.imul($t, Ve) | 0, v = (v = v + Math.imul($t, sr) | 0) + Math.imul(At, Ve) | 0, k = k + Math.imul(At, sr) | 0, w = w + Math.imul(j, Je) | 0, v = (v = v + Math.imul(j, ur) | 0) + Math.imul(Z, Je) | 0, k = k + Math.imul(Z, ur) | 0, w = w + Math.imul(de, Ze) | 0, v = (v = v + Math.imul(de, vr) | 0) + Math.imul(We, Ze) | 0, k = k + Math.imul(We, vr) | 0, w = w + Math.imul(he, Ye) | 0, v = (v = v + Math.imul(he, _r) | 0) + Math.imul(je, Ye) | 0, k = k + Math.imul(je, _r) | 0;
    var sn = (vt + (w = w + Math.imul(ue, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(ue, Mr) | 0) + Math.imul(xe, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(xe, Mr) | 0) + (v >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, w = Math.imul(Gt, Ee), v = (v = Math.imul(Gt, er)) + Math.imul(Qt, Ee) | 0, k = Math.imul(Qt, er), w = w + Math.imul(Ft, Ve) | 0, v = (v = v + Math.imul(Ft, sr) | 0) + Math.imul(Kt, Ve) | 0, k = k + Math.imul(Kt, sr) | 0, w = w + Math.imul($t, Je) | 0, v = (v = v + Math.imul($t, ur) | 0) + Math.imul(At, Je) | 0, k = k + Math.imul(At, ur) | 0, w = w + Math.imul(j, Ze) | 0, v = (v = v + Math.imul(j, vr) | 0) + Math.imul(Z, Ze) | 0, k = k + Math.imul(Z, vr) | 0, w = w + Math.imul(de, Ye) | 0, v = (v = v + Math.imul(de, _r) | 0) + Math.imul(We, Ye) | 0, k = k + Math.imul(We, _r) | 0;
    var cn = (vt + (w = w + Math.imul(he, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(he, Mr) | 0) + Math.imul(je, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(je, Mr) | 0) + (v >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, w = Math.imul(Gt, Ve), v = (v = Math.imul(Gt, sr)) + Math.imul(Qt, Ve) | 0, k = Math.imul(Qt, sr), w = w + Math.imul(Ft, Je) | 0, v = (v = v + Math.imul(Ft, ur) | 0) + Math.imul(Kt, Je) | 0, k = k + Math.imul(Kt, ur) | 0, w = w + Math.imul($t, Ze) | 0, v = (v = v + Math.imul($t, vr) | 0) + Math.imul(At, Ze) | 0, k = k + Math.imul(At, vr) | 0, w = w + Math.imul(j, Ye) | 0, v = (v = v + Math.imul(j, _r) | 0) + Math.imul(Z, Ye) | 0, k = k + Math.imul(Z, _r) | 0;
    var Cn = (vt + (w = w + Math.imul(de, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(de, Mr) | 0) + Math.imul(We, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(We, Mr) | 0) + (v >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, w = Math.imul(Gt, Je), v = (v = Math.imul(Gt, ur)) + Math.imul(Qt, Je) | 0, k = Math.imul(Qt, ur), w = w + Math.imul(Ft, Ze) | 0, v = (v = v + Math.imul(Ft, vr) | 0) + Math.imul(Kt, Ze) | 0, k = k + Math.imul(Kt, vr) | 0, w = w + Math.imul($t, Ye) | 0, v = (v = v + Math.imul($t, _r) | 0) + Math.imul(At, Ye) | 0, k = k + Math.imul(At, _r) | 0;
    var xn = (vt + (w = w + Math.imul(j, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(j, Mr) | 0) + Math.imul(Z, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Z, Mr) | 0) + (v >>> 13) | 0) + (xn >>> 26) | 0, xn &= 67108863, w = Math.imul(Gt, Ze), v = (v = Math.imul(Gt, vr)) + Math.imul(Qt, Ze) | 0, k = Math.imul(Qt, vr), w = w + Math.imul(Ft, Ye) | 0, v = (v = v + Math.imul(Ft, _r) | 0) + Math.imul(Kt, Ye) | 0, k = k + Math.imul(Kt, _r) | 0;
    var Pn = (vt + (w = w + Math.imul($t, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul($t, Mr) | 0) + Math.imul(At, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(At, Mr) | 0) + (v >>> 13) | 0) + (Pn >>> 26) | 0, Pn &= 67108863, w = Math.imul(Gt, Ye), v = (v = Math.imul(Gt, _r)) + Math.imul(Qt, Ye) | 0, k = Math.imul(Qt, _r);
    var Rn = (vt + (w = w + Math.imul(Ft, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(Ft, Mr) | 0) + Math.imul(Kt, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Kt, Mr) | 0) + (v >>> 13) | 0) + (Rn >>> 26) | 0, Rn &= 67108863;
    var Gn = (vt + (w = Math.imul(Gt, tr)) | 0) + ((8191 & (v = (v = Math.imul(Gt, Mr)) + Math.imul(Qt, tr) | 0)) << 13) | 0;
    return vt = ((k = Math.imul(Qt, Mr)) + (v >>> 13) | 0) + (Gn >>> 26) | 0, Gn &= 67108863, it[0] = Ur, it[1] = Fr, it[2] = Zr, it[3] = Qr, it[4] = Xr, it[5] = Yr, it[6] = tn, it[7] = en, it[8] = rn, it[9] = nn, it[10] = on, it[11] = an, it[12] = sn, it[13] = cn, it[14] = Cn, it[15] = xn, it[16] = Pn, it[17] = Rn, it[18] = Gn, vt !== 0 && (it[19] = vt, E.length++), E;
  };
  function rt(m, A, E) {
    return new nt().mulp(m, A, E);
  }
  function nt(m, A) {
    this.x = m, this.y = A;
  }
  Math.imul || (X = N), h.prototype.mulTo = function(m, A) {
    var E, w = this.length + m.length;
    return E = this.length === 10 && m.length === 10 ? X(this, m, A) : w < 63 ? N(this, m, A) : w < 1024 ? function(v, k, O) {
      O.negative = k.negative ^ v.negative, O.length = v.length + k.length;
      for (var W = 0, it = 0, vt = 0; vt < O.length - 1; vt++) {
        var xt = it;
        it = 0;
        for (var It = 67108863 & W, Wt = Math.min(vt, k.length - 1), Ut = Math.max(0, vt - v.length + 1); Ut <= Wt; Ut++) {
          var zt = vt - Ut, Jt = (0 | v.words[zt]) * (0 | k.words[Ut]), Xt = 67108863 & Jt;
          It = 67108863 & (Xt = Xt + It | 0), it += (xt = (xt = xt + (Jt / 67108864 | 0) | 0) + (Xt >>> 26) | 0) >>> 26, xt &= 67108863;
        }
        O.words[vt] = It, W = xt, xt = it;
      }
      return W !== 0 ? O.words[vt] = W : O.length--, O.strip();
    }(this, m, A) : rt(this, m, A), E;
  }, nt.prototype.makeRBT = function(m) {
    for (var A = new Array(m), E = h.prototype._countBits(m) - 1, w = 0; w < m; w++)
      A[w] = this.revBin(w, E, m);
    return A;
  }, nt.prototype.revBin = function(m, A, E) {
    if (m === 0 || m === E - 1)
      return m;
    for (var w = 0, v = 0; v < A; v++)
      w |= (1 & m) << A - v - 1, m >>= 1;
    return w;
  }, nt.prototype.permute = function(m, A, E, w, v, k) {
    for (var O = 0; O < k; O++)
      w[O] = A[m[O]], v[O] = E[m[O]];
  }, nt.prototype.transform = function(m, A, E, w, v, k) {
    this.permute(k, m, A, E, w, v);
    for (var O = 1; O < v; O <<= 1)
      for (var W = O << 1, it = Math.cos(2 * Math.PI / W), vt = Math.sin(2 * Math.PI / W), xt = 0; xt < v; xt += W)
        for (var It = it, Wt = vt, Ut = 0; Ut < O; Ut++) {
          var zt = E[xt + Ut], Jt = w[xt + Ut], Xt = E[xt + Ut + O], ie = w[xt + Ut + O], oe = It * Xt - Wt * ie;
          ie = It * ie + Wt * Xt, Xt = oe, E[xt + Ut] = zt + Xt, w[xt + Ut] = Jt + ie, E[xt + Ut + O] = zt - Xt, w[xt + Ut + O] = Jt - ie, Ut !== W && (oe = it * It - vt * Wt, Wt = it * Wt + vt * It, It = oe);
        }
  }, nt.prototype.guessLen13b = function(m, A) {
    var E = 1 | Math.max(A, m), w = 1 & E, v = 0;
    for (E = E / 2 | 0; E; E >>>= 1)
      v++;
    return 1 << v + 1 + w;
  }, nt.prototype.conjugate = function(m, A, E) {
    if (!(E <= 1))
      for (var w = 0; w < E / 2; w++) {
        var v = m[w];
        m[w] = m[E - w - 1], m[E - w - 1] = v, v = A[w], A[w] = -A[E - w - 1], A[E - w - 1] = -v;
      }
  }, nt.prototype.normalize13b = function(m, A) {
    for (var E = 0, w = 0; w < A / 2; w++) {
      var v = 8192 * Math.round(m[2 * w + 1] / A) + Math.round(m[2 * w] / A) + E;
      m[w] = 67108863 & v, E = v < 67108864 ? 0 : v / 67108864 | 0;
    }
    return m;
  }, nt.prototype.convert13b = function(m, A, E, w) {
    for (var v = 0, k = 0; k < A; k++)
      v += 0 | m[k], E[2 * k] = 8191 & v, v >>>= 13, E[2 * k + 1] = 8191 & v, v >>>= 13;
    for (k = 2 * A; k < w; ++k)
      E[k] = 0;
    c(v === 0), c((-8192 & v) == 0);
  }, nt.prototype.stub = function(m) {
    for (var A = new Array(m), E = 0; E < m; E++)
      A[E] = 0;
    return A;
  }, nt.prototype.mulp = function(m, A, E) {
    var w = 2 * this.guessLen13b(m.length, A.length), v = this.makeRBT(w), k = this.stub(w), O = new Array(w), W = new Array(w), it = new Array(w), vt = new Array(w), xt = new Array(w), It = new Array(w), Wt = E.words;
    Wt.length = w, this.convert13b(m.words, m.length, O, w), this.convert13b(A.words, A.length, vt, w), this.transform(O, k, W, it, w, v), this.transform(vt, k, xt, It, w, v);
    for (var Ut = 0; Ut < w; Ut++) {
      var zt = W[Ut] * xt[Ut] - it[Ut] * It[Ut];
      it[Ut] = W[Ut] * It[Ut] + it[Ut] * xt[Ut], W[Ut] = zt;
    }
    return this.conjugate(W, it, w), this.transform(W, it, Wt, k, w, v), this.conjugate(Wt, k, w), this.normalize13b(Wt, w), E.negative = m.negative ^ A.negative, E.length = m.length + A.length, E.strip();
  }, h.prototype.mul = function(m) {
    var A = new h(null);
    return A.words = new Array(this.length + m.length), this.mulTo(m, A);
  }, h.prototype.mulf = function(m) {
    var A = new h(null);
    return A.words = new Array(this.length + m.length), rt(this, m, A);
  }, h.prototype.imul = function(m) {
    return this.clone().mulTo(m, this);
  }, h.prototype.imuln = function(m) {
    c(typeof m == "number"), c(m < 67108864);
    for (var A = 0, E = 0; E < this.length; E++) {
      var w = (0 | this.words[E]) * m, v = (67108863 & w) + (67108863 & A);
      A >>= 26, A += w / 67108864 | 0, A += v >>> 26, this.words[E] = 67108863 & v;
    }
    return A !== 0 && (this.words[E] = A, this.length++), this;
  }, h.prototype.muln = function(m) {
    return this.clone().imuln(m);
  }, h.prototype.sqr = function() {
    return this.mul(this);
  }, h.prototype.isqr = function() {
    return this.imul(this.clone());
  }, h.prototype.pow = function(m) {
    var A = function(k) {
      for (var O = new Array(k.bitLength()), W = 0; W < O.length; W++) {
        var it = W / 26 | 0, vt = W % 26;
        O[W] = (k.words[it] & 1 << vt) >>> vt;
      }
      return O;
    }(m);
    if (A.length === 0)
      return new h(1);
    for (var E = this, w = 0; w < A.length && A[w] === 0; w++, E = E.sqr())
      ;
    if (++w < A.length)
      for (var v = E.sqr(); w < A.length; w++, v = v.sqr())
        A[w] !== 0 && (E = E.mul(v));
    return E;
  }, h.prototype.iushln = function(m) {
    c(typeof m == "number" && m >= 0);
    var A, E = m % 26, w = (m - E) / 26, v = 67108863 >>> 26 - E << 26 - E;
    if (E !== 0) {
      var k = 0;
      for (A = 0; A < this.length; A++) {
        var O = this.words[A] & v, W = (0 | this.words[A]) - O << E;
        this.words[A] = W | k, k = O >>> 26 - E;
      }
      k && (this.words[A] = k, this.length++);
    }
    if (w !== 0) {
      for (A = this.length - 1; A >= 0; A--)
        this.words[A + w] = this.words[A];
      for (A = 0; A < w; A++)
        this.words[A] = 0;
      this.length += w;
    }
    return this.strip();
  }, h.prototype.ishln = function(m) {
    return c(this.negative === 0), this.iushln(m);
  }, h.prototype.iushrn = function(m, A, E) {
    var w;
    c(typeof m == "number" && m >= 0), w = A ? (A - A % 26) / 26 : 0;
    var v = m % 26, k = Math.min((m - v) / 26, this.length), O = 67108863 ^ 67108863 >>> v << v, W = E;
    if (w -= k, w = Math.max(0, w), W) {
      for (var it = 0; it < k; it++)
        W.words[it] = this.words[it];
      W.length = k;
    }
    if (k !== 0)
      if (this.length > k)
        for (this.length -= k, it = 0; it < this.length; it++)
          this.words[it] = this.words[it + k];
      else
        this.words[0] = 0, this.length = 1;
    var vt = 0;
    for (it = this.length - 1; it >= 0 && (vt !== 0 || it >= w); it--) {
      var xt = 0 | this.words[it];
      this.words[it] = vt << 26 - v | xt >>> v, vt = xt & O;
    }
    return W && vt !== 0 && (W.words[W.length++] = vt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
  }, h.prototype.ishrn = function(m, A, E) {
    return c(this.negative === 0), this.iushrn(m, A, E);
  }, h.prototype.shln = function(m) {
    return this.clone().ishln(m);
  }, h.prototype.ushln = function(m) {
    return this.clone().iushln(m);
  }, h.prototype.shrn = function(m) {
    return this.clone().ishrn(m);
  }, h.prototype.ushrn = function(m) {
    return this.clone().iushrn(m);
  }, h.prototype.testn = function(m) {
    c(typeof m == "number" && m >= 0);
    var A = m % 26, E = (m - A) / 26, w = 1 << A;
    return !(this.length <= E || !(this.words[E] & w));
  }, h.prototype.imaskn = function(m) {
    c(typeof m == "number" && m >= 0);
    var A = m % 26, E = (m - A) / 26;
    if (c(this.negative === 0, "imaskn works only with positive numbers"), this.length <= E)
      return this;
    if (A !== 0 && E++, this.length = Math.min(E, this.length), A !== 0) {
      var w = 67108863 ^ 67108863 >>> A << A;
      this.words[this.length - 1] &= w;
    }
    return this.strip();
  }, h.prototype.maskn = function(m) {
    return this.clone().imaskn(m);
  }, h.prototype.iaddn = function(m) {
    return c(typeof m == "number"), c(m < 67108864), m < 0 ? this.isubn(-m) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < m ? (this.words[0] = m - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(m), this.negative = 1, this) : this._iaddn(m);
  }, h.prototype._iaddn = function(m) {
    this.words[0] += m;
    for (var A = 0; A < this.length && this.words[A] >= 67108864; A++)
      this.words[A] -= 67108864, A === this.length - 1 ? this.words[A + 1] = 1 : this.words[A + 1]++;
    return this.length = Math.max(this.length, A + 1), this;
  }, h.prototype.isubn = function(m) {
    if (c(typeof m == "number"), c(m < 67108864), m < 0)
      return this.iaddn(-m);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(m), this.negative = 1, this;
    if (this.words[0] -= m, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var A = 0; A < this.length && this.words[A] < 0; A++)
        this.words[A] += 67108864, this.words[A + 1] -= 1;
    return this.strip();
  }, h.prototype.addn = function(m) {
    return this.clone().iaddn(m);
  }, h.prototype.subn = function(m) {
    return this.clone().isubn(m);
  }, h.prototype.iabs = function() {
    return this.negative = 0, this;
  }, h.prototype.abs = function() {
    return this.clone().iabs();
  }, h.prototype._ishlnsubmul = function(m, A, E) {
    var w, v, k = m.length + E;
    this._expand(k);
    var O = 0;
    for (w = 0; w < m.length; w++) {
      v = (0 | this.words[w + E]) + O;
      var W = (0 | m.words[w]) * A;
      O = ((v -= 67108863 & W) >> 26) - (W / 67108864 | 0), this.words[w + E] = 67108863 & v;
    }
    for (; w < this.length - E; w++)
      O = (v = (0 | this.words[w + E]) + O) >> 26, this.words[w + E] = 67108863 & v;
    if (O === 0)
      return this.strip();
    for (c(O === -1), O = 0, w = 0; w < this.length; w++)
      O = (v = -(0 | this.words[w]) + O) >> 26, this.words[w] = 67108863 & v;
    return this.negative = 1, this.strip();
  }, h.prototype._wordDiv = function(m, A) {
    var E = (this.length, m.length), w = this.clone(), v = m, k = 0 | v.words[v.length - 1];
    (E = 26 - this._countBits(k)) != 0 && (v = v.ushln(E), w.iushln(E), k = 0 | v.words[v.length - 1]);
    var O, W = w.length - v.length;
    if (A !== "mod") {
      (O = new h(null)).length = W + 1, O.words = new Array(O.length);
      for (var it = 0; it < O.length; it++)
        O.words[it] = 0;
    }
    var vt = w.clone()._ishlnsubmul(v, 1, W);
    vt.negative === 0 && (w = vt, O && (O.words[W] = 1));
    for (var xt = W - 1; xt >= 0; xt--) {
      var It = 67108864 * (0 | w.words[v.length + xt]) + (0 | w.words[v.length + xt - 1]);
      for (It = Math.min(It / k | 0, 67108863), w._ishlnsubmul(v, It, xt); w.negative !== 0; )
        It--, w.negative = 0, w._ishlnsubmul(v, 1, xt), w.isZero() || (w.negative ^= 1);
      O && (O.words[xt] = It);
    }
    return O && O.strip(), w.strip(), A !== "div" && E !== 0 && w.iushrn(E), { div: O || null, mod: w };
  }, h.prototype.divmod = function(m, A, E) {
    return c(!m.isZero()), this.isZero() ? { div: new h(0), mod: new h(0) } : this.negative !== 0 && m.negative === 0 ? (k = this.neg().divmod(m, A), A !== "mod" && (w = k.div.neg()), A !== "div" && (v = k.mod.neg(), E && v.negative !== 0 && v.iadd(m)), { div: w, mod: v }) : this.negative === 0 && m.negative !== 0 ? (k = this.divmod(m.neg(), A), A !== "mod" && (w = k.div.neg()), { div: w, mod: k.mod }) : (this.negative & m.negative) != 0 ? (k = this.neg().divmod(m.neg(), A), A !== "div" && (v = k.mod.neg(), E && v.negative !== 0 && v.isub(m)), { div: k.div, mod: v }) : m.length > this.length || this.cmp(m) < 0 ? { div: new h(0), mod: this } : m.length === 1 ? A === "div" ? { div: this.divn(m.words[0]), mod: null } : A === "mod" ? { div: null, mod: new h(this.modn(m.words[0])) } : { div: this.divn(m.words[0]), mod: new h(this.modn(m.words[0])) } : this._wordDiv(m, A);
    var w, v, k;
  }, h.prototype.div = function(m) {
    return this.divmod(m, "div", !1).div;
  }, h.prototype.mod = function(m) {
    return this.divmod(m, "mod", !1).mod;
  }, h.prototype.umod = function(m) {
    return this.divmod(m, "mod", !0).mod;
  }, h.prototype.divRound = function(m) {
    var A = this.divmod(m);
    if (A.mod.isZero())
      return A.div;
    var E = A.div.negative !== 0 ? A.mod.isub(m) : A.mod, w = m.ushrn(1), v = m.andln(1), k = E.cmp(w);
    return k < 0 || v === 1 && k === 0 ? A.div : A.div.negative !== 0 ? A.div.isubn(1) : A.div.iaddn(1);
  }, h.prototype.modn = function(m) {
    c(m <= 67108863);
    for (var A = (1 << 26) % m, E = 0, w = this.length - 1; w >= 0; w--)
      E = (A * E + (0 | this.words[w])) % m;
    return E;
  }, h.prototype.idivn = function(m) {
    c(m <= 67108863);
    for (var A = 0, E = this.length - 1; E >= 0; E--) {
      var w = (0 | this.words[E]) + 67108864 * A;
      this.words[E] = w / m | 0, A = w % m;
    }
    return this.strip();
  }, h.prototype.divn = function(m) {
    return this.clone().idivn(m);
  }, h.prototype.egcd = function(m) {
    c(m.negative === 0), c(!m.isZero());
    var A = this, E = m.clone();
    A = A.negative !== 0 ? A.umod(m) : A.clone();
    for (var w = new h(1), v = new h(0), k = new h(0), O = new h(1), W = 0; A.isEven() && E.isEven(); )
      A.iushrn(1), E.iushrn(1), ++W;
    for (var it = E.clone(), vt = A.clone(); !A.isZero(); ) {
      for (var xt = 0, It = 1; (A.words[0] & It) == 0 && xt < 26; ++xt, It <<= 1)
        ;
      if (xt > 0)
        for (A.iushrn(xt); xt-- > 0; )
          (w.isOdd() || v.isOdd()) && (w.iadd(it), v.isub(vt)), w.iushrn(1), v.iushrn(1);
      for (var Wt = 0, Ut = 1; (E.words[0] & Ut) == 0 && Wt < 26; ++Wt, Ut <<= 1)
        ;
      if (Wt > 0)
        for (E.iushrn(Wt); Wt-- > 0; )
          (k.isOdd() || O.isOdd()) && (k.iadd(it), O.isub(vt)), k.iushrn(1), O.iushrn(1);
      A.cmp(E) >= 0 ? (A.isub(E), w.isub(k), v.isub(O)) : (E.isub(A), k.isub(w), O.isub(v));
    }
    return { a: k, b: O, gcd: E.iushln(W) };
  }, h.prototype._invmp = function(m) {
    c(m.negative === 0), c(!m.isZero());
    var A = this, E = m.clone();
    A = A.negative !== 0 ? A.umod(m) : A.clone();
    for (var w, v = new h(1), k = new h(0), O = E.clone(); A.cmpn(1) > 0 && E.cmpn(1) > 0; ) {
      for (var W = 0, it = 1; (A.words[0] & it) == 0 && W < 26; ++W, it <<= 1)
        ;
      if (W > 0)
        for (A.iushrn(W); W-- > 0; )
          v.isOdd() && v.iadd(O), v.iushrn(1);
      for (var vt = 0, xt = 1; (E.words[0] & xt) == 0 && vt < 26; ++vt, xt <<= 1)
        ;
      if (vt > 0)
        for (E.iushrn(vt); vt-- > 0; )
          k.isOdd() && k.iadd(O), k.iushrn(1);
      A.cmp(E) >= 0 ? (A.isub(E), v.isub(k)) : (E.isub(A), k.isub(v));
    }
    return (w = A.cmpn(1) === 0 ? v : k).cmpn(0) < 0 && w.iadd(m), w;
  }, h.prototype.gcd = function(m) {
    if (this.isZero())
      return m.abs();
    if (m.isZero())
      return this.abs();
    var A = this.clone(), E = m.clone();
    A.negative = 0, E.negative = 0;
    for (var w = 0; A.isEven() && E.isEven(); w++)
      A.iushrn(1), E.iushrn(1);
    for (; ; ) {
      for (; A.isEven(); )
        A.iushrn(1);
      for (; E.isEven(); )
        E.iushrn(1);
      var v = A.cmp(E);
      if (v < 0) {
        var k = A;
        A = E, E = k;
      } else if (v === 0 || E.cmpn(1) === 0)
        break;
      A.isub(E);
    }
    return E.iushln(w);
  }, h.prototype.invm = function(m) {
    return this.egcd(m).a.umod(m);
  }, h.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, h.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, h.prototype.andln = function(m) {
    return this.words[0] & m;
  }, h.prototype.bincn = function(m) {
    c(typeof m == "number");
    var A = m % 26, E = (m - A) / 26, w = 1 << A;
    if (this.length <= E)
      return this._expand(E + 1), this.words[E] |= w, this;
    for (var v = w, k = E; v !== 0 && k < this.length; k++) {
      var O = 0 | this.words[k];
      v = (O += v) >>> 26, O &= 67108863, this.words[k] = O;
    }
    return v !== 0 && (this.words[k] = v, this.length++), this;
  }, h.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, h.prototype.cmpn = function(m) {
    var A, E = m < 0;
    if (this.negative !== 0 && !E)
      return -1;
    if (this.negative === 0 && E)
      return 1;
    if (this.strip(), this.length > 1)
      A = 1;
    else {
      E && (m = -m), c(m <= 67108863, "Number is too big");
      var w = 0 | this.words[0];
      A = w === m ? 0 : w < m ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -A : A;
  }, h.prototype.cmp = function(m) {
    if (this.negative !== 0 && m.negative === 0)
      return -1;
    if (this.negative === 0 && m.negative !== 0)
      return 1;
    var A = this.ucmp(m);
    return this.negative !== 0 ? 0 | -A : A;
  }, h.prototype.ucmp = function(m) {
    if (this.length > m.length)
      return 1;
    if (this.length < m.length)
      return -1;
    for (var A = 0, E = this.length - 1; E >= 0; E--) {
      var w = 0 | this.words[E], v = 0 | m.words[E];
      if (w !== v) {
        w < v ? A = -1 : w > v && (A = 1);
        break;
      }
    }
    return A;
  }, h.prototype.gtn = function(m) {
    return this.cmpn(m) === 1;
  }, h.prototype.gt = function(m) {
    return this.cmp(m) === 1;
  }, h.prototype.gten = function(m) {
    return this.cmpn(m) >= 0;
  }, h.prototype.gte = function(m) {
    return this.cmp(m) >= 0;
  }, h.prototype.ltn = function(m) {
    return this.cmpn(m) === -1;
  }, h.prototype.lt = function(m) {
    return this.cmp(m) === -1;
  }, h.prototype.lten = function(m) {
    return this.cmpn(m) <= 0;
  }, h.prototype.lte = function(m) {
    return this.cmp(m) <= 0;
  }, h.prototype.eqn = function(m) {
    return this.cmpn(m) === 0;
  }, h.prototype.eq = function(m) {
    return this.cmp(m) === 0;
  }, h.red = function(m) {
    return new _t(m);
  }, h.prototype.toRed = function(m) {
    return c(!this.red, "Already a number in reduction context"), c(this.negative === 0, "red works only with positives"), m.convertTo(this)._forceRed(m);
  }, h.prototype.fromRed = function() {
    return c(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, h.prototype._forceRed = function(m) {
    return this.red = m, this;
  }, h.prototype.forceRed = function(m) {
    return c(!this.red, "Already a number in reduction context"), this._forceRed(m);
  }, h.prototype.redAdd = function(m) {
    return c(this.red, "redAdd works only with red numbers"), this.red.add(this, m);
  }, h.prototype.redIAdd = function(m) {
    return c(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, m);
  }, h.prototype.redSub = function(m) {
    return c(this.red, "redSub works only with red numbers"), this.red.sub(this, m);
  }, h.prototype.redISub = function(m) {
    return c(this.red, "redISub works only with red numbers"), this.red.isub(this, m);
  }, h.prototype.redShl = function(m) {
    return c(this.red, "redShl works only with red numbers"), this.red.shl(this, m);
  }, h.prototype.redMul = function(m) {
    return c(this.red, "redMul works only with red numbers"), this.red._verify2(this, m), this.red.mul(this, m);
  }, h.prototype.redIMul = function(m) {
    return c(this.red, "redMul works only with red numbers"), this.red._verify2(this, m), this.red.imul(this, m);
  }, h.prototype.redSqr = function() {
    return c(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, h.prototype.redISqr = function() {
    return c(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, h.prototype.redSqrt = function() {
    return c(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, h.prototype.redInvm = function() {
    return c(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, h.prototype.redNeg = function() {
    return c(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, h.prototype.redPow = function(m) {
    return c(this.red && !m.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, m);
  };
  var st = { k256: null, p224: null, p192: null, p25519: null };
  function ot(m, A) {
    this.name = m, this.p = new h(A, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function St() {
    ot.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function Ct() {
    ot.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function et() {
    ot.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function at() {
    ot.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function _t(m) {
    if (typeof m == "string") {
      var A = h._prime(m);
      this.m = A.p, this.prime = A;
    } else
      c(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
  }
  function Nt(m) {
    _t.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  ot.prototype._tmp = function() {
    var m = new h(null);
    return m.words = new Array(Math.ceil(this.n / 13)), m;
  }, ot.prototype.ireduce = function(m) {
    var A, E = m;
    do
      this.split(E, this.tmp), A = (E = (E = this.imulK(E)).iadd(this.tmp)).bitLength();
    while (A > this.n);
    var w = A < this.n ? -1 : E.ucmp(this.p);
    return w === 0 ? (E.words[0] = 0, E.length = 1) : w > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
  }, ot.prototype.split = function(m, A) {
    m.iushrn(this.n, 0, A);
  }, ot.prototype.imulK = function(m) {
    return m.imul(this.k);
  }, u(St, ot), St.prototype.split = function(m, A) {
    for (var E = 4194303, w = Math.min(m.length, 9), v = 0; v < w; v++)
      A.words[v] = m.words[v];
    if (A.length = w, m.length <= 9)
      return m.words[0] = 0, void (m.length = 1);
    var k = m.words[9];
    for (A.words[A.length++] = k & E, v = 10; v < m.length; v++) {
      var O = 0 | m.words[v];
      m.words[v - 10] = (O & E) << 4 | k >>> 22, k = O;
    }
    k >>>= 22, m.words[v - 10] = k, k === 0 && m.length > 10 ? m.length -= 10 : m.length -= 9;
  }, St.prototype.imulK = function(m) {
    m.words[m.length] = 0, m.words[m.length + 1] = 0, m.length += 2;
    for (var A = 0, E = 0; E < m.length; E++) {
      var w = 0 | m.words[E];
      A += 977 * w, m.words[E] = 67108863 & A, A = 64 * w + (A / 67108864 | 0);
    }
    return m.words[m.length - 1] === 0 && (m.length--, m.words[m.length - 1] === 0 && m.length--), m;
  }, u(Ct, ot), u(et, ot), u(at, ot), at.prototype.imulK = function(m) {
    for (var A = 0, E = 0; E < m.length; E++) {
      var w = 19 * (0 | m.words[E]) + A, v = 67108863 & w;
      w >>>= 26, m.words[E] = v, A = w;
    }
    return A !== 0 && (m.words[m.length++] = A), m;
  }, h._prime = function(m) {
    if (st[m])
      return st[m];
    var A;
    if (m === "k256")
      A = new St();
    else if (m === "p224")
      A = new Ct();
    else if (m === "p192")
      A = new et();
    else {
      if (m !== "p25519")
        throw new Error("Unknown prime " + m);
      A = new at();
    }
    return st[m] = A, A;
  }, _t.prototype._verify1 = function(m) {
    c(m.negative === 0, "red works only with positives"), c(m.red, "red works only with red numbers");
  }, _t.prototype._verify2 = function(m, A) {
    c((m.negative | A.negative) == 0, "red works only with positives"), c(m.red && m.red === A.red, "red works only with red numbers");
  }, _t.prototype.imod = function(m) {
    return this.prime ? this.prime.ireduce(m)._forceRed(this) : m.umod(this.m)._forceRed(this);
  }, _t.prototype.neg = function(m) {
    return m.isZero() ? m.clone() : this.m.sub(m)._forceRed(this);
  }, _t.prototype.add = function(m, A) {
    this._verify2(m, A);
    var E = m.add(A);
    return E.cmp(this.m) >= 0 && E.isub(this.m), E._forceRed(this);
  }, _t.prototype.iadd = function(m, A) {
    this._verify2(m, A);
    var E = m.iadd(A);
    return E.cmp(this.m) >= 0 && E.isub(this.m), E;
  }, _t.prototype.sub = function(m, A) {
    this._verify2(m, A);
    var E = m.sub(A);
    return E.cmpn(0) < 0 && E.iadd(this.m), E._forceRed(this);
  }, _t.prototype.isub = function(m, A) {
    this._verify2(m, A);
    var E = m.isub(A);
    return E.cmpn(0) < 0 && E.iadd(this.m), E;
  }, _t.prototype.shl = function(m, A) {
    return this._verify1(m), this.imod(m.ushln(A));
  }, _t.prototype.imul = function(m, A) {
    return this._verify2(m, A), this.imod(m.imul(A));
  }, _t.prototype.mul = function(m, A) {
    return this._verify2(m, A), this.imod(m.mul(A));
  }, _t.prototype.isqr = function(m) {
    return this.imul(m, m.clone());
  }, _t.prototype.sqr = function(m) {
    return this.mul(m, m);
  }, _t.prototype.sqrt = function(m) {
    if (m.isZero())
      return m.clone();
    var A = this.m.andln(3);
    if (c(A % 2 == 1), A === 3) {
      var E = this.m.add(new h(1)).iushrn(2);
      return this.pow(m, E);
    }
    for (var w = this.m.subn(1), v = 0; !w.isZero() && w.andln(1) === 0; )
      v++, w.iushrn(1);
    c(!w.isZero());
    var k = new h(1).toRed(this), O = k.redNeg(), W = this.m.subn(1).iushrn(1), it = this.m.bitLength();
    for (it = new h(2 * it * it).toRed(this); this.pow(it, W).cmp(O) !== 0; )
      it.redIAdd(O);
    for (var vt = this.pow(it, w), xt = this.pow(m, w.addn(1).iushrn(1)), It = this.pow(m, w), Wt = v; It.cmp(k) !== 0; ) {
      for (var Ut = It, zt = 0; Ut.cmp(k) !== 0; zt++)
        Ut = Ut.redSqr();
      c(zt < Wt);
      var Jt = this.pow(vt, new h(1).iushln(Wt - zt - 1));
      xt = xt.redMul(Jt), vt = Jt.redSqr(), It = It.redMul(vt), Wt = zt;
    }
    return xt;
  }, _t.prototype.invm = function(m) {
    var A = m._invmp(this.m);
    return A.negative !== 0 ? (A.negative = 0, this.imod(A).redNeg()) : this.imod(A);
  }, _t.prototype.pow = function(m, A) {
    if (A.isZero())
      return new h(1).toRed(this);
    if (A.cmpn(1) === 0)
      return m.clone();
    var E = new Array(16);
    E[0] = new h(1).toRed(this), E[1] = m;
    for (var w = 2; w < E.length; w++)
      E[w] = this.mul(E[w - 1], m);
    var v = E[0], k = 0, O = 0, W = A.bitLength() % 26;
    for (W === 0 && (W = 26), w = A.length - 1; w >= 0; w--) {
      for (var it = A.words[w], vt = W - 1; vt >= 0; vt--) {
        var xt = it >> vt & 1;
        v !== E[0] && (v = this.sqr(v)), xt !== 0 || k !== 0 ? (k <<= 1, k |= xt, (++O == 4 || w === 0 && vt === 0) && (v = this.mul(v, E[k]), O = 0, k = 0)) : O = 0;
      }
      W = 26;
    }
    return v;
  }, _t.prototype.convertTo = function(m) {
    var A = m.umod(this.m);
    return A === m ? A.clone() : A;
  }, _t.prototype.convertFrom = function(m) {
    var A = m.clone();
    return A.red = null, A;
  }, h.mont = function(m) {
    return new Nt(m);
  }, u(Nt, _t), Nt.prototype.convertTo = function(m) {
    return this.imod(m.ushln(this.shift));
  }, Nt.prototype.convertFrom = function(m) {
    var A = this.imod(m.mul(this.rinv));
    return A.red = null, A;
  }, Nt.prototype.imul = function(m, A) {
    if (m.isZero() || A.isZero())
      return m.words[0] = 0, m.length = 1, m;
    var E = m.imul(A), w = E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = E.isub(w).iushrn(this.shift), k = v;
    return v.cmp(this.m) >= 0 ? k = v.isub(this.m) : v.cmpn(0) < 0 && (k = v.iadd(this.m)), k._forceRed(this);
  }, Nt.prototype.mul = function(m, A) {
    if (m.isZero() || A.isZero())
      return new h(0)._forceRed(this);
    var E = m.mul(A), w = E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = E.isub(w).iushrn(this.shift), k = v;
    return v.cmp(this.m) >= 0 ? k = v.isub(this.m) : v.cmpn(0) < 0 && (k = v.iadd(this.m)), k._forceRed(this);
  }, Nt.prototype.invm = function(m) {
    return this.imod(m._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var utils$l = {};
(function(o) {
  var n = utils$l;
  function c(h) {
    return h.length === 1 ? "0" + h : h;
  }
  function u(h) {
    for (var g = "", y = 0; y < h.length; y++)
      g += c(h[y].toString(16));
    return g;
  }
  n.toArray = function(h, g) {
    if (Array.isArray(h))
      return h.slice();
    if (!h)
      return [];
    var y = [];
    if (typeof h != "string") {
      for (var $ = 0; $ < h.length; $++)
        y[$] = 0 | h[$];
      return y;
    }
    if (g === "hex")
      for ((h = h.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (h = "0" + h), $ = 0; $ < h.length; $ += 2)
        y.push(parseInt(h[$] + h[$ + 1], 16));
    else
      for ($ = 0; $ < h.length; $++) {
        var I = h.charCodeAt($), P = I >> 8, L = 255 & I;
        P ? y.push(P, L) : y.push(L);
      }
    return y;
  }, n.zero2 = c, n.toHex = u, n.encode = function(h, g) {
    return g === "hex" ? u(h) : h;
  };
})(), function(o) {
  var n = utils$m, c = bn$2.exports, u = minimalisticAssert, h = utils$l;
  n.assert = u, n.toArray = h.toArray, n.zero2 = h.zero2, n.toHex = h.toHex, n.encode = h.encode, n.getNAF = function(g, y, $) {
    var I = new Array(Math.max(g.bitLength(), $) + 1);
    I.fill(0);
    for (var P = 1 << y + 1, L = g.clone(), q = 0; q < I.length; q++) {
      var N, X = L.andln(P - 1);
      L.isOdd() ? (N = X > (P >> 1) - 1 ? (P >> 1) - X : X, L.isubn(N)) : N = 0, I[q] = N, L.iushrn(1);
    }
    return I;
  }, n.getJSF = function(g, y) {
    var $ = [[], []];
    g = g.clone(), y = y.clone();
    for (var I, P = 0, L = 0; g.cmpn(-P) > 0 || y.cmpn(-L) > 0; ) {
      var q, N, X = g.andln(3) + P & 3, rt = y.andln(3) + L & 3;
      X === 3 && (X = -1), rt === 3 && (rt = -1), q = (1 & X) == 0 ? 0 : (I = g.andln(7) + P & 7) != 3 && I !== 5 || rt !== 2 ? X : -X, $[0].push(q), N = (1 & rt) == 0 ? 0 : (I = y.andln(7) + L & 7) != 3 && I !== 5 || X !== 2 ? rt : -rt, $[1].push(N), 2 * P === q + 1 && (P = 1 - P), 2 * L === N + 1 && (L = 1 - L), g.iushrn(1), y.iushrn(1);
    }
    return $;
  }, n.cachedProperty = function(g, y, $) {
    var I = "_" + y;
    g.prototype[y] = function() {
      return this[I] !== void 0 ? this[I] : this[I] = $.call(this);
    };
  }, n.parseBytes = function(g) {
    return typeof g == "string" ? n.toArray(g, "hex") : g;
  }, n.intFromLE = function(g) {
    return new c(g, "hex", "le");
  };
}();
var brorand = { exports: {} }, r$1;
function Rand(o) {
  this.rand = o;
}
if (brorand.exports = function(o) {
  return r$1 || (r$1 = new Rand(null)), r$1.generate(o);
}, brorand.exports.Rand = Rand, Rand.prototype.generate = function(o) {
  return this._rand(o);
}, Rand.prototype._rand = function(o) {
  if (this.rand.getBytes)
    return this.rand.getBytes(o);
  for (var n = new Uint8Array(o), c = 0; c < n.length; c++)
    n[c] = this.rand.getByte();
  return n;
}, typeof self == "object")
  self.crypto && self.crypto.getRandomValues ? Rand.prototype._rand = function(o) {
    var n = new Uint8Array(o);
    return self.crypto.getRandomValues(n), n;
  } : self.msCrypto && self.msCrypto.getRandomValues ? Rand.prototype._rand = function(o) {
    var n = new Uint8Array(o);
    return self.msCrypto.getRandomValues(n), n;
  } : typeof window == "object" && (Rand.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
else
  try {
    var crypto$1 = require$$2$1;
    if (typeof crypto$1.randomBytes != "function")
      throw new Error("Not supported");
    Rand.prototype._rand = function(o) {
      return crypto$1.randomBytes(o);
    };
  } catch (o) {
  }
var curve = {}, BN$8 = bn$2.exports, utils$k = utils$m, getNAF = utils$k.getNAF, getJSF = utils$k.getJSF, assert$e = utils$k.assert;
function BaseCurve(o, n) {
  this.type = o, this.p = new BN$8(n.p, 16), this.red = n.prime ? BN$8.red(n.prime) : BN$8.mont(this.p), this.zero = new BN$8(0).toRed(this.red), this.one = new BN$8(1).toRed(this.red), this.two = new BN$8(2).toRed(this.red), this.n = n.n && new BN$8(n.n, 16), this.g = n.g && this.pointFromJSON(n.g, n.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var c = this.n && this.p.div(this.n);
  !c || c.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base = BaseCurve;
function BasePoint(o, n) {
  this.curve = o, this.type = n, this.precomputed = null;
}
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
}, BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
}, BaseCurve.prototype._fixedNafMul = function(o, n) {
  assert$e(o.precomputed);
  var c = o._getDoubles(), u = getNAF(n, 1, this._bitLength), h = (1 << c.step + 1) - (c.step % 2 == 0 ? 2 : 1);
  h /= 3;
  var g, y, $ = [];
  for (g = 0; g < u.length; g += c.step) {
    y = 0;
    for (var I = g + c.step - 1; I >= g; I--)
      y = (y << 1) + u[I];
    $.push(y);
  }
  for (var P = this.jpoint(null, null, null), L = this.jpoint(null, null, null), q = h; q > 0; q--) {
    for (g = 0; g < $.length; g++)
      (y = $[g]) === q ? L = L.mixedAdd(c.points[g]) : y === -q && (L = L.mixedAdd(c.points[g].neg()));
    P = P.add(L);
  }
  return P.toP();
}, BaseCurve.prototype._wnafMul = function(o, n) {
  var c = 4, u = o._getNAFPoints(c);
  c = u.wnd;
  for (var h = u.points, g = getNAF(n, c, this._bitLength), y = this.jpoint(null, null, null), $ = g.length - 1; $ >= 0; $--) {
    for (var I = 0; $ >= 0 && g[$] === 0; $--)
      I++;
    if ($ >= 0 && I++, y = y.dblp(I), $ < 0)
      break;
    var P = g[$];
    assert$e(P !== 0), y = o.type === "affine" ? P > 0 ? y.mixedAdd(h[P - 1 >> 1]) : y.mixedAdd(h[-P - 1 >> 1].neg()) : P > 0 ? y.add(h[P - 1 >> 1]) : y.add(h[-P - 1 >> 1].neg());
  }
  return o.type === "affine" ? y.toP() : y;
}, BaseCurve.prototype._wnafMulAdd = function(o, n, c, u, h) {
  var g, y, $, I = this._wnafT1, P = this._wnafT2, L = this._wnafT3, q = 0;
  for (g = 0; g < u; g++) {
    var N = ($ = n[g])._getNAFPoints(o);
    I[g] = N.wnd, P[g] = N.points;
  }
  for (g = u - 1; g >= 1; g -= 2) {
    var X = g - 1, rt = g;
    if (I[X] === 1 && I[rt] === 1) {
      var nt = [n[X], null, null, n[rt]];
      n[X].y.cmp(n[rt].y) === 0 ? (nt[1] = n[X].add(n[rt]), nt[2] = n[X].toJ().mixedAdd(n[rt].neg())) : n[X].y.cmp(n[rt].y.redNeg()) === 0 ? (nt[1] = n[X].toJ().mixedAdd(n[rt]), nt[2] = n[X].add(n[rt].neg())) : (nt[1] = n[X].toJ().mixedAdd(n[rt]), nt[2] = n[X].toJ().mixedAdd(n[rt].neg()));
      var st = [-3, -1, -5, -7, 0, 7, 5, 1, 3], ot = getJSF(c[X], c[rt]);
      for (q = Math.max(ot[0].length, q), L[X] = new Array(q), L[rt] = new Array(q), y = 0; y < q; y++) {
        var St = 0 | ot[0][y], Ct = 0 | ot[1][y];
        L[X][y] = st[3 * (St + 1) + (Ct + 1)], L[rt][y] = 0, P[X] = nt;
      }
    } else
      L[X] = getNAF(c[X], I[X], this._bitLength), L[rt] = getNAF(c[rt], I[rt], this._bitLength), q = Math.max(L[X].length, q), q = Math.max(L[rt].length, q);
  }
  var et = this.jpoint(null, null, null), at = this._wnafT4;
  for (g = q; g >= 0; g--) {
    for (var _t = 0; g >= 0; ) {
      var Nt = !0;
      for (y = 0; y < u; y++)
        at[y] = 0 | L[y][g], at[y] !== 0 && (Nt = !1);
      if (!Nt)
        break;
      _t++, g--;
    }
    if (g >= 0 && _t++, et = et.dblp(_t), g < 0)
      break;
    for (y = 0; y < u; y++) {
      var m = at[y];
      m !== 0 && (m > 0 ? $ = P[y][m - 1 >> 1] : m < 0 && ($ = P[y][-m - 1 >> 1].neg()), et = $.type === "affine" ? et.mixedAdd($) : et.add($));
    }
  }
  for (g = 0; g < u; g++)
    P[g] = null;
  return h ? et : et.toP();
}, BaseCurve.BasePoint = BasePoint, BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
}, BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
}, BaseCurve.prototype.decodePoint = function(o, n) {
  o = utils$k.toArray(o, n);
  var c = this.p.byteLength();
  if ((o[0] === 4 || o[0] === 6 || o[0] === 7) && o.length - 1 == 2 * c)
    return o[0] === 6 ? assert$e(o[o.length - 1] % 2 == 0) : o[0] === 7 && assert$e(o[o.length - 1] % 2 == 1), this.point(o.slice(1, 1 + c), o.slice(1 + c, 1 + 2 * c));
  if ((o[0] === 2 || o[0] === 3) && o.length - 1 === c)
    return this.pointFromX(o.slice(1, 1 + c), o[0] === 3);
  throw new Error("Unknown point format");
}, BasePoint.prototype.encodeCompressed = function(o) {
  return this.encode(o, !0);
}, BasePoint.prototype._encode = function(o) {
  var n = this.curve.p.byteLength(), c = this.getX().toArray("be", n);
  return o ? [this.getY().isEven() ? 2 : 3].concat(c) : [4].concat(c, this.getY().toArray("be", n));
}, BasePoint.prototype.encode = function(o, n) {
  return utils$k.encode(this._encode(n), o);
}, BasePoint.prototype.precompute = function(o) {
  if (this.precomputed)
    return this;
  var n = { doubles: null, naf: null, beta: null };
  return n.naf = this._getNAFPoints(8), n.doubles = this._getDoubles(4, o), n.beta = this._getBeta(), this.precomputed = n, this;
}, BasePoint.prototype._hasDoubles = function(o) {
  if (!this.precomputed)
    return !1;
  var n = this.precomputed.doubles;
  return !!n && n.points.length >= Math.ceil((o.bitLength() + 1) / n.step);
}, BasePoint.prototype._getDoubles = function(o, n) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var c = [this], u = this, h = 0; h < n; h += o) {
    for (var g = 0; g < o; g++)
      u = u.dbl();
    c.push(u);
  }
  return { step: o, points: c };
}, BasePoint.prototype._getNAFPoints = function(o) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var n = [this], c = (1 << o) - 1, u = c === 1 ? null : this.dbl(), h = 1; h < c; h++)
    n[h] = n[h - 1].add(u);
  return { wnd: o, points: n };
}, BasePoint.prototype._getBeta = function() {
  return null;
}, BasePoint.prototype.dblp = function(o) {
  for (var n = this, c = 0; c < o; c++)
    n = n.dbl();
  return n;
};
var utils$j = utils$m, BN$7 = bn$2.exports, inherits$3 = requireInherits_browser(), Base$2 = base, assert$d = utils$j.assert;
function ShortCurve(o) {
  Base$2.call(this, "short", o), this.a = new BN$7(o.a, 16).toRed(this.red), this.b = new BN$7(o.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(o), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$3(ShortCurve, Base$2);
var short = ShortCurve;
function Point$2(o, n, c, u) {
  Base$2.BasePoint.call(this, o, "affine"), n === null && c === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$7(n, 16), this.y = new BN$7(c, 16), u && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
function JPoint(o, n, c, u) {
  Base$2.BasePoint.call(this, o, "jacobian"), n === null && c === null && u === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$7(0)) : (this.x = new BN$7(n, 16), this.y = new BN$7(c, 16), this.z = new BN$7(u, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
ShortCurve.prototype._getEndomorphism = function(o) {
  if (this.zeroA && this.g && this.n && this.p.modn(3) === 1) {
    var n, c;
    if (o.beta)
      n = new BN$7(o.beta, 16).toRed(this.red);
    else {
      var u = this._getEndoRoots(this.p);
      n = (n = u[0].cmp(u[1]) < 0 ? u[0] : u[1]).toRed(this.red);
    }
    if (o.lambda)
      c = new BN$7(o.lambda, 16);
    else {
      var h = this._getEndoRoots(this.n);
      this.g.mul(h[0]).x.cmp(this.g.x.redMul(n)) === 0 ? c = h[0] : (c = h[1], assert$d(this.g.mul(c).x.cmp(this.g.x.redMul(n)) === 0));
    }
    return { beta: n, lambda: c, basis: o.basis ? o.basis.map(function(g) {
      return { a: new BN$7(g.a, 16), b: new BN$7(g.b, 16) };
    }) : this._getEndoBasis(c) };
  }
}, ShortCurve.prototype._getEndoRoots = function(o) {
  var n = o === this.p ? this.red : BN$7.mont(o), c = new BN$7(2).toRed(n).redInvm(), u = c.redNeg(), h = new BN$7(3).toRed(n).redNeg().redSqrt().redMul(c);
  return [u.redAdd(h).fromRed(), u.redSub(h).fromRed()];
}, ShortCurve.prototype._getEndoBasis = function(o) {
  for (var n, c, u, h, g, y, $, I, P, L = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), q = o, N = this.n.clone(), X = new BN$7(1), rt = new BN$7(0), nt = new BN$7(0), st = new BN$7(1), ot = 0; q.cmpn(0) !== 0; ) {
    var St = N.div(q);
    I = N.sub(St.mul(q)), P = nt.sub(St.mul(X));
    var Ct = st.sub(St.mul(rt));
    if (!u && I.cmp(L) < 0)
      n = $.neg(), c = X, u = I.neg(), h = P;
    else if (u && ++ot == 2)
      break;
    $ = I, N = q, q = I, nt = X, X = P, st = rt, rt = Ct;
  }
  g = I.neg(), y = P;
  var et = u.sqr().add(h.sqr());
  return g.sqr().add(y.sqr()).cmp(et) >= 0 && (g = n, y = c), u.negative && (u = u.neg(), h = h.neg()), g.negative && (g = g.neg(), y = y.neg()), [{ a: u, b: h }, { a: g, b: y }];
}, ShortCurve.prototype._endoSplit = function(o) {
  var n = this.endo.basis, c = n[0], u = n[1], h = u.b.mul(o).divRound(this.n), g = c.b.neg().mul(o).divRound(this.n), y = h.mul(c.a), $ = g.mul(u.a), I = h.mul(c.b), P = g.mul(u.b);
  return { k1: o.sub(y).sub($), k2: I.add(P).neg() };
}, ShortCurve.prototype.pointFromX = function(o, n) {
  (o = new BN$7(o, 16)).red || (o = o.toRed(this.red));
  var c = o.redSqr().redMul(o).redIAdd(o.redMul(this.a)).redIAdd(this.b), u = c.redSqrt();
  if (u.redSqr().redSub(c).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var h = u.fromRed().isOdd();
  return (n && !h || !n && h) && (u = u.redNeg()), this.point(o, u);
}, ShortCurve.prototype.validate = function(o) {
  if (o.inf)
    return !0;
  var n = o.x, c = o.y, u = this.a.redMul(n), h = n.redSqr().redMul(n).redIAdd(u).redIAdd(this.b);
  return c.redSqr().redISub(h).cmpn(0) === 0;
}, ShortCurve.prototype._endoWnafMulAdd = function(o, n, c) {
  for (var u = this._endoWnafT1, h = this._endoWnafT2, g = 0; g < o.length; g++) {
    var y = this._endoSplit(n[g]), $ = o[g], I = $._getBeta();
    y.k1.negative && (y.k1.ineg(), $ = $.neg(!0)), y.k2.negative && (y.k2.ineg(), I = I.neg(!0)), u[2 * g] = $, u[2 * g + 1] = I, h[2 * g] = y.k1, h[2 * g + 1] = y.k2;
  }
  for (var P = this._wnafMulAdd(1, u, h, 2 * g, c), L = 0; L < 2 * g; L++)
    u[L] = null, h[L] = null;
  return P;
}, inherits$3(Point$2, Base$2.BasePoint), ShortCurve.prototype.point = function(o, n, c) {
  return new Point$2(this, o, n, c);
}, ShortCurve.prototype.pointFromJSON = function(o, n) {
  return Point$2.fromJSON(this, o, n);
}, Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var o = this.precomputed;
    if (o && o.beta)
      return o.beta;
    var n = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (o) {
      var c = this.curve, u = function(h) {
        return c.point(h.x.redMul(c.endo.beta), h.y);
      };
      o.beta = n, n.precomputed = { beta: null, naf: o.naf && { wnd: o.naf.wnd, points: o.naf.points.map(u) }, doubles: o.doubles && { step: o.doubles.step, points: o.doubles.points.map(u) } };
    }
    return n;
  }
}, Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
}, Point$2.fromJSON = function(o, n, c) {
  typeof n == "string" && (n = JSON.parse(n));
  var u = o.point(n[0], n[1], c);
  if (!n[2])
    return u;
  function h(y) {
    return o.point(y[0], y[1], c);
  }
  var g = n[2];
  return u.precomputed = { beta: null, doubles: g.doubles && { step: g.doubles.step, points: [u].concat(g.doubles.points.map(h)) }, naf: g.naf && { wnd: g.naf.wnd, points: [u].concat(g.naf.points.map(h)) } }, u;
}, Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
}, Point$2.prototype.isInfinity = function() {
  return this.inf;
}, Point$2.prototype.add = function(o) {
  if (this.inf)
    return o;
  if (o.inf)
    return this;
  if (this.eq(o))
    return this.dbl();
  if (this.neg().eq(o))
    return this.curve.point(null, null);
  if (this.x.cmp(o.x) === 0)
    return this.curve.point(null, null);
  var n = this.y.redSub(o.y);
  n.cmpn(0) !== 0 && (n = n.redMul(this.x.redSub(o.x).redInvm()));
  var c = n.redSqr().redISub(this.x).redISub(o.x), u = n.redMul(this.x.redSub(c)).redISub(this.y);
  return this.curve.point(c, u);
}, Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var o = this.y.redAdd(this.y);
  if (o.cmpn(0) === 0)
    return this.curve.point(null, null);
  var n = this.curve.a, c = this.x.redSqr(), u = o.redInvm(), h = c.redAdd(c).redIAdd(c).redIAdd(n).redMul(u), g = h.redSqr().redISub(this.x.redAdd(this.x)), y = h.redMul(this.x.redSub(g)).redISub(this.y);
  return this.curve.point(g, y);
}, Point$2.prototype.getX = function() {
  return this.x.fromRed();
}, Point$2.prototype.getY = function() {
  return this.y.fromRed();
}, Point$2.prototype.mul = function(o) {
  return o = new BN$7(o, 16), this.isInfinity() ? this : this._hasDoubles(o) ? this.curve._fixedNafMul(this, o) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [o]) : this.curve._wnafMul(this, o);
}, Point$2.prototype.mulAdd = function(o, n, c) {
  var u = [this, n], h = [o, c];
  return this.curve.endo ? this.curve._endoWnafMulAdd(u, h) : this.curve._wnafMulAdd(1, u, h, 2);
}, Point$2.prototype.jmulAdd = function(o, n, c) {
  var u = [this, n], h = [o, c];
  return this.curve.endo ? this.curve._endoWnafMulAdd(u, h, !0) : this.curve._wnafMulAdd(1, u, h, 2, !0);
}, Point$2.prototype.eq = function(o) {
  return this === o || this.inf === o.inf && (this.inf || this.x.cmp(o.x) === 0 && this.y.cmp(o.y) === 0);
}, Point$2.prototype.neg = function(o) {
  if (this.inf)
    return this;
  var n = this.curve.point(this.x, this.y.redNeg());
  if (o && this.precomputed) {
    var c = this.precomputed, u = function(h) {
      return h.neg();
    };
    n.precomputed = { naf: c.naf && { wnd: c.naf.wnd, points: c.naf.points.map(u) }, doubles: c.doubles && { step: c.doubles.step, points: c.doubles.points.map(u) } };
  }
  return n;
}, Point$2.prototype.toJ = function() {
  return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
}, inherits$3(JPoint, Base$2.BasePoint), ShortCurve.prototype.jpoint = function(o, n, c) {
  return new JPoint(this, o, n, c);
}, JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var o = this.z.redInvm(), n = o.redSqr(), c = this.x.redMul(n), u = this.y.redMul(n).redMul(o);
  return this.curve.point(c, u);
}, JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
}, JPoint.prototype.add = function(o) {
  if (this.isInfinity())
    return o;
  if (o.isInfinity())
    return this;
  var n = o.z.redSqr(), c = this.z.redSqr(), u = this.x.redMul(n), h = o.x.redMul(c), g = this.y.redMul(n.redMul(o.z)), y = o.y.redMul(c.redMul(this.z)), $ = u.redSub(h), I = g.redSub(y);
  if ($.cmpn(0) === 0)
    return I.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var P = $.redSqr(), L = P.redMul($), q = u.redMul(P), N = I.redSqr().redIAdd(L).redISub(q).redISub(q), X = I.redMul(q.redISub(N)).redISub(g.redMul(L)), rt = this.z.redMul(o.z).redMul($);
  return this.curve.jpoint(N, X, rt);
}, JPoint.prototype.mixedAdd = function(o) {
  if (this.isInfinity())
    return o.toJ();
  if (o.isInfinity())
    return this;
  var n = this.z.redSqr(), c = this.x, u = o.x.redMul(n), h = this.y, g = o.y.redMul(n).redMul(this.z), y = c.redSub(u), $ = h.redSub(g);
  if (y.cmpn(0) === 0)
    return $.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var I = y.redSqr(), P = I.redMul(y), L = c.redMul(I), q = $.redSqr().redIAdd(P).redISub(L).redISub(L), N = $.redMul(L.redISub(q)).redISub(h.redMul(P)), X = this.z.redMul(y);
  return this.curve.jpoint(q, N, X);
}, JPoint.prototype.dblp = function(o) {
  if (o === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!o)
    return this.dbl();
  var n;
  if (this.curve.zeroA || this.curve.threeA) {
    var c = this;
    for (n = 0; n < o; n++)
      c = c.dbl();
    return c;
  }
  var u = this.curve.a, h = this.curve.tinv, g = this.x, y = this.y, $ = this.z, I = $.redSqr().redSqr(), P = y.redAdd(y);
  for (n = 0; n < o; n++) {
    var L = g.redSqr(), q = P.redSqr(), N = q.redSqr(), X = L.redAdd(L).redIAdd(L).redIAdd(u.redMul(I)), rt = g.redMul(q), nt = X.redSqr().redISub(rt.redAdd(rt)), st = rt.redISub(nt), ot = X.redMul(st);
    ot = ot.redIAdd(ot).redISub(N);
    var St = P.redMul($);
    n + 1 < o && (I = I.redMul(N)), g = nt, $ = St, P = ot;
  }
  return this.curve.jpoint(g, P.redMul(h), $);
}, JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
}, JPoint.prototype._zeroDbl = function() {
  var o, n, c;
  if (this.zOne) {
    var u = this.x.redSqr(), h = this.y.redSqr(), g = h.redSqr(), y = this.x.redAdd(h).redSqr().redISub(u).redISub(g);
    y = y.redIAdd(y);
    var $ = u.redAdd(u).redIAdd(u), I = $.redSqr().redISub(y).redISub(y), P = g.redIAdd(g);
    P = (P = P.redIAdd(P)).redIAdd(P), o = I, n = $.redMul(y.redISub(I)).redISub(P), c = this.y.redAdd(this.y);
  } else {
    var L = this.x.redSqr(), q = this.y.redSqr(), N = q.redSqr(), X = this.x.redAdd(q).redSqr().redISub(L).redISub(N);
    X = X.redIAdd(X);
    var rt = L.redAdd(L).redIAdd(L), nt = rt.redSqr(), st = N.redIAdd(N);
    st = (st = st.redIAdd(st)).redIAdd(st), o = nt.redISub(X).redISub(X), n = rt.redMul(X.redISub(o)).redISub(st), c = (c = this.y.redMul(this.z)).redIAdd(c);
  }
  return this.curve.jpoint(o, n, c);
}, JPoint.prototype._threeDbl = function() {
  var o, n, c;
  if (this.zOne) {
    var u = this.x.redSqr(), h = this.y.redSqr(), g = h.redSqr(), y = this.x.redAdd(h).redSqr().redISub(u).redISub(g);
    y = y.redIAdd(y);
    var $ = u.redAdd(u).redIAdd(u).redIAdd(this.curve.a), I = $.redSqr().redISub(y).redISub(y);
    o = I;
    var P = g.redIAdd(g);
    P = (P = P.redIAdd(P)).redIAdd(P), n = $.redMul(y.redISub(I)).redISub(P), c = this.y.redAdd(this.y);
  } else {
    var L = this.z.redSqr(), q = this.y.redSqr(), N = this.x.redMul(q), X = this.x.redSub(L).redMul(this.x.redAdd(L));
    X = X.redAdd(X).redIAdd(X);
    var rt = N.redIAdd(N), nt = (rt = rt.redIAdd(rt)).redAdd(rt);
    o = X.redSqr().redISub(nt), c = this.y.redAdd(this.z).redSqr().redISub(q).redISub(L);
    var st = q.redSqr();
    st = (st = (st = st.redIAdd(st)).redIAdd(st)).redIAdd(st), n = X.redMul(rt.redISub(o)).redISub(st);
  }
  return this.curve.jpoint(o, n, c);
}, JPoint.prototype._dbl = function() {
  var o = this.curve.a, n = this.x, c = this.y, u = this.z, h = u.redSqr().redSqr(), g = n.redSqr(), y = c.redSqr(), $ = g.redAdd(g).redIAdd(g).redIAdd(o.redMul(h)), I = n.redAdd(n), P = (I = I.redIAdd(I)).redMul(y), L = $.redSqr().redISub(P.redAdd(P)), q = P.redISub(L), N = y.redSqr();
  N = (N = (N = N.redIAdd(N)).redIAdd(N)).redIAdd(N);
  var X = $.redMul(q).redISub(N), rt = c.redAdd(c).redMul(u);
  return this.curve.jpoint(L, X, rt);
}, JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var o = this.x.redSqr(), n = this.y.redSqr(), c = this.z.redSqr(), u = n.redSqr(), h = o.redAdd(o).redIAdd(o), g = h.redSqr(), y = this.x.redAdd(n).redSqr().redISub(o).redISub(u), $ = (y = (y = (y = y.redIAdd(y)).redAdd(y).redIAdd(y)).redISub(g)).redSqr(), I = u.redIAdd(u);
  I = (I = (I = I.redIAdd(I)).redIAdd(I)).redIAdd(I);
  var P = h.redIAdd(y).redSqr().redISub(g).redISub($).redISub(I), L = n.redMul(P);
  L = (L = L.redIAdd(L)).redIAdd(L);
  var q = this.x.redMul($).redISub(L);
  q = (q = q.redIAdd(q)).redIAdd(q);
  var N = this.y.redMul(P.redMul(I.redISub(P)).redISub(y.redMul($)));
  N = (N = (N = N.redIAdd(N)).redIAdd(N)).redIAdd(N);
  var X = this.z.redAdd(y).redSqr().redISub(c).redISub($);
  return this.curve.jpoint(q, N, X);
}, JPoint.prototype.mul = function(o, n) {
  return o = new BN$7(o, n), this.curve._wnafMul(this, o);
}, JPoint.prototype.eq = function(o) {
  if (o.type === "affine")
    return this.eq(o.toJ());
  if (this === o)
    return !0;
  var n = this.z.redSqr(), c = o.z.redSqr();
  if (this.x.redMul(c).redISub(o.x.redMul(n)).cmpn(0) !== 0)
    return !1;
  var u = n.redMul(this.z), h = c.redMul(o.z);
  return this.y.redMul(h).redISub(o.y.redMul(u)).cmpn(0) === 0;
}, JPoint.prototype.eqXToP = function(o) {
  var n = this.z.redSqr(), c = o.toRed(this.curve.red).redMul(n);
  if (this.x.cmp(c) === 0)
    return !0;
  for (var u = o.clone(), h = this.curve.redN.redMul(n); ; ) {
    if (u.iadd(this.curve.n), u.cmp(this.curve.p) >= 0)
      return !1;
    if (c.redIAdd(h), this.x.cmp(c) === 0)
      return !0;
  }
}, JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
}, JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$6 = bn$2.exports, inherits$2 = requireInherits_browser(), Base$1 = base, utils$i = utils$m;
function MontCurve(o) {
  Base$1.call(this, "mont", o), this.a = new BN$6(o.a, 16).toRed(this.red), this.b = new BN$6(o.b, 16).toRed(this.red), this.i4 = new BN$6(4).toRed(this.red).redInvm(), this.two = new BN$6(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$2(MontCurve, Base$1);
var mont = MontCurve;
function Point$1(o, n, c) {
  Base$1.BasePoint.call(this, o, "projective"), n === null && c === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$6(n, 16), this.z = new BN$6(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
MontCurve.prototype.validate = function(o) {
  var n = o.normalize().x, c = n.redSqr(), u = c.redMul(n).redAdd(c.redMul(this.a)).redAdd(n);
  return u.redSqrt().redSqr().cmp(u) === 0;
}, inherits$2(Point$1, Base$1.BasePoint), MontCurve.prototype.decodePoint = function(o, n) {
  return this.point(utils$i.toArray(o, n), 1);
}, MontCurve.prototype.point = function(o, n) {
  return new Point$1(this, o, n);
}, MontCurve.prototype.pointFromJSON = function(o) {
  return Point$1.fromJSON(this, o);
}, Point$1.prototype.precompute = function() {
}, Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
}, Point$1.fromJSON = function(o, n) {
  return new Point$1(o, n[0], n[1] || o.one);
}, Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
}, Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
}, Point$1.prototype.dbl = function() {
  var o = this.x.redAdd(this.z).redSqr(), n = this.x.redSub(this.z).redSqr(), c = o.redSub(n), u = o.redMul(n), h = c.redMul(n.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(u, h);
}, Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
}, Point$1.prototype.diffAdd = function(o, n) {
  var c = this.x.redAdd(this.z), u = this.x.redSub(this.z), h = o.x.redAdd(o.z), g = o.x.redSub(o.z).redMul(c), y = h.redMul(u), $ = n.z.redMul(g.redAdd(y).redSqr()), I = n.x.redMul(g.redISub(y).redSqr());
  return this.curve.point($, I);
}, Point$1.prototype.mul = function(o) {
  for (var n = o.clone(), c = this, u = this.curve.point(null, null), h = []; n.cmpn(0) !== 0; n.iushrn(1))
    h.push(n.andln(1));
  for (var g = h.length - 1; g >= 0; g--)
    h[g] === 0 ? (c = c.diffAdd(u, this), u = u.dbl()) : (u = c.diffAdd(u, this), c = c.dbl());
  return u;
}, Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
}, Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
}, Point$1.prototype.eq = function(o) {
  return this.getX().cmp(o.getX()) === 0;
}, Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
}, Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$h = utils$m, BN$5 = bn$2.exports, inherits$1 = requireInherits_browser(), Base = base, assert$c = utils$h.assert;
function EdwardsCurve(o) {
  this.twisted = (0 | o.a) != 1, this.mOneA = this.twisted && (0 | o.a) == -1, this.extended = this.mOneA, Base.call(this, "edwards", o), this.a = new BN$5(o.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$5(o.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$5(o.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (0 | o.c) == 1;
}
inherits$1(EdwardsCurve, Base);
var edwards = EdwardsCurve;
function Point(o, n, c, u, h) {
  Base.BasePoint.call(this, o, "projective"), n === null && c === null && u === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$5(n, 16), this.y = new BN$5(c, 16), this.z = u ? new BN$5(u, 16) : this.curve.one, this.t = h && new BN$5(h, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
EdwardsCurve.prototype._mulA = function(o) {
  return this.mOneA ? o.redNeg() : this.a.redMul(o);
}, EdwardsCurve.prototype._mulC = function(o) {
  return this.oneC ? o : this.c.redMul(o);
}, EdwardsCurve.prototype.jpoint = function(o, n, c, u) {
  return this.point(o, n, c, u);
}, EdwardsCurve.prototype.pointFromX = function(o, n) {
  (o = new BN$5(o, 16)).red || (o = o.toRed(this.red));
  var c = o.redSqr(), u = this.c2.redSub(this.a.redMul(c)), h = this.one.redSub(this.c2.redMul(this.d).redMul(c)), g = u.redMul(h.redInvm()), y = g.redSqrt();
  if (y.redSqr().redSub(g).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var $ = y.fromRed().isOdd();
  return (n && !$ || !n && $) && (y = y.redNeg()), this.point(o, y);
}, EdwardsCurve.prototype.pointFromY = function(o, n) {
  (o = new BN$5(o, 16)).red || (o = o.toRed(this.red));
  var c = o.redSqr(), u = c.redSub(this.c2), h = c.redMul(this.d).redMul(this.c2).redSub(this.a), g = u.redMul(h.redInvm());
  if (g.cmp(this.zero) === 0) {
    if (n)
      throw new Error("invalid point");
    return this.point(this.zero, o);
  }
  var y = g.redSqrt();
  if (y.redSqr().redSub(g).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return y.fromRed().isOdd() !== n && (y = y.redNeg()), this.point(y, o);
}, EdwardsCurve.prototype.validate = function(o) {
  if (o.isInfinity())
    return !0;
  o.normalize();
  var n = o.x.redSqr(), c = o.y.redSqr(), u = n.redMul(this.a).redAdd(c), h = this.c2.redMul(this.one.redAdd(this.d.redMul(n).redMul(c)));
  return u.cmp(h) === 0;
}, inherits$1(Point, Base.BasePoint), EdwardsCurve.prototype.pointFromJSON = function(o) {
  return Point.fromJSON(this, o);
}, EdwardsCurve.prototype.point = function(o, n, c, u) {
  return new Point(this, o, n, c, u);
}, Point.fromJSON = function(o, n) {
  return new Point(o, n[0], n[1], n[2]);
}, Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
}, Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
}, Point.prototype._extDbl = function() {
  var o = this.x.redSqr(), n = this.y.redSqr(), c = this.z.redSqr();
  c = c.redIAdd(c);
  var u = this.curve._mulA(o), h = this.x.redAdd(this.y).redSqr().redISub(o).redISub(n), g = u.redAdd(n), y = g.redSub(c), $ = u.redSub(n), I = h.redMul(y), P = g.redMul($), L = h.redMul($), q = y.redMul(g);
  return this.curve.point(I, P, q, L);
}, Point.prototype._projDbl = function() {
  var o, n, c, u, h, g, y = this.x.redAdd(this.y).redSqr(), $ = this.x.redSqr(), I = this.y.redSqr();
  if (this.curve.twisted) {
    var P = (u = this.curve._mulA($)).redAdd(I);
    this.zOne ? (o = y.redSub($).redSub(I).redMul(P.redSub(this.curve.two)), n = P.redMul(u.redSub(I)), c = P.redSqr().redSub(P).redSub(P)) : (h = this.z.redSqr(), g = P.redSub(h).redISub(h), o = y.redSub($).redISub(I).redMul(g), n = P.redMul(u.redSub(I)), c = P.redMul(g));
  } else
    u = $.redAdd(I), h = this.curve._mulC(this.z).redSqr(), g = u.redSub(h).redSub(h), o = this.curve._mulC(y.redISub(u)).redMul(g), n = this.curve._mulC(u).redMul($.redISub(I)), c = u.redMul(g);
  return this.curve.point(o, n, c);
}, Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
}, Point.prototype._extAdd = function(o) {
  var n = this.y.redSub(this.x).redMul(o.y.redSub(o.x)), c = this.y.redAdd(this.x).redMul(o.y.redAdd(o.x)), u = this.t.redMul(this.curve.dd).redMul(o.t), h = this.z.redMul(o.z.redAdd(o.z)), g = c.redSub(n), y = h.redSub(u), $ = h.redAdd(u), I = c.redAdd(n), P = g.redMul(y), L = $.redMul(I), q = g.redMul(I), N = y.redMul($);
  return this.curve.point(P, L, N, q);
}, Point.prototype._projAdd = function(o) {
  var n, c, u = this.z.redMul(o.z), h = u.redSqr(), g = this.x.redMul(o.x), y = this.y.redMul(o.y), $ = this.curve.d.redMul(g).redMul(y), I = h.redSub($), P = h.redAdd($), L = this.x.redAdd(this.y).redMul(o.x.redAdd(o.y)).redISub(g).redISub(y), q = u.redMul(I).redMul(L);
  return this.curve.twisted ? (n = u.redMul(P).redMul(y.redSub(this.curve._mulA(g))), c = I.redMul(P)) : (n = u.redMul(P).redMul(y.redSub(g)), c = this.curve._mulC(I).redMul(P)), this.curve.point(q, n, c);
}, Point.prototype.add = function(o) {
  return this.isInfinity() ? o : o.isInfinity() ? this : this.curve.extended ? this._extAdd(o) : this._projAdd(o);
}, Point.prototype.mul = function(o) {
  return this._hasDoubles(o) ? this.curve._fixedNafMul(this, o) : this.curve._wnafMul(this, o);
}, Point.prototype.mulAdd = function(o, n, c) {
  return this.curve._wnafMulAdd(1, [this, n], [o, c], 2, !1);
}, Point.prototype.jmulAdd = function(o, n, c) {
  return this.curve._wnafMulAdd(1, [this, n], [o, c], 2, !0);
}, Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var o = this.z.redInvm();
  return this.x = this.x.redMul(o), this.y = this.y.redMul(o), this.t && (this.t = this.t.redMul(o)), this.z = this.curve.one, this.zOne = !0, this;
}, Point.prototype.neg = function() {
  return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
}, Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
}, Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
}, Point.prototype.eq = function(o) {
  return this === o || this.getX().cmp(o.getX()) === 0 && this.getY().cmp(o.getY()) === 0;
}, Point.prototype.eqXToP = function(o) {
  var n = o.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var c = o.clone(), u = this.curve.redN.redMul(this.z); ; ) {
    if (c.iadd(this.curve.n), c.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(u), this.x.cmp(n) === 0)
      return !0;
  }
}, Point.prototype.toP = Point.prototype.normalize, Point.prototype.mixedAdd = Point.prototype.add, function(o) {
  var n = curve;
  n.base = base, n.short = short, n.mont = mont, n.edwards = edwards;
}();
var curves$2 = {}, hash$2 = {}, utils$g = {}, assert$b = minimalisticAssert, inherits = requireInherits_browser();
function isSurrogatePair(o, n) {
  return (64512 & o.charCodeAt(n)) == 55296 && !(n < 0 || n + 1 >= o.length) && (64512 & o.charCodeAt(n + 1)) == 56320;
}
function toArray(o, n) {
  if (Array.isArray(o))
    return o.slice();
  if (!o)
    return [];
  var c = [];
  if (typeof o == "string")
    if (n) {
      if (n === "hex")
        for ((o = o.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (o = "0" + o), h = 0; h < o.length; h += 2)
          c.push(parseInt(o[h] + o[h + 1], 16));
    } else
      for (var u = 0, h = 0; h < o.length; h++) {
        var g = o.charCodeAt(h);
        g < 128 ? c[u++] = g : g < 2048 ? (c[u++] = g >> 6 | 192, c[u++] = 63 & g | 128) : isSurrogatePair(o, h) ? (g = 65536 + ((1023 & g) << 10) + (1023 & o.charCodeAt(++h)), c[u++] = g >> 18 | 240, c[u++] = g >> 12 & 63 | 128, c[u++] = g >> 6 & 63 | 128, c[u++] = 63 & g | 128) : (c[u++] = g >> 12 | 224, c[u++] = g >> 6 & 63 | 128, c[u++] = 63 & g | 128);
      }
  else
    for (h = 0; h < o.length; h++)
      c[h] = 0 | o[h];
  return c;
}
function toHex(o) {
  for (var n = "", c = 0; c < o.length; c++)
    n += zero2(o[c].toString(16));
  return n;
}
function htonl(o) {
  return (o >>> 24 | o >>> 8 & 65280 | o << 8 & 16711680 | (255 & o) << 24) >>> 0;
}
function toHex32(o, n) {
  for (var c = "", u = 0; u < o.length; u++) {
    var h = o[u];
    n === "little" && (h = htonl(h)), c += zero8(h.toString(16));
  }
  return c;
}
function zero2(o) {
  return o.length === 1 ? "0" + o : o;
}
function zero8(o) {
  return o.length === 7 ? "0" + o : o.length === 6 ? "00" + o : o.length === 5 ? "000" + o : o.length === 4 ? "0000" + o : o.length === 3 ? "00000" + o : o.length === 2 ? "000000" + o : o.length === 1 ? "0000000" + o : o;
}
function join32(o, n, c, u) {
  var h = c - n;
  assert$b(h % 4 == 0);
  for (var g = new Array(h / 4), y = 0, $ = n; y < g.length; y++, $ += 4) {
    var I;
    I = u === "big" ? o[$] << 24 | o[$ + 1] << 16 | o[$ + 2] << 8 | o[$ + 3] : o[$ + 3] << 24 | o[$ + 2] << 16 | o[$ + 1] << 8 | o[$], g[y] = I >>> 0;
  }
  return g;
}
function split32(o, n) {
  for (var c = new Array(4 * o.length), u = 0, h = 0; u < o.length; u++, h += 4) {
    var g = o[u];
    n === "big" ? (c[h] = g >>> 24, c[h + 1] = g >>> 16 & 255, c[h + 2] = g >>> 8 & 255, c[h + 3] = 255 & g) : (c[h + 3] = g >>> 24, c[h + 2] = g >>> 16 & 255, c[h + 1] = g >>> 8 & 255, c[h] = 255 & g);
  }
  return c;
}
function rotr32$1(o, n) {
  return o >>> n | o << 32 - n;
}
function rotl32$2(o, n) {
  return o << n | o >>> 32 - n;
}
function sum32$3(o, n) {
  return o + n >>> 0;
}
function sum32_3$1(o, n, c) {
  return o + n + c >>> 0;
}
function sum32_4$2(o, n, c, u) {
  return o + n + c + u >>> 0;
}
function sum32_5$2(o, n, c, u, h) {
  return o + n + c + u + h >>> 0;
}
function sum64$1(o, n, c, u) {
  var h = o[n], g = u + o[n + 1] >>> 0, y = (g < u ? 1 : 0) + c + h;
  o[n] = y >>> 0, o[n + 1] = g;
}
function sum64_hi$1(o, n, c, u) {
  return (n + u >>> 0 < n ? 1 : 0) + o + c >>> 0;
}
function sum64_lo$1(o, n, c, u) {
  return n + u >>> 0;
}
function sum64_4_hi$1(o, n, c, u, h, g, y, $) {
  var I = 0, P = n;
  return I += (P = P + u >>> 0) < n ? 1 : 0, I += (P = P + g >>> 0) < g ? 1 : 0, o + c + h + y + (I += (P = P + $ >>> 0) < $ ? 1 : 0) >>> 0;
}
function sum64_4_lo$1(o, n, c, u, h, g, y, $) {
  return n + u + g + $ >>> 0;
}
function sum64_5_hi$1(o, n, c, u, h, g, y, $, I, P) {
  var L = 0, q = n;
  return L += (q = q + u >>> 0) < n ? 1 : 0, L += (q = q + g >>> 0) < g ? 1 : 0, L += (q = q + $ >>> 0) < $ ? 1 : 0, o + c + h + y + I + (L += (q = q + P >>> 0) < P ? 1 : 0) >>> 0;
}
function sum64_5_lo$1(o, n, c, u, h, g, y, $, I, P) {
  return n + u + g + $ + P >>> 0;
}
function rotr64_hi$1(o, n, c) {
  return (n << 32 - c | o >>> c) >>> 0;
}
function rotr64_lo$1(o, n, c) {
  return (o << 32 - c | n >>> c) >>> 0;
}
function shr64_hi$1(o, n, c) {
  return o >>> c;
}
function shr64_lo$1(o, n, c) {
  return (o << 32 - c | n >>> c) >>> 0;
}
utils$g.inherits = inherits, utils$g.toArray = toArray, utils$g.toHex = toHex, utils$g.htonl = htonl, utils$g.toHex32 = toHex32, utils$g.zero2 = zero2, utils$g.zero8 = zero8, utils$g.join32 = join32, utils$g.split32 = split32, utils$g.rotr32 = rotr32$1, utils$g.rotl32 = rotl32$2, utils$g.sum32 = sum32$3, utils$g.sum32_3 = sum32_3$1, utils$g.sum32_4 = sum32_4$2, utils$g.sum32_5 = sum32_5$2, utils$g.sum64 = sum64$1, utils$g.sum64_hi = sum64_hi$1, utils$g.sum64_lo = sum64_lo$1, utils$g.sum64_4_hi = sum64_4_hi$1, utils$g.sum64_4_lo = sum64_4_lo$1, utils$g.sum64_5_hi = sum64_5_hi$1, utils$g.sum64_5_lo = sum64_5_lo$1, utils$g.rotr64_hi = rotr64_hi$1, utils$g.rotr64_lo = rotr64_lo$1, utils$g.shr64_hi = shr64_hi$1, utils$g.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$f = utils$g, assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4, BlockHash$4.prototype.update = function(o, n) {
  if (o = utils$f.toArray(o, n), this.pending ? this.pending = this.pending.concat(o) : this.pending = o, this.pendingTotal += o.length, this.pending.length >= this._delta8) {
    var c = (o = this.pending).length % this._delta8;
    this.pending = o.slice(o.length - c, o.length), this.pending.length === 0 && (this.pending = null), o = utils$f.join32(o, 0, o.length - c, this.endian);
    for (var u = 0; u < o.length; u += this._delta32)
      this._update(o, u, u + this._delta32);
  }
  return this;
}, BlockHash$4.prototype.digest = function(o) {
  return this.update(this._pad()), assert$a(this.pending === null), this._digest(o);
}, BlockHash$4.prototype._pad = function() {
  var o = this.pendingTotal, n = this._delta8, c = n - (o + this.padLength) % n, u = new Array(c + this.padLength);
  u[0] = 128;
  for (var h = 1; h < c; h++)
    u[h] = 0;
  if (o <<= 3, this.endian === "big") {
    for (var g = 8; g < this.padLength; g++)
      u[h++] = 0;
    u[h++] = 0, u[h++] = 0, u[h++] = 0, u[h++] = 0, u[h++] = o >>> 24 & 255, u[h++] = o >>> 16 & 255, u[h++] = o >>> 8 & 255, u[h++] = 255 & o;
  } else
    for (u[h++] = 255 & o, u[h++] = o >>> 8 & 255, u[h++] = o >>> 16 & 255, u[h++] = o >>> 24 & 255, u[h++] = 0, u[h++] = 0, u[h++] = 0, u[h++] = 0, g = 8; g < this.padLength; g++)
      u[h++] = 0;
  return u;
};
var sha = {}, common$4 = {}, utils$e = utils$g, rotr32 = utils$e.rotr32;
function ft_1$1(o, n, c, u) {
  return o === 0 ? ch32$1(n, c, u) : o === 1 || o === 3 ? p32(n, c, u) : o === 2 ? maj32$1(n, c, u) : void 0;
}
function ch32$1(o, n, c) {
  return o & n ^ ~o & c;
}
function maj32$1(o, n, c) {
  return o & n ^ o & c ^ n & c;
}
function p32(o, n, c) {
  return o ^ n ^ c;
}
function s0_256$1(o) {
  return rotr32(o, 2) ^ rotr32(o, 13) ^ rotr32(o, 22);
}
function s1_256$1(o) {
  return rotr32(o, 6) ^ rotr32(o, 11) ^ rotr32(o, 25);
}
function g0_256$1(o) {
  return rotr32(o, 7) ^ rotr32(o, 18) ^ o >>> 3;
}
function g1_256$1(o) {
  return rotr32(o, 17) ^ rotr32(o, 19) ^ o >>> 10;
}
common$4.ft_1 = ft_1$1, common$4.ch32 = ch32$1, common$4.maj32 = maj32$1, common$4.p32 = p32, common$4.s0_256 = s0_256$1, common$4.s1_256 = s1_256$1, common$4.g0_256 = g0_256$1, common$4.g1_256 = g1_256$1;
var utils$d = utils$g, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$d.rotl32, sum32$2 = utils$d.sum32, sum32_5$1 = utils$d.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
}
utils$d.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512, SHA1.outSize = 160, SHA1.hmacStrength = 80, SHA1.padLength = 64, SHA1.prototype._update = function(o, n) {
  for (var c = this.W, u = 0; u < 16; u++)
    c[u] = o[n + u];
  for (; u < c.length; u++)
    c[u] = rotl32$1(c[u - 3] ^ c[u - 8] ^ c[u - 14] ^ c[u - 16], 1);
  var h = this.h[0], g = this.h[1], y = this.h[2], $ = this.h[3], I = this.h[4];
  for (u = 0; u < c.length; u++) {
    var P = ~~(u / 20), L = sum32_5$1(rotl32$1(h, 5), ft_1(P, g, y, $), I, c[u], sha1_K[P]);
    I = $, $ = y, y = rotl32$1(g, 30), g = h, h = L;
  }
  this.h[0] = sum32$2(this.h[0], h), this.h[1] = sum32$2(this.h[1], g), this.h[2] = sum32$2(this.h[2], y), this.h[3] = sum32$2(this.h[3], $), this.h[4] = sum32$2(this.h[4], I);
}, SHA1.prototype._digest = function(o) {
  return o === "hex" ? utils$d.toHex32(this.h, "big") : utils$d.split32(this.h, "big");
};
var utils$c = utils$g, common$2 = common$5, shaCommon = common$4, assert$9 = minimalisticAssert, sum32$1 = utils$c.sum32, sum32_4$1 = utils$c.sum32_4, sum32_5 = utils$c.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = sha256_K, this.W = new Array(64);
}
utils$c.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512, SHA256$1.outSize = 256, SHA256$1.hmacStrength = 192, SHA256$1.padLength = 64, SHA256$1.prototype._update = function(o, n) {
  for (var c = this.W, u = 0; u < 16; u++)
    c[u] = o[n + u];
  for (; u < c.length; u++)
    c[u] = sum32_4$1(g1_256(c[u - 2]), c[u - 7], g0_256(c[u - 15]), c[u - 16]);
  var h = this.h[0], g = this.h[1], y = this.h[2], $ = this.h[3], I = this.h[4], P = this.h[5], L = this.h[6], q = this.h[7];
  for (assert$9(this.k.length === c.length), u = 0; u < c.length; u++) {
    var N = sum32_5(q, s1_256(I), ch32(I, P, L), this.k[u], c[u]), X = sum32$1(s0_256(h), maj32(h, g, y));
    q = L, L = P, P = I, I = sum32$1($, N), $ = y, y = g, g = h, h = sum32$1(N, X);
  }
  this.h[0] = sum32$1(this.h[0], h), this.h[1] = sum32$1(this.h[1], g), this.h[2] = sum32$1(this.h[2], y), this.h[3] = sum32$1(this.h[3], $), this.h[4] = sum32$1(this.h[4], I), this.h[5] = sum32$1(this.h[5], P), this.h[6] = sum32$1(this.h[6], L), this.h[7] = sum32$1(this.h[7], q);
}, SHA256$1.prototype._digest = function(o) {
  return o === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$g, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
}
utils$b.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512, SHA224.outSize = 224, SHA224.hmacStrength = 192, SHA224.padLength = 64, SHA224.prototype._digest = function(o) {
  return o === "hex" ? utils$b.toHex32(this.h.slice(0, 7), "big") : utils$b.split32(this.h.slice(0, 7), "big");
};
var utils$a = utils$g, common$1 = common$5, assert$8 = minimalisticAssert, rotr64_hi = utils$a.rotr64_hi, rotr64_lo = utils$a.rotr64_lo, shr64_hi = utils$a.shr64_hi, shr64_lo = utils$a.shr64_lo, sum64 = utils$a.sum64, sum64_hi = utils$a.sum64_hi, sum64_lo = utils$a.sum64_lo, sum64_4_hi = utils$a.sum64_4_hi, sum64_4_lo = utils$a.sum64_4_lo, sum64_5_hi = utils$a.sum64_5_hi, sum64_5_lo = utils$a.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = sha512_K, this.W = new Array(160);
}
utils$a.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
function ch64_hi(o, n, c, u, h) {
  var g = o & c ^ ~o & h;
  return g < 0 && (g += 4294967296), g;
}
function ch64_lo(o, n, c, u, h, g) {
  var y = n & u ^ ~n & g;
  return y < 0 && (y += 4294967296), y;
}
function maj64_hi(o, n, c, u, h) {
  var g = o & c ^ o & h ^ c & h;
  return g < 0 && (g += 4294967296), g;
}
function maj64_lo(o, n, c, u, h, g) {
  var y = n & u ^ n & g ^ u & g;
  return y < 0 && (y += 4294967296), y;
}
function s0_512_hi(o, n) {
  var c = rotr64_hi(o, n, 28) ^ rotr64_hi(n, o, 2) ^ rotr64_hi(n, o, 7);
  return c < 0 && (c += 4294967296), c;
}
function s0_512_lo(o, n) {
  var c = rotr64_lo(o, n, 28) ^ rotr64_lo(n, o, 2) ^ rotr64_lo(n, o, 7);
  return c < 0 && (c += 4294967296), c;
}
function s1_512_hi(o, n) {
  var c = rotr64_hi(o, n, 14) ^ rotr64_hi(o, n, 18) ^ rotr64_hi(n, o, 9);
  return c < 0 && (c += 4294967296), c;
}
function s1_512_lo(o, n) {
  var c = rotr64_lo(o, n, 14) ^ rotr64_lo(o, n, 18) ^ rotr64_lo(n, o, 9);
  return c < 0 && (c += 4294967296), c;
}
function g0_512_hi(o, n) {
  var c = rotr64_hi(o, n, 1) ^ rotr64_hi(o, n, 8) ^ shr64_hi(o, n, 7);
  return c < 0 && (c += 4294967296), c;
}
function g0_512_lo(o, n) {
  var c = rotr64_lo(o, n, 1) ^ rotr64_lo(o, n, 8) ^ shr64_lo(o, n, 7);
  return c < 0 && (c += 4294967296), c;
}
function g1_512_hi(o, n) {
  var c = rotr64_hi(o, n, 19) ^ rotr64_hi(n, o, 29) ^ shr64_hi(o, n, 6);
  return c < 0 && (c += 4294967296), c;
}
function g1_512_lo(o, n) {
  var c = rotr64_lo(o, n, 19) ^ rotr64_lo(n, o, 29) ^ shr64_lo(o, n, 6);
  return c < 0 && (c += 4294967296), c;
}
SHA512$1.blockSize = 1024, SHA512$1.outSize = 512, SHA512$1.hmacStrength = 192, SHA512$1.padLength = 128, SHA512$1.prototype._prepareBlock = function(o, n) {
  for (var c = this.W, u = 0; u < 32; u++)
    c[u] = o[n + u];
  for (; u < c.length; u += 2) {
    var h = g1_512_hi(c[u - 4], c[u - 3]), g = g1_512_lo(c[u - 4], c[u - 3]), y = c[u - 14], $ = c[u - 13], I = g0_512_hi(c[u - 30], c[u - 29]), P = g0_512_lo(c[u - 30], c[u - 29]), L = c[u - 32], q = c[u - 31];
    c[u] = sum64_4_hi(h, g, y, $, I, P, L, q), c[u + 1] = sum64_4_lo(h, g, y, $, I, P, L, q);
  }
}, SHA512$1.prototype._update = function(o, n) {
  this._prepareBlock(o, n);
  var c = this.W, u = this.h[0], h = this.h[1], g = this.h[2], y = this.h[3], $ = this.h[4], I = this.h[5], P = this.h[6], L = this.h[7], q = this.h[8], N = this.h[9], X = this.h[10], rt = this.h[11], nt = this.h[12], st = this.h[13], ot = this.h[14], St = this.h[15];
  assert$8(this.k.length === c.length);
  for (var Ct = 0; Ct < c.length; Ct += 2) {
    var et = ot, at = St, _t = s1_512_hi(q, N), Nt = s1_512_lo(q, N), m = ch64_hi(q, N, X, rt, nt), A = ch64_lo(q, N, X, rt, nt, st), E = this.k[Ct], w = this.k[Ct + 1], v = c[Ct], k = c[Ct + 1], O = sum64_5_hi(et, at, _t, Nt, m, A, E, w, v, k), W = sum64_5_lo(et, at, _t, Nt, m, A, E, w, v, k);
    et = s0_512_hi(u, h), at = s0_512_lo(u, h), _t = maj64_hi(u, h, g, y, $), Nt = maj64_lo(u, h, g, y, $, I);
    var it = sum64_hi(et, at, _t, Nt), vt = sum64_lo(et, at, _t, Nt);
    ot = nt, St = st, nt = X, st = rt, X = q, rt = N, q = sum64_hi(P, L, O, W), N = sum64_lo(L, L, O, W), P = $, L = I, $ = g, I = y, g = u, y = h, u = sum64_hi(O, W, it, vt), h = sum64_lo(O, W, it, vt);
  }
  sum64(this.h, 0, u, h), sum64(this.h, 2, g, y), sum64(this.h, 4, $, I), sum64(this.h, 6, P, L), sum64(this.h, 8, q, N), sum64(this.h, 10, X, rt), sum64(this.h, 12, nt, st), sum64(this.h, 14, ot, St);
}, SHA512$1.prototype._digest = function(o) {
  return o === "hex" ? utils$a.toHex32(this.h, "big") : utils$a.split32(this.h, "big");
};
var utils$9 = utils$g, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
}
utils$9.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024, SHA384.outSize = 384, SHA384.hmacStrength = 192, SHA384.padLength = 128, SHA384.prototype._digest = function(o) {
  return o === "hex" ? utils$9.toHex32(this.h.slice(0, 12), "big") : utils$9.split32(this.h.slice(0, 12), "big");
}, sha.sha1 = _1, sha.sha224 = _224, sha.sha256 = _256, sha.sha384 = _384, sha.sha512 = _512;
var ripemd = {}, utils$8 = utils$g, common = common$5, rotl32 = utils$8.rotl32, sum32 = utils$8.sum32, sum32_3 = utils$8.sum32_3, sum32_4 = utils$8.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
function f(o, n, c, u) {
  return o <= 15 ? n ^ c ^ u : o <= 31 ? n & c | ~n & u : o <= 47 ? (n | ~c) ^ u : o <= 63 ? n & u | c & ~u : n ^ (c | ~u);
}
function K(o) {
  return o <= 15 ? 0 : o <= 31 ? 1518500249 : o <= 47 ? 1859775393 : o <= 63 ? 2400959708 : 2840853838;
}
function Kh(o) {
  return o <= 15 ? 1352829926 : o <= 31 ? 1548603684 : o <= 47 ? 1836072691 : o <= 63 ? 2053994217 : 0;
}
utils$8.inherits(RIPEMD160, BlockHash), ripemd.ripemd160 = RIPEMD160, RIPEMD160.blockSize = 512, RIPEMD160.outSize = 160, RIPEMD160.hmacStrength = 192, RIPEMD160.padLength = 64, RIPEMD160.prototype._update = function(o, n) {
  for (var c = this.h[0], u = this.h[1], h = this.h[2], g = this.h[3], y = this.h[4], $ = c, I = u, P = h, L = g, q = y, N = 0; N < 80; N++) {
    var X = sum32(rotl32(sum32_4(c, f(N, u, h, g), o[r[N] + n], K(N)), s[N]), y);
    c = y, y = g, g = rotl32(h, 10), h = u, u = X, X = sum32(rotl32(sum32_4($, f(79 - N, I, P, L), o[rh[N] + n], Kh(N)), sh[N]), q), $ = q, q = L, L = rotl32(P, 10), P = I, I = X;
  }
  X = sum32_3(this.h[1], h, L), this.h[1] = sum32_3(this.h[2], g, q), this.h[2] = sum32_3(this.h[3], y, $), this.h[3] = sum32_3(this.h[4], c, I), this.h[4] = sum32_3(this.h[0], u, P), this.h[0] = X;
}, RIPEMD160.prototype._digest = function(o) {
  return o === "hex" ? utils$8.toHex32(this.h, "little") : utils$8.split32(this.h, "little");
};
var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], utils$7 = utils$g, assert$7 = minimalisticAssert;
function Hmac(o, n, c) {
  if (!(this instanceof Hmac))
    return new Hmac(o, n, c);
  this.Hash = o, this.blockSize = o.blockSize / 8, this.outSize = o.outSize / 8, this.inner = null, this.outer = null, this._init(utils$7.toArray(n, c));
}
var hmac = Hmac, secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 ? secp256k1 : (hasRequiredSecp256k1 = 1, secp256k1 = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } });
}
Hmac.prototype._init = function(o) {
  o.length > this.blockSize && (o = new this.Hash().update(o).digest()), assert$7(o.length <= this.blockSize);
  for (var n = o.length; n < this.blockSize; n++)
    o.push(0);
  for (n = 0; n < o.length; n++)
    o[n] ^= 54;
  for (this.inner = new this.Hash().update(o), n = 0; n < o.length; n++)
    o[n] ^= 106;
  this.outer = new this.Hash().update(o);
}, Hmac.prototype.update = function(o, n) {
  return this.inner.update(o, n), this;
}, Hmac.prototype.digest = function(o) {
  return this.outer.update(this.inner.digest()), this.outer.digest(o);
}, function(o) {
  var n = hash$2;
  n.utils = utils$g, n.common = common$5, n.sha = sha, n.ripemd = ripemd, n.hmac = hmac, n.sha1 = n.sha.sha1, n.sha256 = n.sha.sha256, n.sha224 = n.sha.sha224, n.sha384 = n.sha.sha384, n.sha512 = n.sha.sha512, n.ripemd160 = n.ripemd.ripemd160;
}(), function(o) {
  var n, c = curves$2, u = hash$2, h = curve, g = utils$m.assert;
  function y(I) {
    I.type === "short" ? this.curve = new h.short(I) : I.type === "edwards" ? this.curve = new h.edwards(I) : this.curve = new h.mont(I), this.g = this.curve.g, this.n = this.curve.n, this.hash = I.hash, g(this.g.validate(), "Invalid curve"), g(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  function $(I, P) {
    Object.defineProperty(c, I, { configurable: !0, enumerable: !0, get: function() {
      var L = new y(P);
      return Object.defineProperty(c, I, { configurable: !0, enumerable: !0, value: L }), L;
    } });
  }
  c.PresetCurve = y, $("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: u.sha256, gRed: !1, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), $("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: u.sha256, gRed: !1, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), $("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: u.sha256, gRed: !1, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), $("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: u.sha384, gRed: !1, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), $("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: u.sha512, gRed: !1, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), $("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: u.sha256, gRed: !1, g: ["9"] }), $("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: u.sha256, gRed: !1, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
  try {
    n = requireSecp256k1();
  } catch {
    n = void 0;
  }
  $("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: u.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: !1, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", n] });
}();
var hash$1 = hash$2, utils$6 = utils$l, assert$6 = minimalisticAssert;
function HmacDRBG$1(o) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(o);
  this.hash = o.hash, this.predResist = !!o.predResist, this.outLen = this.hash.outSize, this.minEntropy = o.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var n = utils$6.toArray(o.entropy, o.entropyEnc || "hex"), c = utils$6.toArray(o.nonce, o.nonceEnc || "hex"), u = utils$6.toArray(o.pers, o.persEnc || "hex");
  assert$6(n.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(n, c, u);
}
var hmacDrbg = HmacDRBG$1;
HmacDRBG$1.prototype._init = function(o, n, c) {
  var u = o.concat(n).concat(c);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var h = 0; h < this.V.length; h++)
    this.K[h] = 0, this.V[h] = 1;
  this._update(u), this._reseed = 1, this.reseedInterval = 281474976710656;
}, HmacDRBG$1.prototype._hmac = function() {
  return new hash$1.hmac(this.hash, this.K);
}, HmacDRBG$1.prototype._update = function(o) {
  var n = this._hmac().update(this.V).update([0]);
  o && (n = n.update(o)), this.K = n.digest(), this.V = this._hmac().update(this.V).digest(), o && (this.K = this._hmac().update(this.V).update([1]).update(o).digest(), this.V = this._hmac().update(this.V).digest());
}, HmacDRBG$1.prototype.reseed = function(o, n, c, u) {
  typeof n != "string" && (u = c, c = n, n = null), o = utils$6.toArray(o, n), c = utils$6.toArray(c, u), assert$6(o.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(o.concat(c || [])), this._reseed = 1;
}, HmacDRBG$1.prototype.generate = function(o, n, c, u) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof n != "string" && (u = c, c = n, n = null), c && (c = utils$6.toArray(c, u || "hex"), this._update(c));
  for (var h = []; h.length < o; )
    this.V = this._hmac().update(this.V).digest(), h = h.concat(this.V);
  var g = h.slice(0, o);
  return this._update(c), this._reseed++, utils$6.encode(g, n);
};
var BN$4 = bn$2.exports, utils$5 = utils$m, assert$5 = utils$5.assert;
function KeyPair$3(o, n) {
  this.ec = o, this.priv = null, this.pub = null, n.priv && this._importPrivate(n.priv, n.privEnc), n.pub && this._importPublic(n.pub, n.pubEnc);
}
var key$2 = KeyPair$3;
KeyPair$3.fromPublic = function(o, n, c) {
  return n instanceof KeyPair$3 ? n : new KeyPair$3(o, { pub: n, pubEnc: c });
}, KeyPair$3.fromPrivate = function(o, n, c) {
  return n instanceof KeyPair$3 ? n : new KeyPair$3(o, { priv: n, privEnc: c });
}, KeyPair$3.prototype.validate = function() {
  var o = this.getPublic();
  return o.isInfinity() ? { result: !1, reason: "Invalid public key" } : o.validate() ? o.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
}, KeyPair$3.prototype.getPublic = function(o, n) {
  return typeof o == "string" && (n = o, o = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), n ? this.pub.encode(n, o) : this.pub;
}, KeyPair$3.prototype.getPrivate = function(o) {
  return o === "hex" ? this.priv.toString(16, 2) : this.priv;
}, KeyPair$3.prototype._importPrivate = function(o, n) {
  this.priv = new BN$4(o, n || 16), this.priv = this.priv.umod(this.ec.curve.n);
}, KeyPair$3.prototype._importPublic = function(o, n) {
  if (o.x || o.y)
    return this.ec.curve.type === "mont" ? assert$5(o.x, "Need x coordinate") : this.ec.curve.type !== "short" && this.ec.curve.type !== "edwards" || assert$5(o.x && o.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(o.x, o.y));
  this.pub = this.ec.curve.decodePoint(o, n);
}, KeyPair$3.prototype.derive = function(o) {
  return o.validate() || assert$5(o.validate(), "public point not validated"), o.mul(this.priv).getX();
}, KeyPair$3.prototype.sign = function(o, n, c) {
  return this.ec.sign(o, this, n, c);
}, KeyPair$3.prototype.verify = function(o, n) {
  return this.ec.verify(o, n, this);
}, KeyPair$3.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$3 = bn$2.exports, utils$4 = utils$m, assert$4 = utils$4.assert;
function Signature$3(o, n) {
  if (o instanceof Signature$3)
    return o;
  this._importDER(o, n) || (assert$4(o.r && o.s, "Signature without r or s"), this.r = new BN$3(o.r, 16), this.s = new BN$3(o.s, 16), o.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = o.recoveryParam);
}
var signature$1 = Signature$3;
function Position() {
  this.place = 0;
}
function getLength(o, n) {
  var c = o[n.place++];
  if (!(128 & c))
    return c;
  var u = 15 & c;
  if (u === 0 || u > 4)
    return !1;
  for (var h = 0, g = 0, y = n.place; g < u; g++, y++)
    h <<= 8, h |= o[y], h >>>= 0;
  return !(h <= 127) && (n.place = y, h);
}
function rmPadding(o) {
  for (var n = 0, c = o.length - 1; !o[n] && !(128 & o[n + 1]) && n < c; )
    n++;
  return n === 0 ? o : o.slice(n);
}
function constructLength(o, n) {
  if (n < 128)
    o.push(n);
  else {
    var c = 1 + (Math.log(n) / Math.LN2 >>> 3);
    for (o.push(128 | c); --c; )
      o.push(n >>> (c << 3) & 255);
    o.push(n);
  }
}
Signature$3.prototype._importDER = function(o, n) {
  o = utils$4.toArray(o, n);
  var c = new Position();
  if (o[c.place++] !== 48)
    return !1;
  var u = getLength(o, c);
  if (u === !1 || u + c.place !== o.length || o[c.place++] !== 2)
    return !1;
  var h = getLength(o, c);
  if (h === !1)
    return !1;
  var g = o.slice(c.place, h + c.place);
  if (c.place += h, o[c.place++] !== 2)
    return !1;
  var y = getLength(o, c);
  if (y === !1 || o.length !== y + c.place)
    return !1;
  var $ = o.slice(c.place, y + c.place);
  if (g[0] === 0) {
    if (!(128 & g[1]))
      return !1;
    g = g.slice(1);
  }
  if ($[0] === 0) {
    if (!(128 & $[1]))
      return !1;
    $ = $.slice(1);
  }
  return this.r = new BN$3(g), this.s = new BN$3($), this.recoveryParam = null, !0;
}, Signature$3.prototype.toDER = function(o) {
  var n = this.r.toArray(), c = this.s.toArray();
  for (128 & n[0] && (n = [0].concat(n)), 128 & c[0] && (c = [0].concat(c)), n = rmPadding(n), c = rmPadding(c); !(c[0] || 128 & c[1]); )
    c = c.slice(1);
  var u = [2];
  constructLength(u, n.length), (u = u.concat(n)).push(2), constructLength(u, c.length);
  var h = u.concat(c), g = [48];
  return constructLength(g, h.length), g = g.concat(h), utils$4.encode(g, o);
};
var BN$2 = bn$2.exports, HmacDRBG = hmacDrbg, utils$3 = utils$m, curves$1 = curves$2, rand = brorand.exports, assert$3 = utils$3.assert, KeyPair$2 = key$2, Signature$2 = signature$1;
function EC$3(o) {
  if (!(this instanceof EC$3))
    return new EC$3(o);
  typeof o == "string" && (assert$3(Object.prototype.hasOwnProperty.call(curves$1, o), "Unknown curve " + o), o = curves$1[o]), o instanceof curves$1.PresetCurve && (o = { curve: o }), this.curve = o.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = o.curve.g, this.g.precompute(o.curve.n.bitLength() + 1), this.hash = o.hash || o.curve.hash;
}
var ec = EC$3;
EC$3.prototype.keyPair = function(o) {
  return new KeyPair$2(this, o);
}, EC$3.prototype.keyFromPrivate = function(o, n) {
  return KeyPair$2.fromPrivate(this, o, n);
}, EC$3.prototype.keyFromPublic = function(o, n) {
  return KeyPair$2.fromPublic(this, o, n);
}, EC$3.prototype.genKeyPair = function(o) {
  o || (o = {});
  for (var n = new HmacDRBG({ hash: this.hash, pers: o.pers, persEnc: o.persEnc || "utf8", entropy: o.entropy || rand(this.hash.hmacStrength), entropyEnc: o.entropy && o.entropyEnc || "utf8", nonce: this.n.toArray() }), c = this.n.byteLength(), u = this.n.sub(new BN$2(2)); ; ) {
    var h = new BN$2(n.generate(c));
    if (!(h.cmp(u) > 0))
      return h.iaddn(1), this.keyFromPrivate(h);
  }
}, EC$3.prototype._truncateToN = function(o, n) {
  var c = 8 * o.byteLength() - this.n.bitLength();
  return c > 0 && (o = o.ushrn(c)), !n && o.cmp(this.n) >= 0 ? o.sub(this.n) : o;
}, EC$3.prototype.sign = function(o, n, c, u) {
  typeof c == "object" && (u = c, c = null), u || (u = {}), n = this.keyFromPrivate(n, c), o = this._truncateToN(new BN$2(o, 16));
  for (var h = this.n.byteLength(), g = n.getPrivate().toArray("be", h), y = o.toArray("be", h), $ = new HmacDRBG({ hash: this.hash, entropy: g, nonce: y, pers: u.pers, persEnc: u.persEnc || "utf8" }), I = this.n.sub(new BN$2(1)), P = 0; ; P++) {
    var L = u.k ? u.k(P) : new BN$2($.generate(this.n.byteLength()));
    if (!((L = this._truncateToN(L, !0)).cmpn(1) <= 0 || L.cmp(I) >= 0)) {
      var q = this.g.mul(L);
      if (!q.isInfinity()) {
        var N = q.getX(), X = N.umod(this.n);
        if (X.cmpn(0) !== 0) {
          var rt = L.invm(this.n).mul(X.mul(n.getPrivate()).iadd(o));
          if ((rt = rt.umod(this.n)).cmpn(0) !== 0) {
            var nt = (q.getY().isOdd() ? 1 : 0) | (N.cmp(X) !== 0 ? 2 : 0);
            return u.canonical && rt.cmp(this.nh) > 0 && (rt = this.n.sub(rt), nt ^= 1), new Signature$2({ r: X, s: rt, recoveryParam: nt });
          }
        }
      }
    }
  }
}, EC$3.prototype.verify = function(o, n, c, u) {
  o = this._truncateToN(new BN$2(o, 16)), c = this.keyFromPublic(c, u);
  var h = (n = new Signature$2(n, "hex")).r, g = n.s;
  if (h.cmpn(1) < 0 || h.cmp(this.n) >= 0 || g.cmpn(1) < 0 || g.cmp(this.n) >= 0)
    return !1;
  var y, $ = g.invm(this.n), I = $.mul(o).umod(this.n), P = $.mul(h).umod(this.n);
  return this.curve._maxwellTrick ? !(y = this.g.jmulAdd(I, c.getPublic(), P)).isInfinity() && y.eqXToP(h) : !(y = this.g.mulAdd(I, c.getPublic(), P)).isInfinity() && y.getX().umod(this.n).cmp(h) === 0;
}, EC$3.prototype.recoverPubKey = function(o, n, c, u) {
  assert$3((3 & c) === c, "The recovery param is more than two bits"), n = new Signature$2(n, u);
  var h = this.n, g = new BN$2(o), y = n.r, $ = n.s, I = 1 & c, P = c >> 1;
  if (y.cmp(this.curve.p.umod(this.curve.n)) >= 0 && P)
    throw new Error("Unable to find sencond key candinate");
  y = P ? this.curve.pointFromX(y.add(this.curve.n), I) : this.curve.pointFromX(y, I);
  var L = n.r.invm(h), q = h.sub(g).mul(L).umod(h), N = $.mul(L).umod(h);
  return this.g.mulAdd(q, y, N);
}, EC$3.prototype.getKeyRecoveryParam = function(o, n, c, u) {
  if ((n = new Signature$2(n, u)).recoveryParam !== null)
    return n.recoveryParam;
  for (var h = 0; h < 4; h++) {
    var g;
    try {
      g = this.recoverPubKey(o, n, h);
    } catch {
      continue;
    }
    if (g.eq(c))
      return h;
  }
  throw new Error("Unable to find valid recovery factor");
};
var utils$2 = utils$m, assert$2 = utils$2.assert, parseBytes$2 = utils$2.parseBytes, cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$1(o, n) {
  this.eddsa = o, this._secret = parseBytes$2(n.secret), o.isPoint(n.pub) ? this._pub = n.pub : this._pubBytes = parseBytes$2(n.pub);
}
KeyPair$1.fromPublic = function(o, n) {
  return n instanceof KeyPair$1 ? n : new KeyPair$1(o, { pub: n });
}, KeyPair$1.fromSecret = function(o, n) {
  return n instanceof KeyPair$1 ? n : new KeyPair$1(o, { secret: n });
}, KeyPair$1.prototype.secret = function() {
  return this._secret;
}, cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
}), cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
}), cachedProperty$1(KeyPair$1, "privBytes", function() {
  var o = this.eddsa, n = this.hash(), c = o.encodingLength - 1, u = n.slice(0, o.encodingLength);
  return u[0] &= 248, u[c] &= 127, u[c] |= 64, u;
}), cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
}), cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
}), cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
}), KeyPair$1.prototype.sign = function(o) {
  return assert$2(this._secret, "KeyPair can only verify"), this.eddsa.sign(o, this);
}, KeyPair$1.prototype.verify = function(o, n) {
  return this.eddsa.verify(o, n, this);
}, KeyPair$1.prototype.getSecret = function(o) {
  return assert$2(this._secret, "KeyPair is public only"), utils$2.encode(this.secret(), o);
}, KeyPair$1.prototype.getPublic = function(o) {
  return utils$2.encode(this.pubBytes(), o);
};
var key$1 = KeyPair$1, BN$1 = bn$2.exports, utils$1 = utils$m, assert$1 = utils$1.assert, cachedProperty = utils$1.cachedProperty, parseBytes$1 = utils$1.parseBytes;
function Signature$1(o, n) {
  this.eddsa = o, typeof n != "object" && (n = parseBytes$1(n)), Array.isArray(n) && (n = { R: n.slice(0, o.encodingLength), S: n.slice(o.encodingLength) }), assert$1(n.R && n.S, "Signature without R or S"), o.isPoint(n.R) && (this._R = n.R), n.S instanceof BN$1 && (this._S = n.S), this._Rencoded = Array.isArray(n.R) ? n.R : n.Rencoded, this._Sencoded = Array.isArray(n.S) ? n.S : n.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
}), cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
}), cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
}), cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
}), Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
}, Signature$1.prototype.toHex = function() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$2, utils = utils$m, assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = key$1, Signature = signature;
function EDDSA(o) {
  if (assert(o === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(o);
  o = curves[o].curve, this.curve = o, this.g = o.g, this.g.precompute(o.n.bitLength() + 1), this.pointClass = o.point().constructor, this.encodingLength = Math.ceil(o.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(o, n) {
  o = parseBytes(o);
  var c = this.keyFromSecret(n), u = this.hashInt(c.messagePrefix(), o), h = this.g.mul(u), g = this.encodePoint(h), y = this.hashInt(g, c.pubBytes(), o).mul(c.priv()), $ = u.add(y).umod(this.curve.n);
  return this.makeSignature({ R: h, S: $, Rencoded: g });
}, EDDSA.prototype.verify = function(o, n, c) {
  o = parseBytes(o), n = this.makeSignature(n);
  var u = this.keyFromPublic(c), h = this.hashInt(n.Rencoded(), u.pubBytes(), o), g = this.g.mul(n.S());
  return n.R().add(u.pub().mul(h)).eq(g);
}, EDDSA.prototype.hashInt = function() {
  for (var o = this.hash(), n = 0; n < arguments.length; n++)
    o.update(arguments[n]);
  return utils.intFromLE(o.digest()).umod(this.curve.n);
}, EDDSA.prototype.keyFromPublic = function(o) {
  return KeyPair.fromPublic(this, o);
}, EDDSA.prototype.keyFromSecret = function(o) {
  return KeyPair.fromSecret(this, o);
}, EDDSA.prototype.makeSignature = function(o) {
  return o instanceof Signature ? o : new Signature(this, o);
}, EDDSA.prototype.encodePoint = function(o) {
  var n = o.getY().toArray("le", this.encodingLength);
  return n[this.encodingLength - 1] |= o.getX().isOdd() ? 128 : 0, n;
}, EDDSA.prototype.decodePoint = function(o) {
  var n = (o = utils.parseBytes(o)).length - 1, c = o.slice(0, n).concat(-129 & o[n]), u = (128 & o[n]) != 0, h = utils.intFromLE(c);
  return this.curve.pointFromY(h, u);
}, EDDSA.prototype.encodeInt = function(o) {
  return o.toArray("le", this.encodingLength);
}, EDDSA.prototype.decodeInt = function(o) {
  return utils.intFromLE(o);
}, EDDSA.prototype.isPoint = function(o) {
  return o instanceof this.pointClass;
}, function(o) {
  var n = elliptic$1;
  n.version = require$$0$2.version, n.utils = utils$m, n.rand = brorand.exports, n.curve = curve, n.curves = curves$2, n.ec = ec, n.eddsa = eddsa;
}();
var bn$1 = { exports: {} };
(function(o, n) {
  function c(E, w) {
    if (!E)
      throw new Error(w || "Assertion failed");
  }
  function u(E, w) {
    E.super_ = w;
    var v = function() {
    };
    v.prototype = w.prototype, E.prototype = new v(), E.prototype.constructor = E;
  }
  function h(E, w, v) {
    if (h.isBN(E))
      return E;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, E !== null && (w !== "le" && w !== "be" || (v = w, w = 10), this._init(E || 0, w || 10, v || "be"));
  }
  var g;
  typeof bn$1 == "object" ? bn$1.exports = h : n.BN = h, h.BN = h, h.wordSize = 26;
  try {
    g = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function y(E, w) {
    var v = E.charCodeAt(w);
    return v >= 48 && v <= 57 ? v - 48 : v >= 65 && v <= 70 ? v - 55 : v >= 97 && v <= 102 ? v - 87 : void c(!1, "Invalid character in " + E);
  }
  function $(E, w, v) {
    var k = y(E, v);
    return v - 1 >= w && (k |= y(E, v - 1) << 4), k;
  }
  function I(E, w, v, k) {
    for (var O = 0, W = 0, it = Math.min(E.length, v), vt = w; vt < it; vt++) {
      var xt = E.charCodeAt(vt) - 48;
      O *= k, W = xt >= 49 ? xt - 49 + 10 : xt >= 17 ? xt - 17 + 10 : xt, c(xt >= 0 && W < k, "Invalid character"), O += W;
    }
    return O;
  }
  function P(E, w) {
    E.words = w.words, E.length = w.length, E.negative = w.negative, E.red = w.red;
  }
  if (h.isBN = function(E) {
    return E instanceof h || E !== null && typeof E == "object" && E.constructor.wordSize === h.wordSize && Array.isArray(E.words);
  }, h.max = function(E, w) {
    return E.cmp(w) > 0 ? E : w;
  }, h.min = function(E, w) {
    return E.cmp(w) < 0 ? E : w;
  }, h.prototype._init = function(E, w, v) {
    if (typeof E == "number")
      return this._initNumber(E, w, v);
    if (typeof E == "object")
      return this._initArray(E, w, v);
    w === "hex" && (w = 16), c(w === (0 | w) && w >= 2 && w <= 36);
    var k = 0;
    (E = E.toString().replace(/\s+/g, ""))[0] === "-" && (k++, this.negative = 1), k < E.length && (w === 16 ? this._parseHex(E, k, v) : (this._parseBase(E, w, k), v === "le" && this._initArray(this.toArray(), w, v)));
  }, h.prototype._initNumber = function(E, w, v) {
    E < 0 && (this.negative = 1, E = -E), E < 67108864 ? (this.words = [67108863 & E], this.length = 1) : E < 4503599627370496 ? (this.words = [67108863 & E, E / 67108864 & 67108863], this.length = 2) : (c(E < 9007199254740992), this.words = [67108863 & E, E / 67108864 & 67108863, 1], this.length = 3), v === "le" && this._initArray(this.toArray(), w, v);
  }, h.prototype._initArray = function(E, w, v) {
    if (c(typeof E.length == "number"), E.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(E.length / 3), this.words = new Array(this.length);
    for (var k = 0; k < this.length; k++)
      this.words[k] = 0;
    var O, W, it = 0;
    if (v === "be")
      for (k = E.length - 1, O = 0; k >= 0; k -= 3)
        W = E[k] | E[k - 1] << 8 | E[k - 2] << 16, this.words[O] |= W << it & 67108863, this.words[O + 1] = W >>> 26 - it & 67108863, (it += 24) >= 26 && (it -= 26, O++);
    else if (v === "le")
      for (k = 0, O = 0; k < E.length; k += 3)
        W = E[k] | E[k + 1] << 8 | E[k + 2] << 16, this.words[O] |= W << it & 67108863, this.words[O + 1] = W >>> 26 - it & 67108863, (it += 24) >= 26 && (it -= 26, O++);
    return this._strip();
  }, h.prototype._parseHex = function(E, w, v) {
    this.length = Math.ceil((E.length - w) / 6), this.words = new Array(this.length);
    for (var k = 0; k < this.length; k++)
      this.words[k] = 0;
    var O, W = 0, it = 0;
    if (v === "be")
      for (k = E.length - 1; k >= w; k -= 2)
        O = $(E, w, k) << W, this.words[it] |= 67108863 & O, W >= 18 ? (W -= 18, it += 1, this.words[it] |= O >>> 26) : W += 8;
    else
      for (k = (E.length - w) % 2 == 0 ? w + 1 : w; k < E.length; k += 2)
        O = $(E, w, k) << W, this.words[it] |= 67108863 & O, W >= 18 ? (W -= 18, it += 1, this.words[it] |= O >>> 26) : W += 8;
    this._strip();
  }, h.prototype._parseBase = function(E, w, v) {
    this.words = [0], this.length = 1;
    for (var k = 0, O = 1; O <= 67108863; O *= w)
      k++;
    k--, O = O / w | 0;
    for (var W = E.length - v, it = W % k, vt = Math.min(W, W - it) + v, xt = 0, It = v; It < vt; It += k)
      xt = I(E, It, It + k, w), this.imuln(O), this.words[0] + xt < 67108864 ? this.words[0] += xt : this._iaddn(xt);
    if (it !== 0) {
      var Wt = 1;
      for (xt = I(E, It, E.length, w), It = 0; It < it; It++)
        Wt *= w;
      this.imuln(Wt), this.words[0] + xt < 67108864 ? this.words[0] += xt : this._iaddn(xt);
    }
    this._strip();
  }, h.prototype.copy = function(E) {
    E.words = new Array(this.length);
    for (var w = 0; w < this.length; w++)
      E.words[w] = this.words[w];
    E.length = this.length, E.negative = this.negative, E.red = this.red;
  }, h.prototype._move = function(E) {
    P(E, this);
  }, h.prototype.clone = function() {
    var E = new h(null);
    return this.copy(E), E;
  }, h.prototype._expand = function(E) {
    for (; this.length < E; )
      this.words[this.length++] = 0;
    return this;
  }, h.prototype._strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, h.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, typeof Symbol < "u" && typeof Symbol.for == "function")
    try {
      h.prototype[Symbol.for("nodejs.util.inspect.custom")] = L;
    } catch {
      h.prototype.inspect = L;
    }
  else
    h.prototype.inspect = L;
  function L() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  }
  var q = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], N = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], X = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function rt(E, w, v) {
    v.negative = w.negative ^ E.negative;
    var k = E.length + w.length | 0;
    v.length = k, k = k - 1 | 0;
    var O = 0 | E.words[0], W = 0 | w.words[0], it = O * W, vt = 67108863 & it, xt = it / 67108864 | 0;
    v.words[0] = vt;
    for (var It = 1; It < k; It++) {
      for (var Wt = xt >>> 26, Ut = 67108863 & xt, zt = Math.min(It, w.length - 1), Jt = Math.max(0, It - E.length + 1); Jt <= zt; Jt++) {
        var Xt = It - Jt | 0;
        Wt += (it = (O = 0 | E.words[Xt]) * (W = 0 | w.words[Jt]) + Ut) / 67108864 | 0, Ut = 67108863 & it;
      }
      v.words[It] = 0 | Ut, xt = 0 | Wt;
    }
    return xt !== 0 ? v.words[It] = 0 | xt : v.length--, v._strip();
  }
  h.prototype.toString = function(E, w) {
    var v;
    if (w = 0 | w || 1, (E = E || 10) === 16 || E === "hex") {
      v = "";
      for (var k = 0, O = 0, W = 0; W < this.length; W++) {
        var it = this.words[W], vt = (16777215 & (it << k | O)).toString(16);
        O = it >>> 24 - k & 16777215, (k += 2) >= 26 && (k -= 26, W--), v = O !== 0 || W !== this.length - 1 ? q[6 - vt.length] + vt + v : vt + v;
      }
      for (O !== 0 && (v = O.toString(16) + v); v.length % w != 0; )
        v = "0" + v;
      return this.negative !== 0 && (v = "-" + v), v;
    }
    if (E === (0 | E) && E >= 2 && E <= 36) {
      var xt = N[E], It = X[E];
      v = "";
      var Wt = this.clone();
      for (Wt.negative = 0; !Wt.isZero(); ) {
        var Ut = Wt.modrn(It).toString(E);
        v = (Wt = Wt.idivn(It)).isZero() ? Ut + v : q[xt - Ut.length] + Ut + v;
      }
      for (this.isZero() && (v = "0" + v); v.length % w != 0; )
        v = "0" + v;
      return this.negative !== 0 && (v = "-" + v), v;
    }
    c(!1, "Base should be between 2 and 36");
  }, h.prototype.toNumber = function() {
    var E = this.words[0];
    return this.length === 2 ? E += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? E += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && c(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -E : E;
  }, h.prototype.toJSON = function() {
    return this.toString(16, 2);
  }, g && (h.prototype.toBuffer = function(E, w) {
    return this.toArrayLike(g, E, w);
  }), h.prototype.toArray = function(E, w) {
    return this.toArrayLike(Array, E, w);
  }, h.prototype.toArrayLike = function(E, w, v) {
    this._strip();
    var k = this.byteLength(), O = v || Math.max(1, k);
    c(k <= O, "byte array longer than desired length"), c(O > 0, "Requested array length <= 0");
    var W = function(it, vt) {
      return it.allocUnsafe ? it.allocUnsafe(vt) : new it(vt);
    }(E, O);
    return this["_toArrayLike" + (w === "le" ? "LE" : "BE")](W, k), W;
  }, h.prototype._toArrayLikeLE = function(E, w) {
    for (var v = 0, k = 0, O = 0, W = 0; O < this.length; O++) {
      var it = this.words[O] << W | k;
      E[v++] = 255 & it, v < E.length && (E[v++] = it >> 8 & 255), v < E.length && (E[v++] = it >> 16 & 255), W === 6 ? (v < E.length && (E[v++] = it >> 24 & 255), k = 0, W = 0) : (k = it >>> 24, W += 2);
    }
    if (v < E.length)
      for (E[v++] = k; v < E.length; )
        E[v++] = 0;
  }, h.prototype._toArrayLikeBE = function(E, w) {
    for (var v = E.length - 1, k = 0, O = 0, W = 0; O < this.length; O++) {
      var it = this.words[O] << W | k;
      E[v--] = 255 & it, v >= 0 && (E[v--] = it >> 8 & 255), v >= 0 && (E[v--] = it >> 16 & 255), W === 6 ? (v >= 0 && (E[v--] = it >> 24 & 255), k = 0, W = 0) : (k = it >>> 24, W += 2);
    }
    if (v >= 0)
      for (E[v--] = k; v >= 0; )
        E[v--] = 0;
  }, Math.clz32 ? h.prototype._countBits = function(E) {
    return 32 - Math.clz32(E);
  } : h.prototype._countBits = function(E) {
    var w = E, v = 0;
    return w >= 4096 && (v += 13, w >>>= 13), w >= 64 && (v += 7, w >>>= 7), w >= 8 && (v += 4, w >>>= 4), w >= 2 && (v += 2, w >>>= 2), v + w;
  }, h.prototype._zeroBits = function(E) {
    if (E === 0)
      return 26;
    var w = E, v = 0;
    return (8191 & w) == 0 && (v += 13, w >>>= 13), (127 & w) == 0 && (v += 7, w >>>= 7), (15 & w) == 0 && (v += 4, w >>>= 4), (3 & w) == 0 && (v += 2, w >>>= 2), (1 & w) == 0 && v++, v;
  }, h.prototype.bitLength = function() {
    var E = this.words[this.length - 1], w = this._countBits(E);
    return 26 * (this.length - 1) + w;
  }, h.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var E = 0, w = 0; w < this.length; w++) {
      var v = this._zeroBits(this.words[w]);
      if (E += v, v !== 26)
        break;
    }
    return E;
  }, h.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, h.prototype.toTwos = function(E) {
    return this.negative !== 0 ? this.abs().inotn(E).iaddn(1) : this.clone();
  }, h.prototype.fromTwos = function(E) {
    return this.testn(E - 1) ? this.notn(E).iaddn(1).ineg() : this.clone();
  }, h.prototype.isNeg = function() {
    return this.negative !== 0;
  }, h.prototype.neg = function() {
    return this.clone().ineg();
  }, h.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, h.prototype.iuor = function(E) {
    for (; this.length < E.length; )
      this.words[this.length++] = 0;
    for (var w = 0; w < E.length; w++)
      this.words[w] = this.words[w] | E.words[w];
    return this._strip();
  }, h.prototype.ior = function(E) {
    return c((this.negative | E.negative) == 0), this.iuor(E);
  }, h.prototype.or = function(E) {
    return this.length > E.length ? this.clone().ior(E) : E.clone().ior(this);
  }, h.prototype.uor = function(E) {
    return this.length > E.length ? this.clone().iuor(E) : E.clone().iuor(this);
  }, h.prototype.iuand = function(E) {
    var w;
    w = this.length > E.length ? E : this;
    for (var v = 0; v < w.length; v++)
      this.words[v] = this.words[v] & E.words[v];
    return this.length = w.length, this._strip();
  }, h.prototype.iand = function(E) {
    return c((this.negative | E.negative) == 0), this.iuand(E);
  }, h.prototype.and = function(E) {
    return this.length > E.length ? this.clone().iand(E) : E.clone().iand(this);
  }, h.prototype.uand = function(E) {
    return this.length > E.length ? this.clone().iuand(E) : E.clone().iuand(this);
  }, h.prototype.iuxor = function(E) {
    var w, v;
    this.length > E.length ? (w = this, v = E) : (w = E, v = this);
    for (var k = 0; k < v.length; k++)
      this.words[k] = w.words[k] ^ v.words[k];
    if (this !== w)
      for (; k < w.length; k++)
        this.words[k] = w.words[k];
    return this.length = w.length, this._strip();
  }, h.prototype.ixor = function(E) {
    return c((this.negative | E.negative) == 0), this.iuxor(E);
  }, h.prototype.xor = function(E) {
    return this.length > E.length ? this.clone().ixor(E) : E.clone().ixor(this);
  }, h.prototype.uxor = function(E) {
    return this.length > E.length ? this.clone().iuxor(E) : E.clone().iuxor(this);
  }, h.prototype.inotn = function(E) {
    c(typeof E == "number" && E >= 0);
    var w = 0 | Math.ceil(E / 26), v = E % 26;
    this._expand(w), v > 0 && w--;
    for (var k = 0; k < w; k++)
      this.words[k] = 67108863 & ~this.words[k];
    return v > 0 && (this.words[k] = ~this.words[k] & 67108863 >> 26 - v), this._strip();
  }, h.prototype.notn = function(E) {
    return this.clone().inotn(E);
  }, h.prototype.setn = function(E, w) {
    c(typeof E == "number" && E >= 0);
    var v = E / 26 | 0, k = E % 26;
    return this._expand(v + 1), this.words[v] = w ? this.words[v] | 1 << k : this.words[v] & ~(1 << k), this._strip();
  }, h.prototype.iadd = function(E) {
    var w, v, k;
    if (this.negative !== 0 && E.negative === 0)
      return this.negative = 0, w = this.isub(E), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && E.negative !== 0)
      return E.negative = 0, w = this.isub(E), E.negative = 1, w._normSign();
    this.length > E.length ? (v = this, k = E) : (v = E, k = this);
    for (var O = 0, W = 0; W < k.length; W++)
      w = (0 | v.words[W]) + (0 | k.words[W]) + O, this.words[W] = 67108863 & w, O = w >>> 26;
    for (; O !== 0 && W < v.length; W++)
      w = (0 | v.words[W]) + O, this.words[W] = 67108863 & w, O = w >>> 26;
    if (this.length = v.length, O !== 0)
      this.words[this.length] = O, this.length++;
    else if (v !== this)
      for (; W < v.length; W++)
        this.words[W] = v.words[W];
    return this;
  }, h.prototype.add = function(E) {
    var w;
    return E.negative !== 0 && this.negative === 0 ? (E.negative = 0, w = this.sub(E), E.negative ^= 1, w) : E.negative === 0 && this.negative !== 0 ? (this.negative = 0, w = E.sub(this), this.negative = 1, w) : this.length > E.length ? this.clone().iadd(E) : E.clone().iadd(this);
  }, h.prototype.isub = function(E) {
    if (E.negative !== 0) {
      E.negative = 0;
      var w = this.iadd(E);
      return E.negative = 1, w._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(E), this.negative = 1, this._normSign();
    var v, k, O = this.cmp(E);
    if (O === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    O > 0 ? (v = this, k = E) : (v = E, k = this);
    for (var W = 0, it = 0; it < k.length; it++)
      W = (w = (0 | v.words[it]) - (0 | k.words[it]) + W) >> 26, this.words[it] = 67108863 & w;
    for (; W !== 0 && it < v.length; it++)
      W = (w = (0 | v.words[it]) + W) >> 26, this.words[it] = 67108863 & w;
    if (W === 0 && it < v.length && v !== this)
      for (; it < v.length; it++)
        this.words[it] = v.words[it];
    return this.length = Math.max(this.length, it), v !== this && (this.negative = 1), this._strip();
  }, h.prototype.sub = function(E) {
    return this.clone().isub(E);
  };
  var nt = function(E, w, v) {
    var k, O, W, it = E.words, vt = w.words, xt = v.words, It = 0, Wt = 0 | it[0], Ut = 8191 & Wt, zt = Wt >>> 13, Jt = 0 | it[1], Xt = 8191 & Jt, ie = Jt >>> 13, oe = 0 | it[2], De = 8191 & oe, ue = oe >>> 13, xe = 0 | it[3], se = 8191 & xe, he = xe >>> 13, je = 0 | it[4], jr = 8191 & je, de = je >>> 13, We = 0 | it[5], B = 8191 & We, j = We >>> 13, Z = 0 | it[6], kt = 8191 & Z, $t = Z >>> 13, At = 0 | it[7], Bt = 8191 & At, Ft = At >>> 13, Kt = 0 | it[8], Zt = 8191 & Kt, Gt = Kt >>> 13, Qt = 0 | it[9], Ae = 8191 & Qt, ae = Qt >>> 13, we = 0 | vt[0], ir = 8191 & we, ge = we >>> 13, _e = 0 | vt[1], rr = 8191 & _e, be = _e >>> 13, Ge = 0 | vt[2], Rr = 8191 & Ge, Te = Ge >>> 13, Ie = 0 | vt[3], Pr = 8191 & Ie, Ee = Ie >>> 13, er = 0 | vt[4], Or = 8191 & er, Ve = er >>> 13, sr = 0 | vt[5], qr = 8191 & sr, Je = sr >>> 13, ur = 0 | vt[6], Kr = 8191 & ur, Ze = ur >>> 13, vr = 0 | vt[7], Hr = 8191 & vr, Ye = vr >>> 13, _r = 0 | vt[8], zr = 8191 & _r, tr = _r >>> 13, Mr = 0 | vt[9], Ur = 8191 & Mr, Fr = Mr >>> 13;
    v.negative = E.negative ^ w.negative, v.length = 19;
    var Zr = (It + (k = Math.imul(Ut, ir)) | 0) + ((8191 & (O = (O = Math.imul(Ut, ge)) + Math.imul(zt, ir) | 0)) << 13) | 0;
    It = ((W = Math.imul(zt, ge)) + (O >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, k = Math.imul(Xt, ir), O = (O = Math.imul(Xt, ge)) + Math.imul(ie, ir) | 0, W = Math.imul(ie, ge);
    var Qr = (It + (k = k + Math.imul(Ut, rr) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Ut, be) | 0) + Math.imul(zt, rr) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(zt, be) | 0) + (O >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, k = Math.imul(De, ir), O = (O = Math.imul(De, ge)) + Math.imul(ue, ir) | 0, W = Math.imul(ue, ge), k = k + Math.imul(Xt, rr) | 0, O = (O = O + Math.imul(Xt, be) | 0) + Math.imul(ie, rr) | 0, W = W + Math.imul(ie, be) | 0;
    var Xr = (It + (k = k + Math.imul(Ut, Rr) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Ut, Te) | 0) + Math.imul(zt, Rr) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(zt, Te) | 0) + (O >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, k = Math.imul(se, ir), O = (O = Math.imul(se, ge)) + Math.imul(he, ir) | 0, W = Math.imul(he, ge), k = k + Math.imul(De, rr) | 0, O = (O = O + Math.imul(De, be) | 0) + Math.imul(ue, rr) | 0, W = W + Math.imul(ue, be) | 0, k = k + Math.imul(Xt, Rr) | 0, O = (O = O + Math.imul(Xt, Te) | 0) + Math.imul(ie, Rr) | 0, W = W + Math.imul(ie, Te) | 0;
    var Yr = (It + (k = k + Math.imul(Ut, Pr) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Ut, Ee) | 0) + Math.imul(zt, Pr) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(zt, Ee) | 0) + (O >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, k = Math.imul(jr, ir), O = (O = Math.imul(jr, ge)) + Math.imul(de, ir) | 0, W = Math.imul(de, ge), k = k + Math.imul(se, rr) | 0, O = (O = O + Math.imul(se, be) | 0) + Math.imul(he, rr) | 0, W = W + Math.imul(he, be) | 0, k = k + Math.imul(De, Rr) | 0, O = (O = O + Math.imul(De, Te) | 0) + Math.imul(ue, Rr) | 0, W = W + Math.imul(ue, Te) | 0, k = k + Math.imul(Xt, Pr) | 0, O = (O = O + Math.imul(Xt, Ee) | 0) + Math.imul(ie, Pr) | 0, W = W + Math.imul(ie, Ee) | 0;
    var tn = (It + (k = k + Math.imul(Ut, Or) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Ut, Ve) | 0) + Math.imul(zt, Or) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(zt, Ve) | 0) + (O >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, k = Math.imul(B, ir), O = (O = Math.imul(B, ge)) + Math.imul(j, ir) | 0, W = Math.imul(j, ge), k = k + Math.imul(jr, rr) | 0, O = (O = O + Math.imul(jr, be) | 0) + Math.imul(de, rr) | 0, W = W + Math.imul(de, be) | 0, k = k + Math.imul(se, Rr) | 0, O = (O = O + Math.imul(se, Te) | 0) + Math.imul(he, Rr) | 0, W = W + Math.imul(he, Te) | 0, k = k + Math.imul(De, Pr) | 0, O = (O = O + Math.imul(De, Ee) | 0) + Math.imul(ue, Pr) | 0, W = W + Math.imul(ue, Ee) | 0, k = k + Math.imul(Xt, Or) | 0, O = (O = O + Math.imul(Xt, Ve) | 0) + Math.imul(ie, Or) | 0, W = W + Math.imul(ie, Ve) | 0;
    var en = (It + (k = k + Math.imul(Ut, qr) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Ut, Je) | 0) + Math.imul(zt, qr) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(zt, Je) | 0) + (O >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, k = Math.imul(kt, ir), O = (O = Math.imul(kt, ge)) + Math.imul($t, ir) | 0, W = Math.imul($t, ge), k = k + Math.imul(B, rr) | 0, O = (O = O + Math.imul(B, be) | 0) + Math.imul(j, rr) | 0, W = W + Math.imul(j, be) | 0, k = k + Math.imul(jr, Rr) | 0, O = (O = O + Math.imul(jr, Te) | 0) + Math.imul(de, Rr) | 0, W = W + Math.imul(de, Te) | 0, k = k + Math.imul(se, Pr) | 0, O = (O = O + Math.imul(se, Ee) | 0) + Math.imul(he, Pr) | 0, W = W + Math.imul(he, Ee) | 0, k = k + Math.imul(De, Or) | 0, O = (O = O + Math.imul(De, Ve) | 0) + Math.imul(ue, Or) | 0, W = W + Math.imul(ue, Ve) | 0, k = k + Math.imul(Xt, qr) | 0, O = (O = O + Math.imul(Xt, Je) | 0) + Math.imul(ie, qr) | 0, W = W + Math.imul(ie, Je) | 0;
    var rn = (It + (k = k + Math.imul(Ut, Kr) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Ut, Ze) | 0) + Math.imul(zt, Kr) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(zt, Ze) | 0) + (O >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, k = Math.imul(Bt, ir), O = (O = Math.imul(Bt, ge)) + Math.imul(Ft, ir) | 0, W = Math.imul(Ft, ge), k = k + Math.imul(kt, rr) | 0, O = (O = O + Math.imul(kt, be) | 0) + Math.imul($t, rr) | 0, W = W + Math.imul($t, be) | 0, k = k + Math.imul(B, Rr) | 0, O = (O = O + Math.imul(B, Te) | 0) + Math.imul(j, Rr) | 0, W = W + Math.imul(j, Te) | 0, k = k + Math.imul(jr, Pr) | 0, O = (O = O + Math.imul(jr, Ee) | 0) + Math.imul(de, Pr) | 0, W = W + Math.imul(de, Ee) | 0, k = k + Math.imul(se, Or) | 0, O = (O = O + Math.imul(se, Ve) | 0) + Math.imul(he, Or) | 0, W = W + Math.imul(he, Ve) | 0, k = k + Math.imul(De, qr) | 0, O = (O = O + Math.imul(De, Je) | 0) + Math.imul(ue, qr) | 0, W = W + Math.imul(ue, Je) | 0, k = k + Math.imul(Xt, Kr) | 0, O = (O = O + Math.imul(Xt, Ze) | 0) + Math.imul(ie, Kr) | 0, W = W + Math.imul(ie, Ze) | 0;
    var nn = (It + (k = k + Math.imul(Ut, Hr) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Ut, Ye) | 0) + Math.imul(zt, Hr) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(zt, Ye) | 0) + (O >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, k = Math.imul(Zt, ir), O = (O = Math.imul(Zt, ge)) + Math.imul(Gt, ir) | 0, W = Math.imul(Gt, ge), k = k + Math.imul(Bt, rr) | 0, O = (O = O + Math.imul(Bt, be) | 0) + Math.imul(Ft, rr) | 0, W = W + Math.imul(Ft, be) | 0, k = k + Math.imul(kt, Rr) | 0, O = (O = O + Math.imul(kt, Te) | 0) + Math.imul($t, Rr) | 0, W = W + Math.imul($t, Te) | 0, k = k + Math.imul(B, Pr) | 0, O = (O = O + Math.imul(B, Ee) | 0) + Math.imul(j, Pr) | 0, W = W + Math.imul(j, Ee) | 0, k = k + Math.imul(jr, Or) | 0, O = (O = O + Math.imul(jr, Ve) | 0) + Math.imul(de, Or) | 0, W = W + Math.imul(de, Ve) | 0, k = k + Math.imul(se, qr) | 0, O = (O = O + Math.imul(se, Je) | 0) + Math.imul(he, qr) | 0, W = W + Math.imul(he, Je) | 0, k = k + Math.imul(De, Kr) | 0, O = (O = O + Math.imul(De, Ze) | 0) + Math.imul(ue, Kr) | 0, W = W + Math.imul(ue, Ze) | 0, k = k + Math.imul(Xt, Hr) | 0, O = (O = O + Math.imul(Xt, Ye) | 0) + Math.imul(ie, Hr) | 0, W = W + Math.imul(ie, Ye) | 0;
    var on = (It + (k = k + Math.imul(Ut, zr) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Ut, tr) | 0) + Math.imul(zt, zr) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(zt, tr) | 0) + (O >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, k = Math.imul(Ae, ir), O = (O = Math.imul(Ae, ge)) + Math.imul(ae, ir) | 0, W = Math.imul(ae, ge), k = k + Math.imul(Zt, rr) | 0, O = (O = O + Math.imul(Zt, be) | 0) + Math.imul(Gt, rr) | 0, W = W + Math.imul(Gt, be) | 0, k = k + Math.imul(Bt, Rr) | 0, O = (O = O + Math.imul(Bt, Te) | 0) + Math.imul(Ft, Rr) | 0, W = W + Math.imul(Ft, Te) | 0, k = k + Math.imul(kt, Pr) | 0, O = (O = O + Math.imul(kt, Ee) | 0) + Math.imul($t, Pr) | 0, W = W + Math.imul($t, Ee) | 0, k = k + Math.imul(B, Or) | 0, O = (O = O + Math.imul(B, Ve) | 0) + Math.imul(j, Or) | 0, W = W + Math.imul(j, Ve) | 0, k = k + Math.imul(jr, qr) | 0, O = (O = O + Math.imul(jr, Je) | 0) + Math.imul(de, qr) | 0, W = W + Math.imul(de, Je) | 0, k = k + Math.imul(se, Kr) | 0, O = (O = O + Math.imul(se, Ze) | 0) + Math.imul(he, Kr) | 0, W = W + Math.imul(he, Ze) | 0, k = k + Math.imul(De, Hr) | 0, O = (O = O + Math.imul(De, Ye) | 0) + Math.imul(ue, Hr) | 0, W = W + Math.imul(ue, Ye) | 0, k = k + Math.imul(Xt, zr) | 0, O = (O = O + Math.imul(Xt, tr) | 0) + Math.imul(ie, zr) | 0, W = W + Math.imul(ie, tr) | 0;
    var an = (It + (k = k + Math.imul(Ut, Ur) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Ut, Fr) | 0) + Math.imul(zt, Ur) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(zt, Fr) | 0) + (O >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, k = Math.imul(Ae, rr), O = (O = Math.imul(Ae, be)) + Math.imul(ae, rr) | 0, W = Math.imul(ae, be), k = k + Math.imul(Zt, Rr) | 0, O = (O = O + Math.imul(Zt, Te) | 0) + Math.imul(Gt, Rr) | 0, W = W + Math.imul(Gt, Te) | 0, k = k + Math.imul(Bt, Pr) | 0, O = (O = O + Math.imul(Bt, Ee) | 0) + Math.imul(Ft, Pr) | 0, W = W + Math.imul(Ft, Ee) | 0, k = k + Math.imul(kt, Or) | 0, O = (O = O + Math.imul(kt, Ve) | 0) + Math.imul($t, Or) | 0, W = W + Math.imul($t, Ve) | 0, k = k + Math.imul(B, qr) | 0, O = (O = O + Math.imul(B, Je) | 0) + Math.imul(j, qr) | 0, W = W + Math.imul(j, Je) | 0, k = k + Math.imul(jr, Kr) | 0, O = (O = O + Math.imul(jr, Ze) | 0) + Math.imul(de, Kr) | 0, W = W + Math.imul(de, Ze) | 0, k = k + Math.imul(se, Hr) | 0, O = (O = O + Math.imul(se, Ye) | 0) + Math.imul(he, Hr) | 0, W = W + Math.imul(he, Ye) | 0, k = k + Math.imul(De, zr) | 0, O = (O = O + Math.imul(De, tr) | 0) + Math.imul(ue, zr) | 0, W = W + Math.imul(ue, tr) | 0;
    var sn = (It + (k = k + Math.imul(Xt, Ur) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Xt, Fr) | 0) + Math.imul(ie, Ur) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(ie, Fr) | 0) + (O >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, k = Math.imul(Ae, Rr), O = (O = Math.imul(Ae, Te)) + Math.imul(ae, Rr) | 0, W = Math.imul(ae, Te), k = k + Math.imul(Zt, Pr) | 0, O = (O = O + Math.imul(Zt, Ee) | 0) + Math.imul(Gt, Pr) | 0, W = W + Math.imul(Gt, Ee) | 0, k = k + Math.imul(Bt, Or) | 0, O = (O = O + Math.imul(Bt, Ve) | 0) + Math.imul(Ft, Or) | 0, W = W + Math.imul(Ft, Ve) | 0, k = k + Math.imul(kt, qr) | 0, O = (O = O + Math.imul(kt, Je) | 0) + Math.imul($t, qr) | 0, W = W + Math.imul($t, Je) | 0, k = k + Math.imul(B, Kr) | 0, O = (O = O + Math.imul(B, Ze) | 0) + Math.imul(j, Kr) | 0, W = W + Math.imul(j, Ze) | 0, k = k + Math.imul(jr, Hr) | 0, O = (O = O + Math.imul(jr, Ye) | 0) + Math.imul(de, Hr) | 0, W = W + Math.imul(de, Ye) | 0, k = k + Math.imul(se, zr) | 0, O = (O = O + Math.imul(se, tr) | 0) + Math.imul(he, zr) | 0, W = W + Math.imul(he, tr) | 0;
    var cn = (It + (k = k + Math.imul(De, Ur) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(De, Fr) | 0) + Math.imul(ue, Ur) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(ue, Fr) | 0) + (O >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, k = Math.imul(Ae, Pr), O = (O = Math.imul(Ae, Ee)) + Math.imul(ae, Pr) | 0, W = Math.imul(ae, Ee), k = k + Math.imul(Zt, Or) | 0, O = (O = O + Math.imul(Zt, Ve) | 0) + Math.imul(Gt, Or) | 0, W = W + Math.imul(Gt, Ve) | 0, k = k + Math.imul(Bt, qr) | 0, O = (O = O + Math.imul(Bt, Je) | 0) + Math.imul(Ft, qr) | 0, W = W + Math.imul(Ft, Je) | 0, k = k + Math.imul(kt, Kr) | 0, O = (O = O + Math.imul(kt, Ze) | 0) + Math.imul($t, Kr) | 0, W = W + Math.imul($t, Ze) | 0, k = k + Math.imul(B, Hr) | 0, O = (O = O + Math.imul(B, Ye) | 0) + Math.imul(j, Hr) | 0, W = W + Math.imul(j, Ye) | 0, k = k + Math.imul(jr, zr) | 0, O = (O = O + Math.imul(jr, tr) | 0) + Math.imul(de, zr) | 0, W = W + Math.imul(de, tr) | 0;
    var Cn = (It + (k = k + Math.imul(se, Ur) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(se, Fr) | 0) + Math.imul(he, Ur) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(he, Fr) | 0) + (O >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, k = Math.imul(Ae, Or), O = (O = Math.imul(Ae, Ve)) + Math.imul(ae, Or) | 0, W = Math.imul(ae, Ve), k = k + Math.imul(Zt, qr) | 0, O = (O = O + Math.imul(Zt, Je) | 0) + Math.imul(Gt, qr) | 0, W = W + Math.imul(Gt, Je) | 0, k = k + Math.imul(Bt, Kr) | 0, O = (O = O + Math.imul(Bt, Ze) | 0) + Math.imul(Ft, Kr) | 0, W = W + Math.imul(Ft, Ze) | 0, k = k + Math.imul(kt, Hr) | 0, O = (O = O + Math.imul(kt, Ye) | 0) + Math.imul($t, Hr) | 0, W = W + Math.imul($t, Ye) | 0, k = k + Math.imul(B, zr) | 0, O = (O = O + Math.imul(B, tr) | 0) + Math.imul(j, zr) | 0, W = W + Math.imul(j, tr) | 0;
    var xn = (It + (k = k + Math.imul(jr, Ur) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(jr, Fr) | 0) + Math.imul(de, Ur) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(de, Fr) | 0) + (O >>> 13) | 0) + (xn >>> 26) | 0, xn &= 67108863, k = Math.imul(Ae, qr), O = (O = Math.imul(Ae, Je)) + Math.imul(ae, qr) | 0, W = Math.imul(ae, Je), k = k + Math.imul(Zt, Kr) | 0, O = (O = O + Math.imul(Zt, Ze) | 0) + Math.imul(Gt, Kr) | 0, W = W + Math.imul(Gt, Ze) | 0, k = k + Math.imul(Bt, Hr) | 0, O = (O = O + Math.imul(Bt, Ye) | 0) + Math.imul(Ft, Hr) | 0, W = W + Math.imul(Ft, Ye) | 0, k = k + Math.imul(kt, zr) | 0, O = (O = O + Math.imul(kt, tr) | 0) + Math.imul($t, zr) | 0, W = W + Math.imul($t, tr) | 0;
    var Pn = (It + (k = k + Math.imul(B, Ur) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(B, Fr) | 0) + Math.imul(j, Ur) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(j, Fr) | 0) + (O >>> 13) | 0) + (Pn >>> 26) | 0, Pn &= 67108863, k = Math.imul(Ae, Kr), O = (O = Math.imul(Ae, Ze)) + Math.imul(ae, Kr) | 0, W = Math.imul(ae, Ze), k = k + Math.imul(Zt, Hr) | 0, O = (O = O + Math.imul(Zt, Ye) | 0) + Math.imul(Gt, Hr) | 0, W = W + Math.imul(Gt, Ye) | 0, k = k + Math.imul(Bt, zr) | 0, O = (O = O + Math.imul(Bt, tr) | 0) + Math.imul(Ft, zr) | 0, W = W + Math.imul(Ft, tr) | 0;
    var Rn = (It + (k = k + Math.imul(kt, Ur) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(kt, Fr) | 0) + Math.imul($t, Ur) | 0)) << 13) | 0;
    It = ((W = W + Math.imul($t, Fr) | 0) + (O >>> 13) | 0) + (Rn >>> 26) | 0, Rn &= 67108863, k = Math.imul(Ae, Hr), O = (O = Math.imul(Ae, Ye)) + Math.imul(ae, Hr) | 0, W = Math.imul(ae, Ye), k = k + Math.imul(Zt, zr) | 0, O = (O = O + Math.imul(Zt, tr) | 0) + Math.imul(Gt, zr) | 0, W = W + Math.imul(Gt, tr) | 0;
    var Gn = (It + (k = k + Math.imul(Bt, Ur) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Bt, Fr) | 0) + Math.imul(Ft, Ur) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(Ft, Fr) | 0) + (O >>> 13) | 0) + (Gn >>> 26) | 0, Gn &= 67108863, k = Math.imul(Ae, zr), O = (O = Math.imul(Ae, tr)) + Math.imul(ae, zr) | 0, W = Math.imul(ae, tr);
    var Vn = (It + (k = k + Math.imul(Zt, Ur) | 0) | 0) + ((8191 & (O = (O = O + Math.imul(Zt, Fr) | 0) + Math.imul(Gt, Ur) | 0)) << 13) | 0;
    It = ((W = W + Math.imul(Gt, Fr) | 0) + (O >>> 13) | 0) + (Vn >>> 26) | 0, Vn &= 67108863;
    var ei = (It + (k = Math.imul(Ae, Ur)) | 0) + ((8191 & (O = (O = Math.imul(Ae, Fr)) + Math.imul(ae, Ur) | 0)) << 13) | 0;
    return It = ((W = Math.imul(ae, Fr)) + (O >>> 13) | 0) + (ei >>> 26) | 0, ei &= 67108863, xt[0] = Zr, xt[1] = Qr, xt[2] = Xr, xt[3] = Yr, xt[4] = tn, xt[5] = en, xt[6] = rn, xt[7] = nn, xt[8] = on, xt[9] = an, xt[10] = sn, xt[11] = cn, xt[12] = Cn, xt[13] = xn, xt[14] = Pn, xt[15] = Rn, xt[16] = Gn, xt[17] = Vn, xt[18] = ei, It !== 0 && (xt[19] = It, v.length++), v;
  };
  function st(E, w, v) {
    v.negative = w.negative ^ E.negative, v.length = E.length + w.length;
    for (var k = 0, O = 0, W = 0; W < v.length - 1; W++) {
      var it = O;
      O = 0;
      for (var vt = 67108863 & k, xt = Math.min(W, w.length - 1), It = Math.max(0, W - E.length + 1); It <= xt; It++) {
        var Wt = W - It, Ut = (0 | E.words[Wt]) * (0 | w.words[It]), zt = 67108863 & Ut;
        vt = 67108863 & (zt = zt + vt | 0), O += (it = (it = it + (Ut / 67108864 | 0) | 0) + (zt >>> 26) | 0) >>> 26, it &= 67108863;
      }
      v.words[W] = vt, k = it, it = O;
    }
    return k !== 0 ? v.words[W] = k : v.length--, v._strip();
  }
  function ot(E, w, v) {
    return st(E, w, v);
  }
  Math.imul || (nt = rt), h.prototype.mulTo = function(E, w) {
    var v = this.length + E.length;
    return this.length === 10 && E.length === 10 ? nt(this, E, w) : v < 63 ? rt(this, E, w) : v < 1024 ? st(this, E, w) : ot(this, E, w);
  }, h.prototype.mul = function(E) {
    var w = new h(null);
    return w.words = new Array(this.length + E.length), this.mulTo(E, w);
  }, h.prototype.mulf = function(E) {
    var w = new h(null);
    return w.words = new Array(this.length + E.length), ot(this, E, w);
  }, h.prototype.imul = function(E) {
    return this.clone().mulTo(E, this);
  }, h.prototype.imuln = function(E) {
    var w = E < 0;
    w && (E = -E), c(typeof E == "number"), c(E < 67108864);
    for (var v = 0, k = 0; k < this.length; k++) {
      var O = (0 | this.words[k]) * E, W = (67108863 & O) + (67108863 & v);
      v >>= 26, v += O / 67108864 | 0, v += W >>> 26, this.words[k] = 67108863 & W;
    }
    return v !== 0 && (this.words[k] = v, this.length++), w ? this.ineg() : this;
  }, h.prototype.muln = function(E) {
    return this.clone().imuln(E);
  }, h.prototype.sqr = function() {
    return this.mul(this);
  }, h.prototype.isqr = function() {
    return this.imul(this.clone());
  }, h.prototype.pow = function(E) {
    var w = function(W) {
      for (var it = new Array(W.bitLength()), vt = 0; vt < it.length; vt++) {
        var xt = vt / 26 | 0, It = vt % 26;
        it[vt] = W.words[xt] >>> It & 1;
      }
      return it;
    }(E);
    if (w.length === 0)
      return new h(1);
    for (var v = this, k = 0; k < w.length && w[k] === 0; k++, v = v.sqr())
      ;
    if (++k < w.length)
      for (var O = v.sqr(); k < w.length; k++, O = O.sqr())
        w[k] !== 0 && (v = v.mul(O));
    return v;
  }, h.prototype.iushln = function(E) {
    c(typeof E == "number" && E >= 0);
    var w, v = E % 26, k = (E - v) / 26, O = 67108863 >>> 26 - v << 26 - v;
    if (v !== 0) {
      var W = 0;
      for (w = 0; w < this.length; w++) {
        var it = this.words[w] & O, vt = (0 | this.words[w]) - it << v;
        this.words[w] = vt | W, W = it >>> 26 - v;
      }
      W && (this.words[w] = W, this.length++);
    }
    if (k !== 0) {
      for (w = this.length - 1; w >= 0; w--)
        this.words[w + k] = this.words[w];
      for (w = 0; w < k; w++)
        this.words[w] = 0;
      this.length += k;
    }
    return this._strip();
  }, h.prototype.ishln = function(E) {
    return c(this.negative === 0), this.iushln(E);
  }, h.prototype.iushrn = function(E, w, v) {
    var k;
    c(typeof E == "number" && E >= 0), k = w ? (w - w % 26) / 26 : 0;
    var O = E % 26, W = Math.min((E - O) / 26, this.length), it = 67108863 ^ 67108863 >>> O << O, vt = v;
    if (k -= W, k = Math.max(0, k), vt) {
      for (var xt = 0; xt < W; xt++)
        vt.words[xt] = this.words[xt];
      vt.length = W;
    }
    if (W !== 0)
      if (this.length > W)
        for (this.length -= W, xt = 0; xt < this.length; xt++)
          this.words[xt] = this.words[xt + W];
      else
        this.words[0] = 0, this.length = 1;
    var It = 0;
    for (xt = this.length - 1; xt >= 0 && (It !== 0 || xt >= k); xt--) {
      var Wt = 0 | this.words[xt];
      this.words[xt] = It << 26 - O | Wt >>> O, It = Wt & it;
    }
    return vt && It !== 0 && (vt.words[vt.length++] = It), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
  }, h.prototype.ishrn = function(E, w, v) {
    return c(this.negative === 0), this.iushrn(E, w, v);
  }, h.prototype.shln = function(E) {
    return this.clone().ishln(E);
  }, h.prototype.ushln = function(E) {
    return this.clone().iushln(E);
  }, h.prototype.shrn = function(E) {
    return this.clone().ishrn(E);
  }, h.prototype.ushrn = function(E) {
    return this.clone().iushrn(E);
  }, h.prototype.testn = function(E) {
    c(typeof E == "number" && E >= 0);
    var w = E % 26, v = (E - w) / 26, k = 1 << w;
    return !(this.length <= v || !(this.words[v] & k));
  }, h.prototype.imaskn = function(E) {
    c(typeof E == "number" && E >= 0);
    var w = E % 26, v = (E - w) / 26;
    if (c(this.negative === 0, "imaskn works only with positive numbers"), this.length <= v)
      return this;
    if (w !== 0 && v++, this.length = Math.min(v, this.length), w !== 0) {
      var k = 67108863 ^ 67108863 >>> w << w;
      this.words[this.length - 1] &= k;
    }
    return this._strip();
  }, h.prototype.maskn = function(E) {
    return this.clone().imaskn(E);
  }, h.prototype.iaddn = function(E) {
    return c(typeof E == "number"), c(E < 67108864), E < 0 ? this.isubn(-E) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) <= E ? (this.words[0] = E - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(E), this.negative = 1, this) : this._iaddn(E);
  }, h.prototype._iaddn = function(E) {
    this.words[0] += E;
    for (var w = 0; w < this.length && this.words[w] >= 67108864; w++)
      this.words[w] -= 67108864, w === this.length - 1 ? this.words[w + 1] = 1 : this.words[w + 1]++;
    return this.length = Math.max(this.length, w + 1), this;
  }, h.prototype.isubn = function(E) {
    if (c(typeof E == "number"), c(E < 67108864), E < 0)
      return this.iaddn(-E);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(E), this.negative = 1, this;
    if (this.words[0] -= E, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var w = 0; w < this.length && this.words[w] < 0; w++)
        this.words[w] += 67108864, this.words[w + 1] -= 1;
    return this._strip();
  }, h.prototype.addn = function(E) {
    return this.clone().iaddn(E);
  }, h.prototype.subn = function(E) {
    return this.clone().isubn(E);
  }, h.prototype.iabs = function() {
    return this.negative = 0, this;
  }, h.prototype.abs = function() {
    return this.clone().iabs();
  }, h.prototype._ishlnsubmul = function(E, w, v) {
    var k, O, W = E.length + v;
    this._expand(W);
    var it = 0;
    for (k = 0; k < E.length; k++) {
      O = (0 | this.words[k + v]) + it;
      var vt = (0 | E.words[k]) * w;
      it = ((O -= 67108863 & vt) >> 26) - (vt / 67108864 | 0), this.words[k + v] = 67108863 & O;
    }
    for (; k < this.length - v; k++)
      it = (O = (0 | this.words[k + v]) + it) >> 26, this.words[k + v] = 67108863 & O;
    if (it === 0)
      return this._strip();
    for (c(it === -1), it = 0, k = 0; k < this.length; k++)
      it = (O = -(0 | this.words[k]) + it) >> 26, this.words[k] = 67108863 & O;
    return this.negative = 1, this._strip();
  }, h.prototype._wordDiv = function(E, w) {
    var v = (this.length, E.length), k = this.clone(), O = E, W = 0 | O.words[O.length - 1];
    (v = 26 - this._countBits(W)) != 0 && (O = O.ushln(v), k.iushln(v), W = 0 | O.words[O.length - 1]);
    var it, vt = k.length - O.length;
    if (w !== "mod") {
      (it = new h(null)).length = vt + 1, it.words = new Array(it.length);
      for (var xt = 0; xt < it.length; xt++)
        it.words[xt] = 0;
    }
    var It = k.clone()._ishlnsubmul(O, 1, vt);
    It.negative === 0 && (k = It, it && (it.words[vt] = 1));
    for (var Wt = vt - 1; Wt >= 0; Wt--) {
      var Ut = 67108864 * (0 | k.words[O.length + Wt]) + (0 | k.words[O.length + Wt - 1]);
      for (Ut = Math.min(Ut / W | 0, 67108863), k._ishlnsubmul(O, Ut, Wt); k.negative !== 0; )
        Ut--, k.negative = 0, k._ishlnsubmul(O, 1, Wt), k.isZero() || (k.negative ^= 1);
      it && (it.words[Wt] = Ut);
    }
    return it && it._strip(), k._strip(), w !== "div" && v !== 0 && k.iushrn(v), { div: it || null, mod: k };
  }, h.prototype.divmod = function(E, w, v) {
    return c(!E.isZero()), this.isZero() ? { div: new h(0), mod: new h(0) } : this.negative !== 0 && E.negative === 0 ? (W = this.neg().divmod(E, w), w !== "mod" && (k = W.div.neg()), w !== "div" && (O = W.mod.neg(), v && O.negative !== 0 && O.iadd(E)), { div: k, mod: O }) : this.negative === 0 && E.negative !== 0 ? (W = this.divmod(E.neg(), w), w !== "mod" && (k = W.div.neg()), { div: k, mod: W.mod }) : (this.negative & E.negative) != 0 ? (W = this.neg().divmod(E.neg(), w), w !== "div" && (O = W.mod.neg(), v && O.negative !== 0 && O.isub(E)), { div: W.div, mod: O }) : E.length > this.length || this.cmp(E) < 0 ? { div: new h(0), mod: this } : E.length === 1 ? w === "div" ? { div: this.divn(E.words[0]), mod: null } : w === "mod" ? { div: null, mod: new h(this.modrn(E.words[0])) } : { div: this.divn(E.words[0]), mod: new h(this.modrn(E.words[0])) } : this._wordDiv(E, w);
    var k, O, W;
  }, h.prototype.div = function(E) {
    return this.divmod(E, "div", !1).div;
  }, h.prototype.mod = function(E) {
    return this.divmod(E, "mod", !1).mod;
  }, h.prototype.umod = function(E) {
    return this.divmod(E, "mod", !0).mod;
  }, h.prototype.divRound = function(E) {
    var w = this.divmod(E);
    if (w.mod.isZero())
      return w.div;
    var v = w.div.negative !== 0 ? w.mod.isub(E) : w.mod, k = E.ushrn(1), O = E.andln(1), W = v.cmp(k);
    return W < 0 || O === 1 && W === 0 ? w.div : w.div.negative !== 0 ? w.div.isubn(1) : w.div.iaddn(1);
  }, h.prototype.modrn = function(E) {
    var w = E < 0;
    w && (E = -E), c(E <= 67108863);
    for (var v = (1 << 26) % E, k = 0, O = this.length - 1; O >= 0; O--)
      k = (v * k + (0 | this.words[O])) % E;
    return w ? -k : k;
  }, h.prototype.modn = function(E) {
    return this.modrn(E);
  }, h.prototype.idivn = function(E) {
    var w = E < 0;
    w && (E = -E), c(E <= 67108863);
    for (var v = 0, k = this.length - 1; k >= 0; k--) {
      var O = (0 | this.words[k]) + 67108864 * v;
      this.words[k] = O / E | 0, v = O % E;
    }
    return this._strip(), w ? this.ineg() : this;
  }, h.prototype.divn = function(E) {
    return this.clone().idivn(E);
  }, h.prototype.egcd = function(E) {
    c(E.negative === 0), c(!E.isZero());
    var w = this, v = E.clone();
    w = w.negative !== 0 ? w.umod(E) : w.clone();
    for (var k = new h(1), O = new h(0), W = new h(0), it = new h(1), vt = 0; w.isEven() && v.isEven(); )
      w.iushrn(1), v.iushrn(1), ++vt;
    for (var xt = v.clone(), It = w.clone(); !w.isZero(); ) {
      for (var Wt = 0, Ut = 1; (w.words[0] & Ut) == 0 && Wt < 26; ++Wt, Ut <<= 1)
        ;
      if (Wt > 0)
        for (w.iushrn(Wt); Wt-- > 0; )
          (k.isOdd() || O.isOdd()) && (k.iadd(xt), O.isub(It)), k.iushrn(1), O.iushrn(1);
      for (var zt = 0, Jt = 1; (v.words[0] & Jt) == 0 && zt < 26; ++zt, Jt <<= 1)
        ;
      if (zt > 0)
        for (v.iushrn(zt); zt-- > 0; )
          (W.isOdd() || it.isOdd()) && (W.iadd(xt), it.isub(It)), W.iushrn(1), it.iushrn(1);
      w.cmp(v) >= 0 ? (w.isub(v), k.isub(W), O.isub(it)) : (v.isub(w), W.isub(k), it.isub(O));
    }
    return { a: W, b: it, gcd: v.iushln(vt) };
  }, h.prototype._invmp = function(E) {
    c(E.negative === 0), c(!E.isZero());
    var w = this, v = E.clone();
    w = w.negative !== 0 ? w.umod(E) : w.clone();
    for (var k, O = new h(1), W = new h(0), it = v.clone(); w.cmpn(1) > 0 && v.cmpn(1) > 0; ) {
      for (var vt = 0, xt = 1; (w.words[0] & xt) == 0 && vt < 26; ++vt, xt <<= 1)
        ;
      if (vt > 0)
        for (w.iushrn(vt); vt-- > 0; )
          O.isOdd() && O.iadd(it), O.iushrn(1);
      for (var It = 0, Wt = 1; (v.words[0] & Wt) == 0 && It < 26; ++It, Wt <<= 1)
        ;
      if (It > 0)
        for (v.iushrn(It); It-- > 0; )
          W.isOdd() && W.iadd(it), W.iushrn(1);
      w.cmp(v) >= 0 ? (w.isub(v), O.isub(W)) : (v.isub(w), W.isub(O));
    }
    return (k = w.cmpn(1) === 0 ? O : W).cmpn(0) < 0 && k.iadd(E), k;
  }, h.prototype.gcd = function(E) {
    if (this.isZero())
      return E.abs();
    if (E.isZero())
      return this.abs();
    var w = this.clone(), v = E.clone();
    w.negative = 0, v.negative = 0;
    for (var k = 0; w.isEven() && v.isEven(); k++)
      w.iushrn(1), v.iushrn(1);
    for (; ; ) {
      for (; w.isEven(); )
        w.iushrn(1);
      for (; v.isEven(); )
        v.iushrn(1);
      var O = w.cmp(v);
      if (O < 0) {
        var W = w;
        w = v, v = W;
      } else if (O === 0 || v.cmpn(1) === 0)
        break;
      w.isub(v);
    }
    return v.iushln(k);
  }, h.prototype.invm = function(E) {
    return this.egcd(E).a.umod(E);
  }, h.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, h.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, h.prototype.andln = function(E) {
    return this.words[0] & E;
  }, h.prototype.bincn = function(E) {
    c(typeof E == "number");
    var w = E % 26, v = (E - w) / 26, k = 1 << w;
    if (this.length <= v)
      return this._expand(v + 1), this.words[v] |= k, this;
    for (var O = k, W = v; O !== 0 && W < this.length; W++) {
      var it = 0 | this.words[W];
      O = (it += O) >>> 26, it &= 67108863, this.words[W] = it;
    }
    return O !== 0 && (this.words[W] = O, this.length++), this;
  }, h.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, h.prototype.cmpn = function(E) {
    var w, v = E < 0;
    if (this.negative !== 0 && !v)
      return -1;
    if (this.negative === 0 && v)
      return 1;
    if (this._strip(), this.length > 1)
      w = 1;
    else {
      v && (E = -E), c(E <= 67108863, "Number is too big");
      var k = 0 | this.words[0];
      w = k === E ? 0 : k < E ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -w : w;
  }, h.prototype.cmp = function(E) {
    if (this.negative !== 0 && E.negative === 0)
      return -1;
    if (this.negative === 0 && E.negative !== 0)
      return 1;
    var w = this.ucmp(E);
    return this.negative !== 0 ? 0 | -w : w;
  }, h.prototype.ucmp = function(E) {
    if (this.length > E.length)
      return 1;
    if (this.length < E.length)
      return -1;
    for (var w = 0, v = this.length - 1; v >= 0; v--) {
      var k = 0 | this.words[v], O = 0 | E.words[v];
      if (k !== O) {
        k < O ? w = -1 : k > O && (w = 1);
        break;
      }
    }
    return w;
  }, h.prototype.gtn = function(E) {
    return this.cmpn(E) === 1;
  }, h.prototype.gt = function(E) {
    return this.cmp(E) === 1;
  }, h.prototype.gten = function(E) {
    return this.cmpn(E) >= 0;
  }, h.prototype.gte = function(E) {
    return this.cmp(E) >= 0;
  }, h.prototype.ltn = function(E) {
    return this.cmpn(E) === -1;
  }, h.prototype.lt = function(E) {
    return this.cmp(E) === -1;
  }, h.prototype.lten = function(E) {
    return this.cmpn(E) <= 0;
  }, h.prototype.lte = function(E) {
    return this.cmp(E) <= 0;
  }, h.prototype.eqn = function(E) {
    return this.cmpn(E) === 0;
  }, h.prototype.eq = function(E) {
    return this.cmp(E) === 0;
  }, h.red = function(E) {
    return new m(E);
  }, h.prototype.toRed = function(E) {
    return c(!this.red, "Already a number in reduction context"), c(this.negative === 0, "red works only with positives"), E.convertTo(this)._forceRed(E);
  }, h.prototype.fromRed = function() {
    return c(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, h.prototype._forceRed = function(E) {
    return this.red = E, this;
  }, h.prototype.forceRed = function(E) {
    return c(!this.red, "Already a number in reduction context"), this._forceRed(E);
  }, h.prototype.redAdd = function(E) {
    return c(this.red, "redAdd works only with red numbers"), this.red.add(this, E);
  }, h.prototype.redIAdd = function(E) {
    return c(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, E);
  }, h.prototype.redSub = function(E) {
    return c(this.red, "redSub works only with red numbers"), this.red.sub(this, E);
  }, h.prototype.redISub = function(E) {
    return c(this.red, "redISub works only with red numbers"), this.red.isub(this, E);
  }, h.prototype.redShl = function(E) {
    return c(this.red, "redShl works only with red numbers"), this.red.shl(this, E);
  }, h.prototype.redMul = function(E) {
    return c(this.red, "redMul works only with red numbers"), this.red._verify2(this, E), this.red.mul(this, E);
  }, h.prototype.redIMul = function(E) {
    return c(this.red, "redMul works only with red numbers"), this.red._verify2(this, E), this.red.imul(this, E);
  }, h.prototype.redSqr = function() {
    return c(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, h.prototype.redISqr = function() {
    return c(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, h.prototype.redSqrt = function() {
    return c(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, h.prototype.redInvm = function() {
    return c(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, h.prototype.redNeg = function() {
    return c(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, h.prototype.redPow = function(E) {
    return c(this.red && !E.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, E);
  };
  var St = { k256: null, p224: null, p192: null, p25519: null };
  function Ct(E, w) {
    this.name = E, this.p = new h(w, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function et() {
    Ct.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function at() {
    Ct.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function _t() {
    Ct.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function Nt() {
    Ct.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function m(E) {
    if (typeof E == "string") {
      var w = h._prime(E);
      this.m = w.p, this.prime = w;
    } else
      c(E.gtn(1), "modulus must be greater than 1"), this.m = E, this.prime = null;
  }
  function A(E) {
    m.call(this, E), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  Ct.prototype._tmp = function() {
    var E = new h(null);
    return E.words = new Array(Math.ceil(this.n / 13)), E;
  }, Ct.prototype.ireduce = function(E) {
    var w, v = E;
    do
      this.split(v, this.tmp), w = (v = (v = this.imulK(v)).iadd(this.tmp)).bitLength();
    while (w > this.n);
    var k = w < this.n ? -1 : v.ucmp(this.p);
    return k === 0 ? (v.words[0] = 0, v.length = 1) : k > 0 ? v.isub(this.p) : v.strip !== void 0 ? v.strip() : v._strip(), v;
  }, Ct.prototype.split = function(E, w) {
    E.iushrn(this.n, 0, w);
  }, Ct.prototype.imulK = function(E) {
    return E.imul(this.k);
  }, u(et, Ct), et.prototype.split = function(E, w) {
    for (var v = 4194303, k = Math.min(E.length, 9), O = 0; O < k; O++)
      w.words[O] = E.words[O];
    if (w.length = k, E.length <= 9)
      return E.words[0] = 0, void (E.length = 1);
    var W = E.words[9];
    for (w.words[w.length++] = W & v, O = 10; O < E.length; O++) {
      var it = 0 | E.words[O];
      E.words[O - 10] = (it & v) << 4 | W >>> 22, W = it;
    }
    W >>>= 22, E.words[O - 10] = W, W === 0 && E.length > 10 ? E.length -= 10 : E.length -= 9;
  }, et.prototype.imulK = function(E) {
    E.words[E.length] = 0, E.words[E.length + 1] = 0, E.length += 2;
    for (var w = 0, v = 0; v < E.length; v++) {
      var k = 0 | E.words[v];
      w += 977 * k, E.words[v] = 67108863 & w, w = 64 * k + (w / 67108864 | 0);
    }
    return E.words[E.length - 1] === 0 && (E.length--, E.words[E.length - 1] === 0 && E.length--), E;
  }, u(at, Ct), u(_t, Ct), u(Nt, Ct), Nt.prototype.imulK = function(E) {
    for (var w = 0, v = 0; v < E.length; v++) {
      var k = 19 * (0 | E.words[v]) + w, O = 67108863 & k;
      k >>>= 26, E.words[v] = O, w = k;
    }
    return w !== 0 && (E.words[E.length++] = w), E;
  }, h._prime = function(E) {
    if (St[E])
      return St[E];
    var w;
    if (E === "k256")
      w = new et();
    else if (E === "p224")
      w = new at();
    else if (E === "p192")
      w = new _t();
    else {
      if (E !== "p25519")
        throw new Error("Unknown prime " + E);
      w = new Nt();
    }
    return St[E] = w, w;
  }, m.prototype._verify1 = function(E) {
    c(E.negative === 0, "red works only with positives"), c(E.red, "red works only with red numbers");
  }, m.prototype._verify2 = function(E, w) {
    c((E.negative | w.negative) == 0, "red works only with positives"), c(E.red && E.red === w.red, "red works only with red numbers");
  }, m.prototype.imod = function(E) {
    return this.prime ? this.prime.ireduce(E)._forceRed(this) : (P(E, E.umod(this.m)._forceRed(this)), E);
  }, m.prototype.neg = function(E) {
    return E.isZero() ? E.clone() : this.m.sub(E)._forceRed(this);
  }, m.prototype.add = function(E, w) {
    this._verify2(E, w);
    var v = E.add(w);
    return v.cmp(this.m) >= 0 && v.isub(this.m), v._forceRed(this);
  }, m.prototype.iadd = function(E, w) {
    this._verify2(E, w);
    var v = E.iadd(w);
    return v.cmp(this.m) >= 0 && v.isub(this.m), v;
  }, m.prototype.sub = function(E, w) {
    this._verify2(E, w);
    var v = E.sub(w);
    return v.cmpn(0) < 0 && v.iadd(this.m), v._forceRed(this);
  }, m.prototype.isub = function(E, w) {
    this._verify2(E, w);
    var v = E.isub(w);
    return v.cmpn(0) < 0 && v.iadd(this.m), v;
  }, m.prototype.shl = function(E, w) {
    return this._verify1(E), this.imod(E.ushln(w));
  }, m.prototype.imul = function(E, w) {
    return this._verify2(E, w), this.imod(E.imul(w));
  }, m.prototype.mul = function(E, w) {
    return this._verify2(E, w), this.imod(E.mul(w));
  }, m.prototype.isqr = function(E) {
    return this.imul(E, E.clone());
  }, m.prototype.sqr = function(E) {
    return this.mul(E, E);
  }, m.prototype.sqrt = function(E) {
    if (E.isZero())
      return E.clone();
    var w = this.m.andln(3);
    if (c(w % 2 == 1), w === 3) {
      var v = this.m.add(new h(1)).iushrn(2);
      return this.pow(E, v);
    }
    for (var k = this.m.subn(1), O = 0; !k.isZero() && k.andln(1) === 0; )
      O++, k.iushrn(1);
    c(!k.isZero());
    var W = new h(1).toRed(this), it = W.redNeg(), vt = this.m.subn(1).iushrn(1), xt = this.m.bitLength();
    for (xt = new h(2 * xt * xt).toRed(this); this.pow(xt, vt).cmp(it) !== 0; )
      xt.redIAdd(it);
    for (var It = this.pow(xt, k), Wt = this.pow(E, k.addn(1).iushrn(1)), Ut = this.pow(E, k), zt = O; Ut.cmp(W) !== 0; ) {
      for (var Jt = Ut, Xt = 0; Jt.cmp(W) !== 0; Xt++)
        Jt = Jt.redSqr();
      c(Xt < zt);
      var ie = this.pow(It, new h(1).iushln(zt - Xt - 1));
      Wt = Wt.redMul(ie), It = ie.redSqr(), Ut = Ut.redMul(It), zt = Xt;
    }
    return Wt;
  }, m.prototype.invm = function(E) {
    var w = E._invmp(this.m);
    return w.negative !== 0 ? (w.negative = 0, this.imod(w).redNeg()) : this.imod(w);
  }, m.prototype.pow = function(E, w) {
    if (w.isZero())
      return new h(1).toRed(this);
    if (w.cmpn(1) === 0)
      return E.clone();
    var v = new Array(16);
    v[0] = new h(1).toRed(this), v[1] = E;
    for (var k = 2; k < v.length; k++)
      v[k] = this.mul(v[k - 1], E);
    var O = v[0], W = 0, it = 0, vt = w.bitLength() % 26;
    for (vt === 0 && (vt = 26), k = w.length - 1; k >= 0; k--) {
      for (var xt = w.words[k], It = vt - 1; It >= 0; It--) {
        var Wt = xt >> It & 1;
        O !== v[0] && (O = this.sqr(O)), Wt !== 0 || W !== 0 ? (W <<= 1, W |= Wt, (++it == 4 || k === 0 && It === 0) && (O = this.mul(O, v[W]), it = 0, W = 0)) : it = 0;
      }
      vt = 26;
    }
    return O;
  }, m.prototype.convertTo = function(E) {
    var w = E.umod(this.m);
    return w === E ? w.clone() : w;
  }, m.prototype.convertFrom = function(E) {
    var w = E.clone();
    return w.red = null, w;
  }, h.mont = function(E) {
    return new A(E);
  }, u(A, m), A.prototype.convertTo = function(E) {
    return this.imod(E.ushln(this.shift));
  }, A.prototype.convertFrom = function(E) {
    var w = this.imod(E.mul(this.rinv));
    return w.red = null, w;
  }, A.prototype.imul = function(E, w) {
    if (E.isZero() || w.isZero())
      return E.words[0] = 0, E.length = 1, E;
    var v = E.imul(w), k = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = v.isub(k).iushrn(this.shift), W = O;
    return O.cmp(this.m) >= 0 ? W = O.isub(this.m) : O.cmpn(0) < 0 && (W = O.iadd(this.m)), W._forceRed(this);
  }, A.prototype.mul = function(E, w) {
    if (E.isZero() || w.isZero())
      return new h(0)._forceRed(this);
    var v = E.mul(w), k = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = v.isub(k).iushrn(this.shift), W = O;
    return O.cmp(this.m) >= 0 ? W = O.isub(this.m) : O.cmpn(0) < 0 && (W = O.iadd(this.m)), W._forceRed(this);
  }, A.prototype.invm = function(E) {
    return this.imod(E._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var sha256$1 = { exports: {} };
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function(module) {
  (function() {
    var ERROR = "input is invalid type", WINDOW = typeof window == "object", root = WINDOW ? window : {};
    root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
    var WEB_WORKER = !WINDOW && typeof self == "object", NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    NODE_JS ? root = commonjsGlobal : WEB_WORKER && (root = self);
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && module.exports, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"], blocks = [];
    !root.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(o) {
      return Object.prototype.toString.call(o) === "[object Array]";
    }), !ARRAY_BUFFER || !root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(o) {
      return typeof o == "object" && o.buffer && o.buffer.constructor === ArrayBuffer;
    });
    var createOutputMethod = function(o, n) {
      return function(c) {
        return new Sha256(n, !0).update(c)[o]();
      };
    }, createMethod = function(o) {
      var n = createOutputMethod("hex", o);
      NODE_JS && (n = nodeWrap(n, o)), n.create = function() {
        return new Sha256(o);
      }, n.update = function(h) {
        return n.create().update(h);
      };
      for (var c = 0; c < OUTPUT_TYPES.length; ++c) {
        var u = OUTPUT_TYPES[c];
        n[u] = createOutputMethod(u, o);
      }
      return n;
    }, nodeWrap = function(method, is224) {
      var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? "sha224" : "sha256", nodeMethod = function(o) {
        if (typeof o == "string")
          return crypto.createHash(algorithm).update(o, "utf8").digest("hex");
        if (o == null)
          throw new Error(ERROR);
        return o.constructor === ArrayBuffer && (o = new Uint8Array(o)), Array.isArray(o) || ArrayBuffer.isView(o) || o.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(o)).digest("hex") : method(o);
      };
      return nodeMethod;
    }, createHmacOutputMethod = function(o, n) {
      return function(c, u) {
        return new HmacSha256(c, n, !0).update(u)[o]();
      };
    }, createHmacMethod = function(o) {
      var n = createHmacOutputMethod("hex", o);
      n.create = function(h) {
        return new HmacSha256(h, o);
      }, n.update = function(h, g) {
        return n.create(h).update(g);
      };
      for (var c = 0; c < OUTPUT_TYPES.length; ++c) {
        var u = OUTPUT_TYPES[c];
        n[u] = createHmacOutputMethod(u, o);
      }
      return n;
    };
    function Sha256(o, n) {
      n ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], o ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = o;
    }
    function HmacSha256(o, n, c) {
      var u, h = typeof o;
      if (h === "string") {
        var g, y = [], $ = o.length, I = 0;
        for (u = 0; u < $; ++u)
          (g = o.charCodeAt(u)) < 128 ? y[I++] = g : g < 2048 ? (y[I++] = 192 | g >> 6, y[I++] = 128 | 63 & g) : g < 55296 || g >= 57344 ? (y[I++] = 224 | g >> 12, y[I++] = 128 | g >> 6 & 63, y[I++] = 128 | 63 & g) : (g = 65536 + ((1023 & g) << 10 | 1023 & o.charCodeAt(++u)), y[I++] = 240 | g >> 18, y[I++] = 128 | g >> 12 & 63, y[I++] = 128 | g >> 6 & 63, y[I++] = 128 | 63 & g);
        o = y;
      } else {
        if (h !== "object")
          throw new Error(ERROR);
        if (o === null)
          throw new Error(ERROR);
        if (ARRAY_BUFFER && o.constructor === ArrayBuffer)
          o = new Uint8Array(o);
        else if (!(Array.isArray(o) || ARRAY_BUFFER && ArrayBuffer.isView(o)))
          throw new Error(ERROR);
      }
      o.length > 64 && (o = new Sha256(n, !0).update(o).array());
      var P = [], L = [];
      for (u = 0; u < 64; ++u) {
        var q = o[u] || 0;
        P[u] = 92 ^ q, L[u] = 54 ^ q;
      }
      Sha256.call(this, n, c), this.update(L), this.oKeyPad = P, this.inner = !0, this.sharedMemory = c;
    }
    Sha256.prototype.update = function(o) {
      if (!this.finalized) {
        var n, c = typeof o;
        if (c !== "string") {
          if (c !== "object")
            throw new Error(ERROR);
          if (o === null)
            throw new Error(ERROR);
          if (ARRAY_BUFFER && o.constructor === ArrayBuffer)
            o = new Uint8Array(o);
          else if (!(Array.isArray(o) || ARRAY_BUFFER && ArrayBuffer.isView(o)))
            throw new Error(ERROR);
          n = !0;
        }
        for (var u, h, g = 0, y = o.length, $ = this.blocks; g < y; ) {
          if (this.hashed && (this.hashed = !1, $[0] = this.block, $[16] = $[1] = $[2] = $[3] = $[4] = $[5] = $[6] = $[7] = $[8] = $[9] = $[10] = $[11] = $[12] = $[13] = $[14] = $[15] = 0), n)
            for (h = this.start; g < y && h < 64; ++g)
              $[h >> 2] |= o[g] << SHIFT[3 & h++];
          else
            for (h = this.start; g < y && h < 64; ++g)
              (u = o.charCodeAt(g)) < 128 ? $[h >> 2] |= u << SHIFT[3 & h++] : u < 2048 ? ($[h >> 2] |= (192 | u >> 6) << SHIFT[3 & h++], $[h >> 2] |= (128 | 63 & u) << SHIFT[3 & h++]) : u < 55296 || u >= 57344 ? ($[h >> 2] |= (224 | u >> 12) << SHIFT[3 & h++], $[h >> 2] |= (128 | u >> 6 & 63) << SHIFT[3 & h++], $[h >> 2] |= (128 | 63 & u) << SHIFT[3 & h++]) : (u = 65536 + ((1023 & u) << 10 | 1023 & o.charCodeAt(++g)), $[h >> 2] |= (240 | u >> 18) << SHIFT[3 & h++], $[h >> 2] |= (128 | u >> 12 & 63) << SHIFT[3 & h++], $[h >> 2] |= (128 | u >> 6 & 63) << SHIFT[3 & h++], $[h >> 2] |= (128 | 63 & u) << SHIFT[3 & h++]);
          this.lastByteIndex = h, this.bytes += h - this.start, h >= 64 ? (this.block = $[16], this.start = h - 64, this.hash(), this.hashed = !0) : this.start = h;
        }
        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
      }
    }, Sha256.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var o = this.blocks, n = this.lastByteIndex;
        o[16] = this.block, o[n >> 2] |= EXTRA[3 & n], this.block = o[16], n >= 56 && (this.hashed || this.hash(), o[0] = this.block, o[16] = o[1] = o[2] = o[3] = o[4] = o[5] = o[6] = o[7] = o[8] = o[9] = o[10] = o[11] = o[12] = o[13] = o[14] = o[15] = 0), o[14] = this.hBytes << 3 | this.bytes >>> 29, o[15] = this.bytes << 3, this.hash();
      }
    }, Sha256.prototype.hash = function() {
      var o, n, c, u, h, g, y, $, I, P = this.h0, L = this.h1, q = this.h2, N = this.h3, X = this.h4, rt = this.h5, nt = this.h6, st = this.h7, ot = this.blocks;
      for (o = 16; o < 64; ++o)
        n = ((h = ot[o - 15]) >>> 7 | h << 25) ^ (h >>> 18 | h << 14) ^ h >>> 3, c = ((h = ot[o - 2]) >>> 17 | h << 15) ^ (h >>> 19 | h << 13) ^ h >>> 10, ot[o] = ot[o - 16] + n + ot[o - 7] + c << 0;
      for (I = L & q, o = 0; o < 64; o += 4)
        this.first ? (this.is224 ? (g = 300032, st = (h = ot[0] - 1413257819) - 150054599 << 0, N = h + 24177077 << 0) : (g = 704751109, st = (h = ot[0] - 210244248) - 1521486534 << 0, N = h + 143694565 << 0), this.first = !1) : (n = (P >>> 2 | P << 30) ^ (P >>> 13 | P << 19) ^ (P >>> 22 | P << 10), u = (g = P & L) ^ P & q ^ I, st = N + (h = st + (c = (X >>> 6 | X << 26) ^ (X >>> 11 | X << 21) ^ (X >>> 25 | X << 7)) + (X & rt ^ ~X & nt) + K[o] + ot[o]) << 0, N = h + (n + u) << 0), n = (N >>> 2 | N << 30) ^ (N >>> 13 | N << 19) ^ (N >>> 22 | N << 10), u = (y = N & P) ^ N & L ^ g, nt = q + (h = nt + (c = (st >>> 6 | st << 26) ^ (st >>> 11 | st << 21) ^ (st >>> 25 | st << 7)) + (st & X ^ ~st & rt) + K[o + 1] + ot[o + 1]) << 0, n = ((q = h + (n + u) << 0) >>> 2 | q << 30) ^ (q >>> 13 | q << 19) ^ (q >>> 22 | q << 10), u = ($ = q & N) ^ q & P ^ y, rt = L + (h = rt + (c = (nt >>> 6 | nt << 26) ^ (nt >>> 11 | nt << 21) ^ (nt >>> 25 | nt << 7)) + (nt & st ^ ~nt & X) + K[o + 2] + ot[o + 2]) << 0, n = ((L = h + (n + u) << 0) >>> 2 | L << 30) ^ (L >>> 13 | L << 19) ^ (L >>> 22 | L << 10), u = (I = L & q) ^ L & N ^ $, X = P + (h = X + (c = (rt >>> 6 | rt << 26) ^ (rt >>> 11 | rt << 21) ^ (rt >>> 25 | rt << 7)) + (rt & nt ^ ~rt & st) + K[o + 3] + ot[o + 3]) << 0, P = h + (n + u) << 0;
      this.h0 = this.h0 + P << 0, this.h1 = this.h1 + L << 0, this.h2 = this.h2 + q << 0, this.h3 = this.h3 + N << 0, this.h4 = this.h4 + X << 0, this.h5 = this.h5 + rt << 0, this.h6 = this.h6 + nt << 0, this.h7 = this.h7 + st << 0;
    }, Sha256.prototype.hex = function() {
      this.finalize();
      var o = this.h0, n = this.h1, c = this.h2, u = this.h3, h = this.h4, g = this.h5, y = this.h6, $ = this.h7, I = HEX_CHARS[o >> 28 & 15] + HEX_CHARS[o >> 24 & 15] + HEX_CHARS[o >> 20 & 15] + HEX_CHARS[o >> 16 & 15] + HEX_CHARS[o >> 12 & 15] + HEX_CHARS[o >> 8 & 15] + HEX_CHARS[o >> 4 & 15] + HEX_CHARS[15 & o] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[c >> 28 & 15] + HEX_CHARS[c >> 24 & 15] + HEX_CHARS[c >> 20 & 15] + HEX_CHARS[c >> 16 & 15] + HEX_CHARS[c >> 12 & 15] + HEX_CHARS[c >> 8 & 15] + HEX_CHARS[c >> 4 & 15] + HEX_CHARS[15 & c] + HEX_CHARS[u >> 28 & 15] + HEX_CHARS[u >> 24 & 15] + HEX_CHARS[u >> 20 & 15] + HEX_CHARS[u >> 16 & 15] + HEX_CHARS[u >> 12 & 15] + HEX_CHARS[u >> 8 & 15] + HEX_CHARS[u >> 4 & 15] + HEX_CHARS[15 & u] + HEX_CHARS[h >> 28 & 15] + HEX_CHARS[h >> 24 & 15] + HEX_CHARS[h >> 20 & 15] + HEX_CHARS[h >> 16 & 15] + HEX_CHARS[h >> 12 & 15] + HEX_CHARS[h >> 8 & 15] + HEX_CHARS[h >> 4 & 15] + HEX_CHARS[15 & h] + HEX_CHARS[g >> 28 & 15] + HEX_CHARS[g >> 24 & 15] + HEX_CHARS[g >> 20 & 15] + HEX_CHARS[g >> 16 & 15] + HEX_CHARS[g >> 12 & 15] + HEX_CHARS[g >> 8 & 15] + HEX_CHARS[g >> 4 & 15] + HEX_CHARS[15 & g] + HEX_CHARS[y >> 28 & 15] + HEX_CHARS[y >> 24 & 15] + HEX_CHARS[y >> 20 & 15] + HEX_CHARS[y >> 16 & 15] + HEX_CHARS[y >> 12 & 15] + HEX_CHARS[y >> 8 & 15] + HEX_CHARS[y >> 4 & 15] + HEX_CHARS[15 & y];
      return this.is224 || (I += HEX_CHARS[$ >> 28 & 15] + HEX_CHARS[$ >> 24 & 15] + HEX_CHARS[$ >> 20 & 15] + HEX_CHARS[$ >> 16 & 15] + HEX_CHARS[$ >> 12 & 15] + HEX_CHARS[$ >> 8 & 15] + HEX_CHARS[$ >> 4 & 15] + HEX_CHARS[15 & $]), I;
    }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
      this.finalize();
      var o = this.h0, n = this.h1, c = this.h2, u = this.h3, h = this.h4, g = this.h5, y = this.h6, $ = this.h7, I = [o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o, n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, 255 & n, c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, 255 & c, u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, 255 & u, h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, 255 & h, g >> 24 & 255, g >> 16 & 255, g >> 8 & 255, 255 & g, y >> 24 & 255, y >> 16 & 255, y >> 8 & 255, 255 & y];
      return this.is224 || I.push($ >> 24 & 255, $ >> 16 & 255, $ >> 8 & 255, 255 & $), I;
    }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var o = new ArrayBuffer(this.is224 ? 28 : 32), n = new DataView(o);
      return n.setUint32(0, this.h0), n.setUint32(4, this.h1), n.setUint32(8, this.h2), n.setUint32(12, this.h3), n.setUint32(16, this.h4), n.setUint32(20, this.h5), n.setUint32(24, this.h6), this.is224 || n.setUint32(28, this.h7), o;
    }, HmacSha256.prototype = new Sha256(), HmacSha256.prototype.finalize = function() {
      if (Sha256.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var o = this.array();
        Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(o), Sha256.prototype.finalize.call(this);
      }
    };
    var exports = createMethod();
    exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224);
  })();
})(sha256$1);
var sha512$1 = { exports: {} };
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
(function(o) {
  (function() {
    var n = "input is invalid type", c = typeof window == "object", u = c ? window : {};
    u.JS_SHA512_NO_WINDOW && (c = !1);
    var h = !c && typeof self == "object";
    !u.JS_SHA512_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node ? u = commonjsGlobal : h && (u = self);
    var g = !u.JS_SHA512_NO_COMMON_JS && o.exports, y = !u.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", $ = "0123456789abcdef".split(""), I = [-2147483648, 8388608, 32768, 128], P = [24, 16, 8, 0], L = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], q = ["hex", "array", "digest", "arrayBuffer"], N = [];
    !u.JS_SHA512_NO_NODE_JS && Array.isArray || (Array.isArray = function(et) {
      return Object.prototype.toString.call(et) === "[object Array]";
    }), !y || !u.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(et) {
      return typeof et == "object" && et.buffer && et.buffer.constructor === ArrayBuffer;
    });
    var X = function(et, at) {
      return function(_t) {
        return new ot(at, !0).update(_t)[et]();
      };
    }, rt = function(et) {
      var at = X("hex", et);
      at.create = function() {
        return new ot(et);
      }, at.update = function(m) {
        return at.create().update(m);
      };
      for (var _t = 0; _t < q.length; ++_t) {
        var Nt = q[_t];
        at[Nt] = X(Nt, et);
      }
      return at;
    }, nt = function(et, at) {
      return function(_t, Nt) {
        return new St(_t, at, !0).update(Nt)[et]();
      };
    }, st = function(et) {
      var at = nt("hex", et);
      at.create = function(m) {
        return new St(m, et);
      }, at.update = function(m, A) {
        return at.create(m).update(A);
      };
      for (var _t = 0; _t < q.length; ++_t) {
        var Nt = q[_t];
        at[Nt] = nt(Nt, et);
      }
      return at;
    };
    function ot(et, at) {
      at ? (N[0] = N[1] = N[2] = N[3] = N[4] = N[5] = N[6] = N[7] = N[8] = N[9] = N[10] = N[11] = N[12] = N[13] = N[14] = N[15] = N[16] = N[17] = N[18] = N[19] = N[20] = N[21] = N[22] = N[23] = N[24] = N[25] = N[26] = N[27] = N[28] = N[29] = N[30] = N[31] = N[32] = 0, this.blocks = N) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], et == 384 ? (this.h0h = 3418070365, this.h0l = 3238371032, this.h1h = 1654270250, this.h1l = 914150663, this.h2h = 2438529370, this.h2l = 812702999, this.h3h = 355462360, this.h3l = 4144912697, this.h4h = 1731405415, this.h4l = 4290775857, this.h5h = 2394180231, this.h5l = 1750603025, this.h6h = 3675008525, this.h6l = 1694076839, this.h7h = 1203062813, this.h7l = 3204075428) : et == 256 ? (this.h0h = 573645204, this.h0l = 4230739756, this.h1h = 2673172387, this.h1l = 3360449730, this.h2h = 596883563, this.h2l = 1867755857, this.h3h = 2520282905, this.h3l = 1497426621, this.h4h = 2519219938, this.h4l = 2827943907, this.h5h = 3193839141, this.h5l = 1401305490, this.h6h = 721525244, this.h6l = 746961066, this.h7h = 246885852, this.h7l = 2177182882) : et == 224 ? (this.h0h = 2352822216, this.h0l = 424955298, this.h1h = 1944164710, this.h1l = 2312950998, this.h2h = 502970286, this.h2l = 855612546, this.h3h = 1738396948, this.h3l = 1479516111, this.h4h = 258812777, this.h4l = 2077511080, this.h5h = 2011393907, this.h5l = 79989058, this.h6h = 1067287976, this.h6l = 1780299464, this.h7h = 286451373, this.h7l = 2446758561) : (this.h0h = 1779033703, this.h0l = 4089235720, this.h1h = 3144134277, this.h1l = 2227873595, this.h2h = 1013904242, this.h2l = 4271175723, this.h3h = 2773480762, this.h3l = 1595750129, this.h4h = 1359893119, this.h4l = 2917565137, this.h5h = 2600822924, this.h5l = 725511199, this.h6h = 528734635, this.h6l = 4215389547, this.h7h = 1541459225, this.h7l = 327033209), this.bits = et, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1;
    }
    function St(et, at, _t) {
      var Nt, m = typeof et;
      if (m !== "string") {
        if (m !== "object")
          throw new Error(n);
        if (et === null)
          throw new Error(n);
        if (y && et.constructor === ArrayBuffer)
          et = new Uint8Array(et);
        else if (!(Array.isArray(et) || y && ArrayBuffer.isView(et)))
          throw new Error(n);
        Nt = !0;
      }
      var A = et.length;
      if (!Nt) {
        for (var E, w = [], v = (A = et.length, 0), k = 0; k < A; ++k)
          (E = et.charCodeAt(k)) < 128 ? w[v++] = E : E < 2048 ? (w[v++] = 192 | E >> 6, w[v++] = 128 | 63 & E) : E < 55296 || E >= 57344 ? (w[v++] = 224 | E >> 12, w[v++] = 128 | E >> 6 & 63, w[v++] = 128 | 63 & E) : (E = 65536 + ((1023 & E) << 10 | 1023 & et.charCodeAt(++k)), w[v++] = 240 | E >> 18, w[v++] = 128 | E >> 12 & 63, w[v++] = 128 | E >> 6 & 63, w[v++] = 128 | 63 & E);
        et = w;
      }
      et.length > 128 && (et = new ot(at, !0).update(et).array());
      var O = [], W = [];
      for (k = 0; k < 128; ++k) {
        var it = et[k] || 0;
        O[k] = 92 ^ it, W[k] = 54 ^ it;
      }
      ot.call(this, at, _t), this.update(W), this.oKeyPad = O, this.inner = !0, this.sharedMemory = _t;
    }
    ot.prototype.update = function(et) {
      if (this.finalized)
        throw new Error("finalize already called");
      var at, _t = typeof et;
      if (_t !== "string") {
        if (_t !== "object")
          throw new Error(n);
        if (et === null)
          throw new Error(n);
        if (y && et.constructor === ArrayBuffer)
          et = new Uint8Array(et);
        else if (!(Array.isArray(et) || y && ArrayBuffer.isView(et)))
          throw new Error(n);
        at = !0;
      }
      for (var Nt, m, A = 0, E = et.length, w = this.blocks; A < E; ) {
        if (this.hashed && (this.hashed = !1, w[0] = this.block, w[1] = w[2] = w[3] = w[4] = w[5] = w[6] = w[7] = w[8] = w[9] = w[10] = w[11] = w[12] = w[13] = w[14] = w[15] = w[16] = w[17] = w[18] = w[19] = w[20] = w[21] = w[22] = w[23] = w[24] = w[25] = w[26] = w[27] = w[28] = w[29] = w[30] = w[31] = w[32] = 0), at)
          for (m = this.start; A < E && m < 128; ++A)
            w[m >> 2] |= et[A] << P[3 & m++];
        else
          for (m = this.start; A < E && m < 128; ++A)
            (Nt = et.charCodeAt(A)) < 128 ? w[m >> 2] |= Nt << P[3 & m++] : Nt < 2048 ? (w[m >> 2] |= (192 | Nt >> 6) << P[3 & m++], w[m >> 2] |= (128 | 63 & Nt) << P[3 & m++]) : Nt < 55296 || Nt >= 57344 ? (w[m >> 2] |= (224 | Nt >> 12) << P[3 & m++], w[m >> 2] |= (128 | Nt >> 6 & 63) << P[3 & m++], w[m >> 2] |= (128 | 63 & Nt) << P[3 & m++]) : (Nt = 65536 + ((1023 & Nt) << 10 | 1023 & et.charCodeAt(++A)), w[m >> 2] |= (240 | Nt >> 18) << P[3 & m++], w[m >> 2] |= (128 | Nt >> 12 & 63) << P[3 & m++], w[m >> 2] |= (128 | Nt >> 6 & 63) << P[3 & m++], w[m >> 2] |= (128 | 63 & Nt) << P[3 & m++]);
        this.lastByteIndex = m, this.bytes += m - this.start, m >= 128 ? (this.block = w[32], this.start = m - 128, this.hash(), this.hashed = !0) : this.start = m;
      }
      return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
    }, ot.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var et = this.blocks, at = this.lastByteIndex;
        et[32] = this.block, et[at >> 2] |= I[3 & at], this.block = et[32], at >= 112 && (this.hashed || this.hash(), et[0] = this.block, et[1] = et[2] = et[3] = et[4] = et[5] = et[6] = et[7] = et[8] = et[9] = et[10] = et[11] = et[12] = et[13] = et[14] = et[15] = et[16] = et[17] = et[18] = et[19] = et[20] = et[21] = et[22] = et[23] = et[24] = et[25] = et[26] = et[27] = et[28] = et[29] = et[30] = et[31] = et[32] = 0), et[30] = this.hBytes << 3 | this.bytes >>> 29, et[31] = this.bytes << 3, this.hash();
      }
    }, ot.prototype.hash = function() {
      var et, at, _t, Nt, m, A, E, w, v, k, O, W, it, vt, xt, It, Wt, Ut, zt, Jt, Xt, ie, oe, De, ue, xe = this.h0h, se = this.h0l, he = this.h1h, je = this.h1l, jr = this.h2h, de = this.h2l, We = this.h3h, B = this.h3l, j = this.h4h, Z = this.h4l, kt = this.h5h, $t = this.h5l, At = this.h6h, Bt = this.h6l, Ft = this.h7h, Kt = this.h7l, Zt = this.blocks;
      for (et = 32; et < 160; et += 2)
        at = ((Jt = Zt[et - 30]) >>> 1 | (Xt = Zt[et - 29]) << 31) ^ (Jt >>> 8 | Xt << 24) ^ Jt >>> 7, _t = (Xt >>> 1 | Jt << 31) ^ (Xt >>> 8 | Jt << 24) ^ (Xt >>> 7 | Jt << 25), Nt = ((Jt = Zt[et - 4]) >>> 19 | (Xt = Zt[et - 3]) << 13) ^ (Xt >>> 29 | Jt << 3) ^ Jt >>> 6, m = (Xt >>> 19 | Jt << 13) ^ (Jt >>> 29 | Xt << 3) ^ (Xt >>> 6 | Jt << 26), Jt = Zt[et - 32], Xt = Zt[et - 31], v = ((ie = Zt[et - 14]) >>> 16) + (Jt >>> 16) + (at >>> 16) + (Nt >>> 16) + ((w = (65535 & ie) + (65535 & Jt) + (65535 & at) + (65535 & Nt) + ((E = ((oe = Zt[et - 13]) >>> 16) + (Xt >>> 16) + (_t >>> 16) + (m >>> 16) + ((A = (65535 & oe) + (65535 & Xt) + (65535 & _t) + (65535 & m)) >>> 16)) >>> 16)) >>> 16), Zt[et] = v << 16 | 65535 & w, Zt[et + 1] = E << 16 | 65535 & A;
      var Gt = xe, Qt = se, Ae = he, ae = je, we = jr, ir = de, ge = We, _e = B, rr = j, be = Z, Ge = kt, Rr = $t, Te = At, Ie = Bt, Pr = Ft, Ee = Kt;
      for (It = Ae & we, Wt = ae & ir, et = 0; et < 160; et += 8)
        at = (Gt >>> 28 | Qt << 4) ^ (Qt >>> 2 | Gt << 30) ^ (Qt >>> 7 | Gt << 25), _t = (Qt >>> 28 | Gt << 4) ^ (Gt >>> 2 | Qt << 30) ^ (Gt >>> 7 | Qt << 25), Nt = (rr >>> 14 | be << 18) ^ (rr >>> 18 | be << 14) ^ (be >>> 9 | rr << 23), m = (be >>> 14 | rr << 18) ^ (be >>> 18 | rr << 14) ^ (rr >>> 9 | be << 23), Ut = (k = Gt & Ae) ^ Gt & we ^ It, zt = (O = Qt & ae) ^ Qt & ir ^ Wt, De = rr & Ge ^ ~rr & Te, ue = be & Rr ^ ~be & Ie, Jt = Zt[et], Xt = Zt[et + 1], Jt = (v = ((ie = L[et]) >>> 16) + (Jt >>> 16) + (De >>> 16) + (Nt >>> 16) + (Pr >>> 16) + ((w = (65535 & ie) + (65535 & Jt) + (65535 & De) + (65535 & Nt) + (65535 & Pr) + ((E = ((oe = L[et + 1]) >>> 16) + (Xt >>> 16) + (ue >>> 16) + (m >>> 16) + (Ee >>> 16) + ((A = (65535 & oe) + (65535 & Xt) + (65535 & ue) + (65535 & m) + (65535 & Ee)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, Xt = E << 16 | 65535 & A, ie = (v = (Ut >>> 16) + (at >>> 16) + ((w = (65535 & Ut) + (65535 & at) + ((E = (zt >>> 16) + (_t >>> 16) + ((A = (65535 & zt) + (65535 & _t)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, oe = E << 16 | 65535 & A, Pr = (v = (ge >>> 16) + (Jt >>> 16) + ((w = (65535 & ge) + (65535 & Jt) + ((E = (_e >>> 16) + (Xt >>> 16) + ((A = (65535 & _e) + (65535 & Xt)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, Ee = E << 16 | 65535 & A, at = ((ge = (v = (ie >>> 16) + (Jt >>> 16) + ((w = (65535 & ie) + (65535 & Jt) + ((E = (oe >>> 16) + (Xt >>> 16) + ((A = (65535 & oe) + (65535 & Xt)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w) >>> 28 | (_e = E << 16 | 65535 & A) << 4) ^ (_e >>> 2 | ge << 30) ^ (_e >>> 7 | ge << 25), _t = (_e >>> 28 | ge << 4) ^ (ge >>> 2 | _e << 30) ^ (ge >>> 7 | _e << 25), Nt = (Pr >>> 14 | Ee << 18) ^ (Pr >>> 18 | Ee << 14) ^ (Ee >>> 9 | Pr << 23), m = (Ee >>> 14 | Pr << 18) ^ (Ee >>> 18 | Pr << 14) ^ (Pr >>> 9 | Ee << 23), Ut = (W = ge & Gt) ^ ge & Ae ^ k, zt = (it = _e & Qt) ^ _e & ae ^ O, De = Pr & rr ^ ~Pr & Ge, ue = Ee & be ^ ~Ee & Rr, Jt = Zt[et + 2], Xt = Zt[et + 3], Jt = (v = ((ie = L[et + 2]) >>> 16) + (Jt >>> 16) + (De >>> 16) + (Nt >>> 16) + (Te >>> 16) + ((w = (65535 & ie) + (65535 & Jt) + (65535 & De) + (65535 & Nt) + (65535 & Te) + ((E = ((oe = L[et + 3]) >>> 16) + (Xt >>> 16) + (ue >>> 16) + (m >>> 16) + (Ie >>> 16) + ((A = (65535 & oe) + (65535 & Xt) + (65535 & ue) + (65535 & m) + (65535 & Ie)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, Xt = E << 16 | 65535 & A, ie = (v = (Ut >>> 16) + (at >>> 16) + ((w = (65535 & Ut) + (65535 & at) + ((E = (zt >>> 16) + (_t >>> 16) + ((A = (65535 & zt) + (65535 & _t)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, oe = E << 16 | 65535 & A, Te = (v = (we >>> 16) + (Jt >>> 16) + ((w = (65535 & we) + (65535 & Jt) + ((E = (ir >>> 16) + (Xt >>> 16) + ((A = (65535 & ir) + (65535 & Xt)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, Ie = E << 16 | 65535 & A, at = ((we = (v = (ie >>> 16) + (Jt >>> 16) + ((w = (65535 & ie) + (65535 & Jt) + ((E = (oe >>> 16) + (Xt >>> 16) + ((A = (65535 & oe) + (65535 & Xt)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w) >>> 28 | (ir = E << 16 | 65535 & A) << 4) ^ (ir >>> 2 | we << 30) ^ (ir >>> 7 | we << 25), _t = (ir >>> 28 | we << 4) ^ (we >>> 2 | ir << 30) ^ (we >>> 7 | ir << 25), Nt = (Te >>> 14 | Ie << 18) ^ (Te >>> 18 | Ie << 14) ^ (Ie >>> 9 | Te << 23), m = (Ie >>> 14 | Te << 18) ^ (Ie >>> 18 | Te << 14) ^ (Te >>> 9 | Ie << 23), Ut = (vt = we & ge) ^ we & Gt ^ W, zt = (xt = ir & _e) ^ ir & Qt ^ it, De = Te & Pr ^ ~Te & rr, ue = Ie & Ee ^ ~Ie & be, Jt = Zt[et + 4], Xt = Zt[et + 5], Jt = (v = ((ie = L[et + 4]) >>> 16) + (Jt >>> 16) + (De >>> 16) + (Nt >>> 16) + (Ge >>> 16) + ((w = (65535 & ie) + (65535 & Jt) + (65535 & De) + (65535 & Nt) + (65535 & Ge) + ((E = ((oe = L[et + 5]) >>> 16) + (Xt >>> 16) + (ue >>> 16) + (m >>> 16) + (Rr >>> 16) + ((A = (65535 & oe) + (65535 & Xt) + (65535 & ue) + (65535 & m) + (65535 & Rr)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, Xt = E << 16 | 65535 & A, ie = (v = (Ut >>> 16) + (at >>> 16) + ((w = (65535 & Ut) + (65535 & at) + ((E = (zt >>> 16) + (_t >>> 16) + ((A = (65535 & zt) + (65535 & _t)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, oe = E << 16 | 65535 & A, Ge = (v = (Ae >>> 16) + (Jt >>> 16) + ((w = (65535 & Ae) + (65535 & Jt) + ((E = (ae >>> 16) + (Xt >>> 16) + ((A = (65535 & ae) + (65535 & Xt)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, Rr = E << 16 | 65535 & A, at = ((Ae = (v = (ie >>> 16) + (Jt >>> 16) + ((w = (65535 & ie) + (65535 & Jt) + ((E = (oe >>> 16) + (Xt >>> 16) + ((A = (65535 & oe) + (65535 & Xt)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w) >>> 28 | (ae = E << 16 | 65535 & A) << 4) ^ (ae >>> 2 | Ae << 30) ^ (ae >>> 7 | Ae << 25), _t = (ae >>> 28 | Ae << 4) ^ (Ae >>> 2 | ae << 30) ^ (Ae >>> 7 | ae << 25), Nt = (Ge >>> 14 | Rr << 18) ^ (Ge >>> 18 | Rr << 14) ^ (Rr >>> 9 | Ge << 23), m = (Rr >>> 14 | Ge << 18) ^ (Rr >>> 18 | Ge << 14) ^ (Ge >>> 9 | Rr << 23), Ut = (It = Ae & we) ^ Ae & ge ^ vt, zt = (Wt = ae & ir) ^ ae & _e ^ xt, De = Ge & Te ^ ~Ge & Pr, ue = Rr & Ie ^ ~Rr & Ee, Jt = Zt[et + 6], Xt = Zt[et + 7], Jt = (v = ((ie = L[et + 6]) >>> 16) + (Jt >>> 16) + (De >>> 16) + (Nt >>> 16) + (rr >>> 16) + ((w = (65535 & ie) + (65535 & Jt) + (65535 & De) + (65535 & Nt) + (65535 & rr) + ((E = ((oe = L[et + 7]) >>> 16) + (Xt >>> 16) + (ue >>> 16) + (m >>> 16) + (be >>> 16) + ((A = (65535 & oe) + (65535 & Xt) + (65535 & ue) + (65535 & m) + (65535 & be)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, Xt = E << 16 | 65535 & A, ie = (v = (Ut >>> 16) + (at >>> 16) + ((w = (65535 & Ut) + (65535 & at) + ((E = (zt >>> 16) + (_t >>> 16) + ((A = (65535 & zt) + (65535 & _t)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, oe = E << 16 | 65535 & A, rr = (v = (Gt >>> 16) + (Jt >>> 16) + ((w = (65535 & Gt) + (65535 & Jt) + ((E = (Qt >>> 16) + (Xt >>> 16) + ((A = (65535 & Qt) + (65535 & Xt)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, be = E << 16 | 65535 & A, Gt = (v = (ie >>> 16) + (Jt >>> 16) + ((w = (65535 & ie) + (65535 & Jt) + ((E = (oe >>> 16) + (Xt >>> 16) + ((A = (65535 & oe) + (65535 & Xt)) >>> 16)) >>> 16)) >>> 16)) << 16 | 65535 & w, Qt = E << 16 | 65535 & A;
      v = (xe >>> 16) + (Gt >>> 16) + ((w = (65535 & xe) + (65535 & Gt) + ((E = (se >>> 16) + (Qt >>> 16) + ((A = (65535 & se) + (65535 & Qt)) >>> 16)) >>> 16)) >>> 16), this.h0h = v << 16 | 65535 & w, this.h0l = E << 16 | 65535 & A, v = (he >>> 16) + (Ae >>> 16) + ((w = (65535 & he) + (65535 & Ae) + ((E = (je >>> 16) + (ae >>> 16) + ((A = (65535 & je) + (65535 & ae)) >>> 16)) >>> 16)) >>> 16), this.h1h = v << 16 | 65535 & w, this.h1l = E << 16 | 65535 & A, v = (jr >>> 16) + (we >>> 16) + ((w = (65535 & jr) + (65535 & we) + ((E = (de >>> 16) + (ir >>> 16) + ((A = (65535 & de) + (65535 & ir)) >>> 16)) >>> 16)) >>> 16), this.h2h = v << 16 | 65535 & w, this.h2l = E << 16 | 65535 & A, v = (We >>> 16) + (ge >>> 16) + ((w = (65535 & We) + (65535 & ge) + ((E = (B >>> 16) + (_e >>> 16) + ((A = (65535 & B) + (65535 & _e)) >>> 16)) >>> 16)) >>> 16), this.h3h = v << 16 | 65535 & w, this.h3l = E << 16 | 65535 & A, v = (j >>> 16) + (rr >>> 16) + ((w = (65535 & j) + (65535 & rr) + ((E = (Z >>> 16) + (be >>> 16) + ((A = (65535 & Z) + (65535 & be)) >>> 16)) >>> 16)) >>> 16), this.h4h = v << 16 | 65535 & w, this.h4l = E << 16 | 65535 & A, v = (kt >>> 16) + (Ge >>> 16) + ((w = (65535 & kt) + (65535 & Ge) + ((E = ($t >>> 16) + (Rr >>> 16) + ((A = (65535 & $t) + (65535 & Rr)) >>> 16)) >>> 16)) >>> 16), this.h5h = v << 16 | 65535 & w, this.h5l = E << 16 | 65535 & A, v = (At >>> 16) + (Te >>> 16) + ((w = (65535 & At) + (65535 & Te) + ((E = (Bt >>> 16) + (Ie >>> 16) + ((A = (65535 & Bt) + (65535 & Ie)) >>> 16)) >>> 16)) >>> 16), this.h6h = v << 16 | 65535 & w, this.h6l = E << 16 | 65535 & A, v = (Ft >>> 16) + (Pr >>> 16) + ((w = (65535 & Ft) + (65535 & Pr) + ((E = (Kt >>> 16) + (Ee >>> 16) + ((A = (65535 & Kt) + (65535 & Ee)) >>> 16)) >>> 16)) >>> 16), this.h7h = v << 16 | 65535 & w, this.h7l = E << 16 | 65535 & A;
    }, ot.prototype.hex = function() {
      this.finalize();
      var et = this.h0h, at = this.h0l, _t = this.h1h, Nt = this.h1l, m = this.h2h, A = this.h2l, E = this.h3h, w = this.h3l, v = this.h4h, k = this.h4l, O = this.h5h, W = this.h5l, it = this.h6h, vt = this.h6l, xt = this.h7h, It = this.h7l, Wt = this.bits, Ut = $[et >> 28 & 15] + $[et >> 24 & 15] + $[et >> 20 & 15] + $[et >> 16 & 15] + $[et >> 12 & 15] + $[et >> 8 & 15] + $[et >> 4 & 15] + $[15 & et] + $[at >> 28 & 15] + $[at >> 24 & 15] + $[at >> 20 & 15] + $[at >> 16 & 15] + $[at >> 12 & 15] + $[at >> 8 & 15] + $[at >> 4 & 15] + $[15 & at] + $[_t >> 28 & 15] + $[_t >> 24 & 15] + $[_t >> 20 & 15] + $[_t >> 16 & 15] + $[_t >> 12 & 15] + $[_t >> 8 & 15] + $[_t >> 4 & 15] + $[15 & _t] + $[Nt >> 28 & 15] + $[Nt >> 24 & 15] + $[Nt >> 20 & 15] + $[Nt >> 16 & 15] + $[Nt >> 12 & 15] + $[Nt >> 8 & 15] + $[Nt >> 4 & 15] + $[15 & Nt] + $[m >> 28 & 15] + $[m >> 24 & 15] + $[m >> 20 & 15] + $[m >> 16 & 15] + $[m >> 12 & 15] + $[m >> 8 & 15] + $[m >> 4 & 15] + $[15 & m] + $[A >> 28 & 15] + $[A >> 24 & 15] + $[A >> 20 & 15] + $[A >> 16 & 15] + $[A >> 12 & 15] + $[A >> 8 & 15] + $[A >> 4 & 15] + $[15 & A] + $[E >> 28 & 15] + $[E >> 24 & 15] + $[E >> 20 & 15] + $[E >> 16 & 15] + $[E >> 12 & 15] + $[E >> 8 & 15] + $[E >> 4 & 15] + $[15 & E];
      return Wt >= 256 && (Ut += $[w >> 28 & 15] + $[w >> 24 & 15] + $[w >> 20 & 15] + $[w >> 16 & 15] + $[w >> 12 & 15] + $[w >> 8 & 15] + $[w >> 4 & 15] + $[15 & w]), Wt >= 384 && (Ut += $[v >> 28 & 15] + $[v >> 24 & 15] + $[v >> 20 & 15] + $[v >> 16 & 15] + $[v >> 12 & 15] + $[v >> 8 & 15] + $[v >> 4 & 15] + $[15 & v] + $[k >> 28 & 15] + $[k >> 24 & 15] + $[k >> 20 & 15] + $[k >> 16 & 15] + $[k >> 12 & 15] + $[k >> 8 & 15] + $[k >> 4 & 15] + $[15 & k] + $[O >> 28 & 15] + $[O >> 24 & 15] + $[O >> 20 & 15] + $[O >> 16 & 15] + $[O >> 12 & 15] + $[O >> 8 & 15] + $[O >> 4 & 15] + $[15 & O] + $[W >> 28 & 15] + $[W >> 24 & 15] + $[W >> 20 & 15] + $[W >> 16 & 15] + $[W >> 12 & 15] + $[W >> 8 & 15] + $[W >> 4 & 15] + $[15 & W]), Wt == 512 && (Ut += $[it >> 28 & 15] + $[it >> 24 & 15] + $[it >> 20 & 15] + $[it >> 16 & 15] + $[it >> 12 & 15] + $[it >> 8 & 15] + $[it >> 4 & 15] + $[15 & it] + $[vt >> 28 & 15] + $[vt >> 24 & 15] + $[vt >> 20 & 15] + $[vt >> 16 & 15] + $[vt >> 12 & 15] + $[vt >> 8 & 15] + $[vt >> 4 & 15] + $[15 & vt] + $[xt >> 28 & 15] + $[xt >> 24 & 15] + $[xt >> 20 & 15] + $[xt >> 16 & 15] + $[xt >> 12 & 15] + $[xt >> 8 & 15] + $[xt >> 4 & 15] + $[15 & xt] + $[It >> 28 & 15] + $[It >> 24 & 15] + $[It >> 20 & 15] + $[It >> 16 & 15] + $[It >> 12 & 15] + $[It >> 8 & 15] + $[It >> 4 & 15] + $[15 & It]), Ut;
    }, ot.prototype.toString = ot.prototype.hex, ot.prototype.digest = function() {
      this.finalize();
      var et = this.h0h, at = this.h0l, _t = this.h1h, Nt = this.h1l, m = this.h2h, A = this.h2l, E = this.h3h, w = this.h3l, v = this.h4h, k = this.h4l, O = this.h5h, W = this.h5l, it = this.h6h, vt = this.h6l, xt = this.h7h, It = this.h7l, Wt = this.bits, Ut = [et >> 24 & 255, et >> 16 & 255, et >> 8 & 255, 255 & et, at >> 24 & 255, at >> 16 & 255, at >> 8 & 255, 255 & at, _t >> 24 & 255, _t >> 16 & 255, _t >> 8 & 255, 255 & _t, Nt >> 24 & 255, Nt >> 16 & 255, Nt >> 8 & 255, 255 & Nt, m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, 255 & m, A >> 24 & 255, A >> 16 & 255, A >> 8 & 255, 255 & A, E >> 24 & 255, E >> 16 & 255, E >> 8 & 255, 255 & E];
      return Wt >= 256 && Ut.push(w >> 24 & 255, w >> 16 & 255, w >> 8 & 255, 255 & w), Wt >= 384 && Ut.push(v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, 255 & v, k >> 24 & 255, k >> 16 & 255, k >> 8 & 255, 255 & k, O >> 24 & 255, O >> 16 & 255, O >> 8 & 255, 255 & O, W >> 24 & 255, W >> 16 & 255, W >> 8 & 255, 255 & W), Wt == 512 && Ut.push(it >> 24 & 255, it >> 16 & 255, it >> 8 & 255, 255 & it, vt >> 24 & 255, vt >> 16 & 255, vt >> 8 & 255, 255 & vt, xt >> 24 & 255, xt >> 16 & 255, xt >> 8 & 255, 255 & xt, It >> 24 & 255, It >> 16 & 255, It >> 8 & 255, 255 & It), Ut;
    }, ot.prototype.array = ot.prototype.digest, ot.prototype.arrayBuffer = function() {
      this.finalize();
      var et = this.bits, at = new ArrayBuffer(et / 8), _t = new DataView(at);
      return _t.setUint32(0, this.h0h), _t.setUint32(4, this.h0l), _t.setUint32(8, this.h1h), _t.setUint32(12, this.h1l), _t.setUint32(16, this.h2h), _t.setUint32(20, this.h2l), _t.setUint32(24, this.h3h), et >= 256 && _t.setUint32(28, this.h3l), et >= 384 && (_t.setUint32(32, this.h4h), _t.setUint32(36, this.h4l), _t.setUint32(40, this.h5h), _t.setUint32(44, this.h5l)), et == 512 && (_t.setUint32(48, this.h6h), _t.setUint32(52, this.h6l), _t.setUint32(56, this.h7h), _t.setUint32(60, this.h7l)), at;
    }, ot.prototype.clone = function() {
      var et = new ot(this.bits, !1);
      return this.copyTo(et), et;
    }, ot.prototype.copyTo = function(et) {
      var at = 0, _t = ["h0h", "h0l", "h1h", "h1l", "h2h", "h2l", "h3h", "h3l", "h4h", "h4l", "h5h", "h5l", "h6h", "h6l", "h7h", "h7l", "start", "bytes", "hBytes", "finalized", "hashed", "lastByteIndex"];
      for (at = 0; at < _t.length; ++at)
        et[_t[at]] = this[_t[at]];
      for (at = 0; at < this.blocks.length; ++at)
        et.blocks[at] = this.blocks[at];
    }, St.prototype = new ot(), St.prototype.finalize = function() {
      if (ot.prototype.finalize.call(this), this.inner) {
        this.inner = !1;
        var et = this.array();
        ot.call(this, this.bits, this.sharedMemory), this.update(this.oKeyPad), this.update(et), ot.prototype.finalize.call(this);
      }
    }, St.prototype.clone = function() {
      var et = new St([], this.bits, !1);
      this.copyTo(et), et.inner = this.inner;
      for (var at = 0; at < this.oKeyPad.length; ++at)
        et.oKeyPad[at] = this.oKeyPad[at];
      return et;
    };
    var Ct = rt(512);
    Ct.sha512 = Ct, Ct.sha384 = rt(384), Ct.sha512_256 = rt(256), Ct.sha512_224 = rt(224), Ct.sha512.hmac = st(512), Ct.sha384.hmac = st(384), Ct.sha512_256.hmac = st(256), Ct.sha512_224.hmac = st(224), g ? o.exports = Ct : (u.sha512 = Ct.sha512, u.sha384 = Ct.sha384, u.sha512_256 = Ct.sha512_256, u.sha512_224 = Ct.sha512_224);
  })();
})(sha512$1);
const elliptic = elliptic$1, BN = bn$1.exports, { sha256 } = sha256$1.exports, { sha512 } = sha512$1.exports, EC$2 = new elliptic.ec("secp256k1");
function toBytesInt32(o) {
  return new Uint8Array([(4278190080 & o) >> 24, (16711680 & o) >> 16, (65280 & o) >> 8, 255 & o]);
}
const one = new BN(1);
function Unmarshal(o) {
  const n = EC$2.n.bitLength() + 7 >> 3;
  if (EC$2.g.mul(10), (-2 & o[0]) != 2)
    return [null, null];
  if (o.length != 1 + n)
    return [null, null];
  const c = new BN(o.slice(1, 1 + n));
  try {
    const u = EC$2.curve.pointFromX(c);
    return [u.x, u.y];
  } catch {
    return [null, null];
  }
}
function H1(o) {
  let n = null, c = null;
  const u = EC$2.n.bitLength() + 7 >> 3;
  let h = 0;
  for (; n == null && h < 100; ) {
    const g = [2, ...sha512.array(new Uint8Array([...toBytesInt32(h), ...o]))];
    [n, c] = Unmarshal(g.slice(0, u + 1)), h++;
  }
  return EC$2.curve.point(n, c);
}
function H2(o) {
  const n = EC$2.n.bitLength() + 7 >> 3;
  let c = 0;
  for (; ; ) {
    const u = sha512.array(new Uint8Array([...toBytesInt32(c), ...o])), h = new BN(u.slice(0, n));
    if (h.cmp(EC$2.curve.n.sub(one)) == -1)
      return h.add(one);
    c++;
  }
}
function Evaluate(o, n) {
  const c = EC$2.keyFromPrivate(o), u = EC$2.genKeyPair().getPrivate(), h = H1(n), g = h.mul(o).encode(), y = EC$2.curve.g.mul(u), $ = h.mul(u), I = H2([...EC$2.curve.g.encode(), ...h.encode(), ...c.getPublic().encode(), ...g, ...y.encode(), ...$.encode()]), P = u.sub(I.mul(c.getPrivate())).umod(EC$2.curve.n);
  return [sha256.array(new Uint8Array(g)), [...new Array(32 - I.byteLength()).fill(0), ...I.toArray(), ...new Array(32 - P.byteLength()).fill(0), ...P.toArray(), ...g]];
}
function ProofHoHash(o, n, c) {
  const u = EC$2.keyFromPublic(o);
  if (c.length !== 129)
    throw new Error("invalid vrf");
  const h = c.slice(0, 32), g = c.slice(32, 64), y = c.slice(64, 129), $ = decodePoint(y);
  if (!$)
    throw new Error("invalid vrf");
  const I = EC$2.curve.g.mul(g), P = u.getPublic().mul(h), L = I.add(P), q = H1(n), N = q.mul(g), X = $.mul(h), rt = N.add(X), nt = H2([...EC$2.curve.g.encode(), ...q.encode(), ...u.getPublic().encode(), ...y, ...L.encode(), ...rt.encode()]), st = [...new Array(32 - nt.byteLength()).fill(0), ...nt.toArray()];
  let ot = !0;
  for (let St = 0; St < st.length; St++)
    h[St] !== st[St] && (ot = !1);
  if (!ot)
    throw new Error("invalid vrf");
  return sha256.array(new Uint8Array(y));
}
function decodePoint(o) {
  try {
    return EC$2.curve.decodePoint(o);
  } catch {
    return null;
  }
}
var vrfJs = { Evaluate, ProofHoHash }, StateCache = {};
function canBeCached(o) {
  return o.confirmationStatus === void 0 || o.confirmationStatus === "confirmed";
}
Object.defineProperty(StateCache, "__esModule", { value: !0 }), StateCache.canBeCached = void 0, StateCache.canBeCached = canBeCached;
var TagsParser$1 = {};
Object.defineProperty(TagsParser$1, "__esModule", { value: !0 }), TagsParser$1.TagsParser = void 0;
const SmartWeaveTags_1$2 = SmartWeaveTags, LoggerFactory_1$b = LoggerFactory$1;
class TagsParser {
  constructor() {
    this.logger = LoggerFactory_1$b.LoggerFactory.INST.create("TagsParser");
  }
  getInputTag(n, c) {
    if (TagsParser.hasMultipleInteractions(n)) {
      this.logger.debug("Interaction transaction is using multiple input tx tag format.");
      const u = n.tags.findIndex((g) => g.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID && g.value === c);
      if (n.tags.length - 1 === u)
        return void this.logger.warn("Wrong tags format: 'Contract' is the last tag");
      const h = n.tags[u + 1];
      return h.name !== SmartWeaveTags_1$2.SmartWeaveTags.INPUT ? void this.logger.warn(`No 'Input' tag found after 'Contract' tag. Instead ${h.name} was found`) : h;
    }
    return n.tags.find((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.INPUT);
  }
  isInteractWrite(n, c) {
    return n.tags.some((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.INTERACT_WRITE && u.value === c);
  }
  getInteractWritesContracts(n) {
    return n.tags.filter((c) => c.name === SmartWeaveTags_1$2.SmartWeaveTags.INTERACT_WRITE).map((c) => c.value);
  }
  getContractTag(n) {
    var c;
    return (c = n.tags.find((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID)) === null || c === void 0 ? void 0 : c.value;
  }
  getContractsWithInputs(n) {
    const c = /* @__PURE__ */ new Map();
    return n.tags.filter((u) => u.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID).forEach((u) => {
      c.set(u.value, this.getInputTag(n, u.value));
    }), c;
  }
  static hasMultipleInteractions(n) {
    return n.tags.filter((c) => c.name === SmartWeaveTags_1$2.SmartWeaveTags.CONTRACT_TX_ID).length > 1;
  }
}
TagsParser$1.TagsParser = TagsParser;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(DefaultStateEvaluator$1, "__esModule", { value: !0 }), DefaultStateEvaluator$1.DefaultStateEvaluator = void 0;
const vrf_js_1$1 = vrfJs, elliptic_1$1 = __importDefault$5(elliptic$1), SortKeyCache_1$1 = SortKeyCache, Benchmark_1$1 = Benchmark$1, LoggerFactory_1$a = LoggerFactory$1, utils_1$5 = utils$n, StateEvaluator_1$2 = StateEvaluator, StateCache_1 = StateCache, TagsParser_1 = TagsParser$1, EC$1 = new elliptic_1$1.default.ec("secp256k1");
class DefaultStateEvaluator {
  constructor(n, c = []) {
    this.arweave = n, this.executionContextModifiers = c, this.logger = LoggerFactory_1$a.LoggerFactory.INST.create("DefaultStateEvaluator"), this.tagsParser = new TagsParser_1.TagsParser();
  }
  async eval(n, c) {
    return this.doReadState(n.sortedInteractions, new StateEvaluator_1$2.EvalStateResult(n.contractDefinition.initState, {}, {}), n, c);
  }
  async doReadState(n, c, u, h) {
    var g;
    const { ignoreExceptions: y, stackTrace: $, internalWrites: I } = u.evaluationOptions, { contract: P, contractDefinition: L, sortedInteractions: q } = u;
    let N = c.state, X = null;
    const rt = c.validity, nt = c.errorMessages;
    u == null || u.handler.initState(N);
    const st = u.contract.callDepth();
    this.logger.info(`${(0, utils_1$5.indent)(st)}Evaluating state for ${L.txId} [${n.length} non-cached of ${q.length} all]`);
    let ot = null, St = null;
    const Ct = n.length;
    u.handler.initState(N);
    for (let at = 0; at < Ct; at++) {
      const _t = n[at], Nt = Benchmark_1$1.Benchmark.measure();
      if (X = _t.sortKey, _t.vrf && !this.verifyVrf(_t.vrf, _t.sortKey, this.arweave))
        throw new Error("Vrf verification failed.");
      if (this.logger.debug(`${(0, utils_1$5.indent)(st)}[${L.txId}][${_t.id}][${_t.block.height}]: ${n.indexOf(_t) + 1}/${n.length} [of all:${q.length}]`), this.tagsParser.isInteractWrite(_t, L.txId) && I) {
        const m = this.tagsParser.getContractTag(_t);
        this.logger.debug(`${(0, utils_1$5.indent)(st)}Internal Write - Loading writing contract`, m);
        const A = P.getCallStack().addInteractionData({ interaction: null, interactionTx: _t, currentTx: h }), E = u.warp.contract(m, u.contract, { callingInteraction: _t, callType: "read" });
        await this.onContractCall(_t, u, new StateEvaluator_1$2.EvalStateResult(N, rt, nt)), this.logger.debug(`${(0, utils_1$5.indent)(st)}Reading state of the calling contract at`, _t.sortKey), await E.readState(_t.sortKey, [...h || [], { contractTxId: L.txId, interactionTxId: _t.id }]);
        const w = await this.internalWriteState(L.txId, _t.sortKey);
        if (w !== null) {
          N = w.cachedValue.state, u == null || u.handler.initState(N), rt[_t.id] = w.cachedValue.validity[_t.id], !((g = w.cachedValue.errorMessages) === null || g === void 0) && g[_t.id] && (nt[_t.id] = w.cachedValue.errorMessages[_t.id]);
          const v = new StateEvaluator_1$2.EvalStateResult(N, rt, nt);
          await this.onStateUpdate(_t, u, v), (0, StateCache_1.canBeCached)(_t) && (St = { tx: _t, state: v });
        } else
          rt[_t.id] = !1;
        A.update({ cacheHit: !1, outputState: $.saveState ? N : void 0, executionTime: Nt.elapsed(!0), valid: rt[_t.id], errorMessage: ot, gasUsed: 0 });
      } else {
        const m = this.tagsParser.getInputTag(_t, u.contractDefinition.txId);
        if (!m) {
          this.logger.error(`${(0, utils_1$5.indent)(st)}Skipping tx - Input tag not found for ${_t.id}`);
          continue;
        }
        const A = this.parseInput(m);
        if (!A) {
          this.logger.error(`${(0, utils_1$5.indent)(st)}Skipping tx - invalid Input tag - ${_t.id}`);
          continue;
        }
        const E = { input: A, caller: _t.owner.address }, w = { interaction: E, interactionTx: _t, currentTx: h };
        this.logger.debug(`${(0, utils_1$5.indent)(st)}Interaction:`, E);
        const v = P.getCallStack().addInteractionData(w), k = await u.handler.handle(u, new StateEvaluator_1$2.EvalStateResult(N, rt, nt), w);
        if (ot = k.errorMessage, k.type !== "ok" && (nt[_t.id] = ot), this.logResult(k, _t, u), this.logger.debug(`${(0, utils_1$5.indent)(st)}Interaction evaluation`, Nt.elapsed()), v.update({ cacheHit: !1, outputState: $.saveState ? N : void 0, executionTime: Nt.elapsed(!0), valid: rt[_t.id], errorMessage: ot, gasUsed: k.gasUsed }), k.type === "exception" && y !== !0)
          throw new Error(`Exception while processing ${JSON.stringify(E)}:
${k.errorMessage}`);
        rt[_t.id] = k.type === "ok", N = k.state;
        const O = new StateEvaluator_1$2.EvalStateResult(N, rt, nt);
        (0, StateCache_1.canBeCached)(_t) && (St = { tx: _t, state: O }), await this.onStateUpdate(_t, u, O);
      }
      for (const { modify: m } of this.executionContextModifiers)
        u = await m(N, u);
    }
    const et = new StateEvaluator_1$2.EvalStateResult(N, rt, nt);
    return St !== null && await this.onStateEvaluated(St.tx, u, St.state), new SortKeyCache_1$1.SortKeyCacheResult(X, et);
  }
  verifyVrf(n, c, u) {
    const h = EC$1.keyFromPublic(n.pubkey, "hex");
    let g;
    try {
      g = (0, vrf_js_1$1.ProofHoHash)(h.getPublic(), u.utils.stringToBuffer(c), u.utils.b64UrlToBuffer(n.proof));
    } catch {
      return !1;
    }
    return u.utils.bufferTob64Url(g) == n.index;
  }
  logResult(n, c, u) {
    n.type === "exception" && this.logger.error(`Executing of interaction: [${u.contractDefinition.txId} -> ${c.id}] threw exception:`, `${n.errorMessage}`), n.type === "error" && this.logger.warn(`Executing of interaction: [${u.contractDefinition.txId} -> ${c.id}] returned error:`, n.errorMessage);
  }
  parseInput(n) {
    try {
      return JSON.parse(n.value);
    } catch (c) {
      return this.logger.error(c), null;
    }
  }
}
DefaultStateEvaluator$1.DefaultStateEvaluator = DefaultStateEvaluator;
var LexicographicalInteractionsSorter = {}, WarpGatewayInteractionsLoader = {};
(function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 }), o.WarpGatewayInteractionsLoader = o.SourceType = void 0;
  const n = Benchmark$1, c = LoggerFactory$1, u = utils$n;
  var h;
  (h = o.SourceType || (o.SourceType = {})).ARWEAVE = "arweave", h.WARP_SEQUENCER = "redstone-sequencer", o.WarpGatewayInteractionsLoader = class {
    constructor(g, y = null, $ = null) {
      this.baseUrl = g, this.confirmationStatus = y, this.source = $, this.logger = c.LoggerFactory.INST.create("WarpGatewayInteractionsLoader"), this.baseUrl = (0, u.stripTrailingSlash)(g), Object.assign(this, y), this.source = $;
    }
    async load(g, y, $, I) {
      this.logger.debug("Loading interactions: for ", { contractId: g, fromSortKey: y, toSortKey: $ });
      const P = [];
      let L = 0, q = 0, N = 0;
      const X = n.Benchmark.measure();
      do {
        const rt = n.Benchmark.measure(), nt = `${this.baseUrl}/gateway/v2/interactions-sort-key`, st = await fetch(`${nt}?${new URLSearchParams({ contractId: g, ...y ? { from: y } : "", ...$ ? { to: $ } : "", page: (++L).toString(), fromSdk: "true", ...this.confirmationStatus && this.confirmationStatus.confirmed ? { confirmationStatus: "confirmed" } : "", ...this.confirmationStatus && this.confirmationStatus.notCorrupted ? { confirmationStatus: "not_corrupted" } : "", ...this.source ? { source: this.source } : "" })}`).then((ot) => ot.ok ? ot.json() : Promise.reject(ot)).catch((ot) => {
          var St;
          throw !((St = ot.body) === null || St === void 0) && St.message && this.logger.error(ot.body.message), new Error(`Unable to retrieve transactions. Warp gateway responded with status ${ot.status}.`);
        });
        this.logger.debug(`Loading interactions: page ${L} loaded in ${rt.elapsed()}`), P.push(...st.interactions), q = st.paging.limit, N = st.paging.items, this.logger.debug(`Loaded interactions length: ${P.length}, from: ${y}, to: ${$}`);
      } while (N == q);
      return this.logger.debug("All loaded interactions:", { from: y, to: $, loaded: P.length, time: X.elapsed() }), P;
    }
    type() {
      return "warp";
    }
    clearCache() {
    }
  };
})(WarpGatewayInteractionsLoader), function(o) {
  Object.defineProperty(o, "__esModule", { value: !0 }), o.LexicographicalInteractionsSorter = o.genesisSortKey = o.sortingLast = o.sortingFirst = void 0;
  const n = utils$p, c = LoggerFactory$1, u = WarpGatewayInteractionsLoader, h = "".padEnd(13, "0"), g = "".padEnd(13, "9"), y = "".padEnd(13, "0");
  o.sortingFirst = "".padEnd(64, "0"), o.sortingLast = "".padEnd(64, "z"), o.genesisSortKey = `${"".padStart(12, "0")},${h},${o.sortingFirst}`, o.LexicographicalInteractionsSorter = class {
    constructor($) {
      this.arweave = $, this.logger = c.LoggerFactory.INST.create("LexicographicalInteractionsSorter");
    }
    async sort($) {
      const I = [...$], P = I.map((L) => this.addSortKey(L));
      return await Promise.all(P), I.sort((L, q) => L.node.sortKey.localeCompare(q.node.sortKey));
    }
    async createSortKey($, I, P, L = !1) {
      const q = this.arweave.utils.b64UrlToBuffer($), N = this.arweave.utils.b64UrlToBuffer(I), X = this.arweave.utils.concatBuffers([q, N]), rt = (0, n.arrayToHex)(await this.arweave.crypto.hash(X));
      return `${`${P}`.padStart(12, "0")},${L ? g : y},${rt}`;
    }
    extractBlockHeight($) {
      return $ ? parseInt($.split(",")[0]) : null;
    }
    async addSortKey($) {
      const { node: I } = $;
      $.node.sortKey !== void 0 && $.node.source == u.SourceType.WARP_SEQUENCER ? this.logger.debug("Using sortKey from sequencer", $.node.sortKey) : $.node.sortKey = await this.createSortKey(I.block.id, I.id, I.block.height);
    }
    generateLastSortKey($) {
      return `${`${$}`.padStart(12, "0")},${g},${o.sortingLast}`;
    }
  };
}(LexicographicalInteractionsSorter), Object.defineProperty(CacheableStateEvaluator$1, "__esModule", { value: !0 }), CacheableStateEvaluator$1.CacheableStateEvaluator = void 0;
const SortKeyCache_1 = SortKeyCache, LoggerFactory_1$9 = LoggerFactory$1, utils_1$4 = utils$n, StateEvaluator_1$1 = StateEvaluator, DefaultStateEvaluator_1 = DefaultStateEvaluator$1, LexicographicalInteractionsSorter_1$1 = LexicographicalInteractionsSorter;
class CacheableStateEvaluator extends DefaultStateEvaluator_1.DefaultStateEvaluator {
  constructor(n, c, u = []) {
    super(n, u), this.cache = c, this.cLogger = LoggerFactory_1$9.LoggerFactory.INST.create("CacheableStateEvaluator");
  }
  async eval(n, c) {
    var u, h, g, y;
    const $ = n.cachedState;
    if ($ && $.sortKey == n.requestedSortKey)
      return this.cLogger.info(`Exact cache hit for sortKey ${(u = n == null ? void 0 : n.contractDefinition) === null || u === void 0 ? void 0 : u.txId}:${$.sortKey}`), (h = n.handler) === null || h === void 0 || h.initState($.cachedValue.state), $;
    const I = n.sortedInteractions, P = n.contractDefinition.txId;
    if (!P)
      throw new Error("Contract tx id not set in the execution context");
    for (const X of c || [])
      if (X.contractTxId === n.contractDefinition.txId) {
        const rt = I.findIndex((nt) => nt.id === X.interactionTxId);
        rt !== -1 && (this.cLogger.debug("Inf. Loop fix - removing interaction", { height: I[rt].block.height, contractTxId: X.contractTxId, interactionTxId: X.interactionTxId, sortKey: I[rt].sortKey }), I.splice(rt));
      }
    if (I.length == 0) {
      if (this.cLogger.info(`No missing interactions ${P}`), $)
        return (g = n.handler) === null || g === void 0 || g.initState($.cachedValue.state), $;
      {
        (y = n.handler) === null || y === void 0 || y.initState(n.contractDefinition.initState), this.cLogger.debug("Inserting initial state into cache");
        const X = new StateEvaluator_1$1.EvalStateResult(n.contractDefinition.initState, {}, {});
        return await this.cache.put(new SortKeyCache_1.CacheKey(P, LexicographicalInteractionsSorter_1$1.genesisSortKey), X), new SortKeyCache_1.SortKeyCacheResult(LexicographicalInteractionsSorter_1$1.genesisSortKey, X);
      }
    }
    const L = $ == null ? n.contractDefinition.initState : $.cachedValue.state, q = $ == null ? {} : $.cachedValue.validity, N = $ == null ? {} : $.cachedValue.errorMessages;
    return this.cLogger.debug("Base state", L), await this.doReadState(I, new StateEvaluator_1$1.EvalStateResult(L, q, N || {}), n, c);
  }
  async onStateEvaluated(n, c, u) {
    const h = c.contractDefinition.txId;
    this.cLogger.debug(`${(0, utils_1$4.indent)(c.contract.callDepth())}onStateEvaluated: cache update for contract ${h} [${n.sortKey}]`), await this.putInCache(h, n, u);
  }
  async onStateUpdate(n, c, u, h = !1) {
    (c.evaluationOptions.updateCacheForEachInteraction || h) && (this.cLogger.debug(`onStateUpdate: cache update for contract ${c.contractDefinition.txId} [${n.sortKey}]`, { contract: c.contractDefinition.txId, state: u.state, sortKey: n.sortKey }), await this.putInCache(c.contractDefinition.txId, n, u));
  }
  async latestAvailableState(n, c) {
    if (this.cLogger.debug("Searching for", { contractTxId: n, sortKey: c }), c) {
      const u = await this.cache.getLessOrEqual(n, c);
      return u && this.cLogger.debug(`Latest available state at ${n}: ${u.sortKey}`), u;
    }
    return await this.cache.getLast(n);
  }
  async onInternalWriteStateUpdate(n, c, u) {
    this.cLogger.debug("Internal write state update:", { sortKey: n.sortKey, dry: n.dry, contractTxId: c, state: u.state }), await this.putInCache(c, n, u);
  }
  async onContractCall(n, c, u) {
    var h;
    if (((h = c.sortedInteractions) === null || h === void 0 ? void 0 : h.length) == 0)
      return;
    const g = c.sortedInteractions.indexOf(n);
    g < 1 || await this.putInCache(c.contractDefinition.txId, c.sortedInteractions[g - 1], u);
  }
  async putInCache(n, c, u) {
    if (c.dry || c.confirmationStatus !== void 0 && c.confirmationStatus !== "confirmed")
      return;
    const h = new StateEvaluator_1$1.EvalStateResult(u.state, u.validity, u.errorMessages || {});
    this.cLogger.debug("Putting into cache", { contractTxId: n, transaction: c.id, sortKey: c.sortKey, dry: c.dry, state: h.state, validity: h.validity }), await this.cache.put(new SortKeyCache_1.CacheKey(n, c.sortKey), h);
  }
  async syncState(n, c, u, h) {
    const g = new StateEvaluator_1$1.EvalStateResult(u, h, {});
    await this.cache.put(new SortKeyCache_1.CacheKey(n, c), g);
  }
  async dumpCache() {
    return await this.cache.dump();
  }
  async internalWriteState(n, c) {
    return await this.cache.get(n, c);
  }
  async hasContractCached(n) {
    return await this.cache.getLast(n) != null;
  }
  async lastCachedSortKey() {
    return await this.cache.getLastSortKey();
  }
  async allCachedContracts() {
    return await this.cache.allContracts();
  }
}
CacheableStateEvaluator$1.CacheableStateEvaluator = CacheableStateEvaluator;
var HandlerExecutorFactory$1 = {}, umd = { exports: {} };
(function(o, n) {
  var c = function(u) {
    Object.defineProperty(u, "__esModule", { value: !0 }), u.default = void 0, u.demangle = st, u.instantiate = X, u.instantiateStreaming = nt, u.instantiateSync = rt;
    const h = () => {
      throw Error("Operation requires compiling with --exportRuntime");
    }, g = typeof BigUint64Array < "u", y = Symbol(), $ = new TextDecoder("utf-16le", { fatal: !0 });
    function I(St, Ct) {
      let et = new Uint32Array(St)[Ct + -4 >>> 2] >>> 1;
      const at = new Uint16Array(St, Ct, et);
      if (et <= 192)
        return String.fromCharCode(...at);
      try {
        return $.decode(at);
      } catch {
        let _t = "", Nt = 0;
        for (; et - Nt > 1024; )
          _t += String.fromCharCode(...at.subarray(Nt, Nt += 1024));
        return _t + String.fromCharCode(...at.subarray(Nt));
      }
    }
    function P(St) {
      const Ct = {};
      function et(_t, Nt) {
        return _t ? I(_t.buffer, Nt) : "<yet unknown>";
      }
      const at = St.env = St.env || {};
      return at.abort = at.abort || function(_t, Nt, m, A) {
        const E = Ct.memory || at.memory;
        throw Error(`abort: ${et(E, _t)} at ${et(E, Nt)}:${m}:${A}`);
      }, at.trace = at.trace || function(_t, Nt, ...m) {
        const A = Ct.memory || at.memory;
        console.log(`trace: ${et(A, _t)}${Nt ? " " : ""}${m.slice(0, Nt).join(", ")}`);
      }, at.seed = at.seed || Date.now, St.Math = St.Math || Math, St.Date = St.Date || Date, Ct;
    }
    function L(St, Ct) {
      const et = Ct.exports, at = et.memory, _t = et.table, Nt = et.__new || h, m = et.__pin || h, A = et.__unpin || h, E = et.__collect || h, w = et.__rtti_base, v = w ? (Ut) => Ut[w >>> 2] : h;
      function k(Ut) {
        const zt = new Uint32Array(at.buffer);
        if ((Ut >>>= 0) >= v(zt))
          throw Error(`invalid id: ${Ut}`);
        return zt[(w + 4 >>> 2) + (Ut << 1) + 1];
      }
      function O(Ut) {
        const zt = function(Jt) {
          const Xt = new Uint32Array(at.buffer);
          if ((Jt >>>= 0) >= v(Xt))
            throw Error(`invalid id: ${Jt}`);
          return Xt[(w + 4 >>> 2) + (Jt << 1)];
        }(Ut);
        if (!(7 & zt))
          throw Error(`not an array: ${Ut}, flags=${zt}`);
        return zt;
      }
      function W(Ut) {
        return 31 - Math.clz32(Ut >>> 6 & 31);
      }
      function it(Ut, zt, Jt) {
        const Xt = at.buffer;
        if (Jt)
          switch (Ut) {
            case 2:
              return new Float32Array(Xt);
            case 3:
              return new Float64Array(Xt);
          }
        else
          switch (Ut) {
            case 0:
              return new (zt ? Int8Array : Uint8Array)(Xt);
            case 1:
              return new (zt ? Int16Array : Uint16Array)(Xt);
            case 2:
              return new (zt ? Int32Array : Uint32Array)(Xt);
            case 3:
              return new (zt ? BigInt64Array : BigUint64Array)(Xt);
          }
        throw Error(`unsupported align: ${Ut}`);
      }
      function vt(Ut) {
        const zt = new Uint32Array(at.buffer), Jt = O(zt[Ut + -8 >>> 2]), Xt = W(Jt);
        let ie = 4 & Jt ? Ut : zt[Ut + 4 >>> 2];
        const oe = 2 & Jt ? zt[Ut + 12 >>> 2] : zt[ie + -4 >>> 2] >>> Xt;
        return it(Xt, 2048 & Jt, 4096 & Jt).subarray(ie >>>= Xt, ie + oe);
      }
      function xt(Ut, zt, Jt) {
        return new Ut(It(Ut, zt, Jt));
      }
      function It(Ut, zt, Jt) {
        const Xt = at.buffer, ie = new Uint32Array(Xt);
        return new Ut(Xt, ie[Jt + 4 >>> 2], ie[Jt + 8 >>> 2] >>> zt);
      }
      function Wt(Ut, zt, Jt) {
        St[`__get${zt}`] = xt.bind(null, Ut, Jt), St[`__get${zt}View`] = It.bind(null, Ut, Jt);
      }
      return St.__new = Nt, St.__pin = m, St.__unpin = A, St.__collect = E, St.__newString = function(Ut) {
        if (Ut == null)
          return 0;
        const zt = Ut.length, Jt = Nt(zt << 1, 1), Xt = new Uint16Array(at.buffer);
        for (var ie = 0, oe = Jt >>> 1; ie < zt; ++ie)
          Xt[oe + ie] = Ut.charCodeAt(ie);
        return Jt;
      }, St.__newArrayBuffer = function(Ut) {
        if (Ut == null)
          return 0;
        const zt = new Uint8Array(Ut), Jt = Nt(zt.length, 0);
        return new Uint8Array(at.buffer).set(zt, Jt), Jt;
      }, St.__getString = function(Ut) {
        if (!Ut)
          return null;
        const zt = at.buffer;
        if (new Uint32Array(zt)[Ut + -8 >>> 2] !== 1)
          throw Error(`not a string: ${Ut}`);
        return I(zt, Ut);
      }, St.__newArray = function(Ut, zt = 0) {
        const Jt = zt, Xt = O(Ut), ie = W(Xt), oe = typeof Jt != "number", De = oe ? Jt.length : Jt, ue = Nt(De << ie, 4 & Xt ? Ut : 0);
        let xe;
        if (4 & Xt)
          xe = ue;
        else {
          m(ue);
          const se = Nt(2 & Xt ? 16 : 12, Ut);
          A(ue);
          const he = new Uint32Array(at.buffer);
          he[se + 0 >>> 2] = ue, he[se + 4 >>> 2] = ue, he[se + 8 >>> 2] = De << ie, 2 & Xt && (he[se + 12 >>> 2] = De), xe = se;
        }
        if (oe) {
          const se = it(ie, 2048 & Xt, 4096 & Xt), he = ue >>> ie;
          if (16384 & Xt)
            for (let je = 0; je < De; ++je)
              se[he + je] = Jt[je];
          else
            se.set(Jt, he);
        }
        return xe;
      }, St.__getArrayView = vt, St.__getArray = function(Ut) {
        const zt = vt(Ut), Jt = zt.length, Xt = new Array(Jt);
        for (let ie = 0; ie < Jt; ie++)
          Xt[ie] = zt[ie];
        return Xt;
      }, St.__getArrayBuffer = function(Ut) {
        const zt = at.buffer, Jt = new Uint32Array(zt)[Ut + -4 >>> 2];
        return zt.slice(Ut, Ut + Jt);
      }, St.__getFunction = function(Ut) {
        if (!_t)
          throw Error("Operation requires compiling with --exportTable");
        const zt = new Uint32Array(at.buffer)[Ut >>> 2];
        return _t.get(zt);
      }, [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array].forEach((Ut) => {
        Wt(Ut, Ut.name, 31 - Math.clz32(Ut.BYTES_PER_ELEMENT));
      }), g && [BigUint64Array, BigInt64Array].forEach((Ut) => {
        Wt(Ut, Ut.name.slice(3), 3);
      }), St.__instanceof = function(Ut, zt) {
        const Jt = new Uint32Array(at.buffer);
        let Xt = Jt[Ut + -8 >>> 2];
        if (Xt <= v(Jt))
          do {
            if (Xt == zt)
              return !0;
            Xt = k(Xt);
          } while (Xt);
        return !1;
      }, St.memory = St.memory || at, St.table = St.table || _t, st(et, St);
    }
    function q(St) {
      return typeof Response < "u" && St instanceof Response;
    }
    function N(St) {
      return St instanceof WebAssembly.Module;
    }
    async function X(St, Ct = {}) {
      if (q(St = await St))
        return nt(St, Ct);
      const et = N(St) ? St : await WebAssembly.compile(St), at = P(Ct), _t = await WebAssembly.instantiate(et, Ct);
      return { module: et, instance: _t, exports: L(at, _t) };
    }
    function rt(St, Ct = {}) {
      const et = N(St) ? St : new WebAssembly.Module(St), at = P(Ct), _t = new WebAssembly.Instance(et, Ct);
      return { module: et, instance: _t, exports: L(at, _t) };
    }
    async function nt(St, Ct = {}) {
      if (!WebAssembly.instantiateStreaming)
        return X(q(St = await St) ? St.arrayBuffer() : St, Ct);
      const et = P(Ct), at = await WebAssembly.instantiateStreaming(St, Ct), _t = L(et, at.instance);
      return { ...at, exports: _t };
    }
    function st(St, Ct = {}) {
      const et = St.__argumentsLength ? (at) => {
        St.__argumentsLength.value = at;
      } : St.__setArgumentsLength || St.__setargc || (() => {
      });
      for (let at of Object.keys(St)) {
        const _t = St[at];
        let Nt = at.split("."), m = Ct;
        for (; Nt.length > 1; ) {
          let w = Nt.shift();
          Object.hasOwn(m, w) || (m[w] = {}), m = m[w];
        }
        let A = Nt[0], E = A.indexOf("#");
        if (E >= 0) {
          const w = A.substring(0, E), v = m[w];
          if (v === void 0 || !v.prototype) {
            const k = function(...O) {
              return k.wrap(k.prototype.constructor(0, ...O));
            };
            k.prototype = { valueOf() {
              return this[y];
            } }, k.wrap = function(O) {
              return Object.create(k.prototype, { [y]: { value: O, writable: !1 } });
            }, v && Object.getOwnPropertyNames(v).forEach((O) => Object.defineProperty(k, O, Object.getOwnPropertyDescriptor(v, O))), m[w] = k;
          }
          if (A = A.substring(E + 1), m = m[w].prototype, /^(get|set):/.test(A)) {
            if (!Object.hasOwn(m, A = A.substring(4))) {
              let k = St[at.replace("set:", "get:")], O = St[at.replace("get:", "set:")];
              Object.defineProperty(m, A, { get() {
                return k(this[y]);
              }, set(W) {
                O(this[y], W);
              }, enumerable: !0 });
            }
          } else
            A === "constructor" ? (m[A] = function(...k) {
              return et(k.length), _t(...k);
            }).original = _t : (m[A] = function(...k) {
              return et(k.length), _t(this[y], ...k);
            }).original = _t;
        } else
          /^(get|set):/.test(A) ? Object.hasOwn(m, A = A.substring(4)) || Object.defineProperty(m, A, { get: St[at.replace("set:", "get:")], set: St[at.replace("get:", "set:")], enumerable: !0 }) : typeof _t == "function" && _t !== et ? (m[A] = (...w) => (et(w.length), _t(...w))).original = _t : m[A] = _t;
      }
      return Ct;
    }
    Object.hasOwn = Object.hasOwn || function(St, Ct) {
      return Object.prototype.hasOwnProperty.call(St, Ct);
    };
    var ot = { instantiate: X, instantiateSync: rt, instantiateStreaming: nt, demangle: st };
    return u.default = ot, "default" in u ? u.default : u;
  }({});
  o.exports = c;
})(umd);
var asWasmImports$1 = {};
Object.defineProperty(asWasmImports$1, "__esModule", { value: !0 }), asWasmImports$1.asWasmImports = void 0;
const LoggerFactory_1$8 = LoggerFactory$1, asWasmImports = (o, n) => {
  const c = LoggerFactory_1$8.LoggerFactory.INST.create("WASM:AS");
  return { metering: { usegas: o.useGas }, console: { "console.log": function(u) {
    c.debug(`${o.contract.id}: ${n.exports.__getString(u)}`);
  }, "console.logO": function(u, h) {
    c.debug(`${o.contract.id}: ${n.exports.__getString(u)}`, JSON.parse(n.exports.__getString(h)));
  } }, block: { "Block.height": function() {
    return o.block.height;
  }, "Block.indep_hash": function() {
    return n.exports.__newString(o.block.indep_hash);
  }, "Block.timestamp": function() {
    return o.block.timestamp;
  } }, transaction: { "Transaction.id": function() {
    return n.exports.__newString(o.transaction.id);
  }, "Transaction.owner": function() {
    return n.exports.__newString(o.transaction.owner);
  }, "Transaction.target": function() {
    return n.exports.__newString(o.transaction.target);
  } }, contract: { "Contract.id": function() {
    return n.exports.__newString(o.contract.id);
  }, "Contract.owner": function() {
    return n.exports.__newString(o.contract.owner);
  } }, api: { _readContractState: (u, h) => {
    const g = n.exports.__getString(h), y = ($ = u, n.exports.table.get($));
    var $;
    return console.log("Simulating read state of", g), setTimeout(() => {
      console.log("calling callback"), y(n.exports.__newString(JSON.stringify({ contractTxId: g })));
    }, 1e3);
  }, clearTimeout }, env: { abort(u, h, g, y) {
    const $ = n.exports.__getString(u);
    throw c.error(`--------------------- Error message from AssemblyScript ----------------------
`), c.error("  " + $), c.error('    In file "' + n.exports.__getString(h) + '"'), c.error(`    on line ${g}, column ${y}.`), c.error(`------------------------------------------------------------------------------
`), new Error($);
  } } };
};
asWasmImports$1.asWasmImports = asWasmImports;
var rustWasmImports$1 = {};
Object.defineProperty(rustWasmImports$1, "__esModule", { value: !0 }), rustWasmImports$1.rustWasmImports = void 0;
const LoggerFactory_1$7 = LoggerFactory$1, rustWasmImports = (o, n, c, u) => {
  const h = LoggerFactory_1$7.LoggerFactory.INST.create("WASM:Rust"), g = { metering: { usegas: o.useGas }, console: { log: function(k) {
    h.debug(`${o.contract.id}: ${k}`);
  } }, Block: { height: function() {
    return o.block.height;
  }, indep_hash: function() {
    return o.block.indep_hash;
  }, timestamp: function() {
    return o.block.timestamp;
  } }, Transaction: { id: function() {
    return o.transaction.id;
  }, owner: function() {
    return o.transaction.owner;
  }, target: function() {
    return o.transaction.target;
  } }, Contract: { id: function() {
    return o.contract.id;
  }, owner: function() {
    return o.contract.owner;
  } }, SmartWeave: { caller: function() {
    return o.caller;
  }, readContractState: async function(k) {
    return await o.contracts.readContractState(k);
  }, write: async function(k, O) {
    return await o.contracts.write(k, O);
  } }, Vrf: { value: function() {
    return o.vrf.value;
  }, randomInt: function(k) {
    return o.vrf.randomInt(k);
  } } }, y = { __wbg_log_: function(k, O) {
    g.console.log(X(k, O));
  }, __wbindgen_json_parse: function(k, O) {
    return st(JSON.parse(X(k, O)));
  }, __wbindgen_json_serialize: function(k, O) {
    const W = ot(O);
    var it = at(JSON.stringify(W === void 0 ? null : W), c.exports.__wbindgen_malloc, c.exports.__wbindgen_realloc), vt = St;
    Nt()[k / 4 + 1] = vt, Nt()[k / 4 + 0] = it;
  }, __wbindgen_object_drop_ref: function(k) {
    m(k);
  }, __wbindgen_cb_drop: function(k) {
    const O = m(k).original;
    return O.cnt-- == 1 && (O.a = 0, !0);
  }, __wbg_readContractState: function(k, O) {
    return st(g.SmartWeave.readContractState(X(k, O)));
  }, __wbg_viewContractState: function(k, O) {
  }, __wbg_caller: function(k) {
    var O = at(g.SmartWeave.caller(), c.exports.__wbindgen_malloc, c.exports.__wbindgen_realloc), W = St;
    Nt()[k / 4 + 1] = W, Nt()[k / 4 + 0] = O;
  }, __wbg_write: function(k, O, W) {
    return st(g.SmartWeave.write(X(k, O), m(W)));
  }, __wbg_refreshState: function(k, O) {
  }, __wbg_indephash: function(k) {
    var O = at(g.Block.indep_hash(), c.exports.__wbindgen_malloc, c.exports.__wbindgen_realloc), W = St;
    Nt()[k / 4 + 1] = W, Nt()[k / 4 + 0] = O;
  }, __wbg_height: function() {
    return g.Block.height();
  }, __wbg_timestamp: function() {
    return g.Block.timestamp();
  }, __wbg_id: function(k) {
    var O = at(g.Transaction.id(), c.exports.__wbindgen_malloc, c.exports.__wbindgen_realloc), W = St;
    Nt()[k / 4 + 1] = W, Nt()[k / 4 + 0] = O;
  }, __wbg_contractOwner: function(k) {
    var O = at(g.Contract.owner(), c.exports.__wbindgen_malloc, c.exports.__wbindgen_realloc), W = St;
    Nt()[k / 4 + 1] = W, Nt()[k / 4 + 0] = O;
  }, __wbg_contractId: function(k) {
    var O = at(g.Contract.id(), c.exports.__wbindgen_malloc, c.exports.__wbindgen_realloc), W = St;
    Nt()[k / 4 + 1] = W, Nt()[k / 4 + 0] = O;
  }, __wbg_owner: function(k) {
    var O = at(g.Transaction.owner(), c.exports.__wbindgen_malloc, c.exports.__wbindgen_realloc), W = St;
    Nt()[k / 4 + 1] = W, Nt()[k / 4 + 0] = O;
  }, __wbg_target: function(k) {
    var O = at(g.Transaction.target(), c.exports.__wbindgen_malloc, c.exports.__wbindgen_realloc), W = St;
    Nt()[k / 4 + 1] = W, Nt()[k / 4 + 0] = O;
  }, __wbg_call: function() {
    return v(function(k, O, W) {
      return st(ot(k).call(ot(O), ot(W)));
    }, arguments);
  }, __wbg_new: function(k, O) {
    try {
      var W = { a: k, b: O }, it = new Promise((vt, xt) => {
        const It = W.a;
        W.a = 0;
        try {
          return function(Wt, Ut, zt, Jt) {
            c.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__(Wt, Ut, st(zt), st(Jt));
          }(It, W.b, vt, xt);
        } finally {
          W.a = It;
        }
      });
      return st(it);
    } finally {
      W.a = W.b = 0;
    }
  }, __wbg_resolve: function(k) {
    return st(Promise.resolve(ot(k)));
  }, __wbg_then_a: function(k, O) {
    return st(ot(k).then(ot(O)));
  }, __wbg_then_5: function(k, O, W) {
    return st(ot(k).then(ot(O), ot(W)));
  }, __wbindgen_debug_string: function(k, O) {
    var W = at(A(ot(O)), c.exports.__wbindgen_malloc, c.exports.__wbindgen_realloc), it = St;
    Nt()[k / 4 + 1] = it, Nt()[k / 4 + 0] = W;
  }, __wbindgen_throw: function(k, O) {
    throw new Error(X(k, O));
  }, __wbindgen_closure_wrapper: function(k, O, W) {
    var it = function(vt, xt, It, Wt) {
      const Ut = { a: vt, b: xt, cnt: 1, dtor: It }, zt = (...Jt) => {
        Ut.cnt++;
        const Xt = Ut.a;
        Ut.a = 0;
        try {
          return Wt(Xt, Ut.b, ...Jt);
        } finally {
          --Ut.cnt == 0 ? c.exports.__wbindgen_export_2.get(Ut.dtor)(Xt, Ut.b) : Ut.a = Xt;
        }
      };
      return zt.original = Ut, zt;
    }(k, O, u, E);
    return st(it);
  }, __wbindgen_string_new: function(k, O) {
    return st(X(k, O));
  }, __wbg_value: function(k) {
    var O = at(g.Vrf.value(), c.exports.__wbindgen_malloc, c.exports.__wbindgen_realloc), W = St;
    Nt()[k / 4 + 1] = W, Nt()[k / 4 + 0] = O;
  }, __wbg_randomInt: function(k, O) {
    return g.Vrf.randomInt(O);
  } }, $ = Object.keys(y);
  let I = n.reduce((k, O) => {
    const W = $.find((it) => O.startsWith(it));
    if (W === void 0)
      throw new Error(`Cannot find import mapping for ${O}`);
    return k[O] = y[W], k;
  }, {}), P = {};
  P.__wbindgen_placeholder__ = I;
  let L = new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 });
  L.decode();
  let q = null;
  function N() {
    return q !== null && q.buffer === c.exports.memory.buffer || (q = new Uint8Array(c.exports.memory.buffer)), q;
  }
  function X(k, O) {
    return L.decode(N().subarray(k, k + O));
  }
  const rt = new Array(32).fill(void 0);
  rt.push(void 0, null, !0, !1);
  let nt = rt.length;
  function st(k) {
    nt === rt.length && rt.push(rt.length + 1);
    const O = nt;
    return nt = rt[O], rt[O] = k, O;
  }
  function ot(k) {
    return rt[k];
  }
  let St = 0, Ct = new TextEncoder("utf-8");
  const et = typeof Ct.encodeInto == "function" ? function(k, O) {
    return Ct.encodeInto(k, O);
  } : function(k, O) {
    const W = Ct.encode(k);
    return O.set(W), { read: k.length, written: W.length };
  };
  function at(k, O, W) {
    if (W === void 0) {
      const Wt = Ct.encode(k), Ut = O(Wt.length);
      return N().subarray(Ut, Ut + Wt.length).set(Wt), St = Wt.length, Ut;
    }
    let it = k.length, vt = O(it);
    const xt = N();
    let It = 0;
    for (; It < it; It++) {
      const Wt = k.charCodeAt(It);
      if (Wt > 127)
        break;
      xt[vt + It] = Wt;
    }
    if (It !== it) {
      It !== 0 && (k = k.slice(It)), vt = W(vt, it, it = It + 3 * k.length);
      const Wt = N().subarray(vt + It, vt + it);
      It += et(k, Wt).written;
    }
    return St = It, vt;
  }
  let _t = null;
  function Nt() {
    return _t !== null && _t.buffer === c.exports.memory.buffer || (_t = new Int32Array(c.exports.memory.buffer)), _t;
  }
  function m(k) {
    const O = ot(k);
    return function(W) {
      W < 36 || (rt[W] = nt, nt = W);
    }(k), O;
  }
  function A(k) {
    const O = typeof k;
    if (O == "number" || O == "boolean" || k == null)
      return `${k}`;
    if (O == "string")
      return `"${k}"`;
    if (O == "symbol") {
      const vt = k.description;
      return vt == null ? "Symbol" : `Symbol(${vt})`;
    }
    if (O == "function") {
      const vt = k.name;
      return typeof vt == "string" && vt.length > 0 ? `Function(${vt})` : "Function";
    }
    if (Array.isArray(k)) {
      const vt = k.length;
      let xt = "[";
      vt > 0 && (xt += A(k[0]));
      for (let It = 1; It < vt; It++)
        xt += ", " + A(k[It]);
      return xt += "]", xt;
    }
    const W = /\[object ([^\]]+)\]/.exec(toString.call(k));
    let it;
    if (!(W.length > 1))
      return toString.call(k);
    if (it = W[1], it == "Object")
      try {
        return "Object(" + JSON.stringify(k) + ")";
      } catch {
        return "Object";
      }
    return k instanceof Error ? `${k.name}: ${k.message}
${k.stack}` : it;
  }
  function E(k, O, W) {
    c.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__(k, O, st(W));
  }
  I.handle = function(k) {
    return m(c.exports.handle(st(k)));
  };
  let w = 32;
  function v(k, O) {
    try {
      return k.apply(this, O);
    } catch (W) {
      c.exports.__wbindgen_exn_store(st(W));
    }
  }
  return I.initState = function(k) {
    try {
      c.exports.initState(function(O) {
        if (w == 1)
          throw new Error("out of js stack");
        return rt[--w] = O, w;
      }(k));
    } finally {
      rt[w++] = void 0;
    }
  }, I.currentState = function() {
    return m(c.exports.currentState());
  }, I.lang = function() {
    try {
      const W = c.exports.__wbindgen_add_to_stack_pointer(-16);
      c.exports.lang(W);
      var k = Nt()[W / 4 + 0], O = Nt()[W / 4 + 1];
      return X(k, O);
    } finally {
      c.exports.__wbindgen_add_to_stack_pointer(16), c.exports.__wbindgen_free(k, O);
    }
  }, I.type = function() {
    return c.exports.type();
  }, I.StateWrapper = class {
    __destroy_into_raw() {
      const k = this.ptr;
      return this.ptr = 0, k;
    }
    free() {
      const k = this.__destroy_into_raw();
      c.exports.__wbg_statewrapper_free(k);
    }
  }, P.metering = g.metering, { imports: P, exports: I };
};
rustWasmImports$1.rustWasmImports = rustWasmImports;
var goWasmImports = {};
Object.defineProperty(goWasmImports, "__esModule", { value: !0 }), goWasmImports.Go = void 0;
const LoggerFactory_1$6 = LoggerFactory$1, encoder = new TextEncoder(), decoder = new TextDecoder("utf-8");
let logLine = [], globalJsModule;
(function(o) {
  globalJsModule = o, globalJsModule.redstone = { go: {} };
}).call(commonjsGlobal, commonjsGlobal !== void 0 ? commonjsGlobal : typeof self < "u" ? self : typeof window < "u" ? window : {});
class Go {
  constructor(n) {
    this._callbackTimeouts = /* @__PURE__ */ new Map(), this._nextCallbackTimeoutID = 1;
    const c = LoggerFactory_1$6.LoggerFactory.INST.create("WASM:Go");
    let u = this;
    globalJsModule.redstone.go = { WasmModule: { registerWasmModule: function(N) {
      u._id = N, u.exports = globalJsModule[N], delete globalJsModule[N], globalJsModule.redstone.go[N] = {}, globalJsModule.redstone.go[N].imports = { console: { log: function(...X) {
        c.debug(X[0], ...X.slice(1));
      } }, Transaction: { id: function() {
        return n.transaction.id;
      }, owner: function() {
        return n.transaction.owner;
      }, target: function() {
        return n.transaction.target;
      } }, Block: { indep_hash: function() {
        return n.block.indep_hash;
      }, height: function() {
        return n.block.height;
      }, timestamp: function() {
        return n.block.timestamp;
      } }, Contract: { id: function() {
        return n.contract.id;
      }, owner: function() {
        return n.contract.owner;
      } }, SmartWeave: { readContractState: async function(X) {
        return await n.contracts.readContractState(X);
      } } };
    } } };
    const h = () => new DataView(this._inst.exports.memory.buffer), g = (N, X) => {
      h().setUint32(N + 0, X, !0), h().setUint32(N + 4, Math.floor(X / 4294967296), !0);
    }, y = (N) => {
      const X = h().getFloat64(N, !0);
      if (X === 0)
        return;
      if (!isNaN(X))
        return X;
      const rt = h().getUint32(N, !0);
      return this._values[rt];
    }, $ = (N, X) => {
      if (typeof X == "number")
        return isNaN(X) ? (h().setUint32(N + 4, 2146959360, !0), void h().setUint32(N, 0, !0)) : X === 0 ? (h().setUint32(N + 4, 2146959360, !0), void h().setUint32(N, 1, !0)) : void h().setFloat64(N, X, !0);
      switch (X) {
        case void 0:
          return void h().setFloat64(N, 0, !0);
        case null:
          return h().setUint32(N + 4, 2146959360, !0), void h().setUint32(N, 2, !0);
        case !0:
          return h().setUint32(N + 4, 2146959360, !0), void h().setUint32(N, 3, !0);
        case !1:
          return h().setUint32(N + 4, 2146959360, !0), void h().setUint32(N, 4, !0);
      }
      let nt = this._ids.get(X);
      nt === void 0 && (nt = this._idPool.pop(), nt === void 0 && (nt = this._values.length), this._values[nt] = X, this._goRefCounts[nt] = 0, this._ids.set(X, nt)), this._goRefCounts[nt]++;
      let st = 1;
      switch (typeof X) {
        case "string":
          st = 2;
          break;
        case "symbol":
          st = 3;
          break;
        case "function":
          st = 4;
      }
      h().setUint32(N + 4, 2146959360 | st, !0), h().setUint32(N, nt, !0);
    }, I = (N, X, rt = null) => new Uint8Array(this._inst.exports.memory.buffer, N, X), P = (N, X, rt) => {
      const nt = new Array(X);
      for (let st = 0; st < X; st++)
        nt[st] = y(N + 8 * st);
      return nt;
    }, L = (N, X) => decoder.decode(new DataView(this._inst.exports.memory.buffer, N, X)), q = Date.now() - performance.now();
    this.importObject = { wasi_snapshot_preview1: { fd_write: function(N, X, rt, nt) {
      let st = 0;
      if (N == 1)
        for (let ot = 0; ot < rt; ot++) {
          let St = X + 8 * ot, Ct = h().getUint32(St + 0, !0), et = h().getUint32(St + 4, !0);
          st += et;
          for (let at = 0; at < et; at++) {
            let _t = h().getUint8(Ct + at);
            if (_t != 13)
              if (_t == 10) {
                let Nt = decoder.decode(new Uint8Array(logLine));
                logLine = [], console.log(Nt);
              } else
                logLine.push(_t);
          }
        }
      else
        console.error("invalid file descriptor:", N);
      return h().setUint32(nt, st, !0), 0;
    }, fd_close: () => 0, fd_fdstat_get: () => 0, fd_seek: () => 0, proc_exit: (N) => {
      if (!commonjsGlobal.process)
        throw "trying to exit with code " + N;
      process.exit(N);
    }, random_get: (N, X) => (crypto.getRandomValues(I(N, X, null)), 0) }, env: { "runtime.ticks": () => q + performance.now(), "runtime.sleepTicks": (N) => {
      setTimeout(this._inst.exports.go_scheduler, N);
    }, "syscall/js.finalizeRef": (N) => {
      const X = h().getUint32(N, !0);
      if (this._goRefCounts[X]--, this._goRefCounts[X] === 0) {
        const rt = this._values[X];
        this._values[X] = null, this._ids.delete(rt), this._idPool.push(X);
      }
    }, "syscall/js.stringVal": (N, X, rt) => {
      const nt = L(X, rt);
      $(N, nt);
    }, "syscall/js.valueGet": (N, X, rt, nt) => {
      let st = L(rt, nt), ot = y(X), St = Reflect.get(ot, st);
      $(N, St);
    }, "syscall/js.valueSet": (N, X, rt, nt) => {
      const st = y(N), ot = L(X, rt), St = y(nt);
      Reflect.set(st, ot, St);
    }, "syscall/js.valueDelete": (N, X, rt) => {
      const nt = y(N), st = L(X, rt);
      Reflect.deleteProperty(nt, st);
    }, "syscall/js.valueIndex": (N, X, rt) => {
      $(N, Reflect.get(y(X), rt));
    }, "syscall/js.valueSetIndex": (N, X, rt) => {
      Reflect.set(y(N), X, y(rt));
    }, "syscall/js.valueCall": (N, X, rt, nt, st, ot, St) => {
      const Ct = y(X), et = L(rt, nt), at = P(st, ot);
      try {
        const _t = Reflect.get(Ct, et);
        $(N, Reflect.apply(_t, Ct, at)), h().setUint8(N + 8, 1);
      } catch (_t) {
        $(N, _t), h().setUint8(N + 8, 0);
      }
    }, "syscall/js.valueInvoke": (N, X, rt, nt, st) => {
      try {
        const ot = y(X), St = P(rt, nt);
        $(N, Reflect.apply(ot, void 0, St)), h().setUint8(N + 8, 1);
      } catch (ot) {
        $(N, ot), h().setUint8(N + 8, 0);
      }
    }, "syscall/js.valueNew": (N, X, rt, nt, st) => {
      const ot = y(X), St = P(rt, nt);
      try {
        $(N, Reflect.construct(ot, St)), h().setUint8(N + 8, 1);
      } catch (Ct) {
        $(N, Ct), h().setUint8(N + 8, 0);
      }
    }, "syscall/js.valueLength": (N) => y(N).length, "syscall/js.valuePrepareString": (N, X) => {
      const rt = String(y(X)), nt = encoder.encode(rt);
      $(N, nt), g(N + 8, nt.length);
    }, "syscall/js.valueLoadString": (N, X, rt, nt) => {
      const st = y(N);
      I(X, rt, nt).set(st);
    }, "syscall/js.valueInstanceOf": (N, X) => y(N) instanceof y(X), "syscall/js.copyBytesToGo": (N, X, rt, nt, st) => {
      let ot = N, St = N + 4;
      const Ct = I(X, rt), et = y(st);
      if (!(et instanceof Uint8Array))
        return void h().setUint8(St, 0);
      const at = et.subarray(0, Ct.length);
      Ct.set(at), g(ot, at.length), h().setUint8(St, 1);
    }, "syscall/js.copyBytesToJS": (N, X, rt, nt, st) => {
      let ot = N, St = N + 4;
      const Ct = y(X), et = I(rt, nt);
      if (!(Ct instanceof Uint8Array))
        return void h().setUint8(St, 0);
      const at = et.subarray(0, Ct.length);
      Ct.set(at), g(ot, at.length), h().setUint8(St, 1);
    } } };
  }
  async run(n) {
    for (this._inst = n, this._values = [NaN, 0, null, !0, !1, commonjsGlobal, this], this._goRefCounts = [], this._ids = /* @__PURE__ */ new Map(), this._idPool = [], this.exited = !1, new DataView(this._inst.exports.memory.buffer); ; ) {
      const c = new Promise((u) => {
        this._resolveCallbackPromise = () => {
          if (this.exited)
            throw new Error("bad callback: Go program has already exited");
          setTimeout(u, 0);
        };
      });
      if (this._inst.exports._start(), this.exited)
        break;
      await c;
    }
  }
  _resume() {
    if (this.exited)
      throw new Error("Go program has already exited");
    this._inst.exports.resume(), this.exited && this._resolveExitPromise();
  }
  _makeFuncWrapper(n) {
    const c = this;
    return function() {
      const u = { id: n, this: this, args: arguments };
      return c._pendingEvent = u, c._resume(), u.result;
    };
  }
  _resolveExitPromise() {
  }
}
goWasmImports.Go = Go;
var smartweaveGlobal = {};
Object.defineProperty(smartweaveGlobal, "__esModule", { value: !0 }), smartweaveGlobal.SmartWeaveGlobal = void 0;
class SmartWeaveGlobal {
  constructor(n, c, u) {
    this.gasUsed = 0, this.gasLimit = Number.MAX_SAFE_INTEGER, this.unsafeClient = n, this.arweave = { ar: n.ar, utils: n.utils, wallets: n.wallets, crypto: n.crypto }, this.evaluationOptions = u, this.contract = c, this.transaction = new Transaction(this), this.block = new Block(this), this.contracts = { readContractState: (h, g, y) => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    }, viewContractState: (h, g) => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    }, write: (h, g, y) => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    }, refreshState: () => {
      throw new Error("Not implemented - should be set by HandlerApi implementor");
    } }, this.vrf = new Vrf(this), this.useGas = this.useGas.bind(this), this.getBalance = this.getBalance.bind(this);
  }
  useGas(n) {
    if (n < 0)
      throw new Error("[RE:GNE] Gas number exception - gas < 0.");
    if (this.gasUsed += n, this.gasUsed > this.gasLimit)
      throw new Error(`[RE:OOG] Out of gas! Used: ${this.gasUsed}, limit: ${this.gasLimit}`);
  }
  async getBalance(n, c) {
    if (!this._activeTx)
      throw new Error("Cannot read balance - active tx is not set.");
    if (!this.block.height)
      throw new Error("Cannot read balance - block height not set.");
    const u = c || this.block.height;
    return await fetch(`${this.evaluationOptions.walletBalanceUrl}block/height/${u}/wallet/${n}/balance`).then((h) => h.ok ? h.text() : Promise.reject(h)).catch((h) => {
      var g;
      throw new Error(`Unable to read wallet balance. ${h.status}. ${(g = h.body) === null || g === void 0 ? void 0 : g.message}`);
    });
  }
}
smartweaveGlobal.SmartWeaveGlobal = SmartWeaveGlobal;
class Transaction {
  constructor(n) {
    this.smartWeaveGlobal = n;
  }
  get id() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.id;
  }
  get owner() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.owner.address;
  }
  get target() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.recipient;
  }
  get tags() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.tags;
  }
  get quantity() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.quantity.winston;
  }
  get reward() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.fee.winston;
  }
}
class Block {
  constructor(n) {
    this.smartWeaveGlobal = n;
  }
  get height() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.block.height;
  }
  get indep_hash() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current Tx");
    return this.smartWeaveGlobal._activeTx.block.id;
  }
  get timestamp() {
    if (!this.smartWeaveGlobal._activeTx)
      throw new Error("No current tx");
    return this.smartWeaveGlobal._activeTx.block.timestamp;
  }
}
class Vrf {
  constructor(n) {
    this.smartWeaveGlobal = n;
  }
  get data() {
    return this.smartWeaveGlobal._activeTx.vrf;
  }
  get value() {
    return this.smartWeaveGlobal._activeTx.vrf.bigint;
  }
  randomInt(n) {
    if (!Number.isInteger(n))
      throw new Error("Integer max value required for random integer generation");
    const c = BigInt(this.smartWeaveGlobal._activeTx.vrf.bigint) % BigInt(n) + BigInt(1);
    if (c > Number.MAX_SAFE_INTEGER || c < Number.MIN_SAFE_INTEGER)
      throw new Error("Random int cannot be cast to number");
    return Number(c);
  }
}
var JsHandlerApi$1 = {}, AbstractContractHandler$1 = {}, Contract = {};
Object.defineProperty(Contract, "__esModule", { value: !0 }), Contract.ContractError = void 0;
class ContractError$1 extends Error {
  constructor(n) {
    super(n), this.name = "ContractError";
  }
}
Contract.ContractError = ContractError$1, Object.defineProperty(AbstractContractHandler$1, "__esModule", { value: !0 }), AbstractContractHandler$1.AbstractContractHandler = void 0;
const Contract_1 = Contract, LoggerFactory_1$5 = LoggerFactory$1, utils_1$3 = utils$n;
class AbstractContractHandler {
  constructor(n, c) {
    this.swGlobal = n, this.contractDefinition = c, this.logger = LoggerFactory_1$5.LoggerFactory.INST.create("ContractHandler"), this.assignReadContractState = this.assignReadContractState.bind(this), this.assignViewContractState = this.assignViewContractState.bind(this), this.assignWrite = this.assignWrite.bind(this), this.assignRefreshState = this.assignRefreshState.bind(this);
  }
  async dispose() {
  }
  assignWrite(n, c) {
    this.swGlobal.contracts.write = async (u, h, g) => {
      if (!n.evaluationOptions.internalWrites)
        throw new Error("Internal writes feature switched off. Change EvaluationOptions.internalWrites flag to 'true'");
      const y = g == null ? n.evaluationOptions.throwOnInternalWriteError : g, $ = { from: this.contractDefinition.txId, to: u, input: h };
      this.logger.debug("swGlobal.write call:", $);
      const I = n.warp.contract(u, n.contract, { callingInteraction: this.swGlobal._activeTx, callType: "write" }), P = await I.dryWriteFromTx(h, this.swGlobal._activeTx, [...c || [], { contractTxId: this.contractDefinition.txId, interactionTxId: this.swGlobal.transaction.id }]);
      this.logger.debug("Cache result?:", !this.swGlobal._activeTx.dry);
      const L = P.type !== "ok" && y && (!this.swGlobal._activeTx.dry || this.swGlobal._activeTx.dry && this.swGlobal._activeTx.strict), q = L ? `Internal write auto error for call [${JSON.stringify($)}]: ${P.errorMessage}` : P.errorMessage;
      if (await n.warp.stateEvaluator.onInternalWriteStateUpdate(this.swGlobal._activeTx, u, { state: P.state, validity: { ...P.originalValidity, [this.swGlobal._activeTx.id]: P.type == "ok" }, errorMessages: { ...P.originalErrorMessages, [this.swGlobal._activeTx.id]: q } }), L)
        throw new Contract_1.ContractError(q);
      return P;
    };
  }
  assignViewContractState(n) {
    this.swGlobal.contracts.viewContractState = async (c, u) => (this.logger.debug("swGlobal.viewContractState call:", { from: this.contractDefinition.txId, to: c, input: u }), await n.warp.contract(c, n.contract, { callingInteraction: this.swGlobal._activeTx, callType: "view" }).viewStateForTx(u, this.swGlobal._activeTx));
  }
  assignReadContractState(n, c, u, h) {
    this.swGlobal.contracts.readContractState = async (g, y) => {
      this.logger.debug("swGlobal.readContractState call:", { from: this.contractDefinition.txId, to: g, sortKey: h.sortKey, transaction: this.swGlobal.transaction.id });
      const { stateEvaluator: $ } = n.warp, I = n.warp.contract(g, n.contract, { callingInteraction: h, callType: "read" });
      await $.onContractCall(h, n, u);
      const P = await I.readState(h.sortKey, [...c || [], { contractTxId: this.contractDefinition.txId, interactionTxId: this.swGlobal.transaction.id }]);
      return y ? (0, utils_1$3.deepCopy)(P) : (0, utils_1$3.deepCopy)(P.cachedValue.state);
    };
  }
  assignRefreshState(n) {
    this.swGlobal.contracts.refreshState = async () => {
      const c = n.warp.stateEvaluator, u = await c.latestAvailableState(this.swGlobal.contract.id, this.swGlobal._activeTx.sortKey);
      return u == null ? void 0 : u.cachedValue.state;
    };
  }
}
AbstractContractHandler$1.AbstractContractHandler = AbstractContractHandler, Object.defineProperty(JsHandlerApi$1, "__esModule", { value: !0 }), JsHandlerApi$1.JsHandlerApi = void 0;
const utils_1$2 = utils$n, AbstractContractHandler_1$1 = AbstractContractHandler$1;
class JsHandlerApi extends AbstractContractHandler_1$1.AbstractContractHandler {
  constructor(n, c, u) {
    super(n, c), this.contractFunction = u;
  }
  async handle(n, c, u) {
    const { timeoutId: h, timeoutPromise: g } = (0, utils_1$2.timeout)(n.evaluationOptions.maxInteractionEvaluationTimeSeconds);
    try {
      const { interaction: y, interactionTx: $, currentTx: I } = u, P = (0, utils_1$2.deepCopy)(c.state, n.evaluationOptions.useFastCopy);
      this.swGlobal._activeTx = $, this.swGlobal.caller = y.caller, this.assignReadContractState(n, I, c, $), this.assignViewContractState(n), this.assignWrite(n, I), this.assignRefreshState(n);
      const L = await Promise.race([g, this.contractFunction(P, y)]);
      if (L && (L.state !== void 0 || L.result !== void 0))
        return { type: "ok", result: L.result, state: L.state || c.state };
      throw new Error(`Unexpected result from contract: ${JSON.stringify(L)}`);
    } catch (y) {
      return y.name === "ContractError" ? { type: "error", errorMessage: y.message, state: c.state, result: null } : { type: "exception", errorMessage: `${y && y.stack || y && y.message || y}`, state: c.state, result: null };
    } finally {
      h !== null && clearTimeout(h);
    }
  }
  initState(n) {
  }
}
JsHandlerApi$1.JsHandlerApi = JsHandlerApi;
var WasmHandlerApi$1 = {}, safeStableStringify = { exports: {} };
(function(o, n) {
  const c = st();
  c.configure = st, c.stringify = c, c.default = c, n.stringify = c, n.configure = st, o.exports = c;
  const u = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/, h = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/g, g = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006", "\\u0007", "\\b", "\\t", "\\n", "\\u000b", "\\f", "\\r", "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012", "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c", "\\u001d", "\\u001e", "\\u001f", "", "", '\\"', "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "\\\\"];
  function y(ot) {
    if (ot.length === 2) {
      const Ct = ot.charCodeAt(1);
      return `${ot[0]}\\u${Ct.toString(16)}`;
    }
    const St = ot.charCodeAt(0);
    return g.length > St ? g[St] : `\\u${St.toString(16)}`;
  }
  function $(ot) {
    if (ot.length < 5e3 && !u.test(ot))
      return ot;
    if (ot.length > 100)
      return ot.replace(h, y);
    let St = "", Ct = 0;
    for (let et = 0; et < ot.length; et++) {
      const at = ot.charCodeAt(et);
      if (at === 34 || at === 92 || at < 32)
        St += `${ot.slice(Ct, et)}${g[at]}`, Ct = et + 1;
      else if (at >= 55296 && at <= 57343) {
        if (at <= 56319 && et + 1 < ot.length) {
          const _t = ot.charCodeAt(et + 1);
          if (_t >= 56320 && _t <= 57343) {
            et++;
            continue;
          }
        }
        St += `${ot.slice(Ct, et)}\\u${at.toString(16)}`, Ct = et + 1;
      }
    }
    return St += ot.slice(Ct), St;
  }
  function I(ot) {
    if (ot.length > 200)
      return ot.sort();
    for (let St = 1; St < ot.length; St++) {
      const Ct = ot[St];
      let et = St;
      for (; et !== 0 && ot[et - 1] > Ct; )
        ot[et] = ot[et - 1], et--;
      ot[et] = Ct;
    }
    return ot;
  }
  const P = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())), Symbol.toStringTag).get;
  function L(ot) {
    return P.call(ot) !== void 0 && ot.length !== 0;
  }
  function q(ot, St, Ct) {
    ot.length < Ct && (Ct = ot.length);
    const et = St === "," ? "" : " ";
    let at = `"0":${et}${ot[0]}`;
    for (let _t = 1; _t < Ct; _t++)
      at += `${St}"${_t}":${et}${ot[_t]}`;
    return at;
  }
  function N(ot, St) {
    if (ot && Object.prototype.hasOwnProperty.call(ot, St)) {
      var Ct = ot[St];
      if (typeof Ct != "boolean")
        throw new TypeError(`The "${St}" argument must be of type boolean`);
    }
    return Ct === void 0 || Ct;
  }
  function X(ot, St) {
    if (ot && Object.prototype.hasOwnProperty.call(ot, St)) {
      var Ct = ot[St];
      if (typeof Ct != "number")
        throw new TypeError(`The "${St}" argument must be of type number`);
      if (!Number.isInteger(Ct))
        throw new TypeError(`The "${St}" argument must be an integer`);
      if (Ct < 1)
        throw new RangeError(`The "${St}" argument must be >= 1`);
    }
    return Ct === void 0 ? 1 / 0 : Ct;
  }
  function rt(ot) {
    return ot === 1 ? "1 item" : `${ot} items`;
  }
  function nt(ot) {
    const St = /* @__PURE__ */ new Set();
    for (const Ct of ot)
      typeof Ct == "string" ? St.add(Ct) : typeof Ct == "number" && St.add(String(Ct));
    return St;
  }
  function st(ot) {
    const St = function(w) {
      if (w && Object.prototype.hasOwnProperty.call(w, "circularValue")) {
        var v = w.circularValue;
        if (typeof v == "string")
          return `"${v}"`;
        if (v == null)
          return v;
        if (v === Error || v === TypeError)
          return { toString() {
            throw new TypeError("Converting circular structure to JSON");
          } };
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }(ot), Ct = N(ot, "bigint"), et = N(ot, "deterministic"), at = X(ot, "maximumDepth"), _t = X(ot, "maximumBreadth");
    function Nt(w, v, k, O, W, it) {
      let vt = v[w];
      switch (typeof vt == "object" && vt !== null && typeof vt.toJSON == "function" && (vt = vt.toJSON(w)), vt = O.call(v, w, vt), typeof vt) {
        case "string":
          return `"${$(vt)}"`;
        case "object": {
          if (vt === null)
            return "null";
          if (k.indexOf(vt) !== -1)
            return St;
          let xt = "", It = ",";
          const Wt = it;
          if (Array.isArray(vt)) {
            if (vt.length === 0)
              return "[]";
            if (at < k.length + 1)
              return '"[Array]"';
            k.push(vt), W !== "" && (xt += `
${it += W}`, It = `,
${it}`);
            const oe = Math.min(vt.length, _t);
            let De = 0;
            for (; De < oe - 1; De++) {
              const xe = Nt(De, vt, k, O, W, it);
              xt += xe !== void 0 ? xe : "null", xt += It;
            }
            const ue = Nt(De, vt, k, O, W, it);
            return xt += ue !== void 0 ? ue : "null", vt.length - 1 > _t && (xt += `${It}"... ${rt(vt.length - _t - 1)} not stringified"`), W !== "" && (xt += `
${Wt}`), k.pop(), `[${xt}]`;
          }
          let Ut = Object.keys(vt);
          const zt = Ut.length;
          if (zt === 0)
            return "{}";
          if (at < k.length + 1)
            return '"[Object]"';
          let Jt = "", Xt = "";
          W !== "" && (It = `,
${it += W}`, Jt = " ");
          let ie = Math.min(zt, _t);
          L(vt) && (xt += q(vt, It, _t), Ut = Ut.slice(vt.length), ie -= vt.length, Xt = It), et && (Ut = I(Ut)), k.push(vt);
          for (let oe = 0; oe < ie; oe++) {
            const De = Ut[oe], ue = Nt(De, vt, k, O, W, it);
            ue !== void 0 && (xt += `${Xt}"${$(De)}":${Jt}${ue}`, Xt = It);
          }
          return zt > _t && (xt += `${Xt}"...":${Jt}"${rt(zt - _t)} not stringified"`, Xt = It), W !== "" && Xt.length > 1 && (xt = `
${it}${xt}
${Wt}`), k.pop(), `{${xt}}`;
        }
        case "number":
          return isFinite(vt) ? String(vt) : "null";
        case "boolean":
          return vt === !0 ? "true" : "false";
        case "bigint":
          return Ct ? String(vt) : void 0;
      }
    }
    function m(w, v, k, O, W, it) {
      switch (typeof v == "object" && v !== null && typeof v.toJSON == "function" && (v = v.toJSON(w)), typeof v) {
        case "string":
          return `"${$(v)}"`;
        case "object": {
          if (v === null)
            return "null";
          if (k.indexOf(v) !== -1)
            return St;
          const vt = it;
          let xt = "", It = ",";
          if (Array.isArray(v)) {
            if (v.length === 0)
              return "[]";
            if (at < k.length + 1)
              return '"[Array]"';
            k.push(v), W !== "" && (xt += `
${it += W}`, It = `,
${it}`);
            const zt = Math.min(v.length, _t);
            let Jt = 0;
            for (; Jt < zt - 1; Jt++) {
              const ie = m(Jt, v[Jt], k, O, W, it);
              xt += ie !== void 0 ? ie : "null", xt += It;
            }
            const Xt = m(Jt, v[Jt], k, O, W, it);
            return xt += Xt !== void 0 ? Xt : "null", v.length - 1 > _t && (xt += `${It}"... ${rt(v.length - _t - 1)} not stringified"`), W !== "" && (xt += `
${vt}`), k.pop(), `[${xt}]`;
          }
          if (O.size === 0)
            return "{}";
          k.push(v);
          let Wt = "";
          W !== "" && (It = `,
${it += W}`, Wt = " ");
          let Ut = "";
          for (const zt of O) {
            const Jt = m(zt, v[zt], k, O, W, it);
            Jt !== void 0 && (xt += `${Ut}"${$(zt)}":${Wt}${Jt}`, Ut = It);
          }
          return W !== "" && Ut.length > 1 && (xt = `
${it}${xt}
${vt}`), k.pop(), `{${xt}}`;
        }
        case "number":
          return isFinite(v) ? String(v) : "null";
        case "boolean":
          return v === !0 ? "true" : "false";
        case "bigint":
          return Ct ? String(v) : void 0;
      }
    }
    function A(w, v, k, O, W) {
      switch (typeof v) {
        case "string":
          return `"${$(v)}"`;
        case "object": {
          if (v === null)
            return "null";
          if (typeof v.toJSON == "function") {
            if (typeof (v = v.toJSON(w)) != "object")
              return A(w, v, k, O, W);
            if (v === null)
              return "null";
          }
          if (k.indexOf(v) !== -1)
            return St;
          const it = W;
          if (Array.isArray(v)) {
            if (v.length === 0)
              return "[]";
            if (at < k.length + 1)
              return '"[Array]"';
            k.push(v);
            let Jt = `
${W += O}`;
            const Xt = `,
${W}`, ie = Math.min(v.length, _t);
            let oe = 0;
            for (; oe < ie - 1; oe++) {
              const ue = A(oe, v[oe], k, O, W);
              Jt += ue !== void 0 ? ue : "null", Jt += Xt;
            }
            const De = A(oe, v[oe], k, O, W);
            return Jt += De !== void 0 ? De : "null", v.length - 1 > _t && (Jt += `${Xt}"... ${rt(v.length - _t - 1)} not stringified"`), Jt += `
${it}`, k.pop(), `[${Jt}]`;
          }
          let vt = Object.keys(v);
          const xt = vt.length;
          if (xt === 0)
            return "{}";
          if (at < k.length + 1)
            return '"[Object]"';
          const It = `,
${W += O}`;
          let Wt = "", Ut = "", zt = Math.min(xt, _t);
          L(v) && (Wt += q(v, It, _t), vt = vt.slice(v.length), zt -= v.length, Ut = It), et && (vt = I(vt)), k.push(v);
          for (let Jt = 0; Jt < zt; Jt++) {
            const Xt = vt[Jt], ie = A(Xt, v[Xt], k, O, W);
            ie !== void 0 && (Wt += `${Ut}"${$(Xt)}": ${ie}`, Ut = It);
          }
          return xt > _t && (Wt += `${Ut}"...": "${rt(xt - _t)} not stringified"`, Ut = It), Ut !== "" && (Wt = `
${W}${Wt}
${it}`), k.pop(), `{${Wt}}`;
        }
        case "number":
          return isFinite(v) ? String(v) : "null";
        case "boolean":
          return v === !0 ? "true" : "false";
        case "bigint":
          return Ct ? String(v) : void 0;
      }
    }
    function E(w, v, k) {
      switch (typeof v) {
        case "string":
          return `"${$(v)}"`;
        case "object": {
          if (v === null)
            return "null";
          if (typeof v.toJSON == "function") {
            if (typeof (v = v.toJSON(w)) != "object")
              return E(w, v, k);
            if (v === null)
              return "null";
          }
          if (k.indexOf(v) !== -1)
            return St;
          let O = "";
          if (Array.isArray(v)) {
            if (v.length === 0)
              return "[]";
            if (at < k.length + 1)
              return '"[Array]"';
            k.push(v);
            const It = Math.min(v.length, _t);
            let Wt = 0;
            for (; Wt < It - 1; Wt++) {
              const zt = E(Wt, v[Wt], k);
              O += zt !== void 0 ? zt : "null", O += ",";
            }
            const Ut = E(Wt, v[Wt], k);
            return O += Ut !== void 0 ? Ut : "null", v.length - 1 > _t && (O += `,"... ${rt(v.length - _t - 1)} not stringified"`), k.pop(), `[${O}]`;
          }
          let W = Object.keys(v);
          const it = W.length;
          if (it === 0)
            return "{}";
          if (at < k.length + 1)
            return '"[Object]"';
          let vt = "", xt = Math.min(it, _t);
          L(v) && (O += q(v, ",", _t), W = W.slice(v.length), xt -= v.length, vt = ","), et && (W = I(W)), k.push(v);
          for (let It = 0; It < xt; It++) {
            const Wt = W[It], Ut = E(Wt, v[Wt], k);
            Ut !== void 0 && (O += `${vt}"${$(Wt)}":${Ut}`, vt = ",");
          }
          return it > _t && (O += `${vt}"...":"${rt(it - _t)} not stringified"`), k.pop(), `{${O}}`;
        }
        case "number":
          return isFinite(v) ? String(v) : "null";
        case "boolean":
          return v === !0 ? "true" : "false";
        case "bigint":
          return Ct ? String(v) : void 0;
      }
    }
    return function(w, v, k) {
      if (arguments.length > 1) {
        let O = "";
        if (typeof k == "number" ? O = " ".repeat(Math.min(k, 10)) : typeof k == "string" && (O = k.slice(0, 10)), v != null) {
          if (typeof v == "function")
            return Nt("", { "": w }, [], v, O, "");
          if (Array.isArray(v))
            return m("", w, [], nt(v), O, "");
        }
        if (O.length !== 0)
          return A("", w, [], O, "");
      }
      return E("", w, []);
    };
  }
})(safeStableStringify, safeStableStringify.exports);
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(WasmHandlerApi$1, "__esModule", { value: !0 }), WasmHandlerApi$1.WasmHandlerApi = void 0;
const safe_stable_stringify_1 = __importDefault$4(safeStableStringify.exports), AbstractContractHandler_1 = AbstractContractHandler$1;
class WasmHandlerApi extends AbstractContractHandler_1.AbstractContractHandler {
  constructor(n, c, u) {
    super(n, c), this.wasmExports = u;
  }
  async handle(n, c, u) {
    try {
      const { interaction: h, interactionTx: g, currentTx: y } = u;
      return this.swGlobal._activeTx = g, this.swGlobal.caller = h.caller, this.swGlobal.gasLimit = n.evaluationOptions.gasLimit, this.swGlobal.gasUsed = 0, this.assignReadContractState(n, y, c, g), this.assignWrite(n, y), { type: "ok", result: await this.doHandle(h), state: this.doGetCurrentState(), gasUsed: this.swGlobal.gasUsed };
    } catch (h) {
      const g = { errorMessage: h.message, state: c.state, result: null };
      return h.message.startsWith("[RE:") ? (this.logger.fatal(h), { ...g, type: "exception" }) : { ...g, type: "error" };
    }
  }
  initState(n) {
    switch (this.contractDefinition.srcWasmLang) {
      case "assemblyscript": {
        const c = this.wasmExports.__newString((0, safe_stable_stringify_1.default)(n));
        this.wasmExports.initState(c);
        break;
      }
      case "rust":
        this.wasmExports.initState(n);
        break;
      case "go":
        this.wasmExports.initState((0, safe_stable_stringify_1.default)(n));
        break;
      default:
        throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
    }
  }
  async doHandle(n) {
    switch (this.contractDefinition.srcWasmLang) {
      case "assemblyscript": {
        const c = this.wasmExports.__newString((0, safe_stable_stringify_1.default)(n.input)), u = this.wasmExports.handle(c), h = this.wasmExports.__getString(u);
        return JSON.parse(h);
      }
      case "rust": {
        let c = await this.wasmExports.handle(n.input);
        if (!c)
          return;
        if (Object.prototype.hasOwnProperty.call(c, "Ok"))
          return c.Ok;
        {
          let u;
          this.logger.debug("Error from rust", c.Err);
          let h = "";
          throw typeof c.Err == "string" || c.Err instanceof String ? u = c.Err : (u = Object.keys(c.Err)[0], h = " " + c.Err[u]), u == "RuntimeError" ? new Error(`[RE:RE]${h}`) : new Error(`[CE:${u}${h}]`);
        }
      }
      case "go": {
        const c = await this.wasmExports.handle((0, safe_stable_stringify_1.default)(n.input));
        return JSON.parse(c);
      }
      default:
        throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
    }
  }
  doGetCurrentState() {
    switch (this.contractDefinition.srcWasmLang) {
      case "assemblyscript": {
        const n = this.wasmExports.currentState();
        return JSON.parse(this.wasmExports.__getString(n));
      }
      case "rust":
        return this.wasmExports.currentState();
      case "go": {
        const n = this.wasmExports.currentState();
        return JSON.parse(n);
      }
      default:
        throw new Error(`Support for ${this.contractDefinition.srcWasmLang} not implemented yet.`);
    }
  }
}
WasmHandlerApi$1.WasmHandlerApi = WasmHandlerApi;
var normalizeSource = {};
function normalizeContractSource(o, n) {
  const c = o.trim().split(`
`), u = c[0], h = c[c.length - 1];
  return (/\(\s*\(\)\s*=>\s*{/g.test(u) || /\s*\(\s*function\s*\(\)\s*{/g.test(u)) && /}\s*\)\s*\(\)\s*;/g.test(h) && (c.shift(), c.pop(), o = c.join(`
`)), o = o.replace(/export\s+async\s+function\s+handle/gmu, "async function handle").replace(/export\s+function\s+handle/gmu, "function handle"), n ? `
    ${o}
    module.exports = handle;` : `
    const [SmartWeave, BigNumber, logger] = arguments;
    class ContractError extends Error { constructor(message) { super(message); this.name = 'ContractError' } };
    function ContractAssert(cond, message) { if (!cond) throw new ContractError(message) };
    ${o};
    return handle;
  `;
}
Object.defineProperty(normalizeSource, "__esModule", { value: !0 }), normalizeSource.normalizeContractSource = void 0, normalizeSource.normalizeContractSource = normalizeContractSource;
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, n, c, u) {
  u === void 0 && (u = c);
  var h = Object.getOwnPropertyDescriptor(n, c);
  h && !("get" in h ? !n.__esModule : h.writable || h.configurable) || (h = { enumerable: !0, get: function() {
    return n[c];
  } }), Object.defineProperty(o, u, h);
} : function(o, n, c, u) {
  u === void 0 && (u = c), o[u] = n[c];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, n) {
  Object.defineProperty(o, "default", { enumerable: !0, value: n });
} : function(o, n) {
  o.default = n;
}), __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(o) {
  if (o && o.__esModule)
    return o;
  var n = {};
  if (o != null)
    for (var c in o)
      c !== "default" && Object.prototype.hasOwnProperty.call(o, c) && __createBinding(n, o, c);
  return __setModuleDefault(n, o), n;
}, __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(HandlerExecutorFactory$1, "__esModule", { value: !0 }), HandlerExecutorFactory$1.HandlerExecutorFactory = void 0;
const loader_1 = __importDefault$3(umd.exports), as_wasm_imports_1 = asWasmImports$1, rust_wasm_imports_1 = rustWasmImports$1, go_wasm_imports_1$1 = goWasmImports, bignumber_js_1 = __importDefault$3(bignumber.exports), vm2 = __importStar(require$$2$1), smartweave_global_1 = smartweaveGlobal, Benchmark_1 = Benchmark$1, LoggerFactory_1$4 = LoggerFactory$1, JsHandlerApi_1 = JsHandlerApi$1, WasmHandlerApi_1 = WasmHandlerApi$1, normalize_source_1 = normalizeSource, MemCache_1 = MemCache$1;
class ContractError extends Error {
  constructor(n) {
    super(n), this.name = "ContractError";
  }
}
class HandlerExecutorFactory {
  constructor(n) {
    this.arweave = n, this.logger = LoggerFactory_1$4.LoggerFactory.INST.create("HandlerExecutorFactory"), this.cache = new MemCache_1.MemCache();
  }
  async create(n, c) {
    const u = new smartweave_global_1.SmartWeaveGlobal(this.arweave, { id: n.txId, owner: n.owner }, c);
    if (n.contractType == "wasm") {
      this.logger.info("Creating handler for wasm contract", n.txId);
      const h = Benchmark_1.Benchmark.measure();
      let g, y = null;
      const $ = generateResponse(n.srcBinary);
      switch (n.srcWasmLang) {
        case "assemblyscript": {
          const I = { exports: null };
          g = await loader_1.default.instantiateStreaming($, (0, as_wasm_imports_1.asWasmImports)(u, I)), I.exports = g.exports;
          break;
        }
        case "rust": {
          const I = { exports: null, modifiedExports: { wasm_bindgen__convert__closures__invoke2_mut__: null, _dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__: null } }, P = await getWasmModule($, n.srcBinary), L = WebAssembly.Module.imports(P).filter((X) => X.module === "__wbindgen_placeholder__").map((X) => X.name), { imports: q, exports: N } = (0, rust_wasm_imports_1.rustWasmImports)(u, L, I, n.metadata.dtor);
          y = N, g = await WebAssembly.instantiate(P, q), I.exports = g.exports, Object.keys(g.exports).forEach((X) => {
            X.startsWith("wasm_bindgen__convert__closures__invoke2_mut__") && (I.modifiedExports.wasm_bindgen__convert__closures__invoke2_mut__ = g.exports[X]), X.startsWith("_dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__") && (I.modifiedExports._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__ = g.exports[X]);
          });
          break;
        }
        case "go": {
          const I = new go_wasm_imports_1$1.Go(u);
          I.importObject.metering = { usegas: function(L) {
            u.useGas(L);
          } };
          const P = await getWasmModule($, n.srcBinary);
          g = await WebAssembly.instantiate(P, I.importObject), I.run(g), y = I.exports;
          break;
        }
        default:
          throw new Error(`Support for ${n.srcWasmLang} not implemented yet.`);
      }
      return this.logger.info(`WASM ${n.srcWasmLang} handler created in ${h.elapsed()}`), new WasmHandlerApi_1.WasmHandlerApi(u, n, y || g.exports);
    }
    {
      this.logger.info("Creating handler for js contract", n.txId);
      const h = (0, normalize_source_1.normalizeContractSource)(n.src, c.useVM2);
      if (!c.allowUnsafeClient && h.includes("SmartWeave.unsafeClient"))
        throw new Error("Using unsafeClient is not allowed by default. Use EvaluationOptions.allowUnsafeClient flag.");
      if (!c.allowBigInt && h.includes("BigInt"))
        throw new Error("Using BigInt is not allowed by default. Use EvaluationOptions.allowBigInt flag.");
      if (c.useVM2) {
        const g = new vm2.VMScript(h), y = new vm2.NodeVM({ console: "off", sandbox: { SmartWeave: u, BigNumber: bignumber_js_1.default, logger: this.logger, ContractError, ContractAssert: function($, I) {
          if (!$)
            throw new ContractError(I);
        } }, compiler: "javascript", eval: !1, wasm: !1, allowAsync: !0, wrapper: "commonjs" });
        return new JsHandlerApi_1.JsHandlerApi(u, n, y.run(g));
      }
      {
        const g = new Function(h)(u, bignumber_js_1.default, LoggerFactory_1$4.LoggerFactory.INST.create(u.contract.id));
        return new JsHandlerApi_1.JsHandlerApi(u, n, g);
      }
    }
  }
}
function generateResponse(o) {
  return new Response(o, { status: 200, statusText: "OK", headers: { "Content-Type": "application/wasm" } });
}
async function getWasmModule(o, n) {
  return WebAssembly.compileStreaming ? await WebAssembly.compileStreaming(o) : await WebAssembly.compile(n);
}
HandlerExecutorFactory$1.HandlerExecutorFactory = HandlerExecutorFactory;
var Warp = {}, DefaultCreateContract = {}, SourceImpl$1 = {}, redstoneWasmMetering = {}, redstoneWasmJsonToolkit = {}, wasm2json$1 = { exports: {} }, leb128$1 = {}, bn = { exports: {} };
(function(o, n) {
  function c(m, A) {
    if (!m)
      throw new Error(A || "Assertion failed");
  }
  function u(m, A) {
    m.super_ = A;
    var E = function() {
    };
    E.prototype = A.prototype, m.prototype = new E(), m.prototype.constructor = m;
  }
  function h(m, A, E) {
    if (h.isBN(m))
      return m;
    this.negative = 0, this.words = null, this.length = 0, this.red = null, m !== null && (A !== "le" && A !== "be" || (E = A, A = 10), this._init(m || 0, A || 10, E || "be"));
  }
  var g;
  typeof bn == "object" ? bn.exports = h : n.BN = h, h.BN = h, h.wordSize = 26;
  try {
    g = typeof window < "u" && window.Buffer !== void 0 ? window.Buffer : require$$2$1.Buffer;
  } catch {
  }
  function y(m, A) {
    var E = m.charCodeAt(A);
    return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
  }
  function $(m, A, E) {
    var w = y(m, E);
    return E - 1 >= A && (w |= y(m, E - 1) << 4), w;
  }
  function I(m, A, E, w) {
    for (var v = 0, k = Math.min(m.length, E), O = A; O < k; O++) {
      var W = m.charCodeAt(O) - 48;
      v *= w, v += W >= 49 ? W - 49 + 10 : W >= 17 ? W - 17 + 10 : W;
    }
    return v;
  }
  h.isBN = function(m) {
    return m instanceof h || m !== null && typeof m == "object" && m.constructor.wordSize === h.wordSize && Array.isArray(m.words);
  }, h.max = function(m, A) {
    return m.cmp(A) > 0 ? m : A;
  }, h.min = function(m, A) {
    return m.cmp(A) < 0 ? m : A;
  }, h.prototype._init = function(m, A, E) {
    if (typeof m == "number")
      return this._initNumber(m, A, E);
    if (typeof m == "object")
      return this._initArray(m, A, E);
    A === "hex" && (A = 16), c(A === (0 | A) && A >= 2 && A <= 36);
    var w = 0;
    (m = m.toString().replace(/\s+/g, ""))[0] === "-" && (w++, this.negative = 1), w < m.length && (A === 16 ? this._parseHex(m, w, E) : (this._parseBase(m, A, w), E === "le" && this._initArray(this.toArray(), A, E)));
  }, h.prototype._initNumber = function(m, A, E) {
    m < 0 && (this.negative = 1, m = -m), m < 67108864 ? (this.words = [67108863 & m], this.length = 1) : m < 4503599627370496 ? (this.words = [67108863 & m, m / 67108864 & 67108863], this.length = 2) : (c(m < 9007199254740992), this.words = [67108863 & m, m / 67108864 & 67108863, 1], this.length = 3), E === "le" && this._initArray(this.toArray(), A, E);
  }, h.prototype._initArray = function(m, A, E) {
    if (c(typeof m.length == "number"), m.length <= 0)
      return this.words = [0], this.length = 1, this;
    this.length = Math.ceil(m.length / 3), this.words = new Array(this.length);
    for (var w = 0; w < this.length; w++)
      this.words[w] = 0;
    var v, k, O = 0;
    if (E === "be")
      for (w = m.length - 1, v = 0; w >= 0; w -= 3)
        k = m[w] | m[w - 1] << 8 | m[w - 2] << 16, this.words[v] |= k << O & 67108863, this.words[v + 1] = k >>> 26 - O & 67108863, (O += 24) >= 26 && (O -= 26, v++);
    else if (E === "le")
      for (w = 0, v = 0; w < m.length; w += 3)
        k = m[w] | m[w + 1] << 8 | m[w + 2] << 16, this.words[v] |= k << O & 67108863, this.words[v + 1] = k >>> 26 - O & 67108863, (O += 24) >= 26 && (O -= 26, v++);
    return this.strip();
  }, h.prototype._parseHex = function(m, A, E) {
    this.length = Math.ceil((m.length - A) / 6), this.words = new Array(this.length);
    for (var w = 0; w < this.length; w++)
      this.words[w] = 0;
    var v, k = 0, O = 0;
    if (E === "be")
      for (w = m.length - 1; w >= A; w -= 2)
        v = $(m, A, w) << k, this.words[O] |= 67108863 & v, k >= 18 ? (k -= 18, O += 1, this.words[O] |= v >>> 26) : k += 8;
    else
      for (w = (m.length - A) % 2 == 0 ? A + 1 : A; w < m.length; w += 2)
        v = $(m, A, w) << k, this.words[O] |= 67108863 & v, k >= 18 ? (k -= 18, O += 1, this.words[O] |= v >>> 26) : k += 8;
    this.strip();
  }, h.prototype._parseBase = function(m, A, E) {
    this.words = [0], this.length = 1;
    for (var w = 0, v = 1; v <= 67108863; v *= A)
      w++;
    w--, v = v / A | 0;
    for (var k = m.length - E, O = k % w, W = Math.min(k, k - O) + E, it = 0, vt = E; vt < W; vt += w)
      it = I(m, vt, vt + w, A), this.imuln(v), this.words[0] + it < 67108864 ? this.words[0] += it : this._iaddn(it);
    if (O !== 0) {
      var xt = 1;
      for (it = I(m, vt, m.length, A), vt = 0; vt < O; vt++)
        xt *= A;
      this.imuln(xt), this.words[0] + it < 67108864 ? this.words[0] += it : this._iaddn(it);
    }
    this.strip();
  }, h.prototype.copy = function(m) {
    m.words = new Array(this.length);
    for (var A = 0; A < this.length; A++)
      m.words[A] = this.words[A];
    m.length = this.length, m.negative = this.negative, m.red = this.red;
  }, h.prototype.clone = function() {
    var m = new h(null);
    return this.copy(m), m;
  }, h.prototype._expand = function(m) {
    for (; this.length < m; )
      this.words[this.length++] = 0;
    return this;
  }, h.prototype.strip = function() {
    for (; this.length > 1 && this.words[this.length - 1] === 0; )
      this.length--;
    return this._normSign();
  }, h.prototype._normSign = function() {
    return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
  }, h.prototype.inspect = function() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
  };
  var P = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], L = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  function N(m, A, E) {
    E.negative = A.negative ^ m.negative;
    var w = m.length + A.length | 0;
    E.length = w, w = w - 1 | 0;
    var v = 0 | m.words[0], k = 0 | A.words[0], O = v * k, W = 67108863 & O, it = O / 67108864 | 0;
    E.words[0] = W;
    for (var vt = 1; vt < w; vt++) {
      for (var xt = it >>> 26, It = 67108863 & it, Wt = Math.min(vt, A.length - 1), Ut = Math.max(0, vt - m.length + 1); Ut <= Wt; Ut++) {
        var zt = vt - Ut | 0;
        xt += (O = (v = 0 | m.words[zt]) * (k = 0 | A.words[Ut]) + It) / 67108864 | 0, It = 67108863 & O;
      }
      E.words[vt] = 0 | It, it = 0 | xt;
    }
    return it !== 0 ? E.words[vt] = 0 | it : E.length--, E.strip();
  }
  h.prototype.toString = function(m, A) {
    var E;
    if (A = 0 | A || 1, (m = m || 10) === 16 || m === "hex") {
      E = "";
      for (var w = 0, v = 0, k = 0; k < this.length; k++) {
        var O = this.words[k], W = (16777215 & (O << w | v)).toString(16);
        E = (v = O >>> 24 - w & 16777215) != 0 || k !== this.length - 1 ? P[6 - W.length] + W + E : W + E, (w += 2) >= 26 && (w -= 26, k--);
      }
      for (v !== 0 && (E = v.toString(16) + E); E.length % A != 0; )
        E = "0" + E;
      return this.negative !== 0 && (E = "-" + E), E;
    }
    if (m === (0 | m) && m >= 2 && m <= 36) {
      var it = L[m], vt = q[m];
      E = "";
      var xt = this.clone();
      for (xt.negative = 0; !xt.isZero(); ) {
        var It = xt.modn(vt).toString(m);
        E = (xt = xt.idivn(vt)).isZero() ? It + E : P[it - It.length] + It + E;
      }
      for (this.isZero() && (E = "0" + E); E.length % A != 0; )
        E = "0" + E;
      return this.negative !== 0 && (E = "-" + E), E;
    }
    c(!1, "Base should be between 2 and 36");
  }, h.prototype.toNumber = function() {
    var m = this.words[0];
    return this.length === 2 ? m += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? m += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && c(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -m : m;
  }, h.prototype.toJSON = function() {
    return this.toString(16);
  }, h.prototype.toBuffer = function(m, A) {
    return c(g !== void 0), this.toArrayLike(g, m, A);
  }, h.prototype.toArray = function(m, A) {
    return this.toArrayLike(Array, m, A);
  }, h.prototype.toArrayLike = function(m, A, E) {
    var w = this.byteLength(), v = E || Math.max(1, w);
    c(w <= v, "byte array longer than desired length"), c(v > 0, "Requested array length <= 0"), this.strip();
    var k, O, W = A === "le", it = new m(v), vt = this.clone();
    if (W) {
      for (O = 0; !vt.isZero(); O++)
        k = vt.andln(255), vt.iushrn(8), it[O] = k;
      for (; O < v; O++)
        it[O] = 0;
    } else {
      for (O = 0; O < v - w; O++)
        it[O] = 0;
      for (O = 0; !vt.isZero(); O++)
        k = vt.andln(255), vt.iushrn(8), it[v - O - 1] = k;
    }
    return it;
  }, Math.clz32 ? h.prototype._countBits = function(m) {
    return 32 - Math.clz32(m);
  } : h.prototype._countBits = function(m) {
    var A = m, E = 0;
    return A >= 4096 && (E += 13, A >>>= 13), A >= 64 && (E += 7, A >>>= 7), A >= 8 && (E += 4, A >>>= 4), A >= 2 && (E += 2, A >>>= 2), E + A;
  }, h.prototype._zeroBits = function(m) {
    if (m === 0)
      return 26;
    var A = m, E = 0;
    return (8191 & A) == 0 && (E += 13, A >>>= 13), (127 & A) == 0 && (E += 7, A >>>= 7), (15 & A) == 0 && (E += 4, A >>>= 4), (3 & A) == 0 && (E += 2, A >>>= 2), (1 & A) == 0 && E++, E;
  }, h.prototype.bitLength = function() {
    var m = this.words[this.length - 1], A = this._countBits(m);
    return 26 * (this.length - 1) + A;
  }, h.prototype.zeroBits = function() {
    if (this.isZero())
      return 0;
    for (var m = 0, A = 0; A < this.length; A++) {
      var E = this._zeroBits(this.words[A]);
      if (m += E, E !== 26)
        break;
    }
    return m;
  }, h.prototype.byteLength = function() {
    return Math.ceil(this.bitLength() / 8);
  }, h.prototype.toTwos = function(m) {
    return this.negative !== 0 ? this.abs().inotn(m).iaddn(1) : this.clone();
  }, h.prototype.fromTwos = function(m) {
    return this.testn(m - 1) ? this.notn(m).iaddn(1).ineg() : this.clone();
  }, h.prototype.isNeg = function() {
    return this.negative !== 0;
  }, h.prototype.neg = function() {
    return this.clone().ineg();
  }, h.prototype.ineg = function() {
    return this.isZero() || (this.negative ^= 1), this;
  }, h.prototype.iuor = function(m) {
    for (; this.length < m.length; )
      this.words[this.length++] = 0;
    for (var A = 0; A < m.length; A++)
      this.words[A] = this.words[A] | m.words[A];
    return this.strip();
  }, h.prototype.ior = function(m) {
    return c((this.negative | m.negative) == 0), this.iuor(m);
  }, h.prototype.or = function(m) {
    return this.length > m.length ? this.clone().ior(m) : m.clone().ior(this);
  }, h.prototype.uor = function(m) {
    return this.length > m.length ? this.clone().iuor(m) : m.clone().iuor(this);
  }, h.prototype.iuand = function(m) {
    var A;
    A = this.length > m.length ? m : this;
    for (var E = 0; E < A.length; E++)
      this.words[E] = this.words[E] & m.words[E];
    return this.length = A.length, this.strip();
  }, h.prototype.iand = function(m) {
    return c((this.negative | m.negative) == 0), this.iuand(m);
  }, h.prototype.and = function(m) {
    return this.length > m.length ? this.clone().iand(m) : m.clone().iand(this);
  }, h.prototype.uand = function(m) {
    return this.length > m.length ? this.clone().iuand(m) : m.clone().iuand(this);
  }, h.prototype.iuxor = function(m) {
    var A, E;
    this.length > m.length ? (A = this, E = m) : (A = m, E = this);
    for (var w = 0; w < E.length; w++)
      this.words[w] = A.words[w] ^ E.words[w];
    if (this !== A)
      for (; w < A.length; w++)
        this.words[w] = A.words[w];
    return this.length = A.length, this.strip();
  }, h.prototype.ixor = function(m) {
    return c((this.negative | m.negative) == 0), this.iuxor(m);
  }, h.prototype.xor = function(m) {
    return this.length > m.length ? this.clone().ixor(m) : m.clone().ixor(this);
  }, h.prototype.uxor = function(m) {
    return this.length > m.length ? this.clone().iuxor(m) : m.clone().iuxor(this);
  }, h.prototype.inotn = function(m) {
    c(typeof m == "number" && m >= 0);
    var A = 0 | Math.ceil(m / 26), E = m % 26;
    this._expand(A), E > 0 && A--;
    for (var w = 0; w < A; w++)
      this.words[w] = 67108863 & ~this.words[w];
    return E > 0 && (this.words[w] = ~this.words[w] & 67108863 >> 26 - E), this.strip();
  }, h.prototype.notn = function(m) {
    return this.clone().inotn(m);
  }, h.prototype.setn = function(m, A) {
    c(typeof m == "number" && m >= 0);
    var E = m / 26 | 0, w = m % 26;
    return this._expand(E + 1), this.words[E] = A ? this.words[E] | 1 << w : this.words[E] & ~(1 << w), this.strip();
  }, h.prototype.iadd = function(m) {
    var A, E, w;
    if (this.negative !== 0 && m.negative === 0)
      return this.negative = 0, A = this.isub(m), this.negative ^= 1, this._normSign();
    if (this.negative === 0 && m.negative !== 0)
      return m.negative = 0, A = this.isub(m), m.negative = 1, A._normSign();
    this.length > m.length ? (E = this, w = m) : (E = m, w = this);
    for (var v = 0, k = 0; k < w.length; k++)
      A = (0 | E.words[k]) + (0 | w.words[k]) + v, this.words[k] = 67108863 & A, v = A >>> 26;
    for (; v !== 0 && k < E.length; k++)
      A = (0 | E.words[k]) + v, this.words[k] = 67108863 & A, v = A >>> 26;
    if (this.length = E.length, v !== 0)
      this.words[this.length] = v, this.length++;
    else if (E !== this)
      for (; k < E.length; k++)
        this.words[k] = E.words[k];
    return this;
  }, h.prototype.add = function(m) {
    var A;
    return m.negative !== 0 && this.negative === 0 ? (m.negative = 0, A = this.sub(m), m.negative ^= 1, A) : m.negative === 0 && this.negative !== 0 ? (this.negative = 0, A = m.sub(this), this.negative = 1, A) : this.length > m.length ? this.clone().iadd(m) : m.clone().iadd(this);
  }, h.prototype.isub = function(m) {
    if (m.negative !== 0) {
      m.negative = 0;
      var A = this.iadd(m);
      return m.negative = 1, A._normSign();
    }
    if (this.negative !== 0)
      return this.negative = 0, this.iadd(m), this.negative = 1, this._normSign();
    var E, w, v = this.cmp(m);
    if (v === 0)
      return this.negative = 0, this.length = 1, this.words[0] = 0, this;
    v > 0 ? (E = this, w = m) : (E = m, w = this);
    for (var k = 0, O = 0; O < w.length; O++)
      k = (A = (0 | E.words[O]) - (0 | w.words[O]) + k) >> 26, this.words[O] = 67108863 & A;
    for (; k !== 0 && O < E.length; O++)
      k = (A = (0 | E.words[O]) + k) >> 26, this.words[O] = 67108863 & A;
    if (k === 0 && O < E.length && E !== this)
      for (; O < E.length; O++)
        this.words[O] = E.words[O];
    return this.length = Math.max(this.length, O), E !== this && (this.negative = 1), this.strip();
  }, h.prototype.sub = function(m) {
    return this.clone().isub(m);
  };
  var X = function(m, A, E) {
    var w, v, k, O = m.words, W = A.words, it = E.words, vt = 0, xt = 0 | O[0], It = 8191 & xt, Wt = xt >>> 13, Ut = 0 | O[1], zt = 8191 & Ut, Jt = Ut >>> 13, Xt = 0 | O[2], ie = 8191 & Xt, oe = Xt >>> 13, De = 0 | O[3], ue = 8191 & De, xe = De >>> 13, se = 0 | O[4], he = 8191 & se, je = se >>> 13, jr = 0 | O[5], de = 8191 & jr, We = jr >>> 13, B = 0 | O[6], j = 8191 & B, Z = B >>> 13, kt = 0 | O[7], $t = 8191 & kt, At = kt >>> 13, Bt = 0 | O[8], Ft = 8191 & Bt, Kt = Bt >>> 13, Zt = 0 | O[9], Gt = 8191 & Zt, Qt = Zt >>> 13, Ae = 0 | W[0], ae = 8191 & Ae, we = Ae >>> 13, ir = 0 | W[1], ge = 8191 & ir, _e = ir >>> 13, rr = 0 | W[2], be = 8191 & rr, Ge = rr >>> 13, Rr = 0 | W[3], Te = 8191 & Rr, Ie = Rr >>> 13, Pr = 0 | W[4], Ee = 8191 & Pr, er = Pr >>> 13, Or = 0 | W[5], Ve = 8191 & Or, sr = Or >>> 13, qr = 0 | W[6], Je = 8191 & qr, ur = qr >>> 13, Kr = 0 | W[7], Ze = 8191 & Kr, vr = Kr >>> 13, Hr = 0 | W[8], Ye = 8191 & Hr, _r = Hr >>> 13, zr = 0 | W[9], tr = 8191 & zr, Mr = zr >>> 13;
    E.negative = m.negative ^ A.negative, E.length = 19;
    var Ur = (vt + (w = Math.imul(It, ae)) | 0) + ((8191 & (v = (v = Math.imul(It, we)) + Math.imul(Wt, ae) | 0)) << 13) | 0;
    vt = ((k = Math.imul(Wt, we)) + (v >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, w = Math.imul(zt, ae), v = (v = Math.imul(zt, we)) + Math.imul(Jt, ae) | 0, k = Math.imul(Jt, we);
    var Fr = (vt + (w = w + Math.imul(It, ge) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, _e) | 0) + Math.imul(Wt, ge) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, _e) | 0) + (v >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, w = Math.imul(ie, ae), v = (v = Math.imul(ie, we)) + Math.imul(oe, ae) | 0, k = Math.imul(oe, we), w = w + Math.imul(zt, ge) | 0, v = (v = v + Math.imul(zt, _e) | 0) + Math.imul(Jt, ge) | 0, k = k + Math.imul(Jt, _e) | 0;
    var Zr = (vt + (w = w + Math.imul(It, be) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, Ge) | 0) + Math.imul(Wt, be) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, Ge) | 0) + (v >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, w = Math.imul(ue, ae), v = (v = Math.imul(ue, we)) + Math.imul(xe, ae) | 0, k = Math.imul(xe, we), w = w + Math.imul(ie, ge) | 0, v = (v = v + Math.imul(ie, _e) | 0) + Math.imul(oe, ge) | 0, k = k + Math.imul(oe, _e) | 0, w = w + Math.imul(zt, be) | 0, v = (v = v + Math.imul(zt, Ge) | 0) + Math.imul(Jt, be) | 0, k = k + Math.imul(Jt, Ge) | 0;
    var Qr = (vt + (w = w + Math.imul(It, Te) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, Ie) | 0) + Math.imul(Wt, Te) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, Ie) | 0) + (v >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, w = Math.imul(he, ae), v = (v = Math.imul(he, we)) + Math.imul(je, ae) | 0, k = Math.imul(je, we), w = w + Math.imul(ue, ge) | 0, v = (v = v + Math.imul(ue, _e) | 0) + Math.imul(xe, ge) | 0, k = k + Math.imul(xe, _e) | 0, w = w + Math.imul(ie, be) | 0, v = (v = v + Math.imul(ie, Ge) | 0) + Math.imul(oe, be) | 0, k = k + Math.imul(oe, Ge) | 0, w = w + Math.imul(zt, Te) | 0, v = (v = v + Math.imul(zt, Ie) | 0) + Math.imul(Jt, Te) | 0, k = k + Math.imul(Jt, Ie) | 0;
    var Xr = (vt + (w = w + Math.imul(It, Ee) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, er) | 0) + Math.imul(Wt, Ee) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, er) | 0) + (v >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, w = Math.imul(de, ae), v = (v = Math.imul(de, we)) + Math.imul(We, ae) | 0, k = Math.imul(We, we), w = w + Math.imul(he, ge) | 0, v = (v = v + Math.imul(he, _e) | 0) + Math.imul(je, ge) | 0, k = k + Math.imul(je, _e) | 0, w = w + Math.imul(ue, be) | 0, v = (v = v + Math.imul(ue, Ge) | 0) + Math.imul(xe, be) | 0, k = k + Math.imul(xe, Ge) | 0, w = w + Math.imul(ie, Te) | 0, v = (v = v + Math.imul(ie, Ie) | 0) + Math.imul(oe, Te) | 0, k = k + Math.imul(oe, Ie) | 0, w = w + Math.imul(zt, Ee) | 0, v = (v = v + Math.imul(zt, er) | 0) + Math.imul(Jt, Ee) | 0, k = k + Math.imul(Jt, er) | 0;
    var Yr = (vt + (w = w + Math.imul(It, Ve) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, sr) | 0) + Math.imul(Wt, Ve) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, sr) | 0) + (v >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, w = Math.imul(j, ae), v = (v = Math.imul(j, we)) + Math.imul(Z, ae) | 0, k = Math.imul(Z, we), w = w + Math.imul(de, ge) | 0, v = (v = v + Math.imul(de, _e) | 0) + Math.imul(We, ge) | 0, k = k + Math.imul(We, _e) | 0, w = w + Math.imul(he, be) | 0, v = (v = v + Math.imul(he, Ge) | 0) + Math.imul(je, be) | 0, k = k + Math.imul(je, Ge) | 0, w = w + Math.imul(ue, Te) | 0, v = (v = v + Math.imul(ue, Ie) | 0) + Math.imul(xe, Te) | 0, k = k + Math.imul(xe, Ie) | 0, w = w + Math.imul(ie, Ee) | 0, v = (v = v + Math.imul(ie, er) | 0) + Math.imul(oe, Ee) | 0, k = k + Math.imul(oe, er) | 0, w = w + Math.imul(zt, Ve) | 0, v = (v = v + Math.imul(zt, sr) | 0) + Math.imul(Jt, Ve) | 0, k = k + Math.imul(Jt, sr) | 0;
    var tn = (vt + (w = w + Math.imul(It, Je) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, ur) | 0) + Math.imul(Wt, Je) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, ur) | 0) + (v >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, w = Math.imul($t, ae), v = (v = Math.imul($t, we)) + Math.imul(At, ae) | 0, k = Math.imul(At, we), w = w + Math.imul(j, ge) | 0, v = (v = v + Math.imul(j, _e) | 0) + Math.imul(Z, ge) | 0, k = k + Math.imul(Z, _e) | 0, w = w + Math.imul(de, be) | 0, v = (v = v + Math.imul(de, Ge) | 0) + Math.imul(We, be) | 0, k = k + Math.imul(We, Ge) | 0, w = w + Math.imul(he, Te) | 0, v = (v = v + Math.imul(he, Ie) | 0) + Math.imul(je, Te) | 0, k = k + Math.imul(je, Ie) | 0, w = w + Math.imul(ue, Ee) | 0, v = (v = v + Math.imul(ue, er) | 0) + Math.imul(xe, Ee) | 0, k = k + Math.imul(xe, er) | 0, w = w + Math.imul(ie, Ve) | 0, v = (v = v + Math.imul(ie, sr) | 0) + Math.imul(oe, Ve) | 0, k = k + Math.imul(oe, sr) | 0, w = w + Math.imul(zt, Je) | 0, v = (v = v + Math.imul(zt, ur) | 0) + Math.imul(Jt, Je) | 0, k = k + Math.imul(Jt, ur) | 0;
    var en = (vt + (w = w + Math.imul(It, Ze) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, vr) | 0) + Math.imul(Wt, Ze) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, vr) | 0) + (v >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, w = Math.imul(Ft, ae), v = (v = Math.imul(Ft, we)) + Math.imul(Kt, ae) | 0, k = Math.imul(Kt, we), w = w + Math.imul($t, ge) | 0, v = (v = v + Math.imul($t, _e) | 0) + Math.imul(At, ge) | 0, k = k + Math.imul(At, _e) | 0, w = w + Math.imul(j, be) | 0, v = (v = v + Math.imul(j, Ge) | 0) + Math.imul(Z, be) | 0, k = k + Math.imul(Z, Ge) | 0, w = w + Math.imul(de, Te) | 0, v = (v = v + Math.imul(de, Ie) | 0) + Math.imul(We, Te) | 0, k = k + Math.imul(We, Ie) | 0, w = w + Math.imul(he, Ee) | 0, v = (v = v + Math.imul(he, er) | 0) + Math.imul(je, Ee) | 0, k = k + Math.imul(je, er) | 0, w = w + Math.imul(ue, Ve) | 0, v = (v = v + Math.imul(ue, sr) | 0) + Math.imul(xe, Ve) | 0, k = k + Math.imul(xe, sr) | 0, w = w + Math.imul(ie, Je) | 0, v = (v = v + Math.imul(ie, ur) | 0) + Math.imul(oe, Je) | 0, k = k + Math.imul(oe, ur) | 0, w = w + Math.imul(zt, Ze) | 0, v = (v = v + Math.imul(zt, vr) | 0) + Math.imul(Jt, Ze) | 0, k = k + Math.imul(Jt, vr) | 0;
    var rn = (vt + (w = w + Math.imul(It, Ye) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, _r) | 0) + Math.imul(Wt, Ye) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, _r) | 0) + (v >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, w = Math.imul(Gt, ae), v = (v = Math.imul(Gt, we)) + Math.imul(Qt, ae) | 0, k = Math.imul(Qt, we), w = w + Math.imul(Ft, ge) | 0, v = (v = v + Math.imul(Ft, _e) | 0) + Math.imul(Kt, ge) | 0, k = k + Math.imul(Kt, _e) | 0, w = w + Math.imul($t, be) | 0, v = (v = v + Math.imul($t, Ge) | 0) + Math.imul(At, be) | 0, k = k + Math.imul(At, Ge) | 0, w = w + Math.imul(j, Te) | 0, v = (v = v + Math.imul(j, Ie) | 0) + Math.imul(Z, Te) | 0, k = k + Math.imul(Z, Ie) | 0, w = w + Math.imul(de, Ee) | 0, v = (v = v + Math.imul(de, er) | 0) + Math.imul(We, Ee) | 0, k = k + Math.imul(We, er) | 0, w = w + Math.imul(he, Ve) | 0, v = (v = v + Math.imul(he, sr) | 0) + Math.imul(je, Ve) | 0, k = k + Math.imul(je, sr) | 0, w = w + Math.imul(ue, Je) | 0, v = (v = v + Math.imul(ue, ur) | 0) + Math.imul(xe, Je) | 0, k = k + Math.imul(xe, ur) | 0, w = w + Math.imul(ie, Ze) | 0, v = (v = v + Math.imul(ie, vr) | 0) + Math.imul(oe, Ze) | 0, k = k + Math.imul(oe, vr) | 0, w = w + Math.imul(zt, Ye) | 0, v = (v = v + Math.imul(zt, _r) | 0) + Math.imul(Jt, Ye) | 0, k = k + Math.imul(Jt, _r) | 0;
    var nn = (vt + (w = w + Math.imul(It, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(It, Mr) | 0) + Math.imul(Wt, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Wt, Mr) | 0) + (v >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, w = Math.imul(Gt, ge), v = (v = Math.imul(Gt, _e)) + Math.imul(Qt, ge) | 0, k = Math.imul(Qt, _e), w = w + Math.imul(Ft, be) | 0, v = (v = v + Math.imul(Ft, Ge) | 0) + Math.imul(Kt, be) | 0, k = k + Math.imul(Kt, Ge) | 0, w = w + Math.imul($t, Te) | 0, v = (v = v + Math.imul($t, Ie) | 0) + Math.imul(At, Te) | 0, k = k + Math.imul(At, Ie) | 0, w = w + Math.imul(j, Ee) | 0, v = (v = v + Math.imul(j, er) | 0) + Math.imul(Z, Ee) | 0, k = k + Math.imul(Z, er) | 0, w = w + Math.imul(de, Ve) | 0, v = (v = v + Math.imul(de, sr) | 0) + Math.imul(We, Ve) | 0, k = k + Math.imul(We, sr) | 0, w = w + Math.imul(he, Je) | 0, v = (v = v + Math.imul(he, ur) | 0) + Math.imul(je, Je) | 0, k = k + Math.imul(je, ur) | 0, w = w + Math.imul(ue, Ze) | 0, v = (v = v + Math.imul(ue, vr) | 0) + Math.imul(xe, Ze) | 0, k = k + Math.imul(xe, vr) | 0, w = w + Math.imul(ie, Ye) | 0, v = (v = v + Math.imul(ie, _r) | 0) + Math.imul(oe, Ye) | 0, k = k + Math.imul(oe, _r) | 0;
    var on = (vt + (w = w + Math.imul(zt, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(zt, Mr) | 0) + Math.imul(Jt, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Jt, Mr) | 0) + (v >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, w = Math.imul(Gt, be), v = (v = Math.imul(Gt, Ge)) + Math.imul(Qt, be) | 0, k = Math.imul(Qt, Ge), w = w + Math.imul(Ft, Te) | 0, v = (v = v + Math.imul(Ft, Ie) | 0) + Math.imul(Kt, Te) | 0, k = k + Math.imul(Kt, Ie) | 0, w = w + Math.imul($t, Ee) | 0, v = (v = v + Math.imul($t, er) | 0) + Math.imul(At, Ee) | 0, k = k + Math.imul(At, er) | 0, w = w + Math.imul(j, Ve) | 0, v = (v = v + Math.imul(j, sr) | 0) + Math.imul(Z, Ve) | 0, k = k + Math.imul(Z, sr) | 0, w = w + Math.imul(de, Je) | 0, v = (v = v + Math.imul(de, ur) | 0) + Math.imul(We, Je) | 0, k = k + Math.imul(We, ur) | 0, w = w + Math.imul(he, Ze) | 0, v = (v = v + Math.imul(he, vr) | 0) + Math.imul(je, Ze) | 0, k = k + Math.imul(je, vr) | 0, w = w + Math.imul(ue, Ye) | 0, v = (v = v + Math.imul(ue, _r) | 0) + Math.imul(xe, Ye) | 0, k = k + Math.imul(xe, _r) | 0;
    var an = (vt + (w = w + Math.imul(ie, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(ie, Mr) | 0) + Math.imul(oe, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(oe, Mr) | 0) + (v >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, w = Math.imul(Gt, Te), v = (v = Math.imul(Gt, Ie)) + Math.imul(Qt, Te) | 0, k = Math.imul(Qt, Ie), w = w + Math.imul(Ft, Ee) | 0, v = (v = v + Math.imul(Ft, er) | 0) + Math.imul(Kt, Ee) | 0, k = k + Math.imul(Kt, er) | 0, w = w + Math.imul($t, Ve) | 0, v = (v = v + Math.imul($t, sr) | 0) + Math.imul(At, Ve) | 0, k = k + Math.imul(At, sr) | 0, w = w + Math.imul(j, Je) | 0, v = (v = v + Math.imul(j, ur) | 0) + Math.imul(Z, Je) | 0, k = k + Math.imul(Z, ur) | 0, w = w + Math.imul(de, Ze) | 0, v = (v = v + Math.imul(de, vr) | 0) + Math.imul(We, Ze) | 0, k = k + Math.imul(We, vr) | 0, w = w + Math.imul(he, Ye) | 0, v = (v = v + Math.imul(he, _r) | 0) + Math.imul(je, Ye) | 0, k = k + Math.imul(je, _r) | 0;
    var sn = (vt + (w = w + Math.imul(ue, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(ue, Mr) | 0) + Math.imul(xe, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(xe, Mr) | 0) + (v >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, w = Math.imul(Gt, Ee), v = (v = Math.imul(Gt, er)) + Math.imul(Qt, Ee) | 0, k = Math.imul(Qt, er), w = w + Math.imul(Ft, Ve) | 0, v = (v = v + Math.imul(Ft, sr) | 0) + Math.imul(Kt, Ve) | 0, k = k + Math.imul(Kt, sr) | 0, w = w + Math.imul($t, Je) | 0, v = (v = v + Math.imul($t, ur) | 0) + Math.imul(At, Je) | 0, k = k + Math.imul(At, ur) | 0, w = w + Math.imul(j, Ze) | 0, v = (v = v + Math.imul(j, vr) | 0) + Math.imul(Z, Ze) | 0, k = k + Math.imul(Z, vr) | 0, w = w + Math.imul(de, Ye) | 0, v = (v = v + Math.imul(de, _r) | 0) + Math.imul(We, Ye) | 0, k = k + Math.imul(We, _r) | 0;
    var cn = (vt + (w = w + Math.imul(he, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(he, Mr) | 0) + Math.imul(je, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(je, Mr) | 0) + (v >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, w = Math.imul(Gt, Ve), v = (v = Math.imul(Gt, sr)) + Math.imul(Qt, Ve) | 0, k = Math.imul(Qt, sr), w = w + Math.imul(Ft, Je) | 0, v = (v = v + Math.imul(Ft, ur) | 0) + Math.imul(Kt, Je) | 0, k = k + Math.imul(Kt, ur) | 0, w = w + Math.imul($t, Ze) | 0, v = (v = v + Math.imul($t, vr) | 0) + Math.imul(At, Ze) | 0, k = k + Math.imul(At, vr) | 0, w = w + Math.imul(j, Ye) | 0, v = (v = v + Math.imul(j, _r) | 0) + Math.imul(Z, Ye) | 0, k = k + Math.imul(Z, _r) | 0;
    var Cn = (vt + (w = w + Math.imul(de, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(de, Mr) | 0) + Math.imul(We, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(We, Mr) | 0) + (v >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, w = Math.imul(Gt, Je), v = (v = Math.imul(Gt, ur)) + Math.imul(Qt, Je) | 0, k = Math.imul(Qt, ur), w = w + Math.imul(Ft, Ze) | 0, v = (v = v + Math.imul(Ft, vr) | 0) + Math.imul(Kt, Ze) | 0, k = k + Math.imul(Kt, vr) | 0, w = w + Math.imul($t, Ye) | 0, v = (v = v + Math.imul($t, _r) | 0) + Math.imul(At, Ye) | 0, k = k + Math.imul(At, _r) | 0;
    var xn = (vt + (w = w + Math.imul(j, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(j, Mr) | 0) + Math.imul(Z, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Z, Mr) | 0) + (v >>> 13) | 0) + (xn >>> 26) | 0, xn &= 67108863, w = Math.imul(Gt, Ze), v = (v = Math.imul(Gt, vr)) + Math.imul(Qt, Ze) | 0, k = Math.imul(Qt, vr), w = w + Math.imul(Ft, Ye) | 0, v = (v = v + Math.imul(Ft, _r) | 0) + Math.imul(Kt, Ye) | 0, k = k + Math.imul(Kt, _r) | 0;
    var Pn = (vt + (w = w + Math.imul($t, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul($t, Mr) | 0) + Math.imul(At, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(At, Mr) | 0) + (v >>> 13) | 0) + (Pn >>> 26) | 0, Pn &= 67108863, w = Math.imul(Gt, Ye), v = (v = Math.imul(Gt, _r)) + Math.imul(Qt, Ye) | 0, k = Math.imul(Qt, _r);
    var Rn = (vt + (w = w + Math.imul(Ft, tr) | 0) | 0) + ((8191 & (v = (v = v + Math.imul(Ft, Mr) | 0) + Math.imul(Kt, tr) | 0)) << 13) | 0;
    vt = ((k = k + Math.imul(Kt, Mr) | 0) + (v >>> 13) | 0) + (Rn >>> 26) | 0, Rn &= 67108863;
    var Gn = (vt + (w = Math.imul(Gt, tr)) | 0) + ((8191 & (v = (v = Math.imul(Gt, Mr)) + Math.imul(Qt, tr) | 0)) << 13) | 0;
    return vt = ((k = Math.imul(Qt, Mr)) + (v >>> 13) | 0) + (Gn >>> 26) | 0, Gn &= 67108863, it[0] = Ur, it[1] = Fr, it[2] = Zr, it[3] = Qr, it[4] = Xr, it[5] = Yr, it[6] = tn, it[7] = en, it[8] = rn, it[9] = nn, it[10] = on, it[11] = an, it[12] = sn, it[13] = cn, it[14] = Cn, it[15] = xn, it[16] = Pn, it[17] = Rn, it[18] = Gn, vt !== 0 && (it[19] = vt, E.length++), E;
  };
  function rt(m, A, E) {
    return new nt().mulp(m, A, E);
  }
  function nt(m, A) {
    this.x = m, this.y = A;
  }
  Math.imul || (X = N), h.prototype.mulTo = function(m, A) {
    var E, w = this.length + m.length;
    return E = this.length === 10 && m.length === 10 ? X(this, m, A) : w < 63 ? N(this, m, A) : w < 1024 ? function(v, k, O) {
      O.negative = k.negative ^ v.negative, O.length = v.length + k.length;
      for (var W = 0, it = 0, vt = 0; vt < O.length - 1; vt++) {
        var xt = it;
        it = 0;
        for (var It = 67108863 & W, Wt = Math.min(vt, k.length - 1), Ut = Math.max(0, vt - v.length + 1); Ut <= Wt; Ut++) {
          var zt = vt - Ut, Jt = (0 | v.words[zt]) * (0 | k.words[Ut]), Xt = 67108863 & Jt;
          It = 67108863 & (Xt = Xt + It | 0), it += (xt = (xt = xt + (Jt / 67108864 | 0) | 0) + (Xt >>> 26) | 0) >>> 26, xt &= 67108863;
        }
        O.words[vt] = It, W = xt, xt = it;
      }
      return W !== 0 ? O.words[vt] = W : O.length--, O.strip();
    }(this, m, A) : rt(this, m, A), E;
  }, nt.prototype.makeRBT = function(m) {
    for (var A = new Array(m), E = h.prototype._countBits(m) - 1, w = 0; w < m; w++)
      A[w] = this.revBin(w, E, m);
    return A;
  }, nt.prototype.revBin = function(m, A, E) {
    if (m === 0 || m === E - 1)
      return m;
    for (var w = 0, v = 0; v < A; v++)
      w |= (1 & m) << A - v - 1, m >>= 1;
    return w;
  }, nt.prototype.permute = function(m, A, E, w, v, k) {
    for (var O = 0; O < k; O++)
      w[O] = A[m[O]], v[O] = E[m[O]];
  }, nt.prototype.transform = function(m, A, E, w, v, k) {
    this.permute(k, m, A, E, w, v);
    for (var O = 1; O < v; O <<= 1)
      for (var W = O << 1, it = Math.cos(2 * Math.PI / W), vt = Math.sin(2 * Math.PI / W), xt = 0; xt < v; xt += W)
        for (var It = it, Wt = vt, Ut = 0; Ut < O; Ut++) {
          var zt = E[xt + Ut], Jt = w[xt + Ut], Xt = E[xt + Ut + O], ie = w[xt + Ut + O], oe = It * Xt - Wt * ie;
          ie = It * ie + Wt * Xt, Xt = oe, E[xt + Ut] = zt + Xt, w[xt + Ut] = Jt + ie, E[xt + Ut + O] = zt - Xt, w[xt + Ut + O] = Jt - ie, Ut !== W && (oe = it * It - vt * Wt, Wt = it * Wt + vt * It, It = oe);
        }
  }, nt.prototype.guessLen13b = function(m, A) {
    var E = 1 | Math.max(A, m), w = 1 & E, v = 0;
    for (E = E / 2 | 0; E; E >>>= 1)
      v++;
    return 1 << v + 1 + w;
  }, nt.prototype.conjugate = function(m, A, E) {
    if (!(E <= 1))
      for (var w = 0; w < E / 2; w++) {
        var v = m[w];
        m[w] = m[E - w - 1], m[E - w - 1] = v, v = A[w], A[w] = -A[E - w - 1], A[E - w - 1] = -v;
      }
  }, nt.prototype.normalize13b = function(m, A) {
    for (var E = 0, w = 0; w < A / 2; w++) {
      var v = 8192 * Math.round(m[2 * w + 1] / A) + Math.round(m[2 * w] / A) + E;
      m[w] = 67108863 & v, E = v < 67108864 ? 0 : v / 67108864 | 0;
    }
    return m;
  }, nt.prototype.convert13b = function(m, A, E, w) {
    for (var v = 0, k = 0; k < A; k++)
      v += 0 | m[k], E[2 * k] = 8191 & v, v >>>= 13, E[2 * k + 1] = 8191 & v, v >>>= 13;
    for (k = 2 * A; k < w; ++k)
      E[k] = 0;
    c(v === 0), c((-8192 & v) == 0);
  }, nt.prototype.stub = function(m) {
    for (var A = new Array(m), E = 0; E < m; E++)
      A[E] = 0;
    return A;
  }, nt.prototype.mulp = function(m, A, E) {
    var w = 2 * this.guessLen13b(m.length, A.length), v = this.makeRBT(w), k = this.stub(w), O = new Array(w), W = new Array(w), it = new Array(w), vt = new Array(w), xt = new Array(w), It = new Array(w), Wt = E.words;
    Wt.length = w, this.convert13b(m.words, m.length, O, w), this.convert13b(A.words, A.length, vt, w), this.transform(O, k, W, it, w, v), this.transform(vt, k, xt, It, w, v);
    for (var Ut = 0; Ut < w; Ut++) {
      var zt = W[Ut] * xt[Ut] - it[Ut] * It[Ut];
      it[Ut] = W[Ut] * It[Ut] + it[Ut] * xt[Ut], W[Ut] = zt;
    }
    return this.conjugate(W, it, w), this.transform(W, it, Wt, k, w, v), this.conjugate(Wt, k, w), this.normalize13b(Wt, w), E.negative = m.negative ^ A.negative, E.length = m.length + A.length, E.strip();
  }, h.prototype.mul = function(m) {
    var A = new h(null);
    return A.words = new Array(this.length + m.length), this.mulTo(m, A);
  }, h.prototype.mulf = function(m) {
    var A = new h(null);
    return A.words = new Array(this.length + m.length), rt(this, m, A);
  }, h.prototype.imul = function(m) {
    return this.clone().mulTo(m, this);
  }, h.prototype.imuln = function(m) {
    c(typeof m == "number"), c(m < 67108864);
    for (var A = 0, E = 0; E < this.length; E++) {
      var w = (0 | this.words[E]) * m, v = (67108863 & w) + (67108863 & A);
      A >>= 26, A += w / 67108864 | 0, A += v >>> 26, this.words[E] = 67108863 & v;
    }
    return A !== 0 && (this.words[E] = A, this.length++), this;
  }, h.prototype.muln = function(m) {
    return this.clone().imuln(m);
  }, h.prototype.sqr = function() {
    return this.mul(this);
  }, h.prototype.isqr = function() {
    return this.imul(this.clone());
  }, h.prototype.pow = function(m) {
    var A = function(k) {
      for (var O = new Array(k.bitLength()), W = 0; W < O.length; W++) {
        var it = W / 26 | 0, vt = W % 26;
        O[W] = (k.words[it] & 1 << vt) >>> vt;
      }
      return O;
    }(m);
    if (A.length === 0)
      return new h(1);
    for (var E = this, w = 0; w < A.length && A[w] === 0; w++, E = E.sqr())
      ;
    if (++w < A.length)
      for (var v = E.sqr(); w < A.length; w++, v = v.sqr())
        A[w] !== 0 && (E = E.mul(v));
    return E;
  }, h.prototype.iushln = function(m) {
    c(typeof m == "number" && m >= 0);
    var A, E = m % 26, w = (m - E) / 26, v = 67108863 >>> 26 - E << 26 - E;
    if (E !== 0) {
      var k = 0;
      for (A = 0; A < this.length; A++) {
        var O = this.words[A] & v, W = (0 | this.words[A]) - O << E;
        this.words[A] = W | k, k = O >>> 26 - E;
      }
      k && (this.words[A] = k, this.length++);
    }
    if (w !== 0) {
      for (A = this.length - 1; A >= 0; A--)
        this.words[A + w] = this.words[A];
      for (A = 0; A < w; A++)
        this.words[A] = 0;
      this.length += w;
    }
    return this.strip();
  }, h.prototype.ishln = function(m) {
    return c(this.negative === 0), this.iushln(m);
  }, h.prototype.iushrn = function(m, A, E) {
    var w;
    c(typeof m == "number" && m >= 0), w = A ? (A - A % 26) / 26 : 0;
    var v = m % 26, k = Math.min((m - v) / 26, this.length), O = 67108863 ^ 67108863 >>> v << v, W = E;
    if (w -= k, w = Math.max(0, w), W) {
      for (var it = 0; it < k; it++)
        W.words[it] = this.words[it];
      W.length = k;
    }
    if (k !== 0)
      if (this.length > k)
        for (this.length -= k, it = 0; it < this.length; it++)
          this.words[it] = this.words[it + k];
      else
        this.words[0] = 0, this.length = 1;
    var vt = 0;
    for (it = this.length - 1; it >= 0 && (vt !== 0 || it >= w); it--) {
      var xt = 0 | this.words[it];
      this.words[it] = vt << 26 - v | xt >>> v, vt = xt & O;
    }
    return W && vt !== 0 && (W.words[W.length++] = vt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
  }, h.prototype.ishrn = function(m, A, E) {
    return c(this.negative === 0), this.iushrn(m, A, E);
  }, h.prototype.shln = function(m) {
    return this.clone().ishln(m);
  }, h.prototype.ushln = function(m) {
    return this.clone().iushln(m);
  }, h.prototype.shrn = function(m) {
    return this.clone().ishrn(m);
  }, h.prototype.ushrn = function(m) {
    return this.clone().iushrn(m);
  }, h.prototype.testn = function(m) {
    c(typeof m == "number" && m >= 0);
    var A = m % 26, E = (m - A) / 26, w = 1 << A;
    return !(this.length <= E || !(this.words[E] & w));
  }, h.prototype.imaskn = function(m) {
    c(typeof m == "number" && m >= 0);
    var A = m % 26, E = (m - A) / 26;
    if (c(this.negative === 0, "imaskn works only with positive numbers"), this.length <= E)
      return this;
    if (A !== 0 && E++, this.length = Math.min(E, this.length), A !== 0) {
      var w = 67108863 ^ 67108863 >>> A << A;
      this.words[this.length - 1] &= w;
    }
    return this.strip();
  }, h.prototype.maskn = function(m) {
    return this.clone().imaskn(m);
  }, h.prototype.iaddn = function(m) {
    return c(typeof m == "number"), c(m < 67108864), m < 0 ? this.isubn(-m) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < m ? (this.words[0] = m - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(m), this.negative = 1, this) : this._iaddn(m);
  }, h.prototype._iaddn = function(m) {
    this.words[0] += m;
    for (var A = 0; A < this.length && this.words[A] >= 67108864; A++)
      this.words[A] -= 67108864, A === this.length - 1 ? this.words[A + 1] = 1 : this.words[A + 1]++;
    return this.length = Math.max(this.length, A + 1), this;
  }, h.prototype.isubn = function(m) {
    if (c(typeof m == "number"), c(m < 67108864), m < 0)
      return this.iaddn(-m);
    if (this.negative !== 0)
      return this.negative = 0, this.iaddn(m), this.negative = 1, this;
    if (this.words[0] -= m, this.length === 1 && this.words[0] < 0)
      this.words[0] = -this.words[0], this.negative = 1;
    else
      for (var A = 0; A < this.length && this.words[A] < 0; A++)
        this.words[A] += 67108864, this.words[A + 1] -= 1;
    return this.strip();
  }, h.prototype.addn = function(m) {
    return this.clone().iaddn(m);
  }, h.prototype.subn = function(m) {
    return this.clone().isubn(m);
  }, h.prototype.iabs = function() {
    return this.negative = 0, this;
  }, h.prototype.abs = function() {
    return this.clone().iabs();
  }, h.prototype._ishlnsubmul = function(m, A, E) {
    var w, v, k = m.length + E;
    this._expand(k);
    var O = 0;
    for (w = 0; w < m.length; w++) {
      v = (0 | this.words[w + E]) + O;
      var W = (0 | m.words[w]) * A;
      O = ((v -= 67108863 & W) >> 26) - (W / 67108864 | 0), this.words[w + E] = 67108863 & v;
    }
    for (; w < this.length - E; w++)
      O = (v = (0 | this.words[w + E]) + O) >> 26, this.words[w + E] = 67108863 & v;
    if (O === 0)
      return this.strip();
    for (c(O === -1), O = 0, w = 0; w < this.length; w++)
      O = (v = -(0 | this.words[w]) + O) >> 26, this.words[w] = 67108863 & v;
    return this.negative = 1, this.strip();
  }, h.prototype._wordDiv = function(m, A) {
    var E = (this.length, m.length), w = this.clone(), v = m, k = 0 | v.words[v.length - 1];
    (E = 26 - this._countBits(k)) != 0 && (v = v.ushln(E), w.iushln(E), k = 0 | v.words[v.length - 1]);
    var O, W = w.length - v.length;
    if (A !== "mod") {
      (O = new h(null)).length = W + 1, O.words = new Array(O.length);
      for (var it = 0; it < O.length; it++)
        O.words[it] = 0;
    }
    var vt = w.clone()._ishlnsubmul(v, 1, W);
    vt.negative === 0 && (w = vt, O && (O.words[W] = 1));
    for (var xt = W - 1; xt >= 0; xt--) {
      var It = 67108864 * (0 | w.words[v.length + xt]) + (0 | w.words[v.length + xt - 1]);
      for (It = Math.min(It / k | 0, 67108863), w._ishlnsubmul(v, It, xt); w.negative !== 0; )
        It--, w.negative = 0, w._ishlnsubmul(v, 1, xt), w.isZero() || (w.negative ^= 1);
      O && (O.words[xt] = It);
    }
    return O && O.strip(), w.strip(), A !== "div" && E !== 0 && w.iushrn(E), { div: O || null, mod: w };
  }, h.prototype.divmod = function(m, A, E) {
    return c(!m.isZero()), this.isZero() ? { div: new h(0), mod: new h(0) } : this.negative !== 0 && m.negative === 0 ? (k = this.neg().divmod(m, A), A !== "mod" && (w = k.div.neg()), A !== "div" && (v = k.mod.neg(), E && v.negative !== 0 && v.iadd(m)), { div: w, mod: v }) : this.negative === 0 && m.negative !== 0 ? (k = this.divmod(m.neg(), A), A !== "mod" && (w = k.div.neg()), { div: w, mod: k.mod }) : (this.negative & m.negative) != 0 ? (k = this.neg().divmod(m.neg(), A), A !== "div" && (v = k.mod.neg(), E && v.negative !== 0 && v.isub(m)), { div: k.div, mod: v }) : m.length > this.length || this.cmp(m) < 0 ? { div: new h(0), mod: this } : m.length === 1 ? A === "div" ? { div: this.divn(m.words[0]), mod: null } : A === "mod" ? { div: null, mod: new h(this.modn(m.words[0])) } : { div: this.divn(m.words[0]), mod: new h(this.modn(m.words[0])) } : this._wordDiv(m, A);
    var w, v, k;
  }, h.prototype.div = function(m) {
    return this.divmod(m, "div", !1).div;
  }, h.prototype.mod = function(m) {
    return this.divmod(m, "mod", !1).mod;
  }, h.prototype.umod = function(m) {
    return this.divmod(m, "mod", !0).mod;
  }, h.prototype.divRound = function(m) {
    var A = this.divmod(m);
    if (A.mod.isZero())
      return A.div;
    var E = A.div.negative !== 0 ? A.mod.isub(m) : A.mod, w = m.ushrn(1), v = m.andln(1), k = E.cmp(w);
    return k < 0 || v === 1 && k === 0 ? A.div : A.div.negative !== 0 ? A.div.isubn(1) : A.div.iaddn(1);
  }, h.prototype.modn = function(m) {
    c(m <= 67108863);
    for (var A = (1 << 26) % m, E = 0, w = this.length - 1; w >= 0; w--)
      E = (A * E + (0 | this.words[w])) % m;
    return E;
  }, h.prototype.idivn = function(m) {
    c(m <= 67108863);
    for (var A = 0, E = this.length - 1; E >= 0; E--) {
      var w = (0 | this.words[E]) + 67108864 * A;
      this.words[E] = w / m | 0, A = w % m;
    }
    return this.strip();
  }, h.prototype.divn = function(m) {
    return this.clone().idivn(m);
  }, h.prototype.egcd = function(m) {
    c(m.negative === 0), c(!m.isZero());
    var A = this, E = m.clone();
    A = A.negative !== 0 ? A.umod(m) : A.clone();
    for (var w = new h(1), v = new h(0), k = new h(0), O = new h(1), W = 0; A.isEven() && E.isEven(); )
      A.iushrn(1), E.iushrn(1), ++W;
    for (var it = E.clone(), vt = A.clone(); !A.isZero(); ) {
      for (var xt = 0, It = 1; (A.words[0] & It) == 0 && xt < 26; ++xt, It <<= 1)
        ;
      if (xt > 0)
        for (A.iushrn(xt); xt-- > 0; )
          (w.isOdd() || v.isOdd()) && (w.iadd(it), v.isub(vt)), w.iushrn(1), v.iushrn(1);
      for (var Wt = 0, Ut = 1; (E.words[0] & Ut) == 0 && Wt < 26; ++Wt, Ut <<= 1)
        ;
      if (Wt > 0)
        for (E.iushrn(Wt); Wt-- > 0; )
          (k.isOdd() || O.isOdd()) && (k.iadd(it), O.isub(vt)), k.iushrn(1), O.iushrn(1);
      A.cmp(E) >= 0 ? (A.isub(E), w.isub(k), v.isub(O)) : (E.isub(A), k.isub(w), O.isub(v));
    }
    return { a: k, b: O, gcd: E.iushln(W) };
  }, h.prototype._invmp = function(m) {
    c(m.negative === 0), c(!m.isZero());
    var A = this, E = m.clone();
    A = A.negative !== 0 ? A.umod(m) : A.clone();
    for (var w, v = new h(1), k = new h(0), O = E.clone(); A.cmpn(1) > 0 && E.cmpn(1) > 0; ) {
      for (var W = 0, it = 1; (A.words[0] & it) == 0 && W < 26; ++W, it <<= 1)
        ;
      if (W > 0)
        for (A.iushrn(W); W-- > 0; )
          v.isOdd() && v.iadd(O), v.iushrn(1);
      for (var vt = 0, xt = 1; (E.words[0] & xt) == 0 && vt < 26; ++vt, xt <<= 1)
        ;
      if (vt > 0)
        for (E.iushrn(vt); vt-- > 0; )
          k.isOdd() && k.iadd(O), k.iushrn(1);
      A.cmp(E) >= 0 ? (A.isub(E), v.isub(k)) : (E.isub(A), k.isub(v));
    }
    return (w = A.cmpn(1) === 0 ? v : k).cmpn(0) < 0 && w.iadd(m), w;
  }, h.prototype.gcd = function(m) {
    if (this.isZero())
      return m.abs();
    if (m.isZero())
      return this.abs();
    var A = this.clone(), E = m.clone();
    A.negative = 0, E.negative = 0;
    for (var w = 0; A.isEven() && E.isEven(); w++)
      A.iushrn(1), E.iushrn(1);
    for (; ; ) {
      for (; A.isEven(); )
        A.iushrn(1);
      for (; E.isEven(); )
        E.iushrn(1);
      var v = A.cmp(E);
      if (v < 0) {
        var k = A;
        A = E, E = k;
      } else if (v === 0 || E.cmpn(1) === 0)
        break;
      A.isub(E);
    }
    return E.iushln(w);
  }, h.prototype.invm = function(m) {
    return this.egcd(m).a.umod(m);
  }, h.prototype.isEven = function() {
    return (1 & this.words[0]) == 0;
  }, h.prototype.isOdd = function() {
    return (1 & this.words[0]) == 1;
  }, h.prototype.andln = function(m) {
    return this.words[0] & m;
  }, h.prototype.bincn = function(m) {
    c(typeof m == "number");
    var A = m % 26, E = (m - A) / 26, w = 1 << A;
    if (this.length <= E)
      return this._expand(E + 1), this.words[E] |= w, this;
    for (var v = w, k = E; v !== 0 && k < this.length; k++) {
      var O = 0 | this.words[k];
      v = (O += v) >>> 26, O &= 67108863, this.words[k] = O;
    }
    return v !== 0 && (this.words[k] = v, this.length++), this;
  }, h.prototype.isZero = function() {
    return this.length === 1 && this.words[0] === 0;
  }, h.prototype.cmpn = function(m) {
    var A, E = m < 0;
    if (this.negative !== 0 && !E)
      return -1;
    if (this.negative === 0 && E)
      return 1;
    if (this.strip(), this.length > 1)
      A = 1;
    else {
      E && (m = -m), c(m <= 67108863, "Number is too big");
      var w = 0 | this.words[0];
      A = w === m ? 0 : w < m ? -1 : 1;
    }
    return this.negative !== 0 ? 0 | -A : A;
  }, h.prototype.cmp = function(m) {
    if (this.negative !== 0 && m.negative === 0)
      return -1;
    if (this.negative === 0 && m.negative !== 0)
      return 1;
    var A = this.ucmp(m);
    return this.negative !== 0 ? 0 | -A : A;
  }, h.prototype.ucmp = function(m) {
    if (this.length > m.length)
      return 1;
    if (this.length < m.length)
      return -1;
    for (var A = 0, E = this.length - 1; E >= 0; E--) {
      var w = 0 | this.words[E], v = 0 | m.words[E];
      if (w !== v) {
        w < v ? A = -1 : w > v && (A = 1);
        break;
      }
    }
    return A;
  }, h.prototype.gtn = function(m) {
    return this.cmpn(m) === 1;
  }, h.prototype.gt = function(m) {
    return this.cmp(m) === 1;
  }, h.prototype.gten = function(m) {
    return this.cmpn(m) >= 0;
  }, h.prototype.gte = function(m) {
    return this.cmp(m) >= 0;
  }, h.prototype.ltn = function(m) {
    return this.cmpn(m) === -1;
  }, h.prototype.lt = function(m) {
    return this.cmp(m) === -1;
  }, h.prototype.lten = function(m) {
    return this.cmpn(m) <= 0;
  }, h.prototype.lte = function(m) {
    return this.cmp(m) <= 0;
  }, h.prototype.eqn = function(m) {
    return this.cmpn(m) === 0;
  }, h.prototype.eq = function(m) {
    return this.cmp(m) === 0;
  }, h.red = function(m) {
    return new _t(m);
  }, h.prototype.toRed = function(m) {
    return c(!this.red, "Already a number in reduction context"), c(this.negative === 0, "red works only with positives"), m.convertTo(this)._forceRed(m);
  }, h.prototype.fromRed = function() {
    return c(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
  }, h.prototype._forceRed = function(m) {
    return this.red = m, this;
  }, h.prototype.forceRed = function(m) {
    return c(!this.red, "Already a number in reduction context"), this._forceRed(m);
  }, h.prototype.redAdd = function(m) {
    return c(this.red, "redAdd works only with red numbers"), this.red.add(this, m);
  }, h.prototype.redIAdd = function(m) {
    return c(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, m);
  }, h.prototype.redSub = function(m) {
    return c(this.red, "redSub works only with red numbers"), this.red.sub(this, m);
  }, h.prototype.redISub = function(m) {
    return c(this.red, "redISub works only with red numbers"), this.red.isub(this, m);
  }, h.prototype.redShl = function(m) {
    return c(this.red, "redShl works only with red numbers"), this.red.shl(this, m);
  }, h.prototype.redMul = function(m) {
    return c(this.red, "redMul works only with red numbers"), this.red._verify2(this, m), this.red.mul(this, m);
  }, h.prototype.redIMul = function(m) {
    return c(this.red, "redMul works only with red numbers"), this.red._verify2(this, m), this.red.imul(this, m);
  }, h.prototype.redSqr = function() {
    return c(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
  }, h.prototype.redISqr = function() {
    return c(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
  }, h.prototype.redSqrt = function() {
    return c(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
  }, h.prototype.redInvm = function() {
    return c(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
  }, h.prototype.redNeg = function() {
    return c(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
  }, h.prototype.redPow = function(m) {
    return c(this.red && !m.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, m);
  };
  var st = { k256: null, p224: null, p192: null, p25519: null };
  function ot(m, A) {
    this.name = m, this.p = new h(A, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
  }
  function St() {
    ot.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
  }
  function Ct() {
    ot.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
  }
  function et() {
    ot.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
  }
  function at() {
    ot.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
  }
  function _t(m) {
    if (typeof m == "string") {
      var A = h._prime(m);
      this.m = A.p, this.prime = A;
    } else
      c(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
  }
  function Nt(m) {
    _t.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
  }
  ot.prototype._tmp = function() {
    var m = new h(null);
    return m.words = new Array(Math.ceil(this.n / 13)), m;
  }, ot.prototype.ireduce = function(m) {
    var A, E = m;
    do
      this.split(E, this.tmp), A = (E = (E = this.imulK(E)).iadd(this.tmp)).bitLength();
    while (A > this.n);
    var w = A < this.n ? -1 : E.ucmp(this.p);
    return w === 0 ? (E.words[0] = 0, E.length = 1) : w > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
  }, ot.prototype.split = function(m, A) {
    m.iushrn(this.n, 0, A);
  }, ot.prototype.imulK = function(m) {
    return m.imul(this.k);
  }, u(St, ot), St.prototype.split = function(m, A) {
    for (var E = 4194303, w = Math.min(m.length, 9), v = 0; v < w; v++)
      A.words[v] = m.words[v];
    if (A.length = w, m.length <= 9)
      return m.words[0] = 0, void (m.length = 1);
    var k = m.words[9];
    for (A.words[A.length++] = k & E, v = 10; v < m.length; v++) {
      var O = 0 | m.words[v];
      m.words[v - 10] = (O & E) << 4 | k >>> 22, k = O;
    }
    k >>>= 22, m.words[v - 10] = k, k === 0 && m.length > 10 ? m.length -= 10 : m.length -= 9;
  }, St.prototype.imulK = function(m) {
    m.words[m.length] = 0, m.words[m.length + 1] = 0, m.length += 2;
    for (var A = 0, E = 0; E < m.length; E++) {
      var w = 0 | m.words[E];
      A += 977 * w, m.words[E] = 67108863 & A, A = 64 * w + (A / 67108864 | 0);
    }
    return m.words[m.length - 1] === 0 && (m.length--, m.words[m.length - 1] === 0 && m.length--), m;
  }, u(Ct, ot), u(et, ot), u(at, ot), at.prototype.imulK = function(m) {
    for (var A = 0, E = 0; E < m.length; E++) {
      var w = 19 * (0 | m.words[E]) + A, v = 67108863 & w;
      w >>>= 26, m.words[E] = v, A = w;
    }
    return A !== 0 && (m.words[m.length++] = A), m;
  }, h._prime = function(m) {
    if (st[m])
      return st[m];
    var A;
    if (m === "k256")
      A = new St();
    else if (m === "p224")
      A = new Ct();
    else if (m === "p192")
      A = new et();
    else {
      if (m !== "p25519")
        throw new Error("Unknown prime " + m);
      A = new at();
    }
    return st[m] = A, A;
  }, _t.prototype._verify1 = function(m) {
    c(m.negative === 0, "red works only with positives"), c(m.red, "red works only with red numbers");
  }, _t.prototype._verify2 = function(m, A) {
    c((m.negative | A.negative) == 0, "red works only with positives"), c(m.red && m.red === A.red, "red works only with red numbers");
  }, _t.prototype.imod = function(m) {
    return this.prime ? this.prime.ireduce(m)._forceRed(this) : m.umod(this.m)._forceRed(this);
  }, _t.prototype.neg = function(m) {
    return m.isZero() ? m.clone() : this.m.sub(m)._forceRed(this);
  }, _t.prototype.add = function(m, A) {
    this._verify2(m, A);
    var E = m.add(A);
    return E.cmp(this.m) >= 0 && E.isub(this.m), E._forceRed(this);
  }, _t.prototype.iadd = function(m, A) {
    this._verify2(m, A);
    var E = m.iadd(A);
    return E.cmp(this.m) >= 0 && E.isub(this.m), E;
  }, _t.prototype.sub = function(m, A) {
    this._verify2(m, A);
    var E = m.sub(A);
    return E.cmpn(0) < 0 && E.iadd(this.m), E._forceRed(this);
  }, _t.prototype.isub = function(m, A) {
    this._verify2(m, A);
    var E = m.isub(A);
    return E.cmpn(0) < 0 && E.iadd(this.m), E;
  }, _t.prototype.shl = function(m, A) {
    return this._verify1(m), this.imod(m.ushln(A));
  }, _t.prototype.imul = function(m, A) {
    return this._verify2(m, A), this.imod(m.imul(A));
  }, _t.prototype.mul = function(m, A) {
    return this._verify2(m, A), this.imod(m.mul(A));
  }, _t.prototype.isqr = function(m) {
    return this.imul(m, m.clone());
  }, _t.prototype.sqr = function(m) {
    return this.mul(m, m);
  }, _t.prototype.sqrt = function(m) {
    if (m.isZero())
      return m.clone();
    var A = this.m.andln(3);
    if (c(A % 2 == 1), A === 3) {
      var E = this.m.add(new h(1)).iushrn(2);
      return this.pow(m, E);
    }
    for (var w = this.m.subn(1), v = 0; !w.isZero() && w.andln(1) === 0; )
      v++, w.iushrn(1);
    c(!w.isZero());
    var k = new h(1).toRed(this), O = k.redNeg(), W = this.m.subn(1).iushrn(1), it = this.m.bitLength();
    for (it = new h(2 * it * it).toRed(this); this.pow(it, W).cmp(O) !== 0; )
      it.redIAdd(O);
    for (var vt = this.pow(it, w), xt = this.pow(m, w.addn(1).iushrn(1)), It = this.pow(m, w), Wt = v; It.cmp(k) !== 0; ) {
      for (var Ut = It, zt = 0; Ut.cmp(k) !== 0; zt++)
        Ut = Ut.redSqr();
      c(zt < Wt);
      var Jt = this.pow(vt, new h(1).iushln(Wt - zt - 1));
      xt = xt.redMul(Jt), vt = Jt.redSqr(), It = It.redMul(vt), Wt = zt;
    }
    return xt;
  }, _t.prototype.invm = function(m) {
    var A = m._invmp(this.m);
    return A.negative !== 0 ? (A.negative = 0, this.imod(A).redNeg()) : this.imod(A);
  }, _t.prototype.pow = function(m, A) {
    if (A.isZero())
      return new h(1).toRed(this);
    if (A.cmpn(1) === 0)
      return m.clone();
    var E = new Array(16);
    E[0] = new h(1).toRed(this), E[1] = m;
    for (var w = 2; w < E.length; w++)
      E[w] = this.mul(E[w - 1], m);
    var v = E[0], k = 0, O = 0, W = A.bitLength() % 26;
    for (W === 0 && (W = 26), w = A.length - 1; w >= 0; w--) {
      for (var it = A.words[w], vt = W - 1; vt >= 0; vt--) {
        var xt = it >> vt & 1;
        v !== E[0] && (v = this.sqr(v)), xt !== 0 || k !== 0 ? (k <<= 1, k |= xt, (++O == 4 || w === 0 && vt === 0) && (v = this.mul(v, E[k]), O = 0, k = 0)) : O = 0;
      }
      W = 26;
    }
    return v;
  }, _t.prototype.convertTo = function(m) {
    var A = m.umod(this.m);
    return A === m ? A.clone() : A;
  }, _t.prototype.convertFrom = function(m) {
    var A = m.clone();
    return A.red = null, A;
  }, h.mont = function(m) {
    return new Nt(m);
  }, u(Nt, _t), Nt.prototype.convertTo = function(m) {
    return this.imod(m.ushln(this.shift));
  }, Nt.prototype.convertFrom = function(m) {
    var A = this.imod(m.mul(this.rinv));
    return A.red = null, A;
  }, Nt.prototype.imul = function(m, A) {
    if (m.isZero() || A.isZero())
      return m.words[0] = 0, m.length = 1, m;
    var E = m.imul(A), w = E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = E.isub(w).iushrn(this.shift), k = v;
    return v.cmp(this.m) >= 0 ? k = v.isub(this.m) : v.cmpn(0) < 0 && (k = v.iadd(this.m)), k._forceRed(this);
  }, Nt.prototype.mul = function(m, A) {
    if (m.isZero() || A.isZero())
      return new h(0)._forceRed(this);
    var E = m.mul(A), w = E.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = E.isub(w).iushrn(this.shift), k = v;
    return v.cmp(this.m) >= 0 ? k = v.isub(this.m) : v.cmpn(0) < 0 && (k = v.iadd(this.m)), k._forceRed(this);
  }, Nt.prototype.invm = function(m) {
    return this.imod(m._invmp(this.m).mul(this.r2))._forceRed(this);
  };
})(0, commonjsGlobal);
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(o, n) {
  var c = buffer$2, u = c.Buffer;
  function h(y, $) {
    for (var I in y)
      $[I] = y[I];
  }
  function g(y, $, I) {
    return u(y, $, I);
  }
  u.from && u.alloc && u.allocUnsafe && u.allocUnsafeSlow ? o.exports = c : (h(c, n), n.Buffer = g), g.prototype = Object.create(u.prototype), h(u, g), g.from = function(y, $, I) {
    if (typeof y == "number")
      throw new TypeError("Argument must not be a number");
    return u(y, $, I);
  }, g.alloc = function(y, $, I) {
    if (typeof y != "number")
      throw new TypeError("Argument must be a number");
    var P = u(y);
    return $ !== void 0 ? typeof I == "string" ? P.fill($, I) : P.fill($) : P.fill(0), P;
  }, g.allocUnsafe = function(y) {
    if (typeof y != "number")
      throw new TypeError("Argument must be a number");
    return u(y);
  }, g.allocUnsafeSlow = function(y) {
    if (typeof y != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(y);
  };
})(safeBuffer, safeBuffer.exports);
const Buffer$4 = safeBuffer.exports.Buffer;
var bufferPipe$1 = class {
  constructor(o = Buffer$4.from([])) {
    this.buffer = o;
  }
  read(o) {
    const n = this.buffer.subarray(0, o);
    return this.buffer = this.buffer.subarray(o), n;
  }
  write(o) {
    o = Buffer$4.from(o), this.buffer = Buffer$4.concat([this.buffer, o]);
  }
};
const Bn$1 = bn.exports, Pipe$2 = bufferPipe$1;
var unsigned = { encode: encode$1, decode: decode$1, read: read$1, readBn: readBn$1, write: write$1 };
function read$1(o) {
  return readBn$1(o).toString();
}
function readBn$1(o) {
  const n = new Bn$1(0);
  let c, u = 0;
  for (; c = o.read(1)[0], n.ior(new Bn$1(127 & c).shln(u)), c >> 7 != 0; )
    u += 7;
  return n;
}
function write$1(o, n) {
  const c = new Bn$1(o);
  for (; ; ) {
    const u = c.maskn(7).toNumber();
    if (c.ishrn(7), c.isZero()) {
      n.write([u]);
      break;
    }
    n.write([128 | u]);
  }
}
function encode$1(o) {
  const n = new Pipe$2();
  return write$1(o, n), n.buffer;
}
function decode$1(o) {
  return read$1(new Pipe$2(o));
}
const Bn = bn.exports, Pipe$1 = bufferPipe$1;
var signed = { encode, decode, write, read, readBn };
function read(o) {
  return readBn(o).toString();
}
function readBn(o) {
  const n = new Bn(0);
  let c, u = 0;
  for (; c = o.read(1)[0], n.ior(new Bn(127 & c).shln(u)), u += 7, c >> 7 != 0; )
    ;
  return 64 & c && n.setn(u), n.fromTwos(u);
}
function write(o, n) {
  let c = new Bn(o);
  const u = c.isNeg();
  for (u && (c = c.toTwos(c.bitLength() + 8)); ; ) {
    const g = c.maskn(7).toNumber();
    if (c.ishrn(7), h(c) && (64 & g) != 0 || c.isZero() && (64 & g) == 0) {
      n.write([g]);
      break;
    }
    n.write([128 | g]);
  }
  function h(g) {
    return u && g.toString(2).indexOf("0") < 0;
  }
}
function encode(o) {
  const n = new Pipe$1();
  return write(o, n), n.buffer;
}
function decode(o) {
  return read(new Pipe$1(o));
}
leb128$1.unsigned = unsigned, leb128$1.signed = signed;
const Buffer$3 = safeBuffer.exports.Buffer;
var bufferPipe = class {
  constructor(o = Buffer$3.from([])) {
    this.buffer = o, this._bytesRead = 0, this._bytesWrote = 0;
  }
  read(o) {
    this._bytesRead += o;
    const n = this.buffer.slice(0, o);
    return this.buffer = this.buffer.slice(o), n;
  }
  write(o) {
    o = Buffer$3.from(o), this._bytesWrote += o.length, this.buffer = Buffer$3.concat([this.buffer, o]);
  }
  get end() {
    return !this.buffer.length;
  }
  get bytesRead() {
    return this._bytesRead;
  }
  get bytesWrote() {
    return this._bytesWrote;
  }
};
const block = "block_type", loop = "block_type", br = "varuint32", br_if = "varuint32", br_table = "br_table", call = "varuint32", call_indirect = "call_indirect", get_local = "varuint32", set_local = "varuint32", tee_local = "varuint32", get_global = "varuint32", set_global = "varuint32", load = "memory_immediate", load8_s = "memory_immediate", load8_u = "memory_immediate", load16_s = "memory_immediate", load16_u = "memory_immediate", load32_s = "memory_immediate", load32_u = "memory_immediate", store = "memory_immediate", store8 = "memory_immediate", store16 = "memory_immediate", store32 = "memory_immediate", current_memory = "varuint1", grow_memory = "varuint1", i32 = "varint32", i64 = "varint64", f32 = "uint32", f64 = "uint64", require$$0$1 = { block, loop, if: "block_type", br, br_if, br_table, call, call_indirect, get_local, set_local, tee_local, get_global, set_global, load, load8_s, load8_u, load16_s, load16_u, load32_s, load32_u, store, store8, store16, store32, current_memory, grow_memory, i32, i64, f32, f64 }, leb$1 = leb128$1, Stream$1 = bufferPipe, OP_IMMEDIATES$1 = require$$0$1, _exports$1 = wasm2json$1.exports = (o, n) => {
  const c = new Stream$1(o);
  return _exports$1.parse(c, n);
}, LANGUAGE_TYPES$1 = _exports$1.LANGUAGE_TYPES = { 127: "i32", 126: "i64", 125: "f32", 124: "f64", 112: "anyFunc", 96: "func", 64: "block_type" }, EXTERNAL_KIND$1 = _exports$1.EXTERNAL_KIND = { 0: "function", 1: "table", 2: "memory", 3: "global" };
_exports$1.parsePreramble = (o) => {
  const n = { name: "preramble" };
  return n.magic = [...o.read(4)], n.version = [...o.read(4)], n;
}, _exports$1.parseSectionHeader = (o) => {
  const n = o.read(1)[0], c = leb$1.unsigned.readBn(o).toNumber();
  return { id: n, name: SECTION_IDS$1[n], size: c };
};
const OPCODES$1 = _exports$1.OPCODES = { 0: "unreachable", 1: "nop", 2: "block", 3: "loop", 4: "if", 5: "else", 11: "end", 12: "br", 13: "br_if", 14: "br_table", 15: "return", 16: "call", 17: "call_indirect", 26: "drop", 27: "select", 32: "get_local", 33: "set_local", 34: "tee_local", 35: "get_global", 36: "set_global", 40: "i32.load", 41: "i64.load", 42: "f32.load", 43: "f64.load", 44: "i32.load8_s", 45: "i32.load8_u", 46: "i32.load16_s", 47: "i32.load16_u", 48: "i64.load8_s", 49: "i64.load8_u", 50: "i64.load16_s", 51: "i64.load16_u", 52: "i64.load32_s", 53: "i64.load32_u", 54: "i32.store", 55: "i64.store", 56: "f32.store", 57: "f64.store", 58: "i32.store8", 59: "i32.store16", 60: "i64.store8", 61: "i64.store16", 62: "i64.store32", 63: "current_memory", 64: "grow_memory", 65: "i32.const", 66: "i64.const", 67: "f32.const", 68: "f64.const", 69: "i32.eqz", 70: "i32.eq", 71: "i32.ne", 72: "i32.lt_s", 73: "i32.lt_u", 74: "i32.gt_s", 75: "i32.gt_u", 76: "i32.le_s", 77: "i32.le_u", 78: "i32.ge_s", 79: "i32.ge_u", 80: "i64.eqz", 81: "i64.eq", 82: "i64.ne", 83: "i64.lt_s", 84: "i64.lt_u", 85: "i64.gt_s", 86: "i64.gt_u", 87: "i64.le_s", 88: "i64.le_u", 89: "i64.ge_s", 90: "i64.ge_u", 91: "f32.eq", 92: "f32.ne", 93: "f32.lt", 94: "f32.gt", 95: "f32.le", 96: "f32.ge", 97: "f64.eq", 98: "f64.ne", 99: "f64.lt", 100: "f64.gt", 101: "f64.le", 102: "f64.ge", 103: "i32.clz", 104: "i32.ctz", 105: "i32.popcnt", 106: "i32.add", 107: "i32.sub", 108: "i32.mul", 109: "i32.div_s", 110: "i32.div_u", 111: "i32.rem_s", 112: "i32.rem_u", 113: "i32.and", 114: "i32.or", 115: "i32.xor", 116: "i32.shl", 117: "i32.shr_s", 118: "i32.shr_u", 119: "i32.rotl", 120: "i32.rotr", 121: "i64.clz", 122: "i64.ctz", 123: "i64.popcnt", 124: "i64.add", 125: "i64.sub", 126: "i64.mul", 127: "i64.div_s", 128: "i64.div_u", 129: "i64.rem_s", 130: "i64.rem_u", 131: "i64.and", 132: "i64.or", 133: "i64.xor", 134: "i64.shl", 135: "i64.shr_s", 136: "i64.shr_u", 137: "i64.rotl", 138: "i64.rotr", 139: "f32.abs", 140: "f32.neg", 141: "f32.ceil", 142: "f32.floor", 143: "f32.trunc", 144: "f32.nearest", 145: "f32.sqrt", 146: "f32.add", 147: "f32.sub", 148: "f32.mul", 149: "f32.div", 150: "f32.min", 151: "f32.max", 152: "f32.copysign", 153: "f64.abs", 154: "f64.neg", 155: "f64.ceil", 156: "f64.floor", 157: "f64.trunc", 158: "f64.nearest", 159: "f64.sqrt", 160: "f64.add", 161: "f64.sub", 162: "f64.mul", 163: "f64.div", 164: "f64.min", 165: "f64.max", 166: "f64.copysign", 167: "i32.wrap/i64", 168: "i32.trunc_s/f32", 169: "i32.trunc_u/f32", 170: "i32.trunc_s/f64", 171: "i32.trunc_u/f64", 172: "i64.extend_s/i32", 173: "i64.extend_u/i32", 174: "i64.trunc_s/f32", 175: "i64.trunc_u/f32", 176: "i64.trunc_s/f64", 177: "i64.trunc_u/f64", 178: "f32.convert_s/i32", 179: "f32.convert_u/i32", 180: "f32.convert_s/i64", 181: "f32.convert_u/i64", 182: "f32.demote/f64", 183: "f64.convert_s/i32", 184: "f64.convert_u/i32", 185: "f64.convert_s/i64", 186: "f64.convert_u/i64", 187: "f64.promote/f32", 188: "i32.reinterpret/f32", 189: "i64.reinterpret/f64", 190: "f32.reinterpret/i32", 191: "f64.reinterpret/i64" }, SECTION_IDS$1 = _exports$1.SECTION_IDS = { 0: "custom", 1: "type", 2: "import", 3: "function", 4: "table", 5: "memory", 6: "global", 7: "export", 8: "start", 9: "element", 10: "code", 11: "data" };
_exports$1.immediataryParsers = { varuint1: (o) => o.read(1)[0], varuint32: (o) => leb$1.unsigned.read(o), varint32: (o) => leb$1.signed.read(o), varint64: (o) => leb$1.signed.read(o), uint32: (o) => [...o.read(4)], uint64: (o) => [...o.read(8)], block_type: (o) => {
  const n = o.read(1)[0];
  return LANGUAGE_TYPES$1[n];
}, br_table: (o) => {
  const n = { targets: [] }, c = leb$1.unsigned.readBn(o).toNumber();
  for (let u = 0; u < c; u++) {
    const h = leb$1.unsigned.readBn(o).toNumber();
    n.targets.push(h);
  }
  return n.defaultTarget = leb$1.unsigned.readBn(o).toNumber(), n;
}, call_indirect: (o) => {
  const n = {};
  return n.index = leb$1.unsigned.readBn(o).toNumber(), n.reserved = o.read(1)[0], n;
}, memory_immediate: (o) => {
  const n = {};
  return n.flags = leb$1.unsigned.readBn(o).toNumber(), n.offset = leb$1.unsigned.readBn(o).toNumber(), n;
} }, _exports$1.typeParsers = { function: (o) => leb$1.unsigned.readBn(o).toNumber(), table: (o) => {
  const n = {}, c = o.read(1)[0];
  return n.elementType = LANGUAGE_TYPES$1[c], n.limits = _exports$1.typeParsers.memory(o), n;
}, global: (o) => {
  const n = {};
  let c = o.read(1)[0];
  return n.contentType = LANGUAGE_TYPES$1[c], n.mutability = o.read(1)[0], n;
}, memory: (o) => {
  const n = {};
  return n.flags = leb$1.unsigned.readBn(o).toNumber(), n.intial = leb$1.unsigned.readBn(o).toNumber(), n.flags === 1 && (n.maximum = leb$1.unsigned.readBn(o).toNumber()), n;
}, initExpr: (o) => {
  const n = _exports$1.parseOp(o);
  return o.read(1), n;
} };
const sectionParsers = _exports$1.sectionParsers = { custom: (o, n) => {
  const c = { name: "custom" }, u = new Stream$1(o.read(n.size)), h = leb$1.unsigned.readBn(u).toNumber(), g = u.read(h);
  return c.sectionName = Buffer.from(g).toString(), c.payload = [...u.buffer], c;
}, type: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), c = { name: "type", entries: [] };
  for (let u = 0; u < n; u++) {
    let h = o.read(1)[0];
    const g = { form: LANGUAGE_TYPES$1[h], params: [] }, y = leb$1.unsigned.readBn(o).toNumber();
    for (let $ = 0; $ < y; $++) {
      const I = o.read(1)[0];
      g.params.push(LANGUAGE_TYPES$1[I]);
    }
    leb$1.unsigned.readBn(o).toNumber() && (h = o.read(1)[0], g.return_type = LANGUAGE_TYPES$1[h]), c.entries.push(g);
  }
  return c;
}, import: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), c = { name: "import", entries: [] };
  for (let u = 0; u < n; u++) {
    const h = {}, g = leb$1.unsigned.readBn(o).toNumber();
    h.moduleStr = Buffer.from(o.read(g)).toString();
    const y = leb$1.unsigned.readBn(o).toNumber();
    h.fieldStr = Buffer.from(o.read(y)).toString();
    const $ = o.read(1)[0];
    h.kind = EXTERNAL_KIND$1[$], h.type = _exports$1.typeParsers[h.kind](o), c.entries.push(h);
  }
  return c;
}, function: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), c = { name: "function", entries: [] };
  for (let u = 0; u < n; u++) {
    const h = leb$1.unsigned.readBn(o).toNumber();
    c.entries.push(h);
  }
  return c;
}, table: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), c = { name: "table", entries: [] };
  for (let u = 0; u < n; u++) {
    const h = _exports$1.typeParsers.table(o);
    c.entries.push(h);
  }
  return c;
}, memory: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), c = { name: "memory", entries: [] };
  for (let u = 0; u < n; u++) {
    const h = _exports$1.typeParsers.memory(o);
    c.entries.push(h);
  }
  return c;
}, global: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), c = { name: "global", entries: [] };
  for (let u = 0; u < n; u++) {
    const h = {};
    h.type = _exports$1.typeParsers.global(o), h.init = _exports$1.typeParsers.initExpr(o), c.entries.push(h);
  }
  return c;
}, export: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), c = { name: "export", entries: [] };
  for (let u = 0; u < n; u++) {
    const h = leb$1.unsigned.readBn(o).toNumber(), g = {};
    g.field_str = Buffer.from(o.read(h)).toString();
    const y = o.read(1)[0];
    g.kind = EXTERNAL_KIND$1[y], g.index = leb$1.unsigned.readBn(o).toNumber(), c.entries.push(g);
  }
  return c;
}, start: (o) => {
  const n = { name: "start" };
  return n.index = leb$1.unsigned.readBn(o).toNumber(), n;
}, element: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), c = { name: "element", entries: [] };
  for (let u = 0; u < n; u++) {
    const h = { elements: [] };
    h.index = leb$1.unsigned.readBn(o).toNumber(), h.offset = _exports$1.typeParsers.initExpr(o);
    const g = leb$1.unsigned.readBn(o).toNumber();
    for (let y = 0; y < g; y++) {
      const $ = leb$1.unsigned.readBn(o).toNumber();
      h.elements.push($);
    }
    c.entries.push(h);
  }
  return c;
}, code: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), c = { name: "code", entries: [] };
  for (let u = 0; u < n; u++) {
    const h = { locals: [], code: [] };
    let g = leb$1.unsigned.readBn(o).toNumber();
    const y = o.bytesRead + g, $ = leb$1.unsigned.readBn(o).toNumber();
    for (let I = 0; I < $; I++) {
      const P = {};
      P.count = leb$1.unsigned.readBn(o).toNumber();
      const L = o.read(1)[0];
      P.type = LANGUAGE_TYPES$1[L], h.locals.push(P);
    }
    for (; o.bytesRead < y; ) {
      const I = _exports$1.parseOp(o);
      h.code.push(I);
    }
    c.entries.push(h);
  }
  return c;
}, data: (o) => {
  const n = leb$1.unsigned.readBn(o).toNumber(), c = { name: "data", entries: [] };
  for (let u = 0; u < n; u++) {
    const h = {};
    h.index = leb$1.unsigned.readBn(o).toNumber(), h.offset = _exports$1.typeParsers.initExpr(o);
    const g = leb$1.unsigned.readBn(o).toNumber();
    h.data = [...o.read(g)], c.entries.push(h);
  }
  return c;
} };
_exports$1.parseOp = (o) => {
  const n = {}, c = o.read(1)[0], u = OPCODES$1[c];
  let [h, g] = u.split(".");
  g === void 0 ? g = h : n.return_type = h, n.name = g;
  const y = OP_IMMEDIATES$1[g === "const" ? h : g];
  return y && (n.immediates = _exports$1.immediataryParsers[y](o)), n;
}, _exports$1.parse = (o, n) => {
  const c = [_exports$1.parsePreramble(o)];
  for (; !o.end; ) {
    const u = _exports$1.parseSectionHeader(o);
    c.push(sectionParsers[u.name](o, u));
  }
  return c;
};
var json2wasm = { exports: {} }, npmBrowser = {};
commonjsGlobal.fetch = window.fetch, npmBrowser.buffer = buffer$2.Buffer;
const Buffer$2 = npmBrowser.Buffer, leb = leb128$1, Stream = bufferPipe, OP_IMMEDIATES = require$$0$1, _exports = json2wasm.exports = (o) => _exports.generate(o).buffer, LANGUAGE_TYPES = _exports.LANGUAGE_TYPES = { i32: 127, i64: 126, f32: 125, f64: 124, anyFunc: 112, func: 96, block_type: 64 }, EXTERNAL_KIND = _exports.EXTERNAL_KIND = { function: 0, table: 1, memory: 2, global: 3 }, SECTION_IDS = _exports.SECTION_IDS = { custom: 0, type: 1, import: 2, function: 3, table: 4, memory: 5, global: 6, export: 7, start: 8, element: 9, code: 10, data: 11 }, OPCODES = _exports.OPCODES = { unreachable: 0, nop: 1, block: 2, loop: 3, if: 4, else: 5, end: 11, br: 12, br_if: 13, br_table: 14, return: 15, call: 16, call_indirect: 17, drop: 26, select: 27, get_local: 32, set_local: 33, tee_local: 34, get_global: 35, set_global: 36, "i32.load": 40, "i64.load": 41, "f32.load": 42, "f64.load": 43, "i32.load8_s": 44, "i32.load8_u": 45, "i32.load16_s": 46, "i32.load16_u": 47, "i64.load8_s": 48, "i64.load8_u": 49, "i64.load16_s": 50, "i64.load16_u": 51, "i64.load32_s": 52, "i64.load32_u": 53, "i32.store": 54, "i64.store": 55, "f32.store": 56, "f64.store": 57, "i32.store8": 58, "i32.store16": 59, "i64.store8": 60, "i64.store16": 61, "i64.store32": 62, current_memory: 63, grow_memory: 64, "i32.const": 65, "i64.const": 66, "f32.const": 67, "f64.const": 68, "i32.eqz": 69, "i32.eq": 70, "i32.ne": 71, "i32.lt_s": 72, "i32.lt_u": 73, "i32.gt_s": 74, "i32.gt_u": 75, "i32.le_s": 76, "i32.le_u": 77, "i32.ge_s": 78, "i32.ge_u": 79, "i64.eqz": 80, "i64.eq": 81, "i64.ne": 82, "i64.lt_s": 83, "i64.lt_u": 84, "i64.gt_s": 85, "i64.gt_u": 86, "i64.le_s": 87, "i64.le_u": 88, "i64.ge_s": 89, "i64.ge_u": 90, "f32.eq": 91, "f32.ne": 92, "f32.lt": 93, "f32.gt": 94, "f32.le": 95, "f32.ge": 96, "f64.eq": 97, "f64.ne": 98, "f64.lt": 99, "f64.gt": 100, "f64.le": 101, "f64.ge": 102, "i32.clz": 103, "i32.ctz": 104, "i32.popcnt": 105, "i32.add": 106, "i32.sub": 107, "i32.mul": 108, "i32.div_s": 109, "i32.div_u": 110, "i32.rem_s": 111, "i32.rem_u": 112, "i32.and": 113, "i32.or": 114, "i32.xor": 115, "i32.shl": 116, "i32.shr_s": 117, "i32.shr_u": 118, "i32.rotl": 119, "i32.rotr": 120, "i64.clz": 121, "i64.ctz": 122, "i64.popcnt": 123, "i64.add": 124, "i64.sub": 125, "i64.mul": 126, "i64.div_s": 127, "i64.div_u": 128, "i64.rem_s": 129, "i64.rem_u": 130, "i64.and": 131, "i64.or": 132, "i64.xor": 133, "i64.shl": 134, "i64.shr_s": 135, "i64.shr_u": 136, "i64.rotl": 137, "i64.rotr": 138, "f32.abs": 139, "f32.neg": 140, "f32.ceil": 141, "f32.floor": 142, "f32.trunc": 143, "f32.nearest": 144, "f32.sqrt": 145, "f32.add": 146, "f32.sub": 147, "f32.mul": 148, "f32.div": 149, "f32.min": 150, "f32.max": 151, "f32.copysign": 152, "f64.abs": 153, "f64.neg": 154, "f64.ceil": 155, "f64.floor": 156, "f64.trunc": 157, "f64.nearest": 158, "f64.sqrt": 159, "f64.add": 160, "f64.sub": 161, "f64.mul": 162, "f64.div": 163, "f64.min": 164, "f64.max": 165, "f64.copysign": 166, "i32.wrap/i64": 167, "i32.trunc_s/f32": 168, "i32.trunc_u/f32": 169, "i32.trunc_s/f64": 170, "i32.trunc_u/f64": 171, "i64.extend_s/i32": 172, "i64.extend_u/i32": 173, "i64.trunc_s/f32": 174, "i64.trunc_u/f32": 175, "i64.trunc_s/f64": 176, "i64.trunc_u/f64": 177, "f32.convert_s/i32": 178, "f32.convert_u/i32": 179, "f32.convert_s/i64": 180, "f32.convert_u/i64": 181, "f32.demote/f64": 182, "f64.convert_s/i32": 183, "f64.convert_u/i32": 184, "f64.convert_s/i64": 185, "f64.convert_u/i64": 186, "f64.promote/f32": 187, "i32.reinterpret/f32": 188, "i64.reinterpret/f64": 189, "f32.reinterpret/i32": 190, "f64.reinterpret/i64": 191 };
_exports.typeGenerators = { function: (o, n) => {
  leb.unsigned.write(o, n);
}, table: (o, n) => {
  n.write([LANGUAGE_TYPES[o.elementType]]), _exports.typeGenerators.memory(o.limits, n);
}, global: (o, n) => {
  n.write([LANGUAGE_TYPES[o.contentType]]), n.write([o.mutability]);
}, memory: (o, n) => {
  leb.unsigned.write(Number(o.maximum !== void 0), n), leb.unsigned.write(o.intial, n), o.maximum !== void 0 && leb.unsigned.write(o.maximum, n);
}, initExpr: (o, n) => {
  _exports.generateOp(o, n), _exports.generateOp({ name: "end", type: "void" }, n);
} }, _exports.immediataryGenerators = { varuint1: (o, n) => (n.write([o]), n), varuint32: (o, n) => (leb.unsigned.write(o, n), n), varint32: (o, n) => (leb.signed.write(o, n), n), varint64: (o, n) => (leb.signed.write(o, n), n), uint32: (o, n) => (n.write(o), n), uint64: (o, n) => (n.write(o), n), block_type: (o, n) => (n.write([LANGUAGE_TYPES[o]]), n), br_table: (o, n) => {
  leb.unsigned.write(o.targets.length, n);
  for (let c of o.targets)
    leb.unsigned.write(c, n);
  return leb.unsigned.write(o.defaultTarget, n), n;
}, call_indirect: (o, n) => (leb.unsigned.write(o.index, n), n.write([o.reserved]), n), memory_immediate: (o, n) => (leb.unsigned.write(o.flags, n), leb.unsigned.write(o.offset, n), n) };
const entryGenerators = { type: (o, n = new Stream()) => {
  n.write([LANGUAGE_TYPES[o.form]]);
  const c = o.params.length;
  return leb.unsigned.write(c, n), c !== 0 && n.write(o.params.map((u) => LANGUAGE_TYPES[u])), n.write([o.return_type ? 1 : 0]), o.return_type && n.write([LANGUAGE_TYPES[o.return_type]]), n.buffer;
}, import: (o, n = new Stream()) => {
  leb.unsigned.write(o.moduleStr.length, n), n.write(o.moduleStr), leb.unsigned.write(o.fieldStr.length, n), n.write(o.fieldStr), n.write([EXTERNAL_KIND[o.kind]]), _exports.typeGenerators[o.kind](o.type, n);
}, function: (o, n = new Stream()) => (leb.unsigned.write(o, n), n.buffer), table: _exports.typeGenerators.table, global: (o, n = new Stream()) => (_exports.typeGenerators.global(o.type, n), _exports.typeGenerators.initExpr(o.init, n), n), memory: _exports.typeGenerators.memory, export: (o, n = new Stream()) => {
  const c = Buffer$2.from(o.field_str), u = c.length;
  return leb.unsigned.write(u, n), n.write(c), n.write([EXTERNAL_KIND[o.kind]]), leb.unsigned.write(o.index, n), n;
}, element: (o, n = new Stream()) => {
  leb.unsigned.write(o.index, n), _exports.typeGenerators.initExpr(o.offset, n), leb.unsigned.write(o.elements.length, n);
  for (let c of o.elements)
    leb.unsigned.write(c, n);
  return n;
}, code: (o, n = new Stream()) => {
  let c = new Stream();
  leb.unsigned.write(o.locals.length, c);
  for (let u of o.locals)
    leb.unsigned.write(u.count, c), c.write([LANGUAGE_TYPES[u.type]]);
  for (let u of o.code)
    _exports.generateOp(u, c);
  return leb.unsigned.write(c.bytesWrote, n), n.write(c.buffer), n;
}, data: (o, n = new Stream()) => (leb.unsigned.write(o.index, n), _exports.typeGenerators.initExpr(o.offset, n), leb.unsigned.write(o.data.length, n), n.write(o.data), n) };
_exports.entryGenerators = entryGenerators, _exports.generateSection = function(o, n = new Stream()) {
  const c = o.name, u = new Stream();
  if (n.write([SECTION_IDS[c]]), c === "custom")
    leb.unsigned.write(o.sectionName.length, u), u.write(o.sectionName), u.write(o.payload);
  else if (c === "start")
    leb.unsigned.write(o.index, u);
  else {
    leb.unsigned.write(o.entries.length, u);
    for (let h of o.entries)
      entryGenerators[c](h, u);
  }
  return leb.unsigned.write(u.bytesWrote, n), n.write(u.buffer), n;
}, _exports.generate = (o, n = new Stream()) => {
  const [c, ...u] = o;
  _exports.generatePreramble(c, n);
  for (let h of u)
    _exports.generateSection(h, n);
  return n;
}, _exports.generatePreramble = (o, n = new Stream()) => (n.write(o.magic), n.write(o.version), n), _exports.generateOp = (o, n = new Stream()) => {
  let c = o.name;
  o.return_type !== void 0 && (c = o.return_type + "." + c), n.write([OPCODES[c]]);
  const u = OP_IMMEDIATES[o.name === "const" ? o.return_type : o.name];
  return u && _exports.immediataryGenerators[u](o.immediates, n), n;
};
const immediates = require$$0$1;
var text2json = (o) => {
  const n = [], c = o.split(/\s|\n/);
  for (; c.length; ) {
    const u = c.shift(), h = {};
    let [g, y] = u.split(".");
    y === void 0 ? y = g : h.return_type = g, h.name = y;
    const $ = immediates[h.name === "const" ? h.return_type : h.name];
    $ && (h.immediates = immediataryParser($, c)), n.push(h);
  }
  return n;
};
function immediataryParser(o, n) {
  const c = {};
  switch (o) {
    case "br_table":
      const u = [];
      for (; ; ) {
        let h = n[0];
        if (isNaN(h))
          break;
        n.shift(), u.push(h);
      }
      return u;
    case "call_indirect":
      return c.index = n.shift(), c.reserved = 0, c;
    case "memory_immediate":
      return c.flags = n.shift(), c.offset = n.shift(), c;
    default:
      return n.shift();
  }
}
const Buffer$1 = npmBrowser.Buffer, leb128 = leb128$1.unsigned, wasm2json = wasm2json$1.exports, Pipe = bufferPipe, SECTIONS = ["custom", "type", "import", "function", "table", "memory", "global", "export", "start", "element", "code", "data"];
var iterator = class {
  constructor(o) {
    this._wasm = o, this._sections = [], this._modified = !1;
  }
  get wasm() {
    return this._modified && (this._wasm = Buffer$1.concat(this._sections.concat(this._pipe.buffer)), this._modified = !1), this._wasm;
  }
  *[Symbol.iterator]() {
    for (this._pipe = new Pipe(this._wasm), this._sections = [this._pipe.read(8)]; !this._pipe.end; ) {
      const o = this._pipe.bytesRead, n = this._pipe.read(1)[0], c = Number(leb128.read(this._pipe)), u = this._pipe.read(c), h = this._pipe.bytesRead, g = this._wasm.slice(o, h), y = this._sections.push(g) - 1;
      yield new Section(n, u, this, y);
    }
  }
  _update(o, n) {
    this._modified = !0, this._sections[o] = n;
  }
};
class Section {
  constructor(n, c, u, h) {
    this._it = u, this._index = h, this.type = SECTIONS[n], this._type = n, this._section = c;
    const g = new Pipe(c);
    this.type !== "custom" && (this.count = Number(leb128.read(g))), this._body = g.buffer;
  }
  toJSON() {
    return wasm2json.sectionParsers[this.type](new Pipe(this._section));
  }
  appendEntries(n) {
    this.count += n.length, this._body = Buffer$1.concat([this._body].concat(n));
    const c = Buffer$1.concat([leb128.encode(this.count), this._body]);
    this._it._update(this._index, Buffer$1.concat([Buffer$1.from([this._type]), leb128.encode(c.length), c]));
  }
}
redstoneWasmJsonToolkit.wasm2json = wasm2json$1.exports, redstoneWasmJsonToolkit.json2wasm = json2wasm.exports, redstoneWasmJsonToolkit.text2json = text2json, redstoneWasmJsonToolkit.Iterator = iterator;
const start = 0, type = { params: { DEFAULT: 0 }, return_type: { DEFAULT: 0 } }, code = { locals: { DEFAULT: 1 }, code: { get_local: 120, set_local: 120, tee_local: 120, get_global: 120, set_global: 120, load8_s: 120, load8_u: 120, load16_s: 120, load16_u: 120, load32_s: 120, load32_u: 120, load: 120, store8: 120, store16: 120, store32: 120, store: 120, grow_memory: 1e4, current_memory: 100, nop: 1, block: 1, loop: 1, if: 1, then: 90, else: 90, br: 90, br_if: 90, br_table: 120, return: 90, call: 90, call_indirect: 1e4, const: 1, add: 45, sub: 45, mul: 45, div_s: 36e3, div_u: 36e3, rem_s: 36e3, rem_u: 36e3, and: 45, or: 45, xor: 45, shl: 67, shr_u: 67, shr_s: 67, rotl: 90, rotr: 90, eq: 45, eqz: 45, ne: 45, lt_s: 45, lt_u: 45, le_s: 45, le_u: 45, gt_s: 45, gt_u: 45, ge_s: 45, ge_u: 45, clz: 45, ctz: 45, popcnt: 45, drop: 120, select: 120, unreachable: 1 } }, data = 0, require$$2 = { start, type, import: 0, code, data };
(function(o) {
  const n = redstoneWasmJsonToolkit, c = n.text2json, u = json2wasm.exports.SECTION_IDS, h = require$$2;
  function g($, I = {}, P = 0) {
    let L = 0;
    if (P = I.DEFAULT !== void 0 ? I.DEFAULT : 0, Array.isArray($))
      $.forEach((q) => {
        L += g(q, I);
      });
    else if (typeof $ == "object")
      for (const q in $) {
        const N = I[q];
        N && (L += g($[q], N, P));
      }
    else
      L = I[$] === void 0 ? P : I[$];
    return L;
  }
  function y($, I, P, L, q) {
    function N(St, Ct) {
      return c(`${L}.const ${St} call ${Ct}`);
    }
    function X(St, Ct) {
      St.name === "call" && St.immediates >= Ct && (St.immediates = (++St.immediates).toString());
    }
    const rt = /* @__PURE__ */ new Set(["grow_memory", "end", "br", "br_table", "br_if", "if", "else", "return", "loop"]), nt = N(0, 0).reduce((St, Ct) => St + g(Ct.name, I.code), 0);
    let st = $.code.slice(), ot = [];
    for (q += g($.locals, I.local); st.length; ) {
      let St = 0;
      for (; ; ) {
        const Ct = st[St++];
        if (X(Ct, P), q += g(Ct.name, I.code), rt.has(Ct.name))
          break;
      }
      q !== 0 && (q += nt, ot = ot.concat(N(q, P))), ot = ot.concat(st.slice(0, St)), st = st.slice(St), q = 0;
    }
    return $.code = ot, $;
  }
  o.meterJSON = ($, I) => {
    function P(et, at) {
      return et.find((_t) => _t.name === at);
    }
    function L(et, at) {
      const _t = u[at];
      for (let Nt in et) {
        const m = et[Nt], A = u[m.name];
        if (A && _t < A)
          return void et.splice(Nt, 0, { name: at, entries: [] });
      }
    }
    let q, N, X = 0, { costTable: rt, moduleStr: nt, fieldStr: st, meterType: ot } = I;
    rt || (rt = h), nt || (nt = "metering"), st || (st = "usegas"), ot || (ot = "i32"), P($, "type") || L($, "type"), P($, "import") || L($, "import");
    const St = { moduleStr: nt, fieldStr: st, kind: "function" }, Ct = { form: "func", params: [ot] };
    $ = $.slice(0);
    for (let et of $)
      switch (et = Object.assign(et), et.name) {
        case "type":
          St.type = et.entries.push(Ct) - 1, N = et;
          break;
        case "function":
          q = et;
          break;
        case "import":
          for (const at of et.entries) {
            if (at.moduleStr === nt && at.fieldStr === st)
              throw new Error("importing metering function is not allowed");
            at.kind === "function" && X++;
          }
          et.entries.push(St);
          break;
        case "export":
          for (const at of et.entries)
            at.kind === "function" && at.index >= X && at.index++;
          break;
        case "element":
          for (const at of et.entries)
            at.elements = at.elements.map((_t) => _t >= X ? ++_t : _t);
          break;
        case "start":
          et.index >= X && et.index++;
          break;
        case "code":
          for (const at in et.entries) {
            const _t = et.entries[at], Nt = q.entries[at], m = g(N.entries[Nt], rt.type);
            y(_t, rt.code, X, ot, m);
          }
      }
    return $;
  }, o.meterWASM = ($, I = {}) => {
    let P = n.wasm2json($);
    return P = o.meterJSON(P, I), n.json2wasm(P);
  };
})(redstoneWasmMetering);
var wasmBindgenTools = {};
function matchMutClosureDtor(o) {
  return o.match(/(const|var) ret = makeMutClosure\(arg0, arg1, (\d+?), __wbg_adapter/)[2];
}
Object.defineProperty(wasmBindgenTools, "__esModule", { value: !0 }), wasmBindgenTools.matchMutClosureDtor = void 0, wasmBindgenTools.matchMutClosureDtor = matchMutClosureDtor;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(SourceImpl$1, "__esModule", { value: !0 }), SourceImpl$1.SourceImpl = void 0;
const redstone_wasm_metering_1 = __importDefault$2(redstoneWasmMetering), go_wasm_imports_1 = goWasmImports, fs_1 = __importDefault$2(require$$2$1), wasm_bindgen_tools_1 = wasmBindgenTools, SmartWeaveTags_1$1 = SmartWeaveTags, LoggerFactory_1$3 = LoggerFactory$1, redstone_isomorphic_1$1 = npmBrowser$1, wasmTypeMapping = /* @__PURE__ */ new Map([[1, "assemblyscript"], [2, "rust"], [3, "go"]]);
class SourceImpl {
  constructor(n) {
    this.arweave = n, this.logger = LoggerFactory_1$3.LoggerFactory.INST.create("Source");
  }
  async save(n, c, u = !1) {
    this.logger.debug("Creating new contract source");
    const { src: h, wasmSrcCodeDir: g, wasmGlueCode: y } = n, $ = h instanceof redstone_isomorphic_1$1.Buffer ? "wasm" : "js";
    let I, P = null, L = null;
    const q = {}, N = [];
    if ($ == "wasm") {
      const st = redstone_wasm_metering_1.default.meterWASM(h, { meterType: "i32" });
      N.push(st);
      const ot = await WebAssembly.compile(h), St = WebAssembly.Module.imports(ot);
      let Ct;
      if (this.isGoModule(St)) {
        const at = new go_wasm_imports_1.Go(null), _t = new WebAssembly.Instance(ot, at.importObject);
        at.run(_t), Ct = at.exports.lang(), L = at.exports.version();
      } else {
        const at = await WebAssembly.instantiate(h, dummyImports(St));
        if (!at.instance.exports.lang)
          throw new Error('No info about source type in wasm binary. Did you forget to export "lang" function?');
        if (Ct = at.instance.exports.lang(), L = at.instance.exports.version(), !wasmTypeMapping.has(Ct))
          throw new Error(`Unknown wasm source type ${Ct}`);
      }
      if (P = wasmTypeMapping.get(Ct), g == null)
        throw new Error("No path to original wasm contract source code");
      const et = await this.zipContents(g);
      if (N.push(et), P == "rust") {
        if (!y)
          throw new Error("No path to generated wasm-bindgen js code");
        const at = fs_1.default.readFileSync(y, "utf-8"), _t = (0, wasm_bindgen_tools_1.matchMutClosureDtor)(at);
        q.dtor = parseInt(_t), N.push(redstone_isomorphic_1$1.Buffer.from(at));
      }
    }
    const X = $ == "wasm" ? this.joinBuffers(N) : h;
    I = typeof c == "function" ? await this.arweave.createTransaction({ data: X }) : await this.arweave.createTransaction({ data: X }, c), I.addTag(SmartWeaveTags_1$1.SmartWeaveTags.APP_NAME, "SmartWeaveContractSource"), I.addTag(SmartWeaveTags_1$1.SmartWeaveTags.APP_VERSION, "0.3.0"), I.addTag(SmartWeaveTags_1$1.SmartWeaveTags.SDK, "Warp"), I.addTag(SmartWeaveTags_1$1.SmartWeaveTags.CONTENT_TYPE, $ == "js" ? "application/javascript" : "application/wasm"), $ == "wasm" && (I.addTag(SmartWeaveTags_1$1.SmartWeaveTags.WASM_LANG, P), I.addTag(SmartWeaveTags_1$1.SmartWeaveTags.WASM_LANG_VERSION, L), I.addTag(SmartWeaveTags_1$1.SmartWeaveTags.WASM_META, JSON.stringify(q))), typeof c == "function" ? await c(I) : await this.arweave.transactions.sign(I, c), this.logger.debug("Posting transaction with source");
    let rt, nt = !0;
    if (u || (rt = await this.arweave.transactions.post(I), nt = rt.status === 200 || rt.status === 208), nt)
      return I;
    throw new Error(`Unable to write Contract Source. Arweave responded with status ${rt.status}: ${rt.statusText}`);
  }
  isGoModule(n) {
    return n.some((c) => c.module == "env" && c.name.startsWith("syscall/js"));
  }
  joinBuffers(n) {
    const c = n.length, u = [];
    return u.push(redstone_isomorphic_1$1.Buffer.from(c.toString())), u.push(redstone_isomorphic_1$1.Buffer.from("|")), n.forEach((h) => {
      u.push(redstone_isomorphic_1$1.Buffer.from(h.length.toString())), u.push(redstone_isomorphic_1$1.Buffer.from("|"));
    }), u.push(...n), u.reduce((h, g) => redstone_isomorphic_1$1.Buffer.concat([h, g]));
  }
  async zipContents(n) {
    const c = require$$2$1, u = new require$$2$1.WritableStreamBuffer({ initialSize: 1024e3, incrementAmount: 1024e3 }), h = c("zip", { zlib: { level: 9 } });
    return h.on("error", function(g) {
      throw g;
    }), h.pipe(u), h.directory(n.toString(), n.toString()), await h.finalize(), u.end(), u.getContents();
  }
}
function dummyImports(o) {
  const n = {};
  return o.forEach((c) => {
    Object.prototype.hasOwnProperty.call(n, c.module) || (n[c.module] = {}), n[c.module][c.name] = function() {
    };
  }), n;
}
var hasRequiredDefaultCreateContract;
function requireDefaultCreateContract() {
  if (hasRequiredDefaultCreateContract)
    return DefaultCreateContract;
  hasRequiredDefaultCreateContract = 1, Object.defineProperty(DefaultCreateContract, "__esModule", { value: !0 }), DefaultCreateContract.DefaultCreateContract = void 0;
  const o = SmartWeaveTags, n = requireWarpFactory(), c = LoggerFactory$1, u = SourceImpl$1;
  return DefaultCreateContract.DefaultCreateContract = class {
    constructor(h, g) {
      this.arweave = h, this.warp = g, this.logger = c.LoggerFactory.INST.create("DefaultCreateContract"), this.deployFromSourceTx = this.deployFromSourceTx.bind(this);
    }
    async deploy(h, g) {
      const { wallet: y, initState: $, tags: I, transfer: P, data: L } = h, q = g == null ? this.warp.definitionLoader.type() == "warp" : !g, N = new u.SourceImpl(this.arweave), X = await N.save(h, y, q);
      return this.logger.debug("Creating new contract"), await this.deployFromSourceTx({ srcTxId: X.id, wallet: y, initState: $, tags: I, transfer: P, data: L }, !q, X);
    }
    async deployFromSourceTx(h, g, y = null) {
      this.logger.debug("Creating new contract from src tx");
      const { wallet: $, srcTxId: I, initState: P, tags: L, transfer: q, data: N } = h, X = g == null ? this.warp.definitionLoader.type() == "warp" : !g;
      let rt, nt, st = await this.arweave.createTransaction({ data: (N == null ? void 0 : N.body) || P }, $);
      if (+(q == null ? void 0 : q.winstonQty) > 0 && q.target.length && (this.logger.debug("Creating additional transaction with AR transfer", q), st = await this.arweave.createTransaction({ data: (N == null ? void 0 : N.body) || P, target: q.target, quantity: q.winstonQty }, $)), L == null ? void 0 : L.length)
        for (const ot of L)
          st.addTag(ot.name.toString(), ot.value.toString());
      if (st.addTag(o.SmartWeaveTags.APP_NAME, "SmartWeaveContract"), st.addTag(o.SmartWeaveTags.APP_VERSION, "0.3.0"), st.addTag(o.SmartWeaveTags.CONTRACT_SRC_TX_ID, I), st.addTag(o.SmartWeaveTags.SDK, "RedStone"), N ? (st.addTag(o.SmartWeaveTags.CONTENT_TYPE, N["Content-Type"]), st.addTag(o.SmartWeaveTags.INIT_STATE, P)) : st.addTag(o.SmartWeaveTags.CONTENT_TYPE, "application/json"), await this.arweave.transactions.sign(st, $), X) {
        const ot = await this.post(st, y);
        this.logger.debug(ot), rt = !0;
      } else
        nt = await this.arweave.transactions.post(st), rt = nt.status === 200 || nt.status === 208;
      if (rt)
        return { contractTxId: st.id, srcTxId: I };
      throw new Error(`Unable to write Contract. Arweave responded with status ${nt.status}: ${nt.statusText}`);
    }
    async post(h, g = null) {
      let y = { contractTx: h };
      g && (y = { ...y, srcTx: g });
      const $ = await fetch(`${n.WARP_GW_URL}/gateway/contracts/deploy`, { method: "POST", body: JSON.stringify(y), headers: { "Accept-Encoding": "gzip, deflate, br", "Content-Type": "application/json", Accept: "application/json" } });
      if ($.ok)
        return $.json();
      throw new Error(`Error while posting contract. Sequencer responded with status ${$.status} ${$.statusText}`);
    }
  }, DefaultCreateContract;
}
SourceImpl$1.SourceImpl = SourceImpl;
var HandlerBasedContract = {}, ContractCallRecord$1 = {};
Object.defineProperty(ContractCallRecord$1, "__esModule", { value: !0 }), ContractCallRecord$1.InteractionOutput = ContractCallRecord$1.InteractionInput = ContractCallRecord$1.InteractionCall = ContractCallRecord$1.ContractCallRecord = void 0;
const utils_1$1 = utils$n;
class ContractCallRecord {
  constructor(n, c, u = null) {
    this.contractTxId = n, this.depth = c, this.innerCallType = u, this.interactions = {}, this.id = (0, utils_1$1.isomorphicRandomUUID)();
  }
  addInteractionData(n) {
    const { interaction: c, interactionTx: u } = n, h = InteractionCall.create(new InteractionInput(u.id, u.sortKey, u.block.height, u.block.timestamp, c == null ? void 0 : c.caller, c == null ? void 0 : c.input.function, c == null ? void 0 : c.input, u.dry, {}));
    return this.interactions[u.id] = h, h;
  }
  getInteraction(n) {
    return this.interactions[n];
  }
  print() {
    return JSON.stringify(this, null, 2);
  }
}
ContractCallRecord$1.ContractCallRecord = ContractCallRecord;
class InteractionCall {
  constructor(n) {
    this.interactionInput = n;
  }
  static create(n) {
    return new InteractionCall(n);
  }
  update(n) {
    this.interactionOutput = n;
  }
}
ContractCallRecord$1.InteractionCall = InteractionCall;
class InteractionInput {
  constructor(n, c, u, h, g, y, $, I, P = {}) {
    this.txId = n, this.sortKey = c, this.blockHeight = u, this.blockTimestamp = h, this.caller = g, this.functionName = y, this.functionArguments = $, this.dryWrite = I, this.foreignContractCalls = P;
  }
}
ContractCallRecord$1.InteractionInput = InteractionInput;
class InteractionOutput {
  constructor(n, c, u, h, g = "", y) {
    this.cacheHit = n, this.outputState = c, this.executionTime = u, this.valid = h, this.errorMessage = g, this.gasUsed = y;
  }
}
ContractCallRecord$1.InteractionOutput = InteractionOutput;
var createInteractionTx$1 = {};
Object.defineProperty(createInteractionTx$1, "__esModule", { value: !0 }), createInteractionTx$1.unpackTags = createInteractionTx$1.createDummyTx = createInteractionTx$1.createInteractionTx = void 0;
const SmartWeaveTags_1 = SmartWeaveTags;
async function createInteractionTx(o, n, c, u, h, g = "", y = "0", $ = !1, I) {
  const P = { data: Math.random().toString().slice(-4) };
  g && g.length && (P.target = g.toString(), y && +y > 0 && (P.quantity = y.toString())), $ && (P.reward = "72600854", P.last_tx = "p7vc1iSP6bvH_fCeUFa9LqoV5qiyW-jdEKouAT0XMoSwrNraB9mgpi29Q10waEpO"), I && I.length && (P.reward = I);
  const L = await o.createTransaction(P);
  if (!u)
    throw new Error(`Input should be a truthy value: ${JSON.stringify(u)}`);
  if (h && h.length)
    for (const q of h)
      L.addTag(q.name.toString(), q.value.toString());
  return L.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_NAME, "SmartWeaveAction"), L.addTag(SmartWeaveTags_1.SmartWeaveTags.APP_VERSION, "0.3.0"), L.addTag(SmartWeaveTags_1.SmartWeaveTags.SDK, "Warp"), L.addTag(SmartWeaveTags_1.SmartWeaveTags.CONTRACT_TX_ID, c), L.addTag(SmartWeaveTags_1.SmartWeaveTags.INPUT, JSON.stringify(u)), n && await n(L), L;
}
function createDummyTx(o, n, c) {
  const u = unpackTags(o);
  return { id: o.id, owner: { address: n, key: "" }, recipient: o.target, tags: u, fee: { winston: o.reward, ar: "" }, quantity: { winston: o.quantity, ar: "" }, block: { id: c.indep_hash, height: c.height, timestamp: c.timestamp, previous: null }, dry: !0, anchor: null, signature: null, data: null, parent: null, bundledIn: null };
}
function unpackTags(o) {
  const n = o.get("tags"), c = [];
  for (const u of n)
    try {
      const h = u.get("name", { decode: !0, string: !0 }), g = u.get("value", { decode: !0, string: !0 });
      c.push({ name: h, value: g });
    } catch {
    }
  return c;
}
createInteractionTx$1.createInteractionTx = createInteractionTx, createInteractionTx$1.createDummyTx = createDummyTx, createInteractionTx$1.unpackTags = unpackTags;
var CreateContract = {};
Object.defineProperty(CreateContract, "__esModule", { value: !0 }), CreateContract.emptyTransfer = void 0, CreateContract.emptyTransfer = { target: "", winstonQty: "0" };
var InnerWritesEvaluator$1 = {};
Object.defineProperty(InnerWritesEvaluator$1, "__esModule", { value: !0 }), InnerWritesEvaluator$1.InnerWritesEvaluator = void 0;
class InnerWritesEvaluator {
  eval(n) {
    const c = [];
    return Object.keys(n.interactions).forEach((u) => {
      const h = n.interactions[u];
      this.evalForeignCalls(n.contractTxId, h, c);
    }), c;
  }
  evalForeignCalls(n, c, u) {
    Object.keys(c.interactionInput.foreignContractCalls).forEach((h) => {
      const g = c.interactionInput.foreignContractCalls[h];
      Object.keys(g.interactions).forEach((y) => {
        const $ = g.interactions[y];
        $.interactionInput.dryWrite && !u.includes(g.contractTxId) && n !== g.contractTxId && u.push(g.contractTxId), this.evalForeignCalls(n, $, u);
      });
    });
  }
}
InnerWritesEvaluator$1.InnerWritesEvaluator = InnerWritesEvaluator;
var vrf = {}, __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(vrf, "__esModule", { value: !0 }), vrf.generateMockVrf = void 0;
const elliptic_1 = __importDefault$1(elliptic$1), vrf_js_1 = vrfJs, utils_1 = utils$n, EC = new elliptic_1.default.ec("secp256k1"), key = EC.genKeyPair(), pubKeyS = key.getPublic(!0, "hex");
function generateMockVrf(o, n) {
  const c = n.utils.stringToBuffer(o), [u, h] = (0, vrf_js_1.Evaluate)(key.getPrivate().toArray(), c);
  return { index: n.utils.bufferTob64Url(u), proof: n.utils.bufferTob64Url(h), bigint: (0, utils_1.bufToBn)(u).toString(), pubkey: pubKeyS };
}
var hasRequiredHandlerBasedContract;
function requireHandlerBasedContract() {
  if (hasRequiredHandlerBasedContract)
    return HandlerBasedContract;
  hasRequiredHandlerBasedContract = 1;
  var o = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(et, at, _t, Nt) {
    Nt === void 0 && (Nt = _t);
    var m = Object.getOwnPropertyDescriptor(at, _t);
    m && !("get" in m ? !at.__esModule : m.writable || m.configurable) || (m = { enumerable: !0, get: function() {
      return at[_t];
    } }), Object.defineProperty(et, Nt, m);
  } : function(et, at, _t, Nt) {
    Nt === void 0 && (Nt = _t), et[Nt] = at[_t];
  }), n = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(et, at) {
    Object.defineProperty(et, "default", { enumerable: !0, value: at });
  } : function(et, at) {
    et.default = at;
  }), c = commonjsGlobal && commonjsGlobal.__importStar || function(et) {
    if (et && et.__esModule)
      return et;
    var at = {};
    if (et != null)
      for (var _t in et)
        _t !== "default" && Object.prototype.hasOwnProperty.call(et, _t) && o(at, et, _t);
    return n(at, et), at;
  }, u = commonjsGlobal && commonjsGlobal.__importDefault || function(et) {
    return et && et.__esModule ? et : { default: et };
  };
  Object.defineProperty(HandlerBasedContract, "__esModule", { value: !0 }), HandlerBasedContract.HandlerBasedContract = void 0;
  const h = u(safeStableStringify.exports), g = c(require$$2$1), y = ContractCallRecord$1, $ = LexicographicalInteractionsSorter, I = StateEvaluator, P = SmartWeaveTags, L = createInteractionTx$1, q = Benchmark$1, N = LoggerFactory$1, X = Evolve$1, rt = requireArweaveWrapper(), nt = utils$n, st = CreateContract, ot = SourceImpl$1, St = InnerWritesEvaluator$1, Ct = vrf;
  return HandlerBasedContract.HandlerBasedContract = class {
    constructor(et, at, _t = null, Nt = null) {
      var m, A;
      if (this._contractTxId = et, this.warp = at, this._parentContract = _t, this._innerCallData = Nt, this.logger = N.LoggerFactory.INST.create("HandlerBasedContract"), this._evaluationOptions = new I.DefaultEvaluationOptions(), this._innerWritesEvaluator = new St.InnerWritesEvaluator(), this._benchmarkStats = null, this.waitForConfirmation = this.waitForConfirmation.bind(this), this._arweaveWrapper = new rt.ArweaveWrapper(at.arweave), this._sorter = new $.LexicographicalInteractionsSorter(at.arweave), _t != null) {
        this._evaluationOptions = _t.evaluationOptions(), this._callDepth = _t.callDepth() + 1;
        const E = _t.getCallStack().getInteraction(Nt.callingInteraction.id);
        if (this._callDepth > this._evaluationOptions.maxCallDepth)
          throw Error(`Max call depth of ${this._evaluationOptions.maxCallDepth} has been exceeded for interaction ${JSON.stringify(E.interactionInput)}`);
        if (this.logger.debug("Calling interaction", { id: Nt.callingInteraction.id, sortKey: Nt.callingInteraction.sortKey, type: Nt.callType }), ((A = (m = E.interactionInput) === null || m === void 0 ? void 0 : m.foreignContractCalls[et]) === null || A === void 0 ? void 0 : A.innerCallType) === "write" && Nt.callType === "read")
          throw new Error("Calling a readContractState after performing an inner write is wrong - instead use a state from the result of an internal write.");
        const w = new y.ContractCallRecord(et, this._callDepth, Nt == null ? void 0 : Nt.callType);
        E.interactionInput.foreignContractCalls[et] = w, this._callStack = w, this._rootSortKey = _t.rootSortKey;
      } else
        this._callDepth = 0, this._callStack = new y.ContractCallRecord(et, 0), this._rootSortKey = null;
      this.getCallStack = this.getCallStack.bind(this);
    }
    async readState(et, at, _t) {
      var Nt, m, A;
      this.logger.info("Read state for", { contractTxId: this._contractTxId, currentTx: at, sortKeyOrBlockHeight: et });
      const E = q.Benchmark.measure();
      if (this.maybeResetRootContract(), this._parentContract != null && et == null)
        throw new Error("SortKey MUST be always set for non-root contract calls");
      const { stateEvaluator: w } = this.warp, v = typeof et == "number" ? this._sorter.generateLastSortKey(et) : et, k = await this.createExecutionContext(this._contractTxId, v, !1, _t);
      this.logger.info("Execution Context", { srcTxId: (Nt = k.contractDefinition) === null || Nt === void 0 ? void 0 : Nt.srcTxId, missingInteractions: (m = k.sortedInteractions) === null || m === void 0 ? void 0 : m.length, cachedSortKey: (A = k.cachedState) === null || A === void 0 ? void 0 : A.sortKey }), E.stop();
      const O = q.Benchmark.measure(), W = await w.eval(k, at || []);
      O.stop();
      const it = E.elapsed(!0) + O.elapsed(!0);
      return this._benchmarkStats = { gatewayCommunication: E.elapsed(!0), stateEvaluation: O.elapsed(!0), total: it }, this.logger.info("Benchmark", { "Gateway communication  ": E.elapsed(), "Contract evaluation    ": O.elapsed(), "Total:                 ": `${it.toFixed(0)}ms` }), W;
    }
    async viewState(et, at = [], _t = st.emptyTransfer) {
      return this.logger.info("View state for", this._contractTxId), await this.callContract(et, void 0, void 0, at, _t);
    }
    async viewStateForTx(et, at) {
      return this.logger.info(`View state for ${this._contractTxId}`, at), await this.callContractForTx(et, at);
    }
    async dryWrite(et, at, _t, Nt) {
      return this.logger.info("Dry-write for", this._contractTxId), await this.callContract(et, at, void 0, _t, Nt);
    }
    async dryWriteFromTx(et, at, _t) {
      return this.logger.info(`Dry-write from transaction ${at.id} for ${this._contractTxId}`), await this.callContractForTx(et, at, _t || []);
    }
    async writeInteraction(et, at) {
      if (this.logger.info("Write interaction", { input: et, options: at }), !this.signer)
        throw new Error("Wallet not connected. Use 'connect' method first.");
      const { arweave: _t, interactionsLoader: Nt, environment: m } = this.warp, A = (at == null ? void 0 : at.tags) || [], E = (at == null ? void 0 : at.transfer) || st.emptyTransfer, w = (at == null ? void 0 : at.strict) === !0, v = (at == null ? void 0 : at.vrf) === !0, k = (at == null ? void 0 : at.disableBundling) === !0, O = at == null ? void 0 : at.reward, W = Nt.type() == "warp" && !k;
      if (W && E.target != st.emptyTransfer.target && E.winstonQty != st.emptyTransfer.winstonQty)
        throw new Error("Ar Transfers are not allowed for bundled interactions");
      if (v && !W && m === "mainnet")
        throw new Error("Vrf generation is only available for bundle interaction");
      if (W)
        return await this.bundleInteraction(et, { tags: A, strict: w, vrf: v });
      {
        const it = await this.createInteraction(et, A, E, w, !1, v && m !== "mainnet", O), vt = await _t.transactions.post(it);
        if (vt.status !== 200)
          return this.logger.error("Error while posting transaction", vt), null;
        if (this._evaluationOptions.waitForConfirmation) {
          this.logger.info("Waiting for confirmation of", it.id);
          const xt = q.Benchmark.measure();
          await this.waitForConfirmation(it.id), this.logger.info("Transaction confirmed after", xt.elapsed());
        }
        return this.warp.environment == "local" && this._evaluationOptions.mineArLocalBlocks && await this.warp.testing.mineBlock(), { originalTxId: it.id };
      }
    }
    async bundleInteraction(et, at) {
      this.logger.info("Bundle interaction input", et);
      const _t = await this.createInteraction(et, at.tags, st.emptyTransfer, at.strict, !0, at.vrf);
      return { bundlrResponse: await fetch(`${this._evaluationOptions.bundlerUrl}gateway/sequencer/register`, { method: "POST", body: JSON.stringify(_t), headers: { "Accept-Encoding": "gzip, deflate, br", "Content-Type": "application/json", Accept: "application/json" } }).then((m) => (this.logger.debug(m), m.ok ? m.json() : Promise.reject(m))).catch((m) => {
        var A;
        throw this.logger.error(m), !((A = m.body) === null || A === void 0) && A.message && this.logger.error(m.body.message), new Error(`Unable to bundle interaction: ${JSON.stringify(m)}`);
      }), originalTxId: _t.id };
    }
    async createInteraction(et, at, _t, Nt, m = !1, A = !1, E) {
      if (this._evaluationOptions.internalWrites) {
        const w = await this.callContract(et, void 0, void 0, at, _t, Nt, A);
        if (Nt && w.type !== "ok")
          throw Error(`Cannot create interaction: ${w.errorMessage}`);
        const v = this.getCallStack(), k = this._innerWritesEvaluator.eval(v);
        this.logger.debug("Input", et), this.logger.debug("Callstack", v.print()), k.forEach((O) => {
          at.push({ name: P.SmartWeaveTags.INTERACT_WRITE, value: O });
        }), this.logger.debug("Tags with inner calls", at);
      } else if (Nt) {
        const w = await this.callContract(et, void 0, void 0, at, _t, Nt, A);
        if (w.type !== "ok")
          throw Error(`Cannot create interaction: ${w.errorMessage}`);
      }
      return A && at.push({ name: P.SmartWeaveTags.REQUEST_VRF, value: "true" }), await (0, L.createInteractionTx)(this.warp.arweave, this.signer, this._contractTxId, et, at, _t.target, _t.winstonQty, m, E);
    }
    txId() {
      return this._contractTxId;
    }
    getCallStack() {
      return this._callStack;
    }
    connect(et) {
      return this.signer = typeof et == "function" ? et : async (at) => {
        await this.warp.arweave.transactions.sign(at, et);
      }, this;
    }
    setEvaluationOptions(et) {
      return this._evaluationOptions = { ...this._evaluationOptions, ...et }, this;
    }
    async waitForConfirmation(et) {
      const { arweave: at } = this.warp, _t = await at.transactions.getStatus(et);
      if (_t.confirmed !== null)
        return this.logger.info(`Transaction ${et} confirmed`, _t), _t;
      this.logger.info(`Transaction ${et} not yet confirmed. Waiting another 20 seconds before next check.`), await (0, nt.sleep)(2e4), await this.waitForConfirmation(et);
    }
    async createExecutionContext(et, at, _t = !1, Nt) {
      var m;
      const { definitionLoader: A, interactionsLoader: E, executorFactory: w, stateEvaluator: v } = this.warp, k = q.Benchmark.measure(), O = await v.latestAvailableState(et, at);
      this.logger.debug("cache lookup", k.elapsed()), k.reset();
      const W = X.Evolve.evolvedSrcTxId((m = O == null ? void 0 : O.cachedValue) === null || m === void 0 ? void 0 : m.state);
      let it, vt, xt;
      return this.logger.debug("Cached state", O, at), O && O.sortKey == at ? (this.logger.debug("State fully cached, not loading interactions."), (_t || W) && (vt = await A.load(et, W), it = await w.create(vt, this._evaluationOptions))) : ([vt, xt] = await Promise.all([A.load(et, W), Nt ? Promise.resolve(Nt) : await E.load(et, O == null ? void 0 : O.sortKey, this.getToSortKey(at), this._evaluationOptions)]), O != null && O.sortKey && (xt = xt.filter((It) => It.sortKey.localeCompare(O == null ? void 0 : O.sortKey) > 0)), at && (xt = xt.filter((It) => It.sortKey.localeCompare(at) <= 0)), this.logger.debug("contract and interactions load", k.elapsed()), this._parentContract == null && xt.length && (this._rootSortKey = xt[xt.length - 1].sortKey), it = await w.create(vt, this._evaluationOptions)), { warp: this.warp, contract: this, contractDefinition: vt, sortedInteractions: xt, evaluationOptions: this._evaluationOptions, handler: it, cachedState: O, requestedSortKey: at };
    }
    getToSortKey(et) {
      var at;
      return !((at = this._parentContract) === null || at === void 0) && at.rootSortKey ? et ? this._parentContract.rootSortKey.localeCompare(et) > 0 ? this._parentContract.rootSortKey : et : this._parentContract.rootSortKey : et;
    }
    async createExecutionContextFromTx(et, at) {
      const _t = at.owner.address, Nt = at.sortKey;
      return { ...await this.createExecutionContext(et, Nt, !0), caller: _t };
    }
    maybeResetRootContract() {
      this._parentContract == null && (this.logger.debug("Clearing call stack for the root contract"), this._callStack = new y.ContractCallRecord(this.txId(), 0), this._rootSortKey = null, this.warp.interactionsLoader.clearCache());
    }
    async callContract(et, at, _t, Nt = [], m = st.emptyTransfer, A = !1, E = !1) {
      this.logger.info("Call contract input", et), this.maybeResetRootContract(), this.signer || this.logger.warn("Wallet not set.");
      const { arweave: w, stateEvaluator: v } = this.warp;
      let k = await this.createExecutionContext(this._contractTxId, _t, !0);
      const O = this.warp.environment == "mainnet" ? await this._arweaveWrapper.warpGwBlock() : await w.blocks.getCurrent();
      let W;
      if (at)
        W = at;
      else if (this.signer) {
        const Ut = await w.createTransaction({ data: Math.random().toString().slice(-4), reward: "72600854", last_tx: "p7vc1iSP6bvH_fCeUFa9LqoV5qiyW-jdEKouAT0XMoSwrNraB9mgpi29Q10waEpO" });
        await this.signer(Ut), W = await w.wallets.ownerToAddress(Ut.owner);
      } else
        W = "";
      this.logger.info("effectiveCaller", W), k = { ...k, caller: W };
      const it = await v.eval(k, []);
      this.logger.info("Current state", it.cachedValue.state);
      const vt = { input: et, caller: k.caller };
      this.logger.debug("interaction", vt);
      const xt = await (0, L.createInteractionTx)(w, this.signer, this._contractTxId, et, Nt, m.target, m.winstonQty, !0), It = (0, L.createDummyTx)(xt, k.caller, O);
      this.logger.debug("Creating sortKey for", { blockId: It.block.id, id: It.id, height: It.block.height }), It.sortKey = await this._sorter.createSortKey(It.block.id, It.id, It.block.height, !0), It.strict = A, E && (It.vrf = (0, Ct.generateMockVrf)(It.sortKey, w));
      const Wt = await this.evalInteraction({ interaction: vt, interactionTx: It, currentTx: [] }, k, it.cachedValue);
      return Wt.type !== "ok" && this.logger.fatal("Error while interacting with contract", { type: Wt.type, error: Wt.errorMessage }), Wt;
    }
    async callContractForTx(et, at, _t) {
      this.maybeResetRootContract();
      const Nt = await this.createExecutionContextFromTx(this._contractTxId, at), m = await this.warp.stateEvaluator.eval(Nt, _t);
      this.logger.debug("callContractForTx - evalStateResult", { result: m.cachedValue.state, txId: this._contractTxId });
      const A = { interaction: { input: et, caller: this._parentContract.txId() }, interactionTx: at, currentTx: _t }, E = await this.evalInteraction(A, Nt, m.cachedValue);
      return E.originalValidity = m.cachedValue.validity, E.originalErrorMessages = m.cachedValue.errorMessages, E;
    }
    async evalInteraction(et, at, _t) {
      const Nt = this.getCallStack().addInteractionData(et), m = q.Benchmark.measure(), A = await at.handler.handle(at, _t, et);
      return Nt.update({ cacheHit: !1, outputState: this._evaluationOptions.stackTrace.saveState ? A.state : void 0, executionTime: m.elapsed(!0), valid: A.type === "ok", errorMessage: A.errorMessage, gasUsed: A.gasUsed }), A;
    }
    parent() {
      return this._parentContract;
    }
    callDepth() {
      return this._callDepth;
    }
    evaluationOptions() {
      return this._evaluationOptions;
    }
    lastReadStateStats() {
      return this._benchmarkStats;
    }
    stateHash(et) {
      const at = (0, h.default)(et), _t = g.createHash("sha256");
      return _t.update(at), _t.digest("hex");
    }
    async syncState(et, at) {
      const { stateEvaluator: _t } = this.warp, Nt = await fetch(`${et}?${new URLSearchParams({ id: this._contractTxId, ...at })}`).then((m) => m.ok ? m.json() : Promise.reject(m)).catch((m) => {
        var A, E;
        throw !((A = m.body) === null || A === void 0) && A.message && this.logger.error(m.body.message), new Error(`Unable to retrieve state. ${m.status}: ${(E = m.body) === null || E === void 0 ? void 0 : E.message}`);
      });
      return await _t.syncState(this._contractTxId, Nt.sortKey, Nt.state, Nt.validity), this;
    }
    async evolve(et, at) {
      return await this.writeInteraction({ function: "evolve", value: et }, at);
    }
    async save(et) {
      if (!this.signer)
        throw new Error("Wallet not connected. Use 'connect' method first.");
      const { arweave: at } = this.warp;
      return (await new ot.SourceImpl(at).save(et, this.signer)).id;
    }
    get rootSortKey() {
      return this._rootSortKey;
    }
  }, HandlerBasedContract;
}
vrf.generateMockVrf = generateMockVrf;
var PstContractImpl = {}, hasRequiredPstContractImpl;
function requirePstContractImpl() {
  if (hasRequiredPstContractImpl)
    return PstContractImpl;
  hasRequiredPstContractImpl = 1, Object.defineProperty(PstContractImpl, "__esModule", { value: !0 }), PstContractImpl.PstContractImpl = void 0;
  const o = requireHandlerBasedContract();
  class n extends o.HandlerBasedContract {
    async currentBalance(u) {
      const h = await this.viewState({ function: "balance", target: u });
      if (h.type !== "ok")
        throw Error(h.errorMessage);
      return h.result;
    }
    async currentState() {
      return (await super.readState()).cachedValue.state;
    }
    async transfer(u, h) {
      return await this.writeInteraction({ function: "transfer", ...u }, h);
    }
  }
  return PstContractImpl.PstContractImpl = n, PstContractImpl;
}
var MigrationTool$1 = {}, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(o) {
  return o && o.__esModule ? o : { default: o };
};
Object.defineProperty(MigrationTool$1, "__esModule", { value: !0 }), MigrationTool$1.MigrationTool = void 0;
const LexicographicalInteractionsSorter_1 = LexicographicalInteractionsSorter, StateEvaluator_1 = StateEvaluator, knex_1 = __importDefault(require$$2$1), LoggerFactory_1$2 = LoggerFactory$1;
class MigrationTool {
  constructor(n, c) {
    this.arweave = n, this.levelDb = c, this.logger = LoggerFactory_1$2.LoggerFactory.INST.create("MigrationTool"), this.sorter = new LexicographicalInteractionsSorter_1.LexicographicalInteractionsSorter(n);
  }
  async migrateSqlite(n) {
    this.logger.info(`Migrating from sqlite ${n} to leveldb.`);
    const c = (0, knex_1.default)({ client: "sqlite3", connection: { filename: n }, useNullAsDefault: !0 }), u = await c.select(["contract_id", "height", "state"]).from("states").max("height").groupBy(["contract_id"]);
    this.logger.info(`Migrating ${u == null ? void 0 : u.length} contracts' state`);
    const h = [];
    for (const g of u) {
      const y = g.contract_id, $ = g.height, I = JSON.parse(g.state), P = this.sorter.generateLastSortKey(parseInt($));
      this.logger.debug(`Migrating ${y} at height ${$}: ${P}`), await this.levelDb.put({ contractTxId: y, sortKey: P }, new StateEvaluator_1.EvalStateResult(I.state, I.validity, {})), h.push({ contractTxId: y, height: $, sortKey: P });
    }
    return this.logger.info("Migration done."), h;
  }
}
MigrationTool$1.MigrationTool = MigrationTool;
var Testing$1 = {};
Object.defineProperty(Testing$1, "__esModule", { value: !0 }), Testing$1.Testing = void 0;
class Testing {
  constructor(n) {
    this.arweave = n;
  }
  async mineBlock() {
    this.validateEnv(), await this.arweave.api.get("mine");
  }
  async generateWallet() {
    this.validateEnv();
    const n = await this.arweave.wallets.generate();
    return await this.addFunds(n), { jwk: n, address: await this.arweave.wallets.jwkToAddress(n) };
  }
  async addFunds(n) {
    const c = await this.arweave.wallets.getAddress(n);
    await this.arweave.api.get(`/mint/${c}/1000000000000000`);
  }
  validateEnv() {
    if (this.arweave.api.getConfig().host.includes("arweave"))
      throw new Error("Testing features are not available in a non testing environment");
  }
}
Testing$1.Testing = Testing;
var WarpBuilder = {}, DebuggableExecutorFactor = {};
Object.defineProperty(DebuggableExecutorFactor, "__esModule", { value: !0 }), DebuggableExecutorFactor.DebuggableExecutorFactory = void 0;
class DebuggableExecutorFactory {
  constructor(n, c) {
    this.baseImplementation = n, this.sourceCode = c;
  }
  async create(n, c) {
    return Object.prototype.hasOwnProperty.call(this.sourceCode, n.txId) && (n = { ...n, src: this.sourceCode[n.txId] }), await this.baseImplementation.create(n, c);
  }
}
DebuggableExecutorFactor.DebuggableExecutorFactory = DebuggableExecutorFactory;
var ArweaveGatewayInteractionsLoader = {}, hasRequiredArweaveGatewayInteractionsLoader;
function requireArweaveGatewayInteractionsLoader() {
  if (hasRequiredArweaveGatewayInteractionsLoader)
    return ArweaveGatewayInteractionsLoader;
  hasRequiredArweaveGatewayInteractionsLoader = 1, Object.defineProperty(ArweaveGatewayInteractionsLoader, "__esModule", { value: !0 }), ArweaveGatewayInteractionsLoader.ArweaveGatewayInteractionsLoader = ArweaveGatewayInteractionsLoader.bundledTxsFilter = void 0;
  const o = SmartWeaveTags, n = Benchmark$1, c = LoggerFactory$1, u = requireArweaveWrapper(), h = utils$n, g = LexicographicalInteractionsSorter, y = vrf;
  function $(P) {
    var L, q;
    return !(!((L = P.node.parent) === null || L === void 0) && L.id) && !(!((q = P.node.bundledIn) === null || q === void 0) && q.id);
  }
  ArweaveGatewayInteractionsLoader.bundledTxsFilter = $;
  class I {
    constructor(L, q) {
      this.arweave = L, this.environment = q, this.logger = c.LoggerFactory.INST.create("ArweaveGatewayInteractionsLoader"), this.arweaveWrapper = new u.ArweaveWrapper(L), this.sorter = new g.LexicographicalInteractionsSorter(L);
    }
    async load(L, q, N, X) {
      this.logger.debug("Loading interactions for", { contractId: L, fromSortKey: q, toSortKey: N });
      const rt = this.sorter.extractBlockHeight(q), nt = this.sorter.extractBlockHeight(N), st = { tags: [{ name: o.SmartWeaveTags.APP_NAME, values: ["SmartWeaveAction"] }, { name: o.SmartWeaveTags.CONTRACT_TX_ID, values: [L] }], blockFilter: { min: rt, max: nt }, first: 100 }, ot = n.Benchmark.measure();
      let St = await this.loadPages(st);
      if (ot.stop(), X.internalWrites) {
        const at = { tags: [{ name: o.SmartWeaveTags.INTERACT_WRITE, values: [L] }], blockFilter: { min: rt, max: nt }, first: 100 }, _t = await this.loadPages(at);
        this.logger.debug("Inner writes interactions length:", _t.length), St = St.concat(_t);
      }
      St = St.filter((at) => at.node.block && at.node.block.id && at.node.block.height);
      let Ct = await this.sorter.sort(St);
      q && N ? Ct = Ct.filter((at) => at.node.sortKey.localeCompare(q) > 0 && at.node.sortKey.localeCompare(N) <= 0) : q && !N ? Ct = Ct.filter((at) => at.node.sortKey.localeCompare(q) > 0) : !q && N && (Ct = Ct.filter((at) => at.node.sortKey.localeCompare(N) <= 0)), this.logger.debug("All loaded interactions:", { from: q, to: N, loaded: Ct.length, time: ot.elapsed() });
      const et = this.environment === "local" || this.environment === "testnet";
      return Ct.map((at) => {
        const _t = at.node;
        return et && _t.tags.some((Nt) => Nt.name == o.SmartWeaveTags.REQUEST_VRF && Nt.value === "true") && (_t.vrf = (0, y.generateMockVrf)(_t.sortKey, this.arweave)), _t;
      });
    }
    async loadPages(L) {
      let q = await this.getNextPage(L);
      const N = q.edges.filter((X) => $(X));
      for (; q.pageInfo.hasNextPage; ) {
        const X = q.edges[99].cursor;
        L = { ...L, after: X }, q = await this.getNextPage(L), N.push(...q.edges.filter((rt) => $(rt)));
      }
      return N;
    }
    async getNextPage(L) {
      const q = n.Benchmark.measure();
      let N = await this.arweaveWrapper.gql(I.query, L);
      for (this.logger.debug("GQL page load:", q.elapsed()); N.status === 403; )
        this.logger.warn(`GQL rate limiting, waiting ${I._30seconds}ms before next try.`), await (0, h.sleep)(I._30seconds), N = await this.arweaveWrapper.gql(I.query, L);
      if (N.status !== 200)
        throw new Error(`Unable to retrieve transactions. Arweave gateway responded with status ${N.status}.`);
      if (N.data.errors)
        throw this.logger.error(N.data.errors), new Error("Error while loading interaction transactions");
      return N.data.data.transactions;
    }
    type() {
      return "arweave";
    }
    clearCache() {
    }
  }
  return ArweaveGatewayInteractionsLoader.ArweaveGatewayInteractionsLoader = I, I.query = `query Transactions($tags: [TagFilter!]!, $blockFilter: BlockFilter!, $first: Int!, $after: String) {
    transactions(tags: $tags, block: $blockFilter, first: $first, sort: HEIGHT_ASC, after: $after) {
      pageInfo {
        hasNextPage
      }
      edges {
        node {
          id
          owner { address }
          recipient
          tags {
            name
            value
          }
          block {
            height
            id
            timestamp
          }
          fee { winston }
          quantity { winston }
          parent { id }
          bundledIn { id }
        }
        cursor
      }
    }
  }`, I._30seconds = 3e4, ArweaveGatewayInteractionsLoader;
}
var CacheableInteractionsLoader$1 = {};
Object.defineProperty(CacheableInteractionsLoader$1, "__esModule", { value: !0 }), CacheableInteractionsLoader$1.CacheableInteractionsLoader = void 0;
const LoggerFactory_1$1 = LoggerFactory$1;
class CacheableInteractionsLoader {
  constructor(n) {
    this.delegate = n, this.logger = LoggerFactory_1$1.LoggerFactory.INST.create("CacheableInteractionsLoader"), this.interactionsCache = /* @__PURE__ */ new Map();
  }
  async load(n, c, u, h) {
    if (this.logger.debug("Loading interactions for", { contractTxId: n, fromSortKey: c, toSortKey: u }), this.interactionsCache.has(n)) {
      const g = this.interactionsCache.get(n);
      if (g != null && g.length) {
        const y = g[g.length - 1].sortKey;
        if (y.localeCompare(u) < 0) {
          const $ = await this.delegate.load(n, y, u, h), I = g.concat($);
          return this.interactionsCache.set(n, I), I;
        }
      }
      return g;
    }
    {
      const g = await this.delegate.load(n, c, u, h);
      return g.length && this.interactionsCache.set(n, g), g;
    }
  }
  type() {
    return this.delegate.type();
  }
  clearCache() {
    this.interactionsCache.clear();
  }
}
CacheableInteractionsLoader$1.CacheableInteractionsLoader = CacheableInteractionsLoader;
var WarpGatewayContractDefinitionLoader = {}, WasmSrc$1 = {};
function readBlobAsArrayBuffer(o) {
  return o.arrayBuffer ? o.arrayBuffer() : new Promise((n, c) => {
    const u = new FileReader();
    u.addEventListener("loadend", () => {
      n(u.result);
    }), u.addEventListener("error", c), u.readAsArrayBuffer(o);
  });
}
async function readBlobAsUint8Array(o) {
  const n = await readBlobAsArrayBuffer(o);
  return new Uint8Array(n);
}
function isBlob(o) {
  return typeof Blob < "u" && o instanceof Blob;
}
function isSharedArrayBuffer(o) {
  return typeof SharedArrayBuffer < "u" && o instanceof SharedArrayBuffer;
}
const isNode = typeof process < "u" && process.versions && process.versions.node !== void 0 && process.versions.electron === void 0;
function isTypedArraySameAsArrayBuffer(o) {
  return o.byteOffset === 0 && o.byteLength === o.buffer.byteLength;
}
class ArrayBufferReader {
  constructor(n) {
    this.typedArray = n instanceof ArrayBuffer || isSharedArrayBuffer(n) ? new Uint8Array(n) : new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
  }
  async getLength() {
    return this.typedArray.byteLength;
  }
  async read(n, c) {
    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + n, c);
  }
}
class BlobReader {
  constructor(n) {
    this.blob = n;
  }
  async getLength() {
    return this.blob.size;
  }
  async read(n, c) {
    const u = this.blob.slice(n, n + c), h = await readBlobAsArrayBuffer(u);
    return new Uint8Array(h);
  }
  async sliceAsBlob(n, c, u = "") {
    return this.blob.slice(n, n + c, u);
  }
}
class HTTPRangeReader {
  constructor(n) {
    this.url = n;
  }
  async getLength() {
    if (this.length === void 0) {
      const n = await fetch(this.url, { method: "HEAD" });
      if (!n.ok)
        throw new Error(`failed http request ${this.url}, status: ${n.status}: ${n.statusText}`);
      if (this.length = parseInt(n.headers.get("content-length")), Number.isNaN(this.length))
        throw Error("could not get length");
    }
    return this.length;
  }
  async read(n, c) {
    if (c === 0)
      return new Uint8Array(0);
    const u = await fetch(this.url, { headers: { Range: `bytes=${n}-${n + c - 1}` } });
    if (!u.ok)
      throw new Error(`failed http request ${this.url}, status: ${u.status} offset: ${n} size: ${c}: ${u.statusText}`);
    const h = await u.arrayBuffer();
    return new Uint8Array(h);
  }
}
function inflate(o, n) {
  var c = Uint8Array;
  if (o[0] == 3 && o[1] == 0)
    return n || new c(0);
  var u = _bitsF, h = _bitsE, g = _decodeTiny, y = _get17, $ = n == null;
  $ && (n = new c(o.length >>> 2 << 3));
  for (var I, P, L = 0, q = 0, N = 0, X = 0, rt = 0, nt = 0, st = 0, ot = 0, St = 0; L == 0; )
    if (L = u(o, St, 1), q = u(o, St + 1, 2), St += 3, q != 0) {
      if ($ && (n = _check(n, ot + (1 << 17))), q == 1 && (I = U.flmap, P = U.fdmap, nt = 511, st = 31), q == 2) {
        N = h(o, St, 5) + 257, X = h(o, St + 5, 5) + 1, rt = h(o, St + 10, 4) + 4, St += 14;
        for (var Ct = 0; Ct < 38; Ct += 2)
          U.itree[Ct] = 0, U.itree[Ct + 1] = 0;
        var et = 1;
        for (Ct = 0; Ct < rt; Ct++) {
          var at = h(o, St + 3 * Ct, 3);
          U.itree[1 + (U.ordr[Ct] << 1)] = at, at > et && (et = at);
        }
        St += 3 * rt, makeCodes(U.itree, et), codes2map(U.itree, et, U.imap), I = U.lmap, P = U.dmap, St = g(U.imap, (1 << et) - 1, N + X, o, St, U.ttree);
        var _t = _copyOut(U.ttree, 0, N, U.ltree);
        nt = (1 << _t) - 1;
        var Nt = _copyOut(U.ttree, N, X, U.dtree);
        st = (1 << Nt) - 1, makeCodes(U.ltree, _t), codes2map(U.ltree, _t, I), makeCodes(U.dtree, Nt), codes2map(U.dtree, Nt, P);
      }
      for (; ; ) {
        var m = I[y(o, St) & nt];
        St += 15 & m;
        var A = m >>> 4;
        if (A >>> 8 == 0)
          n[ot++] = A;
        else {
          if (A == 256)
            break;
          var E = ot + A - 254;
          if (A > 264) {
            var w = U.ldef[A - 257];
            E = ot + (w >>> 3) + h(o, St, 7 & w), St += 7 & w;
          }
          var v = P[y(o, St) & st];
          St += 15 & v;
          var k = v >>> 4, O = U.ddef[k], W = (O >>> 4) + u(o, St, 15 & O);
          for (St += 15 & O, $ && (n = _check(n, ot + (1 << 17))); ot < E; )
            n[ot] = n[ot++ - W], n[ot] = n[ot++ - W], n[ot] = n[ot++ - W], n[ot] = n[ot++ - W];
          ot = E;
        }
      }
    } else {
      (7 & St) != 0 && (St += 8 - (7 & St));
      var it = 4 + (St >>> 3), vt = o[it - 4] | o[it - 3] << 8;
      $ && (n = _check(n, ot + vt)), n.set(new c(o.buffer, o.byteOffset + it, vt), ot), St = it + vt << 3, ot += vt;
    }
  return n.length == ot ? n : n.slice(0, ot);
}
function _check(o, n) {
  var c = o.length;
  if (n <= c)
    return o;
  var u = new Uint8Array(Math.max(c << 1, n));
  return u.set(o, 0), u;
}
function _decodeTiny(o, n, c, u, h, g) {
  for (var y = _bitsE, $ = _get17, I = 0; I < c; ) {
    var P = o[$(u, h) & n];
    h += 15 & P;
    var L = P >>> 4;
    if (L <= 15)
      g[I] = L, I++;
    else {
      var q = 0, N = 0;
      L == 16 ? (N = 3 + y(u, h, 2), h += 2, q = g[I - 1]) : L == 17 ? (N = 3 + y(u, h, 3), h += 3) : L == 18 && (N = 11 + y(u, h, 7), h += 7);
      for (var X = I + N; I < X; )
        g[I] = q, I++;
    }
  }
  return h;
}
function _copyOut(o, n, c, u) {
  for (var h = 0, g = 0, y = u.length >>> 1; g < c; ) {
    var $ = o[g + n];
    u[g << 1] = 0, u[1 + (g << 1)] = $, $ > h && (h = $), g++;
  }
  for (; g < y; )
    u[g << 1] = 0, u[1 + (g << 1)] = 0, g++;
  return h;
}
function makeCodes(o, n) {
  for (var c, u, h, g, y = o.length, $ = U.bl_count, I = 0; I <= n; I++)
    $[I] = 0;
  for (I = 1; I < y; I += 2)
    $[o[I]]++;
  var P = U.next_code;
  for (c = 0, $[0] = 0, u = 1; u <= n; u++)
    c = c + $[u - 1] << 1, P[u] = c;
  for (h = 0; h < y; h += 2)
    (g = o[h + 1]) != 0 && (o[h] = P[g], P[g]++);
}
function codes2map(o, n, c) {
  for (var u = o.length, h = U.rev15, g = 0; g < u; g += 2)
    if (o[g + 1] != 0)
      for (var y = g >> 1, $ = o[g + 1], I = y << 4 | $, P = n - $, L = o[g] << P, q = L + (1 << P); L != q; )
        c[h[L] >>> 15 - n] = I, L++;
}
function revCodes(o, n) {
  for (var c = U.rev15, u = 15 - n, h = 0; h < o.length; h += 2) {
    var g = o[h] << n - o[h + 1];
    o[h] = c[g] >>> u;
  }
}
function _bitsE(o, n, c) {
  return (o[n >>> 3] | o[1 + (n >>> 3)] << 8) >>> (7 & n) & (1 << c) - 1;
}
function _bitsF(o, n, c) {
  return (o[n >>> 3] | o[1 + (n >>> 3)] << 8 | o[2 + (n >>> 3)] << 16) >>> (7 & n) & (1 << c) - 1;
}
function _get17(o, n) {
  return (o[n >>> 3] | o[1 + (n >>> 3)] << 8 | o[2 + (n >>> 3)] << 16) >>> (7 & n);
}
const U = (u16 = Uint16Array, u32 = Uint32Array, { next_code: new u16(16), bl_count: new u16(16), ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], ldef: new u16(32), df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], ddef: new u32(32), flmap: new u16(512), fltree: [], fdmap: new u16(32), fdtree: [], lmap: new u16(32768), ltree: [], ttree: [], dmap: new u16(32768), dtree: [], imap: new u16(512), itree: [], rev15: new u16(32768), lhst: new u32(286), dhst: new u32(30), ihst: new u32(19), lits: new u32(15e3), strt: new u16(65536), prev: new u16(32768) });
var u16, u32;
(function() {
  for (var o = 0; o < 32768; o++) {
    var n = o;
    n = (4278255360 & (n = (4042322160 & (n = (3435973836 & (n = (2863311530 & n) >>> 1 | (1431655765 & n) << 1)) >>> 2 | (858993459 & n) << 2)) >>> 4 | (252645135 & n) << 4)) >>> 8 | (16711935 & n) << 8, U.rev15[o] = (n >>> 16 | n << 16) >>> 17;
  }
  function c(u, h, g) {
    for (; h-- != 0; )
      u.push(0, g);
  }
  for (o = 0; o < 32; o++)
    U.ldef[o] = U.of0[o] << 3 | U.exb[o], U.ddef[o] = U.df0[o] << 4 | U.dxb[o];
  c(U.fltree, 144, 8), c(U.fltree, 112, 9), c(U.fltree, 24, 7), c(U.fltree, 8, 8), makeCodes(U.fltree, 9), codes2map(U.fltree, 9, U.flmap), revCodes(U.fltree, 9), c(U.fdtree, 32, 5), makeCodes(U.fdtree, 5), codes2map(U.fdtree, 5, U.fdmap), revCodes(U.fdtree, 5), c(U.itree, 19, 0), c(U.ltree, 286, 0), c(U.dtree, 30, 0), c(U.ttree, 320, 0);
})();
const crc = { table: function() {
  for (var o = new Uint32Array(256), n = 0; n < 256; n++) {
    for (var c = n, u = 0; u < 8; u++)
      1 & c ? c = 3988292384 ^ c >>> 1 : c >>>= 1;
    o[n] = c;
  }
  return o;
}(), update: function(o, n, c, u) {
  for (var h = 0; h < u; h++)
    o = crc.table[255 & (o ^ n[c + h])] ^ o >>> 8;
  return o;
}, crc: function(o, n, c) {
  return 4294967295 ^ crc.update(4294967295, o, n, c);
} };
function inflateRaw(o, n) {
  return inflate(o, n);
}
const config = { numWorkers: 1, workerURL: "", useWorkers: !1 };
let nextId = 0, numWorkers = 0, canUseWorkers = !0;
const workers = [], availableWorkers = [], waitingForWorkerQueue = [], currentlyProcessingIdToRequestMap = /* @__PURE__ */ new Map();
function handleResult(o) {
  makeWorkerAvailable(o.target);
  const { id: n, error: c, data: u } = o.data, h = currentlyProcessingIdToRequestMap.get(n);
  currentlyProcessingIdToRequestMap.delete(n), c ? h.reject(c) : h.resolve(u);
}
function startWorker(o) {
  return new Promise((n, c) => {
    const u = new Worker(o);
    u.onmessage = (h) => {
      h.data === "start" ? (u.onerror = void 0, u.onmessage = void 0, n(u)) : c(new Error(`unexpected message: ${h.data}`));
    }, u.onerror = c;
  });
}
function dynamicRequire(o, n) {
  return o.require(n);
}
const workerHelper = function() {
  if (isNode) {
    const { Worker: o } = dynamicRequire(module, "worker_threads");
    return { createWorker: async (n) => new o(n), addEventListener(n, c) {
      n.on("message", (u) => {
        c({ target: n, data: u });
      });
    }, async terminate(n) {
      await n.terminate();
    } };
  }
  return { async createWorker(o) {
    try {
      return await startWorker(o);
    } catch {
      console.warn("could not load worker:", o);
    }
    let n;
    try {
      const c = await fetch(o, { mode: "cors" });
      if (!c.ok)
        throw new Error(`could not load: ${o}`);
      n = await c.text(), o = URL.createObjectURL(new Blob([n], { type: "application/javascript" }));
      const u = await startWorker(o);
      return config.workerURL = o, u;
    } catch {
      console.warn("could not load worker via fetch:", o);
    }
    if (n !== void 0)
      try {
        o = `data:application/javascript;base64,${btoa(n)}`;
        const c = await startWorker(o);
        return config.workerURL = o, c;
      } catch {
        console.warn("could not load worker via dataURI");
      }
    throw console.warn("workers will not be used"), new Error("can not start workers");
  }, addEventListener(o, n) {
    o.addEventListener("message", n);
  }, async terminate(o) {
    o.terminate();
  } };
}();
function makeWorkerAvailable(o) {
  availableWorkers.push(o), processWaitingForWorkerQueue();
}
async function getAvailableWorker() {
  if (availableWorkers.length === 0 && numWorkers < config.numWorkers) {
    ++numWorkers;
    try {
      const o = await workerHelper.createWorker(config.workerURL);
      workers.push(o), availableWorkers.push(o), workerHelper.addEventListener(o, handleResult);
    } catch {
      canUseWorkers = !1;
    }
  }
  return availableWorkers.pop();
}
function inflateRawLocal(o, n, c, u) {
  const h = new Uint8Array(n);
  inflateRaw(o, h), u(c ? new Blob([h], { type: c }) : h.buffer);
}
async function processWaitingForWorkerQueue() {
  if (waitingForWorkerQueue.length !== 0) {
    if (config.useWorkers && canUseWorkers) {
      const o = await getAvailableWorker();
      if (canUseWorkers) {
        if (o) {
          if (waitingForWorkerQueue.length === 0)
            return void makeWorkerAvailable(o);
          const { id: n, src: c, uncompressedSize: u, type: h, resolve: g, reject: y } = waitingForWorkerQueue.shift();
          currentlyProcessingIdToRequestMap.set(n, { id: n, resolve: g, reject: y });
          const $ = [];
          o.postMessage({ type: "inflate", data: { id: n, type: h, src: c, uncompressedSize: u } }, $);
        }
        return;
      }
    }
    for (; waitingForWorkerQueue.length; ) {
      const { src: o, uncompressedSize: n, type: c, resolve: u } = waitingForWorkerQueue.shift();
      let h = o;
      isBlob(o) && (h = await readBlobAsUint8Array(o)), inflateRawLocal(h, n, c, u);
    }
  }
}
function setOptions(o) {
  config.workerURL = o.workerURL || config.workerURL, o.workerURL && (config.useWorkers = !0), config.useWorkers = o.useWorkers !== void 0 ? o.useWorkers : config.useWorkers, config.numWorkers = o.numWorkers || config.numWorkers;
}
function inflateRawAsync(o, n, c) {
  return new Promise((u, h) => {
    waitingForWorkerQueue.push({ src: o, uncompressedSize: n, type: c, resolve: u, reject: h, id: nextId++ }), processWaitingForWorkerQueue();
  });
}
function clearArray(o) {
  o.splice(0, o.length);
}
async function cleanup() {
  for (const o of workers)
    await workerHelper.terminate(o);
  clearArray(workers), clearArray(availableWorkers), clearArray(waitingForWorkerQueue), currentlyProcessingIdToRequestMap.clear(), numWorkers = 0, canUseWorkers = !0;
}
function dosDateTimeToDate(o, n) {
  return new Date(1980 + (o >> 9 & 127), (o >> 5 & 15) - 1, 31 & o, n >> 11 & 31, n >> 5 & 63, 2 * (31 & n), 0);
}
class ZipEntry {
  constructor(n, c) {
    this._reader = n, this._rawEntry = c, this.name = c.name, this.nameBytes = c.nameBytes, this.size = c.uncompressedSize, this.compressedSize = c.compressedSize, this.comment = c.comment, this.commentBytes = c.commentBytes, this.compressionMethod = c.compressionMethod, this.lastModDate = dosDateTimeToDate(c.lastModFileDate, c.lastModFileTime), this.isDirectory = c.uncompressedSize === 0 && c.name.endsWith("/"), this.encrypted = !!(1 & c.generalPurposeBitFlag), this.externalFileAttributes = c.externalFileAttributes, this.versionMadeBy = c.versionMadeBy;
  }
  async blob(n = "application/octet-stream") {
    return await readEntryDataAsBlob(this._reader, this._rawEntry, n);
  }
  async arrayBuffer() {
    return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);
  }
  async text() {
    const n = await this.arrayBuffer();
    return decodeBuffer(new Uint8Array(n));
  }
  async json() {
    const n = await this.text();
    return JSON.parse(n);
  }
}
const EOCDR_WITHOUT_COMMENT_SIZE = 22, MAX_COMMENT_SIZE = 65535, EOCDR_SIGNATURE = 101010256, ZIP64_EOCDR_SIGNATURE = 101075792;
async function readAs(o, n, c) {
  return await o.read(n, c);
}
async function readAsBlobOrTypedArray(o, n, c, u) {
  return o.sliceAsBlob ? await o.sliceAsBlob(n, c, u) : await o.read(n, c);
}
const crc$1 = { unsigned: () => 0 };
function getUint16LE(o, n) {
  return o[n] + 256 * o[n + 1];
}
function getUint32LE(o, n) {
  return o[n] + 256 * o[n + 1] + 65536 * o[n + 2] + 16777216 * o[n + 3];
}
function getUint64LE(o, n) {
  return getUint32LE(o, n) + 4294967296 * getUint32LE(o, n + 4);
}
const utf8Decoder = new TextDecoder();
function decodeBuffer(o, n) {
  return isSharedArrayBuffer(o.buffer) && (o = new Uint8Array(o)), utf8Decoder.decode(o);
}
async function findEndOfCentralDirector(o, n) {
  const c = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, n), u = n - c, h = await readAs(o, u, c);
  for (let g = c - EOCDR_WITHOUT_COMMENT_SIZE; g >= 0; --g) {
    if (getUint32LE(h, g) !== EOCDR_SIGNATURE)
      continue;
    const y = new Uint8Array(h.buffer, h.byteOffset + g, h.byteLength - g), $ = getUint16LE(y, 4);
    if ($ !== 0)
      throw new Error(`multi-volume zip files are not supported. This is volume: ${$}`);
    const I = getUint16LE(y, 10), P = getUint32LE(y, 12), L = getUint32LE(y, 16), q = getUint16LE(y, 20), N = y.length - EOCDR_WITHOUT_COMMENT_SIZE;
    if (q !== N)
      throw new Error(`invalid comment length. expected: ${N}, actual: ${q}`);
    const X = new Uint8Array(y.buffer, y.byteOffset + 22, q), rt = decodeBuffer(X);
    return I === 65535 || L === 4294967295 ? await readZip64CentralDirectory(o, u + g, rt, X) : await readEntries(o, L, P, I, rt, X);
  }
  throw new Error("could not find end of central directory. maybe not zip file");
}
const END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 117853008;
async function readZip64CentralDirectory(o, n, c, u) {
  const h = n - 20, g = await readAs(o, h, 20);
  if (getUint32LE(g, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE)
    throw new Error("invalid zip64 end of central directory locator signature");
  const y = getUint64LE(g, 8), $ = await readAs(o, y, 56);
  if (getUint32LE($, 0) !== ZIP64_EOCDR_SIGNATURE)
    throw new Error("invalid zip64 end of central directory record signature");
  const I = getUint64LE($, 32), P = getUint64LE($, 40);
  return readEntries(o, getUint64LE($, 48), P, I, c, u);
}
const CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 33639248;
async function readEntries(o, n, c, u, h, g) {
  let y = 0;
  const $ = await readAs(o, n, c), I = [];
  for (let P = 0; P < u; ++P) {
    const L = $.subarray(y, y + 46), q = getUint32LE(L, 0);
    if (q !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE)
      throw new Error(`invalid central directory file header signature: 0x${q.toString(16)}`);
    const N = { versionMadeBy: getUint16LE(L, 4), versionNeededToExtract: getUint16LE(L, 6), generalPurposeBitFlag: getUint16LE(L, 8), compressionMethod: getUint16LE(L, 10), lastModFileTime: getUint16LE(L, 12), lastModFileDate: getUint16LE(L, 14), crc32: getUint32LE(L, 16), compressedSize: getUint32LE(L, 20), uncompressedSize: getUint32LE(L, 24), fileNameLength: getUint16LE(L, 28), extraFieldLength: getUint16LE(L, 30), fileCommentLength: getUint16LE(L, 32), internalFileAttributes: getUint16LE(L, 36), externalFileAttributes: getUint32LE(L, 38), relativeOffsetOfLocalHeader: getUint32LE(L, 42) };
    if (64 & N.generalPurposeBitFlag)
      throw new Error("strong encryption is not supported");
    y += 46;
    const X = $.subarray(y, y + N.fileNameLength + N.extraFieldLength + N.fileCommentLength);
    N.nameBytes = X.slice(0, N.fileNameLength), N.name = decodeBuffer(N.nameBytes);
    const rt = N.fileNameLength + N.extraFieldLength, nt = X.slice(N.fileNameLength, rt);
    N.extraFields = [];
    let st = 0;
    for (; st < nt.length - 3; ) {
      const St = getUint16LE(nt, st + 0), Ct = st + 4, et = Ct + getUint16LE(nt, st + 2);
      if (et > nt.length)
        throw new Error("extra field length exceeds extra field buffer size");
      N.extraFields.push({ id: St, data: nt.slice(Ct, et) }), st = et;
    }
    if (N.commentBytes = X.slice(rt, rt + N.fileCommentLength), N.comment = decodeBuffer(N.commentBytes), y += X.length, N.uncompressedSize === 4294967295 || N.compressedSize === 4294967295 || N.relativeOffsetOfLocalHeader === 4294967295) {
      const St = N.extraFields.find((at) => at.id === 1);
      if (!St)
        throw new Error("expected zip64 extended information extra field");
      const Ct = St.data;
      let et = 0;
      if (N.uncompressedSize === 4294967295) {
        if (et + 8 > Ct.length)
          throw new Error("zip64 extended information extra field does not include uncompressed size");
        N.uncompressedSize = getUint64LE(Ct, et), et += 8;
      }
      if (N.compressedSize === 4294967295) {
        if (et + 8 > Ct.length)
          throw new Error("zip64 extended information extra field does not include compressed size");
        N.compressedSize = getUint64LE(Ct, et), et += 8;
      }
      if (N.relativeOffsetOfLocalHeader === 4294967295) {
        if (et + 8 > Ct.length)
          throw new Error("zip64 extended information extra field does not include relative header offset");
        N.relativeOffsetOfLocalHeader = getUint64LE(Ct, et), et += 8;
      }
    }
    const ot = N.extraFields.find((St) => St.id === 28789 && St.data.length >= 6 && St.data[0] === 1 && getUint32LE(St.data, 1), crc$1.unsigned(N.nameBytes));
    if (ot && (N.fileName = decodeBuffer(ot.data.slice(5))), N.compressionMethod === 0) {
      let St = N.uncompressedSize;
      if ((1 & N.generalPurposeBitFlag) != 0 && (St += 12), N.compressedSize !== St)
        throw new Error(`compressed size mismatch for stored file: ${N.compressedSize} != ${St}`);
    }
    I.push(N);
  }
  return { zip: { comment: h, commentBytes: g }, entries: I.map((P) => new ZipEntry(o, P)) };
}
async function readEntryDataHeader(o, n) {
  if (1 & n.generalPurposeBitFlag)
    throw new Error("encrypted entries not supported");
  const c = await readAs(o, n.relativeOffsetOfLocalHeader, 30), u = await o.getLength(), h = getUint32LE(c, 0);
  if (h !== 67324752)
    throw new Error(`invalid local file header signature: 0x${h.toString(16)}`);
  const g = getUint16LE(c, 26), y = getUint16LE(c, 28), $ = n.relativeOffsetOfLocalHeader + c.length + g + y;
  let I;
  if (n.compressionMethod === 0)
    I = !1;
  else {
    if (n.compressionMethod !== 8)
      throw new Error(`unsupported compression method: ${n.compressionMethod}`);
    I = !0;
  }
  const P = $, L = P + n.compressedSize;
  if (n.compressedSize !== 0 && L > u)
    throw new Error(`file data overflows file bounds: ${P} +  ${n.compressedSize}  > ${u}`);
  return { decompress: I, fileDataStart: P };
}
async function readEntryDataAsArrayBuffer(o, n) {
  const { decompress: c, fileDataStart: u } = await readEntryDataHeader(o, n);
  if (!c) {
    const g = await readAs(o, u, n.compressedSize);
    return isTypedArraySameAsArrayBuffer(g) ? g.buffer : g.slice().buffer;
  }
  const h = await readAsBlobOrTypedArray(o, u, n.compressedSize);
  return await inflateRawAsync(h, n.uncompressedSize);
}
async function readEntryDataAsBlob(o, n, c) {
  const { decompress: u, fileDataStart: h } = await readEntryDataHeader(o, n);
  if (!u) {
    const y = await readAsBlobOrTypedArray(o, h, n.compressedSize, c);
    return isBlob(y) ? y : new Blob([isSharedArrayBuffer(y.buffer) ? new Uint8Array(y) : y], { type: c });
  }
  const g = await readAsBlobOrTypedArray(o, h, n.compressedSize);
  return await inflateRawAsync(g, n.uncompressedSize, c);
}
function setOptions$1(o) {
  setOptions(o);
}
async function unzipRaw(o) {
  let n;
  if (typeof Blob < "u" && o instanceof Blob)
    n = new BlobReader(o);
  else if (o instanceof ArrayBuffer || o && o.buffer && o.buffer instanceof ArrayBuffer)
    n = new ArrayBufferReader(o);
  else if (isSharedArrayBuffer(o) || isSharedArrayBuffer(o.buffer))
    n = new ArrayBufferReader(o);
  else if (typeof o == "string") {
    const u = await fetch(o);
    if (!u.ok)
      throw new Error(`failed http request ${o}, status: ${u.status}: ${u.statusText}`);
    const h = await u.blob();
    n = new BlobReader(h);
  } else {
    if (typeof o.getLength != "function" || typeof o.read != "function")
      throw new Error("unsupported source type");
    n = o;
  }
  const c = await n.getLength();
  if (c > Number.MAX_SAFE_INTEGER)
    throw new Error(`file too large. size: ${c}. Only file sizes up 4503599627370496 bytes are supported`);
  return await findEndOfCentralDirector(n, c);
}
async function unzip(o) {
  const { zip: n, entries: c } = await unzipRaw(o);
  return { zip: n, entries: Object.fromEntries(c.map((u) => [u.name, u])) };
}
function cleanup$1() {
  cleanup();
}
const unzipit_module = Object.freeze(Object.defineProperty({ __proto__: null, HTTPRangeReader, cleanup: cleanup$1, setOptions: setOptions$1, unzip, unzipRaw }, Symbol.toStringTag, { value: "Module" })), require$$0 = getAugmentedNamespace(unzipit_module);
Object.defineProperty(WasmSrc$1, "__esModule", { value: !0 }), WasmSrc$1.WasmSrc = void 0;
const unzipit_1 = require$$0, redstone_isomorphic_1 = npmBrowser$1, LoggerFactory_1 = LoggerFactory$1;
class WasmSrc {
  constructor(n) {
    this.src = n, this.logger = LoggerFactory_1.LoggerFactory.INST.create("WasmSrc"), this.splitted = this.splitBuffer(n), this.logger.debug(`Buffer splitted into ${this.splitted.length} parts`);
  }
  wasmBinary() {
    return this.splitted[0];
  }
  async sourceCode() {
    const { entries: n } = await (0, unzipit_1.unzip)(this.splitted[1]), c = /* @__PURE__ */ new Map();
    for (const [u, h] of Object.entries(n)) {
      if (h.isDirectory)
        continue;
      const g = await h.text();
      c.set(u, g);
    }
    return c;
  }
  additionalCode() {
    return this.splitted.length == 2 ? null : this.splitted[2].toString();
  }
  splitBuffer(n) {
    let c = "";
    const u = parseInt(n.toString("utf8", 0, 1));
    this.logger.debug(`Number of elements: ${u}`);
    const h = n.length;
    let g = 0, y = 0;
    for (let P = 2; P < h; P++) {
      const L = n.toString("utf8", P, P + 1);
      if (L == "|" && g++, g == u) {
        y = P + 1;
        break;
      }
      c += L;
    }
    this.logger.debug("Parsed:", { header: c, dataStart: y });
    const $ = c.split("|").map((P) => parseInt(P));
    this.logger.debug("Lengths", $);
    const I = [];
    for (const P of $) {
      const L = redstone_isomorphic_1.Buffer.alloc(P), q = y + P;
      n.copy(L, 0, y, q), y = q, I.push(L);
    }
    return I;
  }
}
var hasRequiredWarpGatewayContractDefinitionLoader, hasRequiredWarpBuilder, hasRequiredWarp, hasRequiredWarpFactory, hasRequiredArweaveWrapper, hasRequiredContractDefinitionLoader;
function requireWarpGatewayContractDefinitionLoader() {
  if (hasRequiredWarpGatewayContractDefinitionLoader)
    return WarpGatewayContractDefinitionLoader;
  hasRequiredWarpGatewayContractDefinitionLoader = 1;
  var o = commonjsGlobal && commonjsGlobal.__importDefault || function(X) {
    return X && X.__esModule ? X : { default: X };
  };
  Object.defineProperty(WarpGatewayContractDefinitionLoader, "__esModule", { value: !0 }), WarpGatewayContractDefinitionLoader.WarpGatewayContractDefinitionLoader = void 0;
  const n = requireContractDefinitionLoader(), c = npmBrowser$1, u = o(requireTransaction()), h = SmartWeaveTags, g = utils$p, y = Benchmark$1, $ = LoggerFactory$1, I = requireArweaveWrapper(), P = utils$n, L = WasmSrc$1, q = memoryLevel, N = browser;
  return WarpGatewayContractDefinitionLoader.WarpGatewayContractDefinitionLoader = class {
    constructor(X, rt, nt) {
      if (this.baseUrl = X, this.rLogger = $.LoggerFactory.INST.create("WarpGatewayContractDefinitionLoader"), this.baseUrl = (0, P.stripTrailingSlash)(X), this.contractDefinitionLoader = new n.ContractDefinitionLoader(rt), this.arweaveWrapper = new I.ArweaveWrapper(rt), nt.inMemory)
        this.db = new q.MemoryLevel({ valueEncoding: "json" });
      else {
        if (!nt.dbLocation)
          throw new Error("LevelDb cache configuration error - no db location specified");
        const st = nt.dbLocation;
        this.db = new N.Level(`${st}/contracts`, { valueEncoding: "json" });
      }
    }
    async load(X, rt) {
      let nt = X;
      rt && (nt += `_${rt}`);
      let st = null;
      try {
        st = await this.db.get(nt);
      } catch (Ct) {
        if (Ct.code != "LEVEL_NOT_FOUND")
          throw Ct;
        st = null;
      }
      if (st)
        return this.rLogger.debug("WarpGatewayContractDefinitionLoader: Hit from cache!"), st.contractType == "wasm" && (st.srcBinary = c.Buffer.from(st.srcBinary.data)), st;
      const ot = y.Benchmark.measure(), St = await this.doLoad(X, rt);
      return this.rLogger.info(`Contract definition loaded in: ${ot.elapsed()}`), await this.db.put(nt, St), St;
    }
    async doLoad(X, rt) {
      try {
        const nt = await fetch(`${this.baseUrl}/gateway/contract?txId=${X}${rt ? `&srcTxId=${rt}` : ""}`).then((st) => st.ok ? st.json() : Promise.reject(st)).catch((st) => {
          var ot, St;
          throw !((ot = st.body) === null || ot === void 0) && ot.message && this.rLogger.error(st.body.message), new Error(`Unable to retrieve contract data. Warp gateway responded with status ${st.status}:${(St = st.body) === null || St === void 0 ? void 0 : St.message}`);
        });
        if (nt.srcBinary == null || nt.srcBinary instanceof c.Buffer || (nt.srcBinary = c.Buffer.from(nt.srcBinary.data)), nt.srcBinary) {
          const st = new L.WasmSrc(nt.srcBinary);
          let ot;
          nt.srcBinary = st.wasmBinary(), ot = nt.srcTx ? new u.default({ ...nt.srcTx }) : await this.arweaveWrapper.tx(nt.srcTxId);
          const St = JSON.parse((0, g.getTag)(ot, h.SmartWeaveTags.WASM_META));
          nt.metadata = St;
        }
        return nt.contractType = nt.src ? "js" : "wasm", nt;
      } catch (nt) {
        return this.rLogger.warn("Falling back to default contracts loader", nt), await this.contractDefinitionLoader.doLoad(X, rt);
      }
    }
    async loadContractSource(X) {
      return await this.contractDefinitionLoader.loadContractSource(X);
    }
    type() {
      return "warp";
    }
  }, WarpGatewayContractDefinitionLoader;
}
function requireWarpBuilder() {
  if (hasRequiredWarpBuilder)
    return WarpBuilder;
  hasRequiredWarpBuilder = 1, Object.defineProperty(WarpBuilder, "__esModule", { value: !0 }), WarpBuilder.WarpBuilder = void 0;
  const o = DebuggableExecutorFactor, n = requireArweaveGatewayInteractionsLoader(), c = CacheableInteractionsLoader$1, u = requireContractDefinitionLoader(), h = requireWarpGatewayContractDefinitionLoader(), g = WarpGatewayInteractionsLoader, y = requireWarp();
  return WarpBuilder.WarpBuilder = class {
    constructor($, I, P = "custom") {
      this._arweave = $, this._cache = I, this._environment = P;
    }
    setDefinitionLoader($) {
      return this._definitionLoader = $, this;
    }
    setInteractionsLoader($) {
      return this._interactionsLoader = $, this;
    }
    setExecutorFactory($) {
      return this._executorFactory = $, this;
    }
    setStateEvaluator($) {
      return this._stateEvaluator = $, this;
    }
    overwriteSource($) {
      if (this._executorFactory == null)
        throw new Error("Set base ExecutorFactory first");
      return this._executorFactory = new o.DebuggableExecutorFactory(this._executorFactory, $), this.build();
    }
    useWarpGateway($, I) {
      return this._interactionsLoader = new c.CacheableInteractionsLoader(new g.WarpGatewayInteractionsLoader($.address, $.confirmationStatus, $.source)), this._definitionLoader = new h.WarpGatewayContractDefinitionLoader($.address, this._arweave, I), this;
    }
    useArweaveGateway() {
      return this._definitionLoader = new u.ContractDefinitionLoader(this._arweave), this._interactionsLoader = new c.CacheableInteractionsLoader(new n.ArweaveGatewayInteractionsLoader(this._arweave, this._environment)), this;
    }
    build() {
      return new y.Warp(this._arweave, this._cache, this._definitionLoader, this._interactionsLoader, this._executorFactory, this._stateEvaluator, this._environment);
    }
  }, WarpBuilder;
}
function requireWarp() {
  if (hasRequiredWarp)
    return Warp;
  hasRequiredWarp = 1, Object.defineProperty(Warp, "__esModule", { value: !0 }), Warp.Warp = void 0;
  const o = requireDefaultCreateContract(), n = requireHandlerBasedContract(), c = requirePstContractImpl(), u = MigrationTool$1, h = Testing$1, g = requireWarpBuilder();
  return Warp.Warp = class {
    constructor(y, $, I, P, L, q, N = "custom") {
      this.arweave = y, this.levelDb = $, this.definitionLoader = I, this.interactionsLoader = P, this.executorFactory = L, this.stateEvaluator = q, this.environment = N, this.createContract = new o.DefaultCreateContract(y, this), this.migrationTool = new u.MigrationTool(y, $), this.testing = new h.Testing(y);
    }
    static builder(y, $, I) {
      return new g.WarpBuilder(y, $, I);
    }
    contract(y, $, I) {
      return new n.HandlerBasedContract(y, this, $, I);
    }
    pst(y) {
      return new c.PstContractImpl(y, this);
    }
  }, Warp;
}
function requireWarpFactory() {
  return hasRequiredWarpFactory || (hasRequiredWarpFactory = 1, function(o) {
    var n = commonjsGlobal && commonjsGlobal.__importDefault || function(L) {
      return L && L.__esModule ? L : { default: L };
    };
    Object.defineProperty(o, "__esModule", { value: !0 }), o.WarpFactory = o.defaultCacheOptions = o.DEFAULT_LEVEL_DB_LOCATION = o.defaultWarpGwOptions = o.WARP_GW_URL = void 0;
    const c = n(web), u = LevelDbCache$1, h = MemCache$1, g = CacheableExecutorFactory$1, y = Evolve$1, $ = CacheableStateEvaluator$1, I = HandlerExecutorFactory$1, P = requireWarp();
    o.WARP_GW_URL = "https://d1o5nlqr4okus2.cloudfront.net", o.defaultWarpGwOptions = { confirmationStatus: { notCorrupted: !0 }, source: null, address: o.WARP_GW_URL }, o.DEFAULT_LEVEL_DB_LOCATION = "./cache/warp", o.defaultCacheOptions = { inMemory: !1, dbLocation: o.DEFAULT_LEVEL_DB_LOCATION }, o.WarpFactory = class {
      static forLocal(L = 1984, q = c.default.init({ host: "localhost", port: L, protocol: "http" }), N = { ...o.defaultCacheOptions, inMemory: !0 }) {
        return this.customArweaveGw(q, N, "local");
      }
      static forTestnet(L = c.default.init({ host: "testnet.redstone.tools", port: 443, protocol: "https" }), q = o.defaultCacheOptions) {
        return this.customArweaveGw(L, q, "testnet");
      }
      static forMainnet(L = o.defaultCacheOptions, q = !1, N = c.default.init({ host: "arweave.net", port: 443, protocol: "https" })) {
        return q ? this.customArweaveGw(N, L, "mainnet") : this.customWarpGw(N, o.defaultWarpGwOptions, L, "mainnet");
      }
      static custom(L, q, N) {
        const X = new u.LevelDbCache({ ...q, dbLocation: `${q.dbLocation}/state` }), rt = new g.CacheableExecutorFactory(L, new I.HandlerExecutorFactory(L), new h.MemCache()), nt = new $.CacheableStateEvaluator(L, X, [new y.Evolve()]);
        return P.Warp.builder(L, X, N).setExecutorFactory(rt).setStateEvaluator(nt);
      }
      static customArweaveGw(L, q = o.defaultCacheOptions, N) {
        return this.custom(L, q, N).useArweaveGateway().build();
      }
      static customWarpGw(L, q = o.defaultWarpGwOptions, N = o.defaultCacheOptions, X) {
        return this.custom(L, N, X).useWarpGateway(q, N).build();
      }
    };
  }(WarpFactory)), WarpFactory;
}
function requireArweaveWrapper() {
  if (hasRequiredArweaveWrapper)
    return ArweaveWrapper;
  hasRequiredArweaveWrapper = 1;
  var o = commonjsGlobal && commonjsGlobal.__importDefault || function(y) {
    return y && y.__esModule ? y : { default: y };
  };
  Object.defineProperty(ArweaveWrapper, "__esModule", { value: !0 }), ArweaveWrapper.ArweaveWrapper = void 0;
  const n = o(web), c = o(requireTransaction()), u = npmBrowser$1, h = requireWarpFactory(), g = LoggerFactory$1;
  return ArweaveWrapper.ArweaveWrapper = class {
    constructor(y) {
      this.arweave = y, this.logger = g.LoggerFactory.INST.create("ArweaveWrapper"), this.baseUrl = `${y.api.config.protocol}://${y.api.config.host}:${y.api.config.port}`, this.logger.debug("baseurl", this.baseUrl);
    }
    async warpGwInfo() {
      return await this.doFetchInfo(`${h.WARP_GW_URL}/gateway/arweave/info`);
    }
    async warpGwBlock() {
      return this.logger.debug("Calling warp gw block info"), await this.doFetchInfo(`${h.WARP_GW_URL}/gateway/arweave/block`);
    }
    async info() {
      return await this.doFetchInfo(`${this.baseUrl}/info`);
    }
    async gql(y, $) {
      try {
        const I = JSON.stringify({ query: y, variables: $ });
        return { data: await fetch(`${this.baseUrl}/graphql`, { method: "POST", body: I, headers: { "Accept-Encoding": "gzip, deflate, br", "Content-Type": "application/json", Accept: "application/json" } }).then((L) => L.ok ? L.json() : Promise.reject(L)).catch((L) => {
          var q, N;
          throw !((q = L.body) === null || q === void 0) && q.message && this.logger.error(L.body.message), new Error(`Unable to retrieve gql page. ${L.status}: ${(N = L.body) === null || N === void 0 ? void 0 : N.message}`);
        }), status: 200 };
      } catch (I) {
        throw this.logger.error("Error while loading gql", I), I;
      }
    }
    async tx(y) {
      const $ = await fetch(`${this.baseUrl}/tx/${y}`).then((I) => I.ok ? I.json() : Promise.reject(I)).catch((I) => {
        var P, L;
        throw !((P = I.body) === null || P === void 0) && P.message && this.logger.error(I.body.message), new Error(`Unable to retrieve tx ${y}. ${I.status}. ${(L = I.body) === null || L === void 0 ? void 0 : L.message}`);
      });
      return new c.default({ ...$ });
    }
    async txData(y) {
      const $ = await fetch(`${this.baseUrl}/${y}`);
      if ($.ok) {
        const I = await $.arrayBuffer();
        return u.Buffer.from(I);
      }
      {
        this.logger.warn(`Unable to load data from arweave.net/${y} endpoint, falling back to arweave.js`);
        const I = await this.arweave.transactions.getData(y, { decode: !0 });
        return u.Buffer.from(I);
      }
    }
    async txDataString(y) {
      const $ = await this.txData(y);
      return n.default.utils.bufferToString($);
    }
    async doFetchInfo(y) {
      try {
        return await fetch(y).then((I) => I.ok ? I.json() : Promise.reject(I)).catch((I) => {
          var P, L;
          throw !((P = I.body) === null || P === void 0) && P.message && this.logger.error(I.body.message), new Error(`Unable to retrieve info. ${I.status}: ${(L = I.body) === null || L === void 0 ? void 0 : L.message}`);
        });
      } catch ($) {
        throw this.logger.error("Error while loading info", $), $;
      }
    }
  }, ArweaveWrapper;
}
function requireContractDefinitionLoader() {
  if (hasRequiredContractDefinitionLoader)
    return ContractDefinitionLoader;
  hasRequiredContractDefinitionLoader = 1, Object.defineProperty(ContractDefinitionLoader, "__esModule", { value: !0 }), ContractDefinitionLoader.ContractDefinitionLoader = void 0;
  const o = SmartWeaveTags, n = utils$p, c = Benchmark$1, u = LoggerFactory$1, h = requireArweaveWrapper(), g = WasmSrc$1, y = ["application/javascript", "application/wasm"];
  return ContractDefinitionLoader.ContractDefinitionLoader = class {
    constructor($) {
      this.arweave = $, this.logger = u.LoggerFactory.INST.create("ContractDefinitionLoader"), this.arweaveWrapper = new h.ArweaveWrapper($);
    }
    async load($, I) {
      const P = c.Benchmark.measure(), L = await this.doLoad($, I);
      return this.logger.info(`Contract definition loaded in: ${P.elapsed()}`), L;
    }
    async doLoad($, I) {
      const P = c.Benchmark.measure(), L = await this.arweaveWrapper.tx($), q = await this.arweave.wallets.ownerToAddress(L.owner);
      this.logger.debug("Contract tx and owner", P.elapsed()), P.reset();
      const N = I || (0, n.getTag)(L, o.SmartWeaveTags.CONTRACT_SRC_TX_ID), X = (0, n.getTag)(L, o.SmartWeaveTags.MIN_FEE);
      this.logger.debug("Tags decoding", P.elapsed()), P.reset();
      const rt = await this.evalInitialState(L);
      this.logger.debug("init state", rt);
      const nt = JSON.parse(await this.evalInitialState(L));
      this.logger.debug("Parsing src and init state", P.elapsed());
      const { src: st, srcBinary: ot, srcWasmLang: St, contractType: Ct, metadata: et, srcTx: at } = await this.loadContractSource(N);
      return { txId: $, srcTxId: N, src: st, srcBinary: ot, srcWasmLang: St, initState: nt, minFee: X, owner: q, contractType: Ct, metadata: et, contractTx: L.toJSON(), srcTx: at };
    }
    async loadContractSource($) {
      const I = c.Benchmark.measure(), P = await this.arweaveWrapper.tx($), L = (0, n.getTag)(P, o.SmartWeaveTags.CONTENT_TYPE);
      if (!y.includes(L))
        throw new Error(`Contract source content type ${L} not supported`);
      const q = L == "application/javascript" ? "js" : "wasm", N = q == "js" ? await this.arweaveWrapper.txDataString($) : await this.arweaveWrapper.txData($);
      let X, rt, nt;
      if (q == "wasm") {
        if (rt = new g.WasmSrc(N), X = (0, n.getTag)(P, o.SmartWeaveTags.WASM_LANG), !X)
          throw new Error(`Wasm lang not set for wasm contract src ${$}`);
        nt = JSON.parse((0, n.getTag)(P, o.SmartWeaveTags.WASM_META));
      }
      return this.logger.debug("Contract src tx load", I.elapsed()), I.reset(), { src: q == "js" ? N : null, srcBinary: q == "wasm" ? rt.wasmBinary() : null, srcWasmLang: X, contractType: q, metadata: nt, srcTx: P.toJSON() };
    }
    async evalInitialState($) {
      if ((0, n.getTag)($, o.SmartWeaveTags.INIT_STATE))
        return (0, n.getTag)($, o.SmartWeaveTags.INIT_STATE);
      if ((0, n.getTag)($, o.SmartWeaveTags.INIT_STATE_TX)) {
        const I = (0, n.getTag)($, o.SmartWeaveTags.INIT_STATE_TX);
        return this.arweaveWrapper.txDataString(I);
      }
      return this.arweaveWrapper.txDataString($.id);
    }
    type() {
      return "arweave";
    }
  }, ContractDefinitionLoader;
}
WasmSrc$1.WasmSrc = WasmSrc;
var ExecutionContextModifier = {};
Object.defineProperty(ExecutionContextModifier, "__esModule", { value: !0 });
var ExecutionContext = {};
Object.defineProperty(ExecutionContext, "__esModule", { value: !0 });
var ContractDefinition = {};
Object.defineProperty(ContractDefinition, "__esModule", { value: !0 }), ContractDefinition.ContractMetadata = void 0;
class ContractMetadata {
}
ContractDefinition.ContractMetadata = ContractMetadata;
var PstContract = {};
Object.defineProperty(PstContract, "__esModule", { value: !0 });
var Source = {};
Object.defineProperty(Source, "__esModule", { value: !0 });
var gqlResult = {};
Object.defineProperty(gqlResult, "__esModule", { value: !0 }), function(o) {
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(u, h, g, y) {
    y === void 0 && (y = g);
    var $ = Object.getOwnPropertyDescriptor(h, g);
    $ && !("get" in $ ? !h.__esModule : $.writable || $.configurable) || ($ = { enumerable: !0, get: function() {
      return h[g];
    } }), Object.defineProperty(u, y, $);
  } : function(u, h, g, y) {
    y === void 0 && (y = g), u[y] = h[g];
  }), c = commonjsGlobal && commonjsGlobal.__exportStar || function(u, h) {
    for (var g in u)
      g === "default" || Object.prototype.hasOwnProperty.call(h, g) || n(h, u, g);
  };
  Object.defineProperty(o, "__esModule", { value: !0 }), c(ConsoleLogger$1, o), c(ConsoleLoggerFactory$1, o), c(WarpLogger, o), c(LoggerFactory$1, o), c(LoggerSettings, o), c(Benchmark$1, o), c(DefinitionLoader, o), c(ExecutorFactory, o), c(InteractionsLoader, o), c(InteractionsSorter, o), c(StateEvaluator, o), c(requireContractDefinitionLoader(), o), c(requireWarpGatewayContractDefinitionLoader(), o), c(requireArweaveGatewayInteractionsLoader(), o), c(WarpGatewayInteractionsLoader, o), c(CacheableInteractionsLoader$1, o), c(DefaultStateEvaluator$1, o), c(CacheableStateEvaluator$1, o), c(HandlerExecutorFactory$1, o), c(LexicographicalInteractionsSorter, o), c(TagsParser$1, o), c(normalizeSource, o), c(StateCache, o), c(WasmSrc$1, o), c(AbstractContractHandler$1, o), c(JsHandlerApi$1, o), c(WasmHandlerApi$1, o), c(ExecutionContextModifier, o), c(SmartWeaveTags, o), c(ExecutionContext, o), c(ContractDefinition, o), c(ContractCallRecord$1, o), c(requireWarpFactory(), o), c(requireWarp(), o), c(requireWarpBuilder(), o), c(Contract, o), c(requireHandlerBasedContract(), o), c(PstContract, o), c(requirePstContractImpl(), o), c(InnerWritesEvaluator$1, o), c(Source, o), c(SourceImpl$1, o), c(requireDefaultCreateContract(), o), c(CreateContract, o), c(gqlResult, o), c(smartweaveGlobal, o), c(errors, o), c(utils$p, o), c(createInteractionTx$1, o), c(utils$n, o), c(requireArweaveWrapper(), o);
}(cjs);
const index$1 = getDefaultExportFromCjs(cjs), index$2 = _mergeNamespaces({ __proto__: null, default: index$1 }, [cjs]);
function add_css(o) {
  append_styles(o, "svelte-ygngpq", ".iframe-container.svelte-ygngpq{display:flex;flex:1;height:100%;width:100%;border-radius:4px}.header.svelte-ygngpq{font-weight:700;font-size:0.8rem;text-transform:uppercase;color:rgba(0, 0, 0, 0.7)}iframe.svelte-ygngpq{display:flex;flex:1;height:100%;width:100%;border:0}.iframe-inner.svelte-ygngpq{display:flex;flex:1;height:100%}");
}
function create_if_block(o) {
  let n;
  return { c() {
    n = text("Rendering...");
  }, m(c, u) {
    insert(c, n, u);
  }, d(c) {
    c && detach(n);
  } };
}
function create_fragment$3(o) {
  let n, c, u, h, g, y, $ = !o[2] && create_if_block();
  return { c() {
    n = element("div"), c = element("div"), $ && $.c(), u = space(), h = element("div"), g = element("iframe"), attr(c, "class", "header svelte-ygngpq"), attr(g, "sandbox", sandbox), attr(g, "allow", "camera *;microphone *"), attr(g, "title", "Rendered Component"), attr(g, "srcdoc", o[1]), g.allowFullscreen = !0, attr(g, "class", "svelte-ygngpq"), add_render_callback(() => o[7].call(g)), attr(h, "class", "iframe-inner svelte-ygngpq"), attr(n, "class", "iframe-container svelte-ygngpq");
  }, m(I, P) {
    insert(I, n, P), append(n, c), $ && $.m(c, null), append(n, u), append(n, h), append(h, g), o[6](g), y = add_resize_listener(g, o[7].bind(g));
  }, p(I, [P]) {
    I[2] ? $ && ($.d(1), $ = null) : $ || ($ = create_if_block(), $.c(), $.m(c, null)), 2 & P && attr(g, "srcdoc", I[1]);
  }, i: noop$3, o: noop$3, d(I) {
    I && detach(n), $ && $.d(), o[6](null), y();
  } };
}
let sandbox = "allow-scripts";
function instance$3(o, n, c) {
  let u, h, g, { iframe: y = null } = n, { srcdoc: $ } = n, { rendered: I } = n;
  async function P() {
    if (!y || !u)
      throw new Error("Missing offsetWidth");
    c(5, g = new MessageChannel()), c(5, g.port1.onmessage = (L) => {
    }, g), c(4, h = () => {
      y.contentWindow.postMessage({ offsetWidth: u }, "*", [g.port2]);
    });
  }
  return o.$$set = (L) => {
    "iframe" in L && c(0, y = L.iframe), "srcdoc" in L && c(1, $ = L.srcdoc), "rendered" in L && c(2, I = L.rendered);
  }, o.$$.update = () => {
    1 & o.$$.dirty && y && y.addEventListener("load", P), 24 & o.$$.dirty && u && h && h(), 33 & o.$$.dirty && y && g && (!y.getAttribute("sandbox") || y.getAttribute("sandbox") && y.sandbox != sandbox) && y.contentWindow.location.reload();
  }, [y, $, I, u, h, g, function(L) {
    binding_callbacks[L ? "unshift" : "push"](() => {
      y = L, c(0, y);
    });
  }, function() {
    u = this.offsetWidth, c(3, u);
  }];
}
class IFrame extends SvelteComponent {
  constructor(n) {
    super(), init$1(this, n, instance$3, create_fragment$3, safe_not_equal, { iframe: 0, srcdoc: 1, rendered: 2 }, add_css);
  }
}
const CHANGE = "change";
function create_fragment$2(o) {
  let n, c, u;
  function h(y) {
    o[7](y);
  }
  let g = { srcdoc: o[2], rendered: o[0] };
  return o[1] !== void 0 && (g.iframe = o[1]), n = new IFrame({ props: g }), binding_callbacks.push(() => bind$3(n, "iframe", h)), { c() {
    create_component(n.$$.fragment);
  }, m(y, $) {
    mount_component(n, y, $), u = !0;
  }, p(y, [$]) {
    const I = {};
    1 & $ && (I.rendered = y[0]), !c && 2 & $ && (c = !0, I.iframe = y[1], add_flush_callback(() => c = !1)), n.$set(I);
  }, i(y) {
    u || (transition_in(n.$$.fragment, y), u = !0);
  }, o(y) {
    transition_out(n.$$.fragment, y), u = !1;
  }, d(y) {
    destroy_component(n, y);
  } };
}
const srcdoc64 = "PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KCTxoZWFkPgoJCTxtZXRhIGNoYXJzZXQ9InV0Zi04IiAvPgoJCTxtZXRhIG5hbWU9InZpZXdwb3J0IiBjb250ZW50PSJ3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xIiAvPgoJCTxzdHlsZT4KCQkJKiB7CgkJCQltYXJnaW46IDA7CgkJCQlwYWRkaW5nOiAwOwoJCQkJLyogIGluY2x1ZGUgcGFkZGluZyBhbmQgdGhlIGJvcmRlciAqLwoJCQkJYm94LXNpemluZzogYm9yZGVyLWJveDsKCQkJCS8qIG1vcmUgcGFkZGluZyBvbiB0aGUgaW5zaWRlIG9mIHlvdXIgYm94LCBidXQgeW91IGRvbid0IHdhbnQgdGhlIGJveCB0byByZXNpemUgKi8KCQkJCS8qIGJveC1zaXppbmc6IGNvbnRlbnQtYm94OyAqLwoJCQl9CgoJCQlib2R5IHsKCQkJCW1hcmdpbjogMDsKCQkJCXBvc2l0aW9uOiByZWxhdGl2ZTsKCQkJfQoJCTwvc3R5bGU+CgkJPHNjcmlwdCBkZWZlciB0eXBlPSJtb2R1bGUiPgoJCQl2YXIgYXBwPWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHQoKXt9ZnVuY3Rpb24gZSh0KXtyZXR1cm4gdCgpfWZ1bmN0aW9uIG4oKXtyZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKX1mdW5jdGlvbiBvKHQpe3QuZm9yRWFjaChlKX1mdW5jdGlvbiBzKHQpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiB0fWZ1bmN0aW9uIHIodCxlKXtyZXR1cm4gdCE9dD9lPT1lOnQhPT1lfHx0JiYib2JqZWN0Ij09dHlwZW9mIHR8fCJmdW5jdGlvbiI9PXR5cGVvZiB0fWZ1bmN0aW9uIGModCxlLG4pe3QuaW5zZXJ0QmVmb3JlKGUsbnx8bnVsbCl9ZnVuY3Rpb24gaSh0KXt0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCl9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0KX1mdW5jdGlvbiBsKHQpe3JldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0KX1mdW5jdGlvbiBhKCl7cmV0dXJuIGwoIiIpfWNsYXNzIGR7Y29uc3RydWN0b3IodD0hMSl7dGhpcy5pc19zdmc9ITEsdGhpcy5pc19zdmc9dCx0aGlzLmU9dGhpcy5uPW51bGx9Yyh0KXt0aGlzLmgodCl9bSh0LGUsbj1udWxsKXt2YXIgbzt0aGlzLmV8fCh0aGlzLmlzX3N2Zz90aGlzLmU9KG89ZS5ub2RlTmFtZSxkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIixvKSk6dGhpcy5lPXUoZS5ub2RlTmFtZSksdGhpcy50PWUsdGhpcy5jKHQpKSx0aGlzLmkobil9aCh0KXt0aGlzLmUuaW5uZXJIVE1MPXQsdGhpcy5uPUFycmF5LmZyb20odGhpcy5lLmNoaWxkTm9kZXMpfWkodCl7Zm9yKGxldCBlPTA7ZTx0aGlzLm4ubGVuZ3RoO2UrPTEpYyh0aGlzLnQsdGhpcy5uW2VdLHQpfXAodCl7dGhpcy5kKCksdGhpcy5oKHQpLHRoaXMuaSh0aGlzLmEpfWQoKXt0aGlzLm4uZm9yRWFjaChpKX19bGV0IGY7ZnVuY3Rpb24gcCh0KXtmPXR9ZnVuY3Rpb24gaCgpe2lmKCFmKXRocm93IG5ldyBFcnJvcigiRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uIik7cmV0dXJuIGZ9ZnVuY3Rpb24gJCgpe2NvbnN0IHQ9aCgpO3JldHVybihlLG4se2NhbmNlbGFibGU6bz0hMX09e30pPT57Y29uc3Qgcz10LiQkLmNhbGxiYWNrc1tlXTtpZihzKXtjb25zdCByPWZ1bmN0aW9uKHQsZSx7YnViYmxlczpuPSExLGNhbmNlbGFibGU6bz0hMX0pe2NvbnN0IHM9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoIkN1c3RvbUV2ZW50Iik7cmV0dXJuIHMuaW5pdEN1c3RvbUV2ZW50KHQsbixvLGUpLHN9KGUsbix7Y2FuY2VsYWJsZTpvfSk7cmV0dXJuIHMuc2xpY2UoKS5mb3JFYWNoKChlPT57ZS5jYWxsKHQscil9KSksIXIuZGVmYXVsdFByZXZlbnRlZH1yZXR1cm4hMH19Y29uc3QgbT1bXSxnPVtdLGI9W10seT1bXSx2PVByb21pc2UucmVzb2x2ZSgpO2xldCBfPSExO2Z1bmN0aW9uIHcodCl7Yi5wdXNoKHQpfWNvbnN0IHg9bmV3IFNldDtsZXQgRT0wO2Z1bmN0aW9uIGsoKXtjb25zdCB0PWY7ZG97Zm9yKDtFPG0ubGVuZ3RoOyl7Y29uc3QgdD1tW0VdO0UrKyxwKHQpLEwodC4kJCl9Zm9yKHAobnVsbCksbS5sZW5ndGg9MCxFPTA7Zy5sZW5ndGg7KWcucG9wKCkoKTtmb3IobGV0IHQ9MDt0PGIubGVuZ3RoO3QrPTEpe2NvbnN0IGU9Ylt0XTt4LmhhcyhlKXx8KHguYWRkKGUpLGUoKSl9Yi5sZW5ndGg9MH13aGlsZShtLmxlbmd0aCk7Zm9yKDt5Lmxlbmd0aDspeS5wb3AoKSgpO189ITEseC5jbGVhcigpLHAodCl9ZnVuY3Rpb24gTCh0KXtpZihudWxsIT09dC5mcmFnbWVudCl7dC51cGRhdGUoKSxvKHQuYmVmb3JlX3VwZGF0ZSk7Y29uc3QgZT10LmRpcnR5O3QuZGlydHk9Wy0xXSx0LmZyYWdtZW50JiZ0LmZyYWdtZW50LnAodC5jdHgsZSksdC5hZnRlcl91cGRhdGUuZm9yRWFjaCh3KX19Y29uc3QgTT1uZXcgU2V0O2xldCBqO2Z1bmN0aW9uIE8odCxlKXt0JiZ0LmkmJihNLmRlbGV0ZSh0KSx0LmkoZSkpfWZ1bmN0aW9uIE4odCxlLG4sbyl7aWYodCYmdC5vKXtpZihNLmhhcyh0KSlyZXR1cm47TS5hZGQodCksai5jLnB1c2goKCgpPT57TS5kZWxldGUodCksbyYmKG4mJnQuZCgxKSxvKCkpfSkpLHQubyhlKX1lbHNlIG8mJm8oKX1mdW5jdGlvbiBSKHQsbixyLGMpe2NvbnN0e2ZyYWdtZW50Omksb25fbW91bnQ6dSxvbl9kZXN0cm95OmwsYWZ0ZXJfdXBkYXRlOmF9PXQuJCQ7aSYmaS5tKG4sciksY3x8dygoKCk9Pntjb25zdCBuPXUubWFwKGUpLmZpbHRlcihzKTtsP2wucHVzaCguLi5uKTpvKG4pLHQuJCQub25fbW91bnQ9W119KSksYS5mb3JFYWNoKHcpfWZ1bmN0aW9uIFAodCxlKXtjb25zdCBuPXQuJCQ7bnVsbCE9PW4uZnJhZ21lbnQmJihvKG4ub25fZGVzdHJveSksbi5mcmFnbWVudCYmbi5mcmFnbWVudC5kKGUpLG4ub25fZGVzdHJveT1uLmZyYWdtZW50PW51bGwsbi5jdHg9W10pfWZ1bmN0aW9uIFUodCxlKXstMT09PXQuJCQuZGlydHlbMF0mJihtLnB1c2godCksX3x8KF89ITAsdi50aGVuKGspKSx0LiQkLmRpcnR5LmZpbGwoMCkpLHQuJCQuZGlydHlbZS8zMXwwXXw9MTw8ZSUzMX1mdW5jdGlvbiBUKGUscyxyLGMsdSxsLGEsZD1bLTFdKXtjb25zdCBoPWY7cChlKTtjb25zdCAkPWUuJCQ9e2ZyYWdtZW50Om51bGwsY3R4Om51bGwscHJvcHM6bCx1cGRhdGU6dCxub3RfZXF1YWw6dSxib3VuZDpuKCksb25fbW91bnQ6W10sb25fZGVzdHJveTpbXSxvbl9kaXNjb25uZWN0OltdLGJlZm9yZV91cGRhdGU6W10sYWZ0ZXJfdXBkYXRlOltdLGNvbnRleHQ6bmV3IE1hcChzLmNvbnRleHR8fChoP2guJCQuY29udGV4dDpbXSkpLGNhbGxiYWNrczpuKCksZGlydHk6ZCxza2lwX2JvdW5kOiExLHJvb3Q6cy50YXJnZXR8fGguJCQucm9vdH07YSYmYSgkLnJvb3QpO2xldCBtPSExO2lmKCQuY3R4PXI/cihlLHMucHJvcHN8fHt9LCgodCxuLC4uLm8pPT57Y29uc3Qgcz1vLmxlbmd0aD9vWzBdOm47cmV0dXJuICQuY3R4JiZ1KCQuY3R4W3RdLCQuY3R4W3RdPXMpJiYoISQuc2tpcF9ib3VuZCYmJC5ib3VuZFt0XSYmJC5ib3VuZFt0XShzKSxtJiZVKGUsdCkpLG59KSk6W10sJC51cGRhdGUoKSxtPSEwLG8oJC5iZWZvcmVfdXBkYXRlKSwkLmZyYWdtZW50PSEhYyYmYygkLmN0eCkscy50YXJnZXQpe2lmKHMuaHlkcmF0ZSl7Y29uc3QgdD1mdW5jdGlvbih0KXtyZXR1cm4gQXJyYXkuZnJvbSh0LmNoaWxkTm9kZXMpfShzLnRhcmdldCk7JC5mcmFnbWVudCYmJC5mcmFnbWVudC5sKHQpLHQuZm9yRWFjaChpKX1lbHNlICQuZnJhZ21lbnQmJiQuZnJhZ21lbnQuYygpO3MuaW50cm8mJk8oZS4kJC5mcmFnbWVudCksUihlLHMudGFyZ2V0LHMuYW5jaG9yLHMuY3VzdG9tRWxlbWVudCksaygpfXAoaCl9Y2xhc3MgQXskZGVzdHJveSgpe1AodGhpcywxKSx0aGlzLiRkZXN0cm95PXR9JG9uKHQsZSl7Y29uc3Qgbj10aGlzLiQkLmNhbGxiYWNrc1t0XXx8KHRoaXMuJCQuY2FsbGJhY2tzW3RdPVtdKTtyZXR1cm4gbi5wdXNoKGUpLCgpPT57Y29uc3QgdD1uLmluZGV4T2YoZSk7LTEhPT10JiZuLnNwbGljZSh0LDEpfX0kc2V0KHQpe3ZhciBlO3RoaXMuJCRzZXQmJihlPXQsMCE9PU9iamVjdC5rZXlzKGUpLmxlbmd0aCkmJih0aGlzLiQkLnNraXBfYm91bmQ9ITAsdGhpcy4kJHNldCh0KSx0aGlzLiQkLnNraXBfYm91bmQ9ITEpfX1jb25zdCBTPSJjaGFuZ2UiO2Z1bmN0aW9uIEMoZSl7bGV0IG4sbyxzLHI7cmV0dXJue2MoKXt2YXIgdCxlLGM7bj1uZXcgZCghMSksbz1hKCkscz1sKCIgIikscj11KCJkaXYiKSxuLmE9byx0PXIsZT0iY2xhc3MiLG51bGw9PShjPSJjb21wb25lbnQtbW91bnRlci10YXJnZXQiKT90LnJlbW92ZUF0dHJpYnV0ZShlKTp0LmdldEF0dHJpYnV0ZShlKSE9PWMmJnQuc2V0QXR0cmlidXRlKGUsYyksZnVuY3Rpb24odCxlLG4sbyl7bnVsbD09PW4/dC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShlKTp0LnN0eWxlLnNldFByb3BlcnR5KGUsbixvPyJpbXBvcnRhbnQiOiIiKX0ociwiYWxsIiwidW5zZXQiKX0sbSh0LGkpe24ubShlWzBdLGRvY3VtZW50LmhlYWQpLGZ1bmN0aW9uKHQsZSl7dC5hcHBlbmRDaGlsZChlKX0oZG9jdW1lbnQuaGVhZCxvKSxjKHQscyxpKSxjKHQscixpKSxlWzZdKHIpfSxwKHQsW2VdKXsxJmUmJm4ucCh0WzBdKX0saTp0LG86dCxkKHQpe2kobyksdCYmbi5kKCksdCYmaShzKSx0JiZpKHIpLGVbNl0obnVsbCl9fX1mdW5jdGlvbiBIKHQsZSxuKXtsZXR7ZXNNb2R1bGU6b309ZSx7cHJvcHM6c309ZSx7Y3NzOnJ9PWU7Y29uc3QgYz0kKCk7bGV0IGksdSxsLGE7ZnVuY3Rpb24gZCh0KXtpJiZ0JiZpLiRzZXQoey4uLnR9KX12YXIgZjtyZXR1cm4gZj0oKT0+e24oNSxhPSEwKX0saCgpLiQkLm9uX21vdW50LnB1c2goZiksZnVuY3Rpb24odCl7aCgpLiQkLm9uX2Rlc3Ryb3kucHVzaCh0KX0oKCgpPT57aSYmaS4kZGVzdHJveSgpLHUmJlVSTC5yZXZva2VPYmplY3RVUkwodSl9KSksdC4kJHNldD10PT57ImVzTW9kdWxlImluIHQmJm4oMixvPXQuZXNNb2R1bGUpLCJwcm9wcyJpbiB0JiZuKDMscz10LnByb3BzKSwiY3NzImluIHQmJm4oMCxyPXQuY3NzKX0sdC4kJC51cGRhdGU9KCk9PnszNiZ0LiQkLmRpcnR5JiZhJiZvJiZhc3luYyBmdW5jdGlvbigpe24oMCxyPXI/YDxzdHlsZT4ke3J9PC9zdHlsZT5gOiIiKSxpJiYoaS4kZGVzdHJveSgpLFVSTC5yZXZva2VPYmplY3RVUkwodSkpO2NvbnN0IHQ9bmV3IEJsb2IoW29dLHt0eXBlOiJ0ZXh0L2phdmFzY3JpcHQifSk7dT1VUkwuY3JlYXRlT2JqZWN0VVJMKHQpO2NvbnN0IGU9KGF3YWl0IGltcG9ydCh1KSkuZGVmYXVsdDtpZighZXx8IWwpcmV0dXJuO24oMSxsLmlubmVySFRNTD0iIixsKSxuKDQsaT1uZXcgZSh7dGFyZ2V0OmwscHJvcHM6e319KSk7Y29uc3QgYT1pLiQkLnByb3BzO2xldCBmPXt9O09iamVjdC5rZXlzKGEpLm1hcCgodD0+e2ZbdF09aVt0XX0pKTtsZXQgcD1PYmplY3QuYXNzaWduKGYscyk7YyhTLHApLGkuJG9uKCJjaGFuZ2UiLCh0PT57YyhTLHQuZGV0YWlsKX0pKSxkKHApLHUmJlVSTC5yZXZva2VPYmplY3RVUkwodSl9KCksMjQmdC4kJC5kaXJ0eSYmaSYmcyYmZCgpfSxbcixsLG8scyxpLGEsZnVuY3Rpb24odCl7Z1t0PyJ1bnNoaWZ0IjoicHVzaCJdKCgoKT0+e2w9dCxuKDEsbCl9KSl9XX1jbGFzcyBxIGV4dGVuZHMgQXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLFQodGhpcyx0LEgsQyxyLHtlc01vZHVsZToyLHByb3BzOjMsY3NzOjB9KX19ZnVuY3Rpb24gQih0KXtsZXQgZSxuO3JldHVybiBlPW5ldyBxKHtwcm9wczp7ZXNNb2R1bGU6dFswXSxwcm9wczp0WzFdfX0pLGUuJG9uKCJjaGFuZ2UiLHRbM10pLHtjKCl7dmFyIHQ7KHQ9ZS4kJC5mcmFnbWVudCkmJnQuYygpfSxtKHQsbyl7UihlLHQsbyksbj0hMH0scCh0LG4pe2NvbnN0IG89e307MSZuJiYoby5lc01vZHVsZT10WzBdKSwyJm4mJihvLnByb3BzPXRbMV0pLGUuJHNldChvKX0saSh0KXtufHwoTyhlLiQkLmZyYWdtZW50LHQpLG49ITApfSxvKHQpe04oZS4kJC5mcmFnbWVudCx0KSxuPSExfSxkKHQpe1AoZSx0KX19fWZ1bmN0aW9uIFgodCl7bGV0IGUsbixzLHIsdT10WzBdJiZCKHQpO3JldHVybntjKCl7dSYmdS5jKCksZT1hKCl9LG0obyxpKXt2YXIgbCxhLGQsZjt1JiZ1Lm0obyxpKSxjKG8sZSxpKSxuPSEwLHN8fChsPXdpbmRvdyxhPSJtZXNzYWdlIixkPXRbMl0sbC5hZGRFdmVudExpc3RlbmVyKGEsZCxmKSxyPSgpPT5sLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxkLGYpLHM9ITApfSxwKHQsW25dKXt0WzBdP3U/KHUucCh0LG4pLDEmbiYmTyh1LDEpKToodT1CKHQpLHUuYygpLE8odSwxKSx1Lm0oZS5wYXJlbnROb2RlLGUpKTp1JiYoaj17cjowLGM6W10scDpqfSxOKHUsMSwxLCgoKT0+e3U9bnVsbH0pKSxqLnJ8fG8oai5jKSxqPWoucCl9LGkodCl7bnx8KE8odSksbj0hMCl9LG8odCl7Tih1KSxuPSExfSxkKHQpe3UmJnUuZCh0KSx0JiZpKGUpLHM9ITEscigpfX19ZnVuY3Rpb24geih0LGUsbil7bGV0IG8scyxyO3JldHVybltvLHMsYXN5bmMgZnVuY3Rpb24odCl7dD8uZGF0YSYmKHQ/LmRhdGEuaGFzT3duUHJvcGVydHkoImxvYWQiKSYmKG4oMCwoe2VzTW9kdWxlOm8scHJvcHM6c309dC5kYXRhLmxvYWQpLG8sbigxLHMpKSxyPWU9Pnt0LnBvcnRzWzBdLnBvc3RNZXNzYWdlKGUpfSksdD8uZGF0YS5oYXNPd25Qcm9wZXJ0eSgic2V0UHJvcHMiKSYmbigxLHM9dC5kYXRhLnNldFByb3BzKSl9LGZ1bmN0aW9uKHQpe3ImJnQuZGV0YWlsJiZyKHQuZGV0YWlsKX1dfWdsb2JhbFRoaXMuZmV0Y2g9KCk9Pihjb25zb2xlLmxvZygiTnVsbGVkIG91dCBmZXRjaCIpLHtqc29uOigpPT4oe3Jlc3VsdDoibm8gZmV0Y2gsIHNvcnJ5In0pfSksZ2xvYmFsVGhpcy5YTUxIdHRwUmVxdWVzdD1jbGFzc3tjb25zdHJ1Y3Rvcigpe2NvbnNvbGUubG9nKCJOdWxsZWQgb3V0IFhIUiB0b28iKX1vcGVuPSgpPT5udWxsO3NlbmQ9KCk9Pm51bGx9LGdsb2JhbFRoaXMuV2ViU29ja2V0PW51bGwsZ2xvYmFsVGhpcy5FdmVudFNvdXJjZT1udWxsO3JldHVybiBuZXcgY2xhc3MgZXh0ZW5kcyBBe2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksVCh0aGlzLHQseixYLHIse30pfX0oe3RhcmdldDpkb2N1bWVudC5ib2R5LHByb3BzOnt9fSl9KCk7CgoJCTwvc2NyaXB0PgoJPC9oZWFkPgoKCTxib2R5PjwvYm9keT4KPC9odG1sPgo=";
function instance$2(o, n, c) {
  const u = atob(srcdoc64);
  let h, g, { esModule: y } = n, { css: $ = null } = n, { props: I } = n, { rendered: P = !1 } = n;
  const L = createEventDispatcher();
  async function q() {
    if (!y || !h)
      throw new Error("Missing esModule");
    const N = new MessageChannel();
    N.port1.onmessage = (X) => {
      c(0, P = !0), (I || X.data) && L(CHANGE, Object.assign({}, I, X.data)), c(6, g = (rt) => {
        h.contentWindow.postMessage({ setProps: rt }, "*");
      });
    }, h.contentWindow.postMessage({ load: { esModule: y, props: I, css: $ } }, "*", [N.port2]);
  }
  return o.$$set = (N) => {
    "esModule" in N && c(3, y = N.esModule), "css" in N && c(4, $ = N.css), "props" in N && c(5, I = N.props), "rendered" in N && c(0, P = N.rendered);
  }, o.$$.update = () => {
    10 & o.$$.dirty && y && h && q(), 2 & o.$$.dirty && h && h.addEventListener("load", q), 96 & o.$$.dirty && I && g && g(I);
  }, [P, h, u, y, $, I, g, function(N) {
    h = N, c(1, h);
  }];
}
class Gateway extends SvelteComponent {
  constructor(n) {
    super(), init$1(this, n, instance$2, create_fragment$2, safe_not_equal, { esModule: 3, css: 4, props: 5, rendered: 0 });
  }
}
const Gateway$1 = Gateway, get_default_slot_changes = (o) => ({ component: 2 & o }), get_default_slot_context = (o) => ({ component: o[1] });
function create_fragment$1(o) {
  let n, c, u, h, g;
  const y = o[4].default, $ = create_slot(y, o, o[3], get_default_slot_context);
  return { c() {
    n = element("div"), c = text("Loading from: "), u = text(o[0]), h = space(), $ && $.c();
  }, m(I, P) {
    insert(I, n, P), append(n, c), append(n, u), insert(I, h, P), $ && $.m(I, P), g = !0;
  }, p(I, [P]) {
    (!g || 1 & P) && set_data(u, I[0]), $ && $.p && (!g || 10 & P) && update_slot_base($, y, I, I[3], g ? get_slot_changes(y, I[3], P, get_default_slot_changes) : get_all_dirty_from_scope(I[3]), get_default_slot_context);
  }, i(I) {
    g || (transition_in($, I), g = !0);
  }, o(I) {
    transition_out($, I), g = !1;
  }, d(I) {
    I && detach(n), I && detach(h), $ && $.d(I);
  } };
}
function instance$1(o, n, c) {
  let u, h, { $$slots: g = {}, $$scope: y } = n, { url: $ } = n, I = !1;
  async function P(L) {
    if (L)
      try {
        if (window.cachedURL = L, h = await fetch(L), !h.ok)
          throw new Error(h.statusText);
        const q = await h.text();
        c(1, u = q);
      } catch (q) {
        console.log(q);
      }
  }
  return onMount(() => {
    c(2, I = !0), c(0, $ = new URL(document.location).searchParams.get("url") || $), window.cachedURL = $, P($);
  }), o.$$set = (L) => {
    "url" in L && c(0, $ = L.url), "$$scope" in L && c(3, y = L.$$scope);
  }, o.$$.update = () => {
    5 & o.$$.dirty && I && $ && window.cachedURL != $ && P($);
  }, [$, u, I, y, g];
}
class FetchComponent extends SvelteComponent {
  constructor(n) {
    super(), init$1(this, n, instance$1, create_fragment$1, safe_not_equal, { url: 0 });
  }
}
const FetchComponent$1 = FetchComponent;
function create_fragment(o) {
  let n, c, u, h;
  return { c() {
    n = new HtmlTag(!1), c = empty$1(), u = space(), h = element("div"), n.a = c, attr(h, "class", "component-mounter-target"), set_style(h, "all", "unset");
  }, m(g, y) {
    n.m(o[0], document.head), append(document.head, c), insert(g, u, y), insert(g, h, y), o[6](h);
  }, p(g, [y]) {
    1 & y && n.p(g[0]);
  }, i: noop$3, o: noop$3, d(g) {
    detach(c), g && n.d(), g && detach(u), g && detach(h), o[6](null);
  } };
}
function instance(o, n, c) {
  let { esModule: u } = n, { props: h } = n, { css: g } = n;
  const y = createEventDispatcher();
  let $, I, P, L;
  function q(N) {
    $ && N && $.$set({ ...N });
  }
  return onMount(() => {
    c(5, L = !0);
  }), onDestroy(() => {
    $ && $.$destroy(), I && URL.revokeObjectURL(I);
  }), o.$$set = (N) => {
    "esModule" in N && c(2, u = N.esModule), "props" in N && c(3, h = N.props), "css" in N && c(0, g = N.css);
  }, o.$$.update = () => {
    36 & o.$$.dirty && L && u && async function() {
      c(0, g = g ? `<style>${g}</style>` : ""), $ && ($.$destroy(), URL.revokeObjectURL(I));
      const N = new Blob([u], { type: "text/javascript" });
      I = URL.createObjectURL(N);
      const X = (await import(I)).default;
      if (!X || !P)
        return;
      c(1, P.innerHTML = "", P), c(4, $ = new X({ target: P, props: {} }));
      const rt = $.$$.props;
      let nt = {};
      Object.keys(rt).map((ot) => {
        nt[ot] = $[ot];
      });
      let st = Object.assign(nt, h);
      y(CHANGE, st), $.$on("change", (ot) => {
        y(CHANGE, ot.detail);
      }), q(st), I && URL.revokeObjectURL(I);
    }(), 24 & o.$$.dirty && $ && h && q();
  }, [g, P, u, h, $, L, function(N) {
    binding_callbacks[N ? "unshift" : "push"](() => {
      P = N, c(1, P);
    });
  }];
}
class ComponentMounter extends SvelteComponent {
  constructor(n) {
    super(), init$1(this, n, instance, create_fragment, safe_not_equal, { esModule: 2, props: 3, css: 0 });
  }
}
const ComponentMounter$1 = ComponentMounter, index = Object.freeze(Object.defineProperty({ __proto__: null, Gateway: Gateway$1, FetchComponent: FetchComponent$1, CHANGE, ComponentMounter: ComponentMounter$1 }, Symbol.toStringTag, { value: "Module" }));
export {
  NameTag as default
};
